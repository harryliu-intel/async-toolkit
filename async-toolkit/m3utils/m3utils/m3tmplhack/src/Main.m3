MODULE Main;
IMPORT Wr, Rd;
IMPORT FileWr;
IMPORT Text;
IMPORT TextReader;
IMPORT Thread;
IMPORT OSError;
FROM Stdio IMPORT stdin;

<* FATAL Wr.Failure, Thread.Alerted, Rd.EndOfFile, Rd.Failure, OSError.E *>

CONST
  Delims = " ";
  Version = "$Id$";

PROCEDURE FormatNames(args: TextReader.T; VAR comma, space: TEXT;
                      countLimit := LAST(INTEGER)) =
  VAR
    s: TEXT;
  BEGIN
    comma := "";
    space := NIL;
    TRY
      FOR i := 1 TO countLimit DO
        s := args.nextE(Delims, TRUE);
        comma := comma & ", " & s;
        IF space = NIL THEN
          space := s;
        ELSE
          space := space & " " & s;
        END;
      END;
    EXCEPT ELSE END;
    IF space = NIL THEN space := ""; END;
  END FormatNames;

PROCEDURE SpaceCat(a, b: TEXT): TEXT =
  BEGIN
    IF Text.Length(a) = 0 THEN RETURN b; END;
    IF Text.Length(b) = 0 THEN RETURN a; END;
    RETURN a & " " & b;
  END SpaceCat;

PROCEDURE WriteProc(commaArgs, instArgs, build, name: TEXT) =
  BEGIN
    Wr.PutText(out, "\nreadonly proc " & name & "(nm" &
      commaArgs & ") is\n    " & build & "_generic_" & mode &
      "(nm & \"" & nm & "\", \"" & nm & "\"" & instArgs & ")\nend\n");
  END WriteProc;

PROCEDURE WriteProcs(commaArgs, instArgs, suffix: TEXT := "") =
  BEGIN
    WriteProc(commaArgs, instArgs, "build", lowNM & suffix);
    WriteProc(commaArgs, instArgs, "Build", nm & suffix);
  END WriteProcs;

PROCEDURE DoModule() =
  VAR
    line1 := Rd.GetLine(stdin);
    line2 := Rd.GetLine(stdin);    
    args1 := NEW(TextReader.T).init(line1);
    args2 := NEW(TextReader.T).init(line2);
    com := 0;
    comma,space: ARRAY [0..2] OF TEXT;
    (* 0 = common, 1 = interface, 2 = implementation *)
  BEGIN
    Wr.PutText(out, "/* intf_args = \""&line1 &
      "\", impl_args = \""&line2&"\" */\n");
    TRY
      WHILE Text.Equal(args1.nextE(Delims, TRUE),
                       args2.nextE(Delims, TRUE)) DO
        INC(com);
      END;
    EXCEPT ELSE END;
    args1 := NEW(TextReader.T).init(line1);
    args2 := NEW(TextReader.T).init(line2);
    FormatNames(args1, comma[0], space[0], com);
    FormatNames(args2, comma[0], space[0], com);
    FormatNames(args1, comma[1], space[1]);
    FormatNames(args2, comma[2], space[2]);
    space[1] := ", [" & SpaceCat(space[0],space[1]) & "]";
    space[2] := ", [" & SpaceCat(space[0],space[2]) & "]";
    WriteProcs(comma[0] & comma[1] & comma[2], space[1] & space[2]);
    mode := "interface";
    WriteProcs(comma[0] & comma[1], space[1], "_intf");
    mode := "implementation";
    WriteProcs(comma[0] & comma[2], space[2], "_impl");
  END DoModule;

PROCEDURE DoOther() =
  VAR
    line := Rd.GetLine(stdin);
    args := NEW(TextReader.T).init(line);
    comma,space: TEXT;
  BEGIN
    Wr.PutText(out, "/* args = \""&line&"\" */\n");
    <* ASSERT Text.Equal(mode, "interface") OR
    Text.Equal(mode, "implementation") *>
    FormatNames(args, comma, space);
    WriteProcs(comma,", [" & space & "]");
  END DoOther;

PROCEDURE LowerFirst(a: TEXT): TEXT =
  VAR
    c := ORD(Text.GetChar(a, 0));
  BEGIN
    <* ASSERT c >= ORD('A') AND c <= ORD('Z') *>
    RETURN Text.FromChar(VAL(c + ORD('a') - ORD('A'), CHAR)) &
           Text.Sub(a, 1, Text.Length(a) - 1);
  END LowerFirst;

VAR
  mode := Rd.GetLine(stdin);
  nm := Rd.GetLine(stdin);
  lowNM := LowerFirst(nm);
  out := FileWr.Open(nm & ".tmpl");
BEGIN
  Wr.PutText(out, "/* generated by m3tmplhack version " & Version & " */\n");
  Wr.PutText(out, "/* mode = " & mode & ", source = " & nm & ".*g */\n");
  IF Text.Equal(mode, "module") THEN
    DoModule();
  ELSE
    DoOther();
  END;
  Wr.Close(out);
END Main.

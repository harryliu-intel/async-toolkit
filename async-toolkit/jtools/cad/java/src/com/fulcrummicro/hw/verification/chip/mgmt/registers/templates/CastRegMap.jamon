<%extends /com/fulcrummicro/util/jamon/timestamp>
<%import>
java.util.Collection;
com.fulcrummicro.util.misc.Utility;
com.fulcrummicro.hw.verification.chip.mgmt.registers.*;
</%import>\
<%args>
Collection<RegisterCrossbarPort> crossbarPorts;
Collection<RegisterBase> bases;
Collection<Register> regs;
String chip;
</%args>\
/**
 * INTEL TOP SECRET
 * Copyright <& copyright_year; &> Intel Corporation. All Rights Reserved.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.
 * Last Updated <& timestamp; &>
 */
module chip.<% chip %>.base.register_map;

import chip.<% chip %>.base.constant.*;
import chip.<% chip %>.base.functions.*;
import chip.<% chip %>.base.registers.*;

/**
 * Functions defined:
 *
<%for RegisterCrossbarPort xbPort : crossbarPorts %>\
<%if xbPort.hasBusStops() %>\
 * <% xbPort.getBusStopCspAttributeName() %>
</%if>\
</%for>\
 *
 * CbpDecoderFunctions
 *
 */

define BusFunctions()() attributes {
  csp {
    structure DecodedRegister = (
//FIXME addr using chip_addr for now
//if changed to block_offset_addr there will be aliasing problems
//if 2 or more register sets map onto the same bus stop
      int addr;          // index into structure (in units of register width)
      int bus_stop_nr;   // target bus stop
      int num_words;     // number of atomic words in this register
                         // otherwise one for non-atomic reg
      int word_nr;       // word offset for current mgmt cycle for atomic reg
                         // otherwise zero for non-atomic reg
    );
  }
}

<%for RegisterCrossbarPort xbPort : crossbarPorts %>\
<%if xbPort.hasBusStops() %>\
//Mgmt linear bus register decode functions
define <% xbPort.getBusStopCspAttributeName() %>()() attributes
  <+ chip.<% chip %>.base.functions.RegisterFunctions
  <+ chip.<% chip %>.base.registers.AddressSpace
  <+ BusFunctions
{
  csp {
//FIXME dec_reg::addr using chip_addr for now
//if changed to block_offset_addr there will be aliasing problems
//if 2 or more register sets map onto the same bus stop

    //decode chip address into bus stop address for MGMT_IN
    function reg_map(
      int -chip_addr; //chip level address
      DecodedRegister +dec_reg) = (
      int block_addr, i, i0, i1, i2, word;
      dec_reg::num_words = 1; // default for registers w/ atomic width 1
      dec_reg::word_nr   = 0; // default for registers w/ atomic width 1
      dec_reg::addr = chip_addr; //FIXME may want to change to block_addr later
<%java boolean firstBusStop = true; %>\
      #[\
<%doc></%doc><%for RegisterBusStop busStop : xbPort.getBusStops() %>\
<%doc>--</%doc><%for RegisterBase base : busStop.getRegisterBases() %>\
<% firstBusStop ? "" : "      []" %><%java firstBusStop=false; %>\
regRange(chip_addr, <% base.getFullName() %>, <% base.getName() %>_SIZE, block_addr) ->
<%doc>----</%doc><%if busStop.getStride() > 0 %>\
        int bus_stop_offset = (chip_addr - <% base.getFullName() %>) / <% String.format("0x%x",busStop.getStride()) %>;
        dec_reg::bus_stop_nr = <% busStop.getName() %> + bus_stop_offset;
        block_addr = block_addr - <% String.format("0x%x",busStop.getStride()) %> * bus_stop_offset;
<%doc>----</%doc><%else>\
        dec_reg::bus_stop_nr = <% busStop.getName() %>;
<%doc>----</%doc></%if>\
<%doc>  disable block_offset_addr until issue of how to handle
overlapping address ranges is resolved. currently multiple ranges
can map onto a bus stop.
        int block_base_addr = <% base.getFullName() %>;
        int block_offset_addr = chip_addr - block_base_addr;
</%doc>\
        #[\
<%java boolean firstReg = true; %>\
<%doc>----</%doc><%for Register reg : base.getRegisters() %><%if reg.getAlias() == null %>\
<% firstReg ? "" : "        []" %><%java firstReg=false; %>\
<%doc>------</%doc><%if reg.getNumEntries() == 1 %><%doc>single entry</%doc>\
addrMatch(block_addr,
              <% reg.getName() %>_ADDR,
              <% reg.getName() %>_BITS,
              word) ->
<%doc>------</%doc><%elseif reg.getNumEntries1() == 1 %>\
addrMatch1D(block_addr,
              <% reg.getName() %>_BASE,
              <% reg.getName() %>_ENTRIES,
              <% reg.getName() %>_STRIDE,
              <% reg.getName() %>_BITS,
              i, word) ->
<%doc>------</%doc><%elseif reg.getNumEntries2() == 1 %>\
addrMatch2D(block_addr,
              <% reg.getName() %>_BASE,
              <% reg.getName() %>_ENTRIES_0,
              <% reg.getName() %>_ENTRIES_1,
              <% reg.getName() %>_STRIDE_0,
              <% reg.getName() %>_STRIDE_1,
              <% reg.getName() %>_BITS,
              i0, i1, word) ->
<%doc>------</%doc><%else>\
addrMatch3D(block_addr,
              <% reg.getName() %>_BASE,
              <% reg.getName() %>_ENTRIES_0,
              <% reg.getName() %>_ENTRIES_1,
              <% reg.getName() %>_ENTRIES_2,
              <% reg.getName() %>_STRIDE_0,
              <% reg.getName() %>_STRIDE_1,
              <% reg.getName() %>_STRIDE_2,
              <% reg.getName() %>_BITS,
              i0, i1, i2, word) ->
<%doc>------</%doc></%if>\
          dec_reg::num_words   = <% reg.getName() %>_ATOMIC_WIDTH;
          dec_reg::word_nr     = word % <% reg.getName() %>_ATOMIC_WIDTH;
<%doc>    dec_reg::addr        = chip_addr; //FIXME block addr support </%doc>\
<%doc>----</%doc></%if></%for><%doc>register</%doc>\
        ]
<%doc>--</%doc></%for><%doc>register base in bus stop</%doc>\
<%doc></%doc></%for><%doc>bus stop</%doc>\
      ]
    );
  }
}

</%if><%doc>has bus stops</%doc>
</%for><%doc>crossbar ports</%doc>
<%doc>End Mgmt Linear Bus Decode Function</%doc>
\
\
<%doc>Crossbar Port Address Decoder Function</%doc>
define CbpDecoderFunctions () () attributes
  <+ chip.<% chip %>.base.constant.MgmtConstants
  <+ chip.<% chip %>.base.registers.AddressSpace
  <+ chip.<% chip %>.base.functions.RegisterFunctions
  <+ standard.base.functions
{
  csp {
  	//return the crossbar port number that the chip_addr belongs to
    function get_cb_port(
      int -chip_addr; //chip level address
  	  int +cb_port //crossbar port
  	  ) = (
  	  int addr; //unused
  	  int cb_offset = 0; //for crossbar ports with non-zero stride
<%for RegisterCrossbarPort cbp : crossbarPorts %>
      // <% cbp.getName() %>
      [ \
<%doc></%doc><%for RegisterBase base : cbp.getRegisterBases() %>regRange(chip_addr, <% base.getFullName() %>, <% base.getName() %>_SIZE, addr) ->
<%doc>--</%doc><%if cbp.getStride() > 0 %>\
        cb_offset = (chip_addr - <% base.getFullName() %>) / <% String.format("0x%x",cbp.getStride()) %>;
        cb_port = <% cbp.getName() %> + cb_offset
<%doc>--</%doc><%else>\
        cb_port = <% cbp.getName() %>
<%doc>--</%doc></%if>\
      [] \
<%doc></%doc></%for><%doc>base</%doc>else -> assert(false, "unknown address "+hex(chip_addr))
      ];
</%for>
  	);<%doc>end get_cb_port</%doc>\

  } <%doc>end csp block</%doc>\

}

<%doc>end Crossbar Port Address Decoder Function</%doc>
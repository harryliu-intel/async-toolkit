#!/usr/intel/bin/perl -w

use FileHandle;
use IPC::Open2;

# Estimate electromigration and current violations from extracted
# layout.  Uses alint delay characterizations and capacitance
# reports. Assumes only one via and minimum width wire.  Assumes 100%
# duty cycle at nominal frequency.  Reports violations relative to
# limit.  Filters out nodes which pass all limits.  Reports by parent
# cell and local node, just like alint.

# Author: Andrew Lines, Mike Davies

use strict;

my $package_root;

# find relevant packaged tools and libraries
BEGIN {
    $package_root = $0;
    my $exe = $package_root;
    $exe =~ s:.*/::;
    if (! ($package_root =~ m:^/:)) {
        my $pwd = `pwd`;
        chomp $pwd;
        $package_root = $pwd;
        $package_root .= "/$0";
        $package_root =~ s:$exe$::;
        $package_root =~ s://:/:g;
        chdir $package_root;
        $package_root = `pwd`;
        chomp $package_root;
        chdir $pwd;
    }
    else {
        $package_root =~ s:/bin/$exe::;
    }
    push @INC,"$package_root/lib/perl";
}

use LveStatus;
use LveUtil;


my %my_options = ();
# default options
$my_options{"minimumWireWidth"} = 0.06e-6;      # minimum wire width;
$my_options{"cycleTime"} = 1/1.35e9;        # cycle time;
$my_options{"lve_dir"} = $ENV{PWD};
$my_options{"cast_path"} = $ENV{CAST_PATH};
$my_options{"pdk_root"} = $ENV{FULCRUM_PDK_ROOT};
$my_options{"debug"} = 0;
$my_options{"voltage"} = 0.99;         # supply voltage;
$my_options{"corner"} = "pwr";
$my_options{"true"} = "1.045";
$my_options{"temp"} = "90";
$my_options{"cc"} = "0";
$my_options{"tau"} = 8;
$my_options{"limit"} = 1;
$my_options{"activityFactor"}=1;
$my_options{"recoveryFactor"}=0.9;
$my_options{"em_width_scaling"}=0.9;
$my_options{"max_heap_size"} = "8G"; # default max-hea-size for jflat calls
# capacitance technology data
$my_options{"ng_cap"} = 11.0E-3; # nmos gate capacitance per m^2
$my_options{"na_cap"} = 0;       # ndiffusion area capacitance per m^2
$my_options{"np_cap"} = 0;       # ndiffusion perimeter capacitance per m
$my_options{"pg_cap"} = 11.0E-3; # pmos gate capacitance per m^2
$my_options{"pa_cap"} = 0;       # pdiffusion area capacitance per m^2
$my_options{"pp_cap"} = 0;       # pdiffusion perimeter capacitance per m
$my_options{"default_metal"} = ""; #no default metal, will pick min limit
$my_options{"default_via"} = ""; #no default via, will pick min limit

$my_options{"verbose"} = 0;
$my_options{"report"} = "lve_em.rpt";


#parse options
my @cmd_options = ();
&parseArgs(\@ARGV,\@cmd_options);
my @jauto_config_a = ();
my @jauto_config = ();
open (P, "$my_options{pdk_root}/share/Fulcrum/jauto/transistors.config");
while (<P>) {
    chomp;
    next if /^#/ or /^\s*$/;
    s/ //g;
    my ($key,$value)=split(/=/);
    $my_options{$key}=$value;
}
close P;
my @lve_raw_config_a = ();
my @lve_raw_config = ();
&includeConfig("$my_options{pdk_root}/share/Fulcrum/lve/lve_raw.config",\@lve_raw_config_a);
&parseArgs(\@lve_raw_config_a,\@lve_raw_config);
foreach my $opt (@lve_raw_config, @cmd_options) {
    if(ref($opt) eq "ARRAY") { 
	my ($key, $value) = @{$opt};
        print STDERR "K $key $value\n" if $key =~ /mos/;
	$key =~ s/-/_/g;
        if ($key =~ /^em/) {
            my $kn=$key;
            $kn =~ s/:.*//;
            if ($key =~ /^$kn:(\S+):(\S+)/ )   {
                if ( ! defined ($my_options{$kn}{$1}) or $value < $my_options{$kn}{$1}) {
                    $my_options{$kn}{$1} = $value;
                }
            }
            elsif ($key =~ /^$kn:(\S+)/ )  { $my_options{$kn}{$1} = $value; }
        }
	$my_options{$key} = $value;
    }
}

$my_options{"ng_cap"} = $my_options{"unitNmosGateCapacitance[1]"}
    if defined $my_options{"unitNmosGateCapacitance[1]"};
$my_options{"na_cap"} = $my_options{"unitNmosDiffusionAreaCapacitance[1]"}
    if defined $my_options{"unitNmosDiffusionAreaCapacitance[1]"};
$my_options{"np_cap"} = $my_options{"unitNmosDiffusionPerimeterCapacitance[1]"}
    if defined $my_options{"unitNmosDiffusionPerimeterCapacitance[1]"};
$my_options{"pg_cap"} = $my_options{"unitPmosGateCapacitance[1]"}
    if defined $my_options{"unitPmosGateCapacitance[1]"};
$my_options{"pa_cap"} = $my_options{"unitPmosDiffusionAreaCapacitance[1]"}
    if defined $my_options{"unitPmosDiffusionAreaCapacitance[1]"};
$my_options{"pp_cap"} = $my_options{"unitPmosDiffusionPerimeterCapacitance[1]"}
    if defined $my_options{"unitPmosDiffusionPerimeterCapacitance[1]"};
set_em_cycletime();


# error checking
die usage() if(!defined ($my_options{tau}) or $my_options{"tau"} eq "" or defined($my_options{"help"}) or ! defined($my_options{"cast_path"}));
open (RF, ">$my_options{report}") or die "Cannot write to $my_options{report}";


# print options we're running with 
$my_options{verbose}=1 if $my_options{debug};

if ($my_options{verbose}) {
print "Running lve_em with the following options ..\n";
print usage(1);
print RF "Running lve_em with the following options ..\n";
print RF usage(1);
}

# set up driver query command
my $driver_query = "jflat" .
    " --cast-path=$my_options{cast_path}" . 
    " --max-heap-size=$my_options{max_heap_size}" .
    " --tool=query --query-tasks=local_nodes=drivers";

# set up em directives query command
my $em_query = "jflat" .
    " --cast-path=$my_options{cast_path}" .
    " --max-heap-size=$my_options{max_heap_size}" .
    " --tool=query --query-tasks=em_spec ";

# initialize drivers hashtables
my %drivers_worst = (); # worst relative violation
my %drivers_err   = (); # error message for the worst violation

# find all relevant alint results for specified conditions
my $find_cmd;
my $extractCorner = "";
my $extractTemp = "";

if (defined $my_options{extract_corner}) {
  if ($my_options{extract_corner} eq "cworst") {
    $extractCorner = "-cwo";
  } elsif ($my_options{extract_corner} eq "cbest") {
    $extractCorner = "-cbe";
  }
}

if (defined $my_options{extractTemp}) {
  $extractTemp = "-$my_options{extractTemp}";
}


if (defined $my_options{cell}) {
    my $do_cell = $my_options{cell};
    $do_cell =~ s/\./\//g;
    print "$do_cell\n";
    $find_cmd = "find $my_options{lve_dir}/$do_cell/ -noleaf -path '*/extracted${extractCorner}${extractTemp}' -prune";
}
else {
    $find_cmd = "find $my_options{lve_dir} -noleaf -path '*/extracted${extractCorner}${extractTemp}' -prune";
}

print STDERR "Running $find_cmd\n" if $my_options{debug};
open ALINTDIRS, "$find_cmd |"
    or die "ERROR: can't find alint.raw files\n Please run with extracted mode\n";
my $alint_raw_cnt=0;
while (my $raw = <ALINTDIRS>) {
    chomp($raw);
    $raw .= "/alint/$my_options{corner}/$my_options{true}V/$my_options{temp}C/alint.raw";
    next if ! -s "$raw";
    print STDERR "RAW $raw\n" if $my_options{debug};
    my $cell = "";
    my $dir = $raw;
    $dir =~ s|/alint\.raw$||g;
    
    my %nodebin=get_node_bin("$dir/alint_parallel","alint.in");

    # read raw file
    my @errors = ();
    my @raw = get_lines("$raw");
    my $drivers_loaded = 0;
    my $em_directives_loaded = 0;
    my %drivers = ();
    my %em_directives = ();
    foreach my $line (@raw) {
        my ($status, $task, $c, $path, %results) = parse_raw_line($line);
        $cell = (partition_fqcnminus($c))[0];
        my $node = $results{node};
        if (($task eq "alint") && (defined $node) &&
            (defined $results{delay_dn}) && 
            (defined $results{delay_up}) &&
            (defined $results{slow_delay_dn}) && 
            (defined $results{slow_delay_up}) &&
            (defined $results{fast_delay_dn}) &&
            (defined $results{fast_delay_up}) &&
            (defined $results{skew_dn}) &&
            (defined $results{skew_up}) &&
            (defined $results{slow_slew_dn}) &&
            (defined $results{slow_slew_up}) &&
            (defined $results{fast_slew_dn}) &&
            (defined $results{fast_slew_up})) {

            # skip wrong cc/tau
            if ((defined $results{cc}  && ($my_options{cc}  != $results{cc})) || 
                (defined $results{tau} && ($my_options{tau} != $results{tau}))) { next; }
            
            print STDERR "######## $node ###########\n" if $my_options{debug};
            print STDERR "Parse $line\n" if $my_options{debug};
            # get up/dn slews
            my ($Up) = split("@",$results{fast_slew_up});
            my ($Dn) = split("@",$results{fast_slew_dn});
            if (($Up eq "SIGNOFF") || ($Dn eq "SIGNOFF") || 
                ($Up eq "FAIL")    || ($Dn eq "FAIL")) { next; }

            # snoop through node.out file for capacitance info
            my $open=1;
            my $alint_bin="alint.bin.$nodebin{$node}";
            my $out_file="$dir/$alint_bin/$node/out";
            $out_file="$dir/$alint_bin/$node/out.gz" if (-e "$dir/$alint_bin/$node/out.gz");
            if($out_file=~/\.gz$/){
                 open (OUT, "gzip -cd \'$out_file\'|") or warn "Cannot read $out_file.\n";
            }else{
                 open (OUT, "<$out_file") or warn "Cannot read $out_file.\n";
            }
                
            my ($c, $ng, $na, $np, $pg, $pa, $pp);
            while (my $l = <OUT> ) {
                chomp($l);
                if ($l =~ /^\s*Constant capacitance (.*)fF$/) {
                    $c = $1 * 1e-15;
                } elsif ($l =~ /^\s*Capacitance (.*)fF$/) {
                    $c = $1 * 1e-15;
                } elsif ($l =~ /^\s*Nmos gate area (.*)um\^2$/) {
                    $ng = $1 * 1e-12;
                } elsif ($l =~ /^\s*Ndiffusion area (.*)um\^2$/) {
                    $na = $1 * 1e-12;
                } elsif ($l =~ /^\s*Ndiffusion non-gate perimeter (.*)um$/) {
                    $np = $1 * 1e-6;
                } elsif ($l =~ /^\s*Ndiffusion gate perimeter (.*)um$/) {
                    $np += $1 * 1e-6;
                } elsif ($l =~ /^\s*Pmos gate area (.*)um\^2$/) {
                    $pg = $1 * 1e-12;
                } elsif ($l =~ /^\s*Pdiffusion area (.*)um\^2$/) {
                    $pa = $1 * 1e-12;
                } elsif ($l =~ /^\s*Pdiffusion non-gate perimeter (.*)um$/) {
                    $pp = $1 * 1e-6;
                } elsif ($l =~ /^\s*Pdiffusion gate perimeter (.*)um$/) {
                    $pp += $1 * 1e-6;
                }
            }
            close OUT;

            # check for problems with capacitance info
            if ((!defined $ng) || (!defined $na) || (!defined $np) ||
                (!defined $pg) || (!defined $pa) || (!defined $pp)) {
                push @errors, "ERROR: $node has no capacitance data";
                next;
            }

            # compute total capacitance
            my $Cap = $c + 
		$ng * $my_options{ng_cap} + 
		$na * $my_options{na_cap} + 
		$np * $my_options{np_cap} +
                $pg * $my_options{pg_cap} + 
		$pa * $my_options{pa_cap} + 
		$pp * $my_options{pp_cap};
            
            # convert 1/3 to 2/3 slews in ps to full swing times in seconds
            $Up = 22 if (!defined ($Up) or $Up == 0);
            $Dn = 22 if (!defined ($Dn) or $Dn == 0);

            $Up *= 3e-12;
            $Dn *= 3e-12;

            # compute currents
            my $Activity = $my_options{activityFactor};
            my $DC_width = $my_options{"minimumWireWidth"};
            my $DC_vias  = 1;
            my $AC_width = $my_options{"minimumWireWidth"};
            my $Reset_node=0;
            my ($Iav_wire_err,$Iav_via_err,$Irms_wire_err,$Ipeak_wire_err,
                $worst) = compute_currents($Activity,$DC_width,$DC_vias,
                                           $AC_width,$Up,$Dn,$Cap,undef,undef);


            # if the node fails, look up wiring directives from the cast
            if ($worst>$my_options{limit}) {
                if ($em_directives_loaded==0) {
                    %em_directives = query_em_directives($cell);
                    $em_directives_loaded = 1;
                }
                if (defined $em_directives{$node}) {
                    ($Activity,$DC_width,$DC_vias,$AC_width,$Reset_node) = 
                        @{$em_directives{$node}};
                    $Reset_node = 1 if defined($Reset_node) and $Reset_node eq "1";
                }
                elsif ($my_options{verbose}) {
                    warn "Didn't find wiring directives for node $node in ".
                         "cell:\n  $cell.\n";
                }
                $Activity = 1e-6 if $Activity == 1 and $Reset_node == 1;
                ($Iav_wire_err,$Iav_via_err,$Irms_wire_err,$Ipeak_wire_err,
                $worst) = compute_currents($Activity,$DC_width,$DC_vias,
                                           $AC_width,$Up,$Dn,$Cap,undef,undef);
            }

            # report if worst violation still exceeds the limit
            if ($worst>$my_options{limit}) {
                $Cap            = round_float($Cap*1e15,-2);
                $Iav_via_err    = round_float($Iav_via_err,-4);
                $Iav_wire_err   = round_float($Iav_wire_err,-4);
                $Irms_wire_err  = round_float($Irms_wire_err,-4);
                $Ipeak_wire_err = round_float($Ipeak_wire_err,-4);
                my $err = "Cap=${Cap}fF Iav_via_err=$Iav_via_err" .
                    " Iav_wire_err=$Iav_wire_err Irms_wire_err=$Irms_wire_err" .
                    " Ipeak_wire_err=$Ipeak_wire_err";
                $err .= " Up=$Up Dn=$Dn Activity=$Activity DC_vias=$DC_vias ".
                        " DC_width=$DC_width AC_width=$AC_width" if ($my_options{debug});
                push @errors, "$node $err";
                
                # load driver database unless already cached
                if ($drivers_loaded==0) {
                    %drivers = query_drivers($cell);
                    $drivers_loaded = 1;
                }

                # find driver and keep track of worst error
                my $driver = $drivers{$node};
                if (!defined $driver) { $driver = "NOT_FOUND($cell/$node)"; }
                next if ($driver eq "-1");
                if (!defined $drivers_worst{$driver} ||
                        ($worst>$drivers_worst{$driver})) {
                    $drivers_worst{$driver} = $worst;
                    $drivers_err{$driver}   = $err;
                }
            }
        }
    }
    # print error report for this cell
    my $celldir = $cell;
    $celldir =~ s/\./\//g;
    $celldir=$my_options{"lve_dir"}."/$celldir";
    my $accurateprops="$celldir/cell.localprops.routed.accurate";
    if (@errors>0) {
        print RF ("CELL $cell {\n");
        my %nodes=();
        foreach my $err (@errors) {
            my $node=$err;
            $node =~ s/^\s+//;
            $node =~ s/\s.*//;
            $nodes{$node}=1;
            print RF ("  $err\n");
        }
        print RF ("}\n\n");
        open (O, ">$accurateprops.tmp");
        open (I, "<$celldir/cell.localprops.routed");
        while (<I>) {
            chomp;
            s/^SIGNOFF //;
            s/^"SIGNOFF" //;
            my ($node, $rest)=split(/ /, $_, 2);
            print O "$_\n" if defined ($nodes{$node});
        }
        close I;
        close O;
        if ( ! -s "$accurateprops") {
            rename "$accurateprops.tmp", $accurateprops;
            print STDERR "$celldir/cell.localprops.routed.accurate added.\n";
        }
        else {
            my $dif=`diff "$accurateprops.tmp" "$accurateprops" | wc -l`;
            chomp $dif;
            if ($dif > 0) {
                print STDERR "$accurateprops changed.\n";
                rename "$accurateprops.tmp", $accurateprops;
            }
            else {
                print STDERR "$accurateprops unchanged.\n";
                unlink "$accurateprops.tmp";
            }
        }
        print STDERR "FAIL $cell\n";
    }
    else {
        print STDERR "PASS $cell\n";
        print RF "CELL $cell PASS\n";
        if ( -s "$accurateprops") {
            print STDERR "$accurateprops removed.\n";
            unlink $accurateprops;
            `touch "$accurateprops"`;
        }
    }
    # print sorted drivers output
    if (keys %drivers_err){
      print RF "DRIVERS {\n";
      foreach my $driver (sort keys %drivers_err) {
        print RF "  $driver $drivers_err{$driver}\n";
      }
      print RF "}\n\n";
    }
    $alint_raw_cnt++;
}
close ALINTDIRS;

close RF;
print "View detail information in lve_em reports: $my_options{report}\n";
print "ERROR: can't find alint.raw files\n Please run lve with extracted mode\n" if($alint_raw_cnt==0);
#########################################
# functions
#########################################
sub get_node_bin{
    my($alint_parallel,$file_prefix)=@_;
    my @loc=`grep '^alint' \"$alint_parallel/$file_prefix.\"*`;
    my %node_bin_map=();
    foreach my $loc (@loc){
        chomp $loc;
        my($bin_path,$node_info)=split(":",$loc);
        my $node_bin=0;
        my $node="";
        if($bin_path =~ /\.(\d+)$/){
          $node_bin=$1;
          (my $a,$node) = split(/\s+/,$node_info);
          $node_bin_map{$node}=$node_bin;
        }
    }
    return %node_bin_map;
}

#set em cycle time
sub set_em_cycletime {
  if(defined $my_options{em_frequency}){
    my $emfreq=$my_options{em_frequency};
    if(defined  $my_options{em_unit}{frequency}){
      if($my_options{em_unit}{frequency}=~/(\d+)(\S)/){
        my($div,$u)=($1,$2);
       $emfreq *= 1e+9 if ($u eq "G" or $u eq "g");
       $emfreq *= 1e+6 if ($u eq "M" or $u eq "m");
       $emfreq *= 1e+3 if ($u eq "K" or $u eq "k");
       $emfreq /= $div;
       $my_options{cycleTime} = 1.0/$emfreq;
      }
    }
  }
}

sub unit_length_2m {
  if(defined  $my_options{em_unit}{length}){
    if($my_options{em_unit}{length}=~/(\d+)(\S)/){
      my($div,$u)=($1,$2);
      for (my $i=0; $i<@_; $i++) {
        $_[$i] *= 1e-9 if ($u eq "n");
        $_[$i] *= 1e-6 if ($u eq "u");
        $_[$i] *= 1e-3 if ($u eq "m");
        $_[$i] *= $div;
      }
      my $x;
      $x = 1e-9 if ($u eq "n");
      $x = 1e-6 if ($u eq "u");
      $x = 1e-3 if ($u eq "m");
      $x *= $div;
      return $x;
    }
  }
}

sub unit_current_2A {
  if(defined  $my_options{em_unit}{current}){
    if($my_options{em_unit}{current}=~/(\d+)(\S)/){
      my($div,$u)=($1,$2);
      for (my $i=0; $i<@_; $i++) {
        $_[$i] *= 1e-9 if ($u eq "n");
        $_[$i] *= 1e-6 if ($u eq "u");
        $_[$i] *= 1e-3 if ($u eq "m");
        $_[$i] *= $div;
      }
      my $x;
      $x = 1e-9 if ($u eq "n");
      $x = 1e-6 if ($u eq "u");
      $x = 1e-3 if ($u eq "m");
      $x *= $div;
      return $x;
    }
  }
}

# use cast_query to find all drivers of a localnode
sub query_drivers {
    my ($cell) = @_;
    my %drivers = ();
    my @lines = split("\n",`$driver_query --cell=\"$cell\"`);
    foreach my $line (@lines) {
        chomp($line);
        my @args = split(" ",$line);
        if (($args[0] eq "SIGNOFF") || (@args<13)) { next; }
        $drivers{$args[0]} = $args[12];
    }
    return %drivers;
}

# use cast_query to find all em directives for the cell's localnodes
sub query_em_directives {
    my ($cell) = @_;
    my %directives = ();
    open QUERY, "$em_query --cell=\"$cell\"|";
    my $ignore_fist = <QUERY>;
    while (<QUERY>) {
        my ($node,$activity,$dc_width,$dc_vias,$ac_width,$ac_vias,$wirewidth,$reset) 
            = split /\s+/, $_;
        $activity = 1.0    if ($activity == -1);
        $dc_width = $my_options{"minimumWireWidth"} if ($dc_width == -1);
        $dc_vias  = 1      if ($dc_vias == -1);
        $ac_width = $my_options{"minimumWireWidth"} if ($ac_width == -1);
        $ac_width = $wirewidth if ($wirewidth > $ac_width);
        $reset = "u" if ! defined $reset;
        $directives{$node} = [ $activity, $dc_width, $dc_vias, $ac_width, $reset ];
    }
    close QUERY;
    return %directives;
}

sub get_min_Iavg_limit {
  my $Iavg_min_limit=1e10;
  my $width=$my_options{minimumWireWidth};
  foreach my $layer (sort keys %{$my_options{em_avg_wire_parm}}){
    if ($layer =~/^M(\d+)/){
      my $Iavg_limit;
      if(defined $my_options{em_avg_wire_width}{$layer}){
        my $width_thresh=$my_options{em_avg_wire_width}{$layer};
        my $unit_2m=unit_length_2m($width_thresh);
        $Iavg_limit=$my_options{em_avg_temp_rating}{$layer}*$my_options{em_avg_wire_parm}{$layer}*($width*(1/$unit_2m)*$my_options{em_width_scaling}+$my_options{em_avg_wire_offset}{$layer});
        
        if($width >= $width_thresh){
          $Iavg_limit*=$my_options{em_avg_wire_width_coef}{$layer};
        }
        $Iavg_min_limit=$Iavg_limit if($Iavg_min_limit > $Iavg_limit );
      }
    }
  }
  unit_current_2A($Iavg_min_limit);
  return $Iavg_min_limit;
}

sub get_min_Iavg_via_limit {
  my $Iavg_min_limit=1e10;
  foreach my $layer (sort keys %{$my_options{em_avg_via_limit}}){
    if ($layer =~/^VIA(\d+)$/){
        my $Iavg_limit;
        $Iavg_limit=$my_options{em_avg_temp_rating}{$layer}*$my_options{em_avg_via_limit}{$layer};
        $Iavg_min_limit=$Iavg_limit if($Iavg_min_limit > $Iavg_limit );
    }
  }
  unit_current_2A($Iavg_min_limit);
  return $Iavg_min_limit;
}

sub get_min_Irms_limit {
  my $Irms_min_limit=1e10;
  my $width=$my_options{minimumWireWidth};
  my $unit_2m=unit_length_2m();
  my $width_shrink=$width*(1/$unit_2m)*$my_options{em_width_scaling}; #translate m to tech file config unit and *widthscaling

  foreach my $layer (sort keys %{$my_options{em_rms_parm}}){
    if ($layer =~/^M(\d+)/){
      my $Irms_limit=$my_options{em_rms_parm}{$layer}*$my_options{em_rms_heating}
                    *($width_shrink+$my_options{em_rms_offset1}{$layer})*($width_shrink+$my_options{em_rms_offset1}{$layer})*
                      ($width_shrink+$my_options{em_rms_offset1}{$layer}+$my_options{em_rms_offset2}{$layer})/
                        ($width_shrink+$my_options{em_rms_offset1}{$layer}+$my_options{em_rms_offset3}{$layer});
        $Irms_limit=sqrt($Irms_limit);

        $Irms_min_limit=$Irms_limit if($Irms_min_limit > $Irms_limit );
    }
  }
  unit_current_2A($Irms_min_limit);
  return $Irms_min_limit;
}

sub get_min_Ipeak_limit {
  my $Ipeak_min_limit=1e10;
  my $width=$my_options{minimumWireWidth};
  my $unit_2m=unit_length_2m();
  my $width_shrink=$width*(1/$unit_2m)*$my_options{em_width_scaling}; #translate m to tech file config unit and *widthscaling

  foreach my $layer (sort keys %{$my_options{em_peak_parm}}){
    if ($layer =~/^M(\d+)/){
#     print "$layer parm:$my_options{em_peak_parm}{$layer}\n";
      my $offset=0;
      $offset= $my_options{em_peak_offset}{$layer} if (defined $my_options{em_peak_offset}{$layer});
      my $Ipeak_limit=$my_options{em_peak_parm}{$layer}*($width_shrink+$offset);
        $Ipeak_min_limit=$Ipeak_limit if($Ipeak_min_limit > $Ipeak_limit );
    }
  }
  unit_current_2A($Ipeak_min_limit);
  return $Ipeak_min_limit;
}

# common code for calculating ave/rms/peak current failure ratios
sub compute_currents {
    my ($Activity,$DC_width,$DC_vias,$AC_width,$Up,$Dn,$Cap,$current_layer,$current_via) = @_;

    # compute average unidirectional current
    my $Iav_wire = $Cap*$my_options{voltage}/$my_options{cycleTime}*$Activity*(1-$my_options{recoveryFactor});
    my $Iav_via  = $Cap*$my_options{voltage}/$DC_vias/$my_options{cycleTime}*$Activity*(1-$my_options{recoveryFactor});
        
    # curse divide by zero errors!

    $Up = 66e-12 if (!defined ($Up) or $Up == 0);
    $Dn = 66e-12 if (!defined ($Dn) or $Dn == 0);

    # compute root-mean-squared bidirectional current
    my $Irms = $Cap*$my_options{voltage}*sqrt($Activity*(1/($Up*$my_options{cycleTime}) + 1/($Dn*$my_options{cycleTime})));
    
    # compute peak bidirectional current adjusted by duty cycle
    my $Ipeak_up = $Cap*$my_options{voltage}*sqrt(2*$Activity/($Up*$my_options{cycleTime}));
    my $Ipeak_dn = $Cap*$my_options{voltage}*sqrt(2*$Activity/($Dn*$my_options{cycleTime}));
    my $Ipeak = ($Ipeak_dn>$Ipeak_up) ? $Ipeak_dn : $Ipeak_up;

    my $Iav_wire_limit = get_min_Iavg_limit();
    my $Iav_via_limit  = get_min_Iavg_via_limit();
    my $Irms_wire_limit= get_min_Irms_limit();
    my $Ipeak_wire_limit=get_min_Ipeak_limit();

    # compute relative electromigration violations
    my $Iav_wire_err   = $Iav_wire/$Iav_wire_limit;
    my $Iav_via_err    = $Iav_via/$Iav_via_limit;
    my $Irms_wire_err  = $Irms/$Irms_wire_limit;
    my $Ipeak_wire_err = $Ipeak/$Ipeak_wire_limit;
    
    # max up worst violation
    my $worst = $Iav_via_err;
    if ($Iav_wire_err>$worst)   {$worst = $Iav_wire_err;}
    if ($Irms_wire_err>$worst)  {$worst = $Irms_wire_err;}
    if ($Ipeak_wire_err>$worst) {$worst = $Ipeak_wire_err;}
    print STDERR "avg wire $Iav_wire / $Iav_wire_limit \n" if ($my_options{debug});
    print STDERR "avg via $Iav_via / $Iav_via_limit\n" if ($my_options{debug});
    print STDERR "rms $Irms / $Irms_wire_limit\n" if ($my_options{debug});
    print STDERR "peak $Ipeak / $Ipeak_wire_limit\n" if ($my_options{debug});
    return ($Iav_wire_err,$Iav_via_err,$Irms_wire_err,$Ipeak_wire_err,$worst);
}

sub usage {
 my($report)=@_;
my $cell_str="";
$cell_str=$my_options{cell} if (defined $my_options{cell});
my $usage_pre="Usage: lve_em\n";

my $usage =<<EOF;
  [--pdk-root=$my_options{pdk_root}]  (location of Fulcrum pdk)
  [--lve-dir=$my_options{lve_dir}]
  [--cast-path=$my_options{cast_path}]
  [--debug=$my_options{debug}]
  [--max-heap-size=$my_options{max_heap_size}]
  [--cell=$cell_str]
  [--minimumWireWidth=$my_options{minimumWireWidth}]
  [--cycleTime=$my_options{cycleTime}]
  [--voltage=$my_options{voltage}]
  [--recoveryFactor=$my_options{recoveryFactor}] #used for Iavg calculation
  [--activityFactor=$my_options{activityFactor}]
  [--limit=$my_options{limit}] #list em results if the ratio > limit; (ratio is defined as Ipeak/Ipeak_limit. Same as rms and avg)
  [--default-metal=$my_options{default_metal}]  #no default metal, will pick min limit
  [--default-via=$my_options{default_via}]  #no default via, will pick min limit
  [--report=$my_options{report}] #lve_em report file
  --corner=$my_options{corner}
  --true=$my_options{true}
  --temp=$my_options{temp}
  --cc=$my_options{cc}
  --tau=$my_options{tau}
EOF

my $usage_post =<<EOF;
  --verbose

    Recursively searches for extracted alint results for the given
    conditions.  Will report any potential electromigration or current
    violations on local nodes of all cells found.  Assumes only 1 via,
    xxxm wide wire, a xxxs cycle time, and xxxV supply
    voltage.  Used technology data for specified pdk xxx
    Run from an lve working directory (or specify the lve directory
    with --lve-dir.)  Limit defaults to 1, and is used as the threshold 
    to filter relative violations.  Also reports violations organized 
    by leaf cell drivers.
EOF

  return $usage_pre.$usage.$usage_post if (not defined $report);
  return $usage if(defined $report);
}

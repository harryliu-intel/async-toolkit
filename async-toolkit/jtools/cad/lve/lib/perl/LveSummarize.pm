
package LveSummarize;

BEGIN {
    use Exporter;
    our @ISA = qw(Exporter);
    our @EXPORT = qw( 
        &lve_summarize 
        &start_page &finish_page &status2color 
        &start_table &table_row &finish_table
    );
}

use Time::Local;
use LveStatus;
use LveUtil;
use File::stat;

# color palatte for simulation results
%color_palette = ();
$color_palette{PASS} = 'white';
$color_palette{NA} = 'white';
$color_palette{FAIL} = 'red';
$color_palette{SIGNOFF} = 'yellow';
$color_palette{INCOMPLETE} = 'lightblue';
$color_palette{NOT_TESTED} = 'lightblue';

$index_page = "index.html";
$statistics_page = "statistics.html";
$tracking_page = "status.html";
$help_page = "intro.html";
$fulcrum_logo = "logo.png";
$doc="\.doc";

@months = ("Jan","Feb","Mar","Apr","May",
              "Jun","Jul","Aug","Sep","Oct","Nov","Dec");
@wdays  = ("Sun","Mon","Tue","Wed","Thur","Fri","Sat");

sub status2color {
    my $status = shift;
    return $color_palette{$status};
}

sub index {
    my ($list,$x)= @_;
    for(my $i = 0; $i < ( scalar @{$list} ); $i ++ ) {
        my $y = $list->[$i];
        return $i if ($y eq $x);
    }
	return undef;
}

sub get_seconds {
    my ($date) = @_;
    my @components = split(" ",$date);
    foreach my $str (@components) {
        if ( $str =~ /.*:.*:.*/ ) {
            ($hours,$minutes,$seconds) = split(":", $str);
        } elsif ($str =~ /^[0-9][0-9]?$/ ) {
            $day = $str;
        } elsif (defined(&index(\@months,$str)) ) {
            $month = &index(\@months,$str );
        } elsif ($str =~ /^[0-9]+$/ ) {
            $year = $str - 1900;
        }
    }
    timelocal($seconds, $minutes, $hours, $day, $month, $year);
}
 
# determine the relative path of where to output
sub get_dotdot {
    my $dir = shift;
    my $backup = shift;
    my @dirparts = split('/', $dir);
    
    my $depth = scalar(@dirparts);
    $depth -= $backup;
    my $celldir = "";
    my $i=0;
    foreach $part(@dirparts){
        $celldir .= "$part/";
        $i++;
        if($i == $depth){ last; }
    }
    
    my $cellname = get_cellname($celldir);
    chop($cellname);
    my ($basename, $plusminus) = partition_fqcnminus($cellname);
    my $cellpath = $basename;
    $cellpath =~ s/\./\//g;
    $cellpath .= "$plusminus";
    
    my @cellp = split('/', $cellpath);
    my $numslash = scalar(@cellp);
    $numslash += $backup;
    
    my $dotdot = "./";
    for($i=0; $i < $numslash; $i++){
        $dotdot .= "../";
    }
    return $dotdot;
}

# start a simple page
sub start_simple_page {
    my ($file,$title,$dotdot) = @_;

    unlink "$file"; # in case it is owned by someone else
    # and is fortuitously in a writeable directory
    if (! open HTML, ">$file") {
        warn "Can't write $file\n";
        return 0;
    }
    my $fh = \*HTML;

    $dotdot = "./" if !defined($dotdot);
    my @time_array = gmtime;
    my $year = $time_array[5]+1900;
    my $day  = $time_array[3]-1;
    my $month = $months[$time_array[4]];
    my $wday  = $wdays[$time_array[6]];
    my $hour = $time_array[2];
    my $date = "$wday $month $day, $year "
        ."$hour:$time_array[1]:$time_array[0] GMT";
    my $back_page = "";
    my $forward_page = "";
    my $get_date = `date`;

    print $fh <<START_PAGE;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<!-- Copyright $year. Fulcrum Microsystems. All Rights Reserved -->
<!-- Generated by Layout Verification Engine on $date -->
<TITLE>$title</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="${dotdot}$doc/table.css">
<LINK REL ="stylesheet" TYPE="text/css" HREF="${dotdot}$doc/lve.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD><TD ALIGN="LEFT" HEIGHT="90"><IMG SRC="${dotdot}$doc/$fulcrum_logo" WIDTH="250" HEIGHT="90" ALT="Fulcrum" BORDER="0" align="left"></A>
</TD>
</TR>
</TABLE>
<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD CLASS="NavBarCell1">
  <A HREF="$dotdot$index_page"><B>Index</B></A></TD>
  <TD CLASS="NavBarCell1"><A HREF=$dotdot$tracking_page><B>Tracking</B></A></TD>
  <TD CLASS="NavBarCell1"><A HREF="${dotdot}$doc/$help_page" target="lvehelp"><B>Help Doc</B></A></TD>
  <TD CLASS="NavBarCell1"><A HREF="$dotdot$statistics_page"><B>Statistics</B></A></TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3></TD>
</TR>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->
Last Modified: $get_date <br>
START_PAGE
    if (defined ($ENV{LVE_GID})) {
        `chgrp $ENV{LVE_GID} "$file"`;
    }
    if (defined ($ENV{LVE_FILEMODE})) {
        my $md=sprintf("0%o", $ENV{LVE_FILEMODE});
        `chmod $md "$file"`;
    }
    return $fh;
}

# emit a centered title with status and cell name
sub centered_title {
    my ($fh,$status,$title,$cellname) = @_;
    return if $fh == 0;
    print $fh "<center>\n";
    print $fh "<h2 style=\"background-color: $color_palette{$status};\">$status $title $cellname </h2>\n";
    print $fh "</center>\n";
}

# start a web page and add a task specific title
sub start_page {
    my ($file,$title,$task,$status, $dotdot) = @_;
    my $fh = start_simple_page($file,$title,$dotdot);
    return 0 if $fh == 0;
    
    # add task specific title
    my $ASPICE_DIR_LEN = 6;
    my $HSIM_DIR_LEN = 5;
    my $ALINT_DIR_LEN = 3;
    $task = "" if(!defined $task);
    if($task eq "aspice" ){
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)\/aspice\/(\S+)/ ) {
            
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"ASPICE",$cellname);
            
            my @conditions = split('/', $4);
            if(scalar(@conditions) == $ASPICE_DIR_LEN){
                push @conditions, $2;
                push @conditions, $3;
                print_2col_table($fh,"Parameters",
                                 ["Environment","Corner","Voltage",
                                  "Temperature","Simulation Duration",
                                  "Time Delay Range",
                                  "View","Mode"], \@conditions);
            }
            else {
                print $fh "<h1>A: $title</h1>\n";
            }
        }
        else {
            print $fh "<h1>$title</h1>\n";
        }
    }
    elsif($task eq "asta" ) {
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)\/alint\/(\S+)/ ) {
            
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"ASTA",$cellname);
            
            my @conditions = split('/', $4);
            if(scalar(@conditions) == $ALINT_DIR_LEN){
                push @conditions, $2;
                push @conditions, $3;
                print_2col_table($fh,"Parameters",
                                 ["Corner","Voltage","Temperature","View",
                                  "Mode"], \@conditions);
            }
            else {
                print $fh "<h1>A: $title</h1>\n";
            }
        }
        else {
            print $fh "<h1>$title</h1>\n";
        }
    }
    elsif($task eq "slint" ) {
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)\/alint\/(\S+)/ ) {
            
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"SLINT",$cellname);
            
            my @conditions = split('/', $4);
            if(scalar(@conditions) == $ALINT_DIR_LEN){
                push @conditions, $2;
                push @conditions, $3;
                print_2col_table($fh,"Parameters",
                                 ["Corner","Voltage","Temperature","View",
                                  "Mode"], \@conditions);
            }
            else {
                print $fh "<h1>A: $title</h1>\n";
            }
        }
        else {
            print $fh "<h1>$title</h1>\n";
        }
    }
    elsif($task eq "hsim" ){
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)\/hsim\/(\S+)/ ) {
            
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"HSIM",$cellname);
            
            my @conditions = split('/', $4);
            if(scalar(@conditions) == $HSIM_DIR_LEN){
                push @conditions, $2;
                push @conditions, $3;
                print_2col_table($fh,"Parameters",
                                 ["Environment","Corner","Voltage",
                                  "Temperature","Simulation Duration",
                                  "View","Mode"], \@conditions);
            }
            else {
                print $fh "<h1>A: $title</h1>\n";
            }
        }
        else {
            print $fh "<h1>$title</h1>\n";
        }
    }
    elsif($task eq "alint"){
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)\/alint\/(\S+)/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"ALINT",$cellname);
            
            my @conditions = split('/', $4);
            if(scalar(@conditions) == $ALINT_DIR_LEN){
                push @conditions, $2;
                push @conditions, $3;
                print_2col_table($fh,"Parameters", 
                                 ["Corner","Voltage","Temperature","View","Mode"], 
                                 \@conditions);
            }
            else {
                print $fh "<h1>$title</h1>\n";
            }
        }
    }
    elsif($task eq "lib"){
        # note: this is not lib because lib is in the alint tree
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)\/alint\/(\S+)/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"LIB",$cellname);
            
            my @conditions = split('/', $4);
            if(scalar(@conditions) == $ALINT_DIR_LEN){
                push @conditions, $2;
                push @conditions, $3;
                print_2col_table($fh,"Parameters", 
                                 ["Corner","Voltage","Temperature","View","Mode"], 
                                 \@conditions);
            }
            else {
                print $fh "<h1>$title</h1>\n";
            }
        }
    }
    elsif($task eq "hdrc") {
        if($title =~ /(\S+)\/layout/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"HDRC",$cellname);
        }
    }
    elsif($task eq "drc") {
        if($title =~ /(\S+)\/layout/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"DRC",$cellname);
        }
    }
    elsif($task eq "frc") {
        if($title =~ /(\S+)\/layout/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"FRC",$cellname);
        }
    }
    elsif($task eq "lvs") {
        if($title =~ /(\S+)\/layout/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"LVS",$cellname);
        }
    }
    elsif($task eq "extract") {
        if($title =~ /(\S+)\/([^\/]+)\/([^\/]+)/){
            my $cellname = get_cellname($1);
            centered_title($fh,$status,"EXTRACT",$cellname);
            my @conditions = ($2, $3);
            print_2col_table($fh,"Parameters", ["View","Mode"], \@conditions);
        }
    }
    elsif($task eq "jlvs") {
        my $cellname = get_cellname($title);
        centered_title($fh,$status,"JLVS",$cellname);
    }
    elsif($task eq "cell") {
        my $cellname = get_cellname($title);
        centered_title($fh,$status,"",$cellname);
    }
    else {
        print $fh "<center>\n";
        print $fh "<h1>$title</h1>\n";
        print $fh "</center>\n";
    }
    return $fh;
}

#get the cellname from .cellname file in subtype dir
sub get_cellname {
    my $celldir = shift;
    my $cellname = "$$";
    if(-e "$celldir/.cellname"){
        #get first line from .cellname file
        open _CELLNAME_, "<$celldir/.cellname";
        $cellname = <_CELLNAME_>;  # read and discard name from cdlfile
        $cellname = <_CELLNAME_>;  # apparently this is the cellname                                   
        close _CELLNAME_;
    }
    return $cellname;
}

sub print_2col_table {
    my($fh,$header,$keys,$values) = @_;
    
    return if $fh == 0;
    table($fh,1,"100%",1,1);
    print $fh "<TR BGCOLOR=\"#CCCCFF\">\n";
    print $fh "<TD COLSPAN=2><FONT SIZE=\"+2\">"
        ."<B>$header</B></FONT></TD></TR>\n";

    my $i=0;

    foreach my $value(@{$values}){
        print $fh "<TR BGCOLOR=\"white\" CLASS=\"TableRowColor\">"
            ."<TD ALIGN=\"right\" VALIGN=\"top\" WIDTH=\"1%\">"
            ."<CODE> @{$keys}[$i] </CODE></TD>\n";
        if (defined @{$values}[$i]) {
            print $fh "<TD><CODE><B> @{$values}[$i] </B></CODE>\n";
        }
        else {
            print $fh "<TD><CODE><B> not found </B></CODE>\n";
        }
        $i++;
    }
    finish_table($fh);    
}

# given an working dir use the .cellname file to determine the base
sub index_base {
    my $dir = shift;
    my $cellname = get_cellname($dir);
    chop($cellname);
    ($basename, $plusminus) = partition_fqcnminus($cellname);
    my $cellpath = $basename;
    $cellpath =~ s/\./\//g;
    $cellpath .= "$plusminus";
    
    if($dir =~ /(\S+)\Q$cellpath\E/){
        return ($1,$cellname);
    }
    # infact this should be good for both case; don't want to 
    # tamper too much before leaf though
    else {
        $basename =~ s/\./\//g;
        if($dir =~ /(\S+)\Q$basename\E/){
            return ($1,$cellname);
        }
    }
    ("",$cellname);
}

# extract the circuit statistics from a given aspice run
sub read_aspice_stdout {
    my $outfile = shift;
    my %statistics = ();
    open ASPICE_OUT, "<$outfile" or return;
    while(<ASPICE_OUT>){
        if($_ =~ /(\d+) analog nodes/)    { $statistics{"analog nodes"}    = $1; }
        if($_ =~ /(\d+) transistors/)     { $statistics{"transistors"}     = $1; }
        if($_ =~ /(\d+) diodes/)          { $statistics{"diodes"}          = $1; }
        if($_ =~ /(\d+) capacitors/)      { $statistics{"capacitors"}      = $1; }
        if($_ =~ /(\d+) resistors/)       { $statistics{"resistors"}       = $1; }
        if($_ =~ /(\d+) current sources/) { $statistics{"current sources"} = $1; }
        if($_ =~ /(\d+) digital nodes/)   { $statistics{"digital nodes"}   = $1; }
        if($_ =~ /(\d+) digital rules/)   { $statistics{"digital rules"}   = $1; }       
    }    
    return %statistics;
}

sub circuit_stats {
    my ($fh,$aspice_out) = @_;
    return if $fh == 0;
    my %statistics = read_aspice_stdout($aspice_out);
    print_2col_table($fh,"Circuit Statistics", 
                     ["analog_nodes",
                      "transistors",
                      "diodes",
                      "capacitors",
                      "resistors",
                      "current_sources",
                      "digital_nodes",
                      "digital_rules"],
                     [$statistics{"analog nodes"},
                      $statistics{"transistors"},
                      $statistics{"diodes"},
                      $statistics{"capacitors"},
                      $statistics{"resistors"},
                      $statistics{"current sources"},
                      $statistics{"digital nodes"},
                      $statistics{"digital rules"}]);
}

#write out simulation diagnostics info
sub sim_diagnostics {
    my ($fh,$dir,$file) = @_;
    return if $fh == 0;
    my $opened = 1;
    open TIME, "<$dir/$file" or $opened = 0;
    print $fh "<h3>Simulation Diagnostics:</h3>";
    if($opened == 0){
        print $fh "No simulation time information found.<br>";
        return;
    }
    
    my $lveVersion = "LVE Build: unspecified";
    my $pdkVersion = "PDK Build: unspecified";
    my $hostinfo = "Host: unspecified";
    my $computeHostinfo = "Compute Host: unspecified";
    my $start = "";
    my $stop = "";
    my $duration = "?";

    # for backward compatibility
    while(<TIME>) {
        my $str = $_;
        if($str =~ /^Host/){
            $hostinfo = $str;
        } elsif($str =~ /^lve Build:/){
            $lveVersion = $str; 
        } elsif($str =~ /pdk Build:/){
            $pdkVersion = $str; 
        } elsif($str =~ /^Compute Host:/){
            $computeHostinfo = $str; 
        } elsif($str =~ /^started: (.*)/){
            $start = $1; chomp $start;
        } elsif($str =~ /^finished: (.*)/){
            $stop = $1;  chomp $stop;
        }
    }
    if($start && $stop ) {
        $duration = get_seconds($stop) - get_seconds($start);
    }
    print $fh "Simulation Started: $start<br>";
    print $fh "Simulation Ended: $stop<br>";
    print $fh "Duration: $duration(s)<br>";
    print $fh "$lveVersion<br>";
    print $fh "$pdkVersion<br>";
    print $fh "$hostinfo<br>";
    print $fh "$computeHostinfo<br>";
    close TIME;
}


# creat a table withe passed border, with and cellpadding
sub table {
    my $fh = shift;
    return if $fh == 0;
    my $border; 
    my $width; 
    my $cellpadding; 
    my $cellspacing;
    ($border,$width,$cellpadding,$cellspacing) = @_;
    print $fh "\n<TABLE BORDER=\"$border\" WIDTH=\"$width\" "
        ."CELLPADDING=\"$cellpadding\" CELLSPACING=\"$cellspacing\">\n";
}

# insert Fulcrum copyright notice into page
sub FulcrumCopyright {
    my $fh = shift;
    return if $fh == 0;
    my @time_array = gmtime;
    my $year = $time_array[5];
    $year = $year + 1900;
    my $copyright = <<COPYRIGHT;
<i>CONFIDENTIAL AND PROPRIETARY DATA of Fulcrum Microsystems. 
&copy copyright $year. All Rights Reserved<br>
This package contains valuable trade secrets and proprietary information of 
Fulcrum Microsystems, Inc., and is protected by U.S. and international laws
 and/or treaties.</i>
COPYRIGHT
        print $fh "$copyright";
}

# write final contents of Fulrcum Html page 
sub finish_page {
    my $fh = shift;
    return if $fh == 0;
    print $fh "<HR>\n";
    FulcrumCopyright($fh);
    finish_simple_page($fh);
}

# just finish up a basic web page
sub finish_simple_page {
    my $fh = shift;
    return if $fh == 0;
    print $fh "</BODY>\n";
    print $fh "</HTML>\n";
    close $fh;
}

# write row of an HTML table
sub write_row {
    my $fh = shift;
    return if $fh == 0;
    my $color = shift;
    print $fh "<TR BGCOLOR=\"$color\" >\n";
    foreach $value (@_){
        print $fh "<TD>$value</TD>";
    }
    print $fh "\n</TR>\n";
}

# start a table given a header list
sub start_table {
    my $fh = shift;
    return if $fh == 0;
    print $fh "<table cellpadding=\"2\" cellspacing=\"2\" border=\"1\" width=\"100%\" align=\"center\">\n";
    print $fh "<tr BGCOLOR=\"#CCCCFF\">\n";
    foreach my $i (@_) {
        print $fh "<th>$i</th>\n";
    }
    print $fh "</tr>\n";
}

# finish a table
sub finish_table {
    my $fh = shift;
    return if $fh == 0;
    print $fh "</table>\n";
}

# start a row of a table using color given by status
sub table_row {
    my ($fh, $status, @entries) = @_;
    return if $fh == 0;
    print $fh "<tr BGCOLOR=\"$color_palette{$status}\">\n";
    foreach my $entry (@entries) {
        print $fh "<td>$entry</td>\n";
    }
    print $fh "</tr>\n";
}

# emit an HTML link
sub web_link {
    my ($fh, $name, $link) = @_;
    return if $fh == 0;
    print $fh "<a href=\"$link\">$name</a><br>\n";
}

# link a bunch of text files in a html list, if they exist
sub link_files {
    my $fh = shift;
    return if $fh == 0;
    my $dir = shift;
    my @files = @_;
    ul($fh);
    foreach my $file (@files) {
        if (-e "$dir/$file") { li($fh); web_link($fh,$file,$file); }
    }
    Endul($fh);
}

# useful html tags
sub hr { my $fh = shift; print $fh "<HR>\n" unless $fh == 0; }
sub ul { my $fh = shift; print $fh "<UL>\n" unless $fh == 0; }
sub li { my $fh = shift; print $fh "<LI>\n" unless $fh == 0; }
sub p  { my $fh = shift; print $fh "<P>\n" unless $fh == 0; }
sub Endul { my $fh = shift; print $fh "</UL>\n" unless $fh == 0; }


sub lve_summarize {
    my ($task,$dir,$tmp_index_table,$force) = @_;

    $force = 1 if ! defined $force;
    my @alint_html=("em.html","bumps.html","alint.html","leakage.html","delays.html");
    my @lib_html=("lib.html","libdelays.html");
    my @html=();
    if ($task eq "alint") {
        @html=@alint_html;
    }
    elsif ($task eq "lib") {
        @html=@lib_html;
    }
    elsif ($task =~ /^(hlvs|jlvs|drc|hdrc|lvs)$/) {
        @html=("$task.html");
    }
    # read raw file
    if ( ! $force and @html) {
        my $done=1;
        my $stat=stat("$dir/$task.raw");
        if ($stat) {
            my $rawtime=$stat->mtime;
            foreach my $file (@html) {
                $stat=stat("$dir/$file");
                if ($stat) {
                    if ($stat->mtime < $rawtime) {
                        $done=0;
                        last;
                    }
                }
                else {
                    $done=0;
                    last;
                }
            }
        }
        return if $done;
    }
    print "summarizing $task $dir\n";
    my @raw = get_lines("$dir/${task}.raw");
    
    # handle various tasks
    if ($task eq "aspice") {

        return if (! -e "$dir/aspice.done");
        
        # transient aspice simulation
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,9);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);

        # report power, deadlock, cosim failure
        print $fh "<h3>Warnings/Notices:</h3>\n" unless $fh == 0;
        foreach my $line (sort @raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            if ($task eq "aspice" && defined $results{initial} && $status eq "FAIL") {
                print $fh "[FAIL] Some nodes U after reset.  " .
                    "Inspect <a href=\"aspice.initial\">aspice.initial</a>.<br>\n"
                        unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{extract} && $status eq "FAIL") {
                print $fh "[FAIL] Extract failed, skipping aspice.<br>\n"
                    unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{extract} && $status eq "SIGNOFF") {
                print $fh "[SIGNOFF] Extract signed off, skipping aspice.<br>\n"
                    unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{power} && $status eq "FAIL") {
                print $fh "[FAIL] Power: Measurement failed.<br>\n"
                    unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{power} && $status eq "PASS") {
                print $fh "[PASS] Power: $results{power}W<br>\n"
                    unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{peak_power} && $status eq "PASS") {
                print $fh "[PASS] Peak power: $results{peak_power}W<br>\n"
                    unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{deadlock} && $status eq "FAIL") {
                my ($n,$t) = split("@",$results{deadlock});
                print $fh "[FAIL] Simulation deadlocked.  " .
                    "Last transition of node $n occurred at ${t}ps.<br>"
                        unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{warn} && $status eq "FAIL") {
                print $fh "[FAIL] Analog/digital cosimulation failure.  " . 
                    "Inspect <a href=\"aspice.warn\">aspice.warn</a>.<br>"
                        unless $fh == 0;
            }
            if ($task eq "aspice" && defined $results{warn_file} && $status eq "FAIL") {
                print $fh "[FAIL] Analog/digital cosimulation failure.  " . 
                    "Inspect <a href=\"aspice.warn\">aspice.warn</a>.<br>"
                        unless $fh == 0;
            }
        }

        # report ntpc_spec nodes
        print $fh "<h3>Nodes of interest:</h3>\n"
            unless $fh == 0;
        start_table($fh,"Node","Critical Path","History","Frequency (GHz)",
                    "Measured Cycles","NTPC")
                        unless $fh == 0;
        foreach my $line (sort @raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            if ($task eq "aspice" && defined $results{node}) {
                if (!defined $results{frequency}) { $results{frequency} = MISSING; }
                if (!defined $results{ntpc})      { $results{ntpc}      = MISSING; }
                if (!defined $results{cycles})    { $results{cycles}    = MISSING; }
                my $node = $results{node};
                my $nodelink = $node;
                if (-e "$dir/aspice:${node}.png") {
                    $nodelink = "<a href=./aspice:${node}.png>$node</a>";
                }
                table_row($fh,$status,
                          $nodelink,
                          "<a href=./aspice:${node}.critical>critical</a>",
                          "<a href=./aspice:${node}.history>history</a>",
                          "$results{frequency}",
                          "$results{cycles}",
                          "$results{ntpc}");
            }
        }
        finish_table($fh);
        p($fh);
        
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"aspice.raw","aspice.out","aspice.err",
                   "aspice.prelog","aspice.log","aspice.warn",
                   "aspice.initial","aspice.final","aspice.final_pending")
                    unless $fh == 0;
        circuit_stats($fh,"$dir/aspice.out");
        sim_diagnostics($fh,$dir, "aspice.done.diag");
        finish_page($fh);
        
    } elsif ($task eq "asta") {

        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,9);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        @raw = sort(@raw);
        start_table($fh,"Tau (ps)","Input slew (ps)", "Output cap (fF)",
                    "Worst Tau (ps)", "Flat Violations",
                    "Hierarchical Violations", "Flat Timing Arcs",
                    "Hierarchical Timing Arcs", "stdout", "stderr")
                        unless $fh == 0;
        print $fh "<h3>ASTA Measurements:</h3>\n"
            unless $fh == 0;
        foreach my $line (@raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            my $tau = $results{tau};
            my ($worst_tau, $input_slew, $output_cap) = ('','','');
            $worst_tau = $results{worst_tau} if exists($results{worst_tau});
            $input_slew = $results{input_slew} if exists($results{input_slew});
            $output_cap = $results{output_cap} if exists($results{output_cap});

            my @entries = ();
            push @entries,$tau,$input_slew,$output_cap,$worst_tau;

            foreach my $file ('flat.violations', 'hier.violations',
                              'flat.timing', 'hier.timing', 'out',
                              'err') {
                my $entry = "";
                if ( -e "$dir/asta/$tau/$file" ) {
                    $entry = "<a href=\"./asta/$tau/$file\">$file</a>";
                }
                push @entries,$entry;
            }
            table_row($fh,$status,@entries);
        }
        finish_table($fh);
        finish_page($fh);
    } elsif ($task eq "slint") {

        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,9);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        @raw = sort(@raw);
        start_table($fh, "All Violations",
                    "Violations by type", "stdout", "stderr")
                        unless $fh == 0;
        print $fh "<h3>Slint Results:</h3>\n"
            unless $fh == 0;
        my @entries = ();
        foreach my $file ('violations.all', 'violations.summary',
                          'out', 'err') {
            my $entry = "";
            if ( -e "$dir/slint/$file" ) {
                $entry = "<a href=\"./slint/$file\">$file</a>";
            }
            push @entries,$entry;
        }
        table_row($fh,$overall_status,@entries);
        finish_table($fh);
        finish_page($fh);
    } elsif ($task eq "alint") {

        return if (! -e "$dir/alint.done");
        # alint aspice simulation
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,6);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        @raw = sort(@raw);

        # first pass through alint.raw
        my $cellname = "";
        print $fh "<h3>Warnings/Notices:</h3>\n"
            unless $fh == 0;
        my @parsed_raw=();
        my @parsed_bump_raw=();
        my @parsed_delay_raw=();
        my @parsed_leak_raw=();
        my @parsed_em_raw=();
        foreach my $line (@raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            push @parsed_raw, [$status, $task, $cell, $path, %results];
            push @parsed_bump_raw, [$status, $task, $cell, $path, %results]
                if ((defined $results{bump_up}) && (defined $results{bump_dn}));
            push @parsed_delay_raw, [$status, $task, $cell, $path, %results]
                if ((defined $results{delay_dn}) && (defined $results{delay_up}));
            push @parsed_leak_raw, [$status, $task, $cell, $path, %results]
                if ((defined $results{leak_up}) && (defined $results{leak_dn}));
            push @parsed_em_raw, [$status, $task, $cell, $path, %results]
                if ((defined $results{em_avg}) && (defined $results{em_rms}));
            $cellname = $cell; # remember the cellname

            # check extract issues
            if ($task eq "alint" && defined $results{extract} && $status eq "FAIL") {
                print $fh "[FAIL] Extract failed, skipping alint.<br>\n"
                    unless $fh == 0;
            }
        }

        # alint signoff/fail table
        print $fh "<h3>Signoffs or failed measurements:</h3>\n"
            unless $fh == 0;
        start_table($fh,"Node","stdout","stderr","Delay Dn (ps)<br>(spec)",
                    "Delay Up (ps)<br>(spec)","Error Message")
                        unless $fh == 0;
        foreach my $line (@parsed_raw) {
            my ($status, $task, $cell, $path, %results) = @{$line};
            if ((defined $results{node}) && (defined $results{alint})) {
                my $node = $results{node};

                # parse results
                my $delay_dn = $results{delay_dn};
                my $delay_up = $results{delay_up};
                my $error = "";
                if (defined $results{error}) { $error = $results{error}; }
                
                # print row of table
                my $out = $status;
                my $err = $status;
                if ( -d "$dir/$task.bin.0" ) {
                    for (my $bin=0; $bin < 16; $bin++) {
                        if (-e "$dir/$task.bin.$bin/$node/out") {
                            $out = "<a href=\"./$task.bin.$bin/$node/out\">out</a>";
                            last;
                        }
                    }
                }
                elsif ( -e "$dir/$node/out" ) { $out = "<a href=\"./$node/out\">out</a>"; }
                if ( -d "$dir/$task.bin.0" ) {
                    for (my $bin=0; $bin < 16; $bin++) {
                        if (-e "$dir/$task.bin.$bin/$node/err") {
                            $err = "<a href=\"./$task.bin.$bin/$node/err\">err</a>";
                            last;
                        }
                    }
                }
                elsif ( -e "$dir/$node/err" ) { $err = "<a href=\"./$node/err\">err</a>"; }
                table_row($fh,$status,$node,
                          "$out","$err",
                          "$delay_dn","$delay_up","$error");
            }
        }
        finish_table($fh);

        # alint tables
        print $fh "<h3><a href=\"bumps.html\">Bumps:</a></h3>\n"
            unless $fh == 0;
        $bump_status = alint_bump_table($dir,$fh,1,@parsed_bump_raw);

        print $fh "<h3><a href=\"delays.html\">Delays:</a></h3>\n"
            unless $fh == 0;
        $delay_status = alint_delay_table($dir,$fh,1,@parsed_delay_raw);

        print $fh "<h3><a href=\"leakage.html\">Leakage:</a></h3>\n"
            unless $fh == 0;
        $leak_status = alint_leak_table($dir,$fh,1,@parsed_leak_raw);

        print $fh "<h3><a href=\"em.html\">Electromigration:</a></h3>\n"
            unless $fh == 0;
        $em_status = alint_em_table($dir,$fh,1,@parsed_em_raw);

        # link additional files
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"alint.raw","alint.out","alint.err");
        circuit_stats($fh,"$dir/alint.out");
        sim_diagnostics($fh,$dir, "alint.done.diag");
        finish_page($fh);

        # alint sub-tables
        $fh = start_simple_page("$dir/bumps.html","Bumps",$dotdot);
        centered_title($fh,$bump_status,"ALINT Bumps",$cellname);
        alint_bump_table($dir,$fh,0,@parsed_bump_raw);
        finish_simple_page($fh);

        $fh = start_simple_page("$dir/delays.html","Delays",$dotdot);
        centered_title($fh,$delay_status,"ALINT Delays",$cellname);
        alint_delay_table($dir,$fh,0,@parsed_delay_raw);
        finish_simple_page($fh);

        $fh = start_simple_page("$dir/leakage.html","Leakage",$dotdot);
        centered_title($fh,$leak_status,"ALINT Leakage",$cellname);
        alint_leak_table($dir,$fh,0,@parsed_leak_raw);
        finish_simple_page($fh);

        $fh = start_simple_page("$dir/em.html","Electromigration",$dotdot);
        centered_title($fh,$em_status,"ALINT Electromigration",$cellname);
        alint_em_table($dir,$fh,0,@parsed_em_raw);
        finish_simple_page($fh);

    } elsif ($task eq "lib") {

        return if (! -e "$dir/lib.done");
        return if (! @raw);
        my $ok = 0;
        foreach my $line (@raw) {
            my @f=split(/ /, $line);
            if ($#f > 0) {$ok = 1; last}
        }
        return if ! $ok;
        # lib aspice simulation
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,6);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        @raw = sort(@raw);

        # first pass through lib.raw
        my $cellname = "";
        print $fh "<h3>Warnings/Notices:</h3>\n"
            unless $fh == 0;
        my @parsed_raw=();
        my @parsed_delay_raw=();
        foreach my $line (@raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            push @parsed_raw, [$status, $task, $cell, $path, %results];
            push @parsed_delay_raw, [$status, $task, $cell, $path, %results]
                if ((defined $results{delay_dn}) && (defined $results{delay_up}));
            $cellname = $cell; # remember the cellname

            # check extract issues
            if (defined $results{extract} && $status eq "FAIL") {
                print $fh "[FAIL] Extract failed, skipping alint.<br>\n"
                    unless $fh == 0;
            }
        }

        # lib signoff/fail table
        print $fh "<h3>Signoffs or failed measurements:</h3>\n"
            unless $fh == 0;
        start_table($fh,"Node","stdout","stderr","Delay Dn (ps)<br>(spec)",
                    "Delay Up (ps)<br>(spec)","Error Message");
        foreach my $line (@parsed_raw) {
            my ($status, $task, $cell, $path, %results) = @{$line};
            if (($task eq "lib") && 
                (defined $results{node}) && 
                (defined $results{lib})) {
                my $node = $results{node};

                # parse results
                my $delay_dn = $results{slow_delay_dn};
                my $delay_up = $results{slow_delay_up};
                next if ! defined ($delay_dn) or ! defined ($delay_up);
                my $error = "";
                if (defined $results{error}) { $error = $results{error}; }
                
                # print row of table
                my $out = $status;
                my $err = $status;
                if ( -d "$dir/$task.bin.0" ) {
                    for (my $bin=0; $bin < 16; $bin++) {
                        if (-e "$dir/$task.bin.$bin/$node/out") {
                            $out = "<a href=\"./$task.bin.$bin/$node/out\">out</a>";
                            last;
                        }
                    }
                }
                elsif ( -e "$dir/$node/out" ) { $out = "<a href=\"./$node/out\">out</a>"; }
                if ( -d "$dir/$task.bin.0" ) {
                    for (my $bin=0; $bin < 16; $bin++) {
                        if (-e "$dir/$task.bin.$bin/$node/err") {
                            $err = "<a href=\"./$task.bin.$bin/$node/err\">err</a>";
                            last;
                        }
                    }
                }
                elsif ( -e "$dir/$node/err" ) { $err = "<a href=\"./$node/err\">err</a>"; }
                table_row($fh,$status,$node,
                          "$out","$err",
                          "$delay_dn","$delay_up","$error");
            }
        }
        finish_table($fh);

        # lib tables
        print $fh "<h3><a href=\"delays.html\">Delays:</a></h3>\n"
            unless $fh == 0;
        $delay_status = alint_delay_table($dir,$fh,1,@parsed_delay_raw);

        # link additional files
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"lib.raw","lib.out","lib.err");
        circuit_stats($fh,"$dir/lib.out");
        sim_diagnostics($fh,$dir, "lib.done.diag");
        finish_page($fh);

        # lib sub-tables

        $fh = start_simple_page("$dir/libdelays.html","Delays",$dotdot);
        centered_title($fh,$delay_status,"LIB Delays",$cellname);
        alint_delay_table($dir,$fh,0,@parsed_delay_raw);
        finish_simple_page($fh);

    } elsif ($task eq "hsim") {

        # hsim transient simulation
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,8);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);

        print $fh "<h3>Warnings/Notices:</h3>\n"
            unless $fh == 0;
        foreach my $line (sort @raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            if ($task eq "hsim" && defined $results{power} && defined $results{supply}) {
                print $fh "[$status] Supply=$results{supply} Power=$results{power}W<br>\n"
                    unless $fh == 0;
            }
        }
        
        # report ntpc_spec nodes
        print $fh "<h3>Nodes of interest:</h3>\n"
            unless $fh == 0;
        start_table($fh,"Node","Frequency (GHz)","Measured Cycles");
        foreach my $line (sort @raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            if ($task eq "hsim" && defined $results{node}) {
                if (!defined $results{frequency}) { $results{frequency} = MISSING; }
                if (!defined $results{cycles})    { $results{cycles}    = MISSING; }
                my $node = $results{node};
                table_row($fh,$status,"$node","$results{frequency}","$results{cycles}");
            }
        }
        finish_table($fh);
        p($fh);
        
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"hsim.raw","hsim.out","hsim.log","hsim.err");
        sim_diagnostics($fh, $dir, "hsim.out.diag");
        finish_page($fh);

    } elsif ($task eq "hlvs") {

        # hlvs
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,1);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"hlvs.raw","hlvs.err","hlvs.compare");
        sim_diagnostics($fh, $dir, "hlvs.diag");
        finish_page($fh);

    } elsif ($task eq "hdrc") {

        # hdrc
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,1);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"hdrc.raw","hdrc.err","hdrc.layout_errs");
        sim_diagnostics($fh, $dir, "hdrc.err.diag");
        finish_page($fh);

    } elsif ($task eq "drc") {

        # drc
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,1);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"drc.raw","drc.err","drc.tar.bz2");
        sim_diagnostics($fh, $dir, "drc.err.diag");
        finish_page($fh);

    } elsif ($task eq "frc") {

        # Fulcrum Rule Check (was: checkpoly)
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,1);
        my $fh = start_page("$dir/frc.html",$dir,"frc",$overall_status,$dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"frc.raw","frc.err");
        sim_diagnostics($fh, $dir, "$task.err.diag");
        finish_page($fh);
        
    } elsif ($task eq "checkpoly") {

        # Old checkpoly test: ignore

    } elsif ($task eq "lvs") {

        # lvs
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,1);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status,$dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"lvs.raw","lvs.cls","lvs.tar.bz2");
        sim_diagnostics($fh,$dir, "lvs.cls.diag");
        finish_page($fh);

    } elsif ($task eq "extract") {

        # extract
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,2);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,
                   "extract.raw","extract.err",
                   "nvn.log","nvn2.log","extract.tar.bz2", 
                   "cell.spice","cell.aspice",
                   "rc_spice2aspice.out","rc_spice2aspice.err",
                   "cell.spice_gds2","cell.spice_hsim",
                   "electromigration_localnets.debug",
                   "electromigration_operators.debug",
                   "wires.debug", "lib.lef", "graybox_list");
        sim_diagnostics($fh, $dir, "cell.spice_gds2.diag");
        finish_page($fh);

    } elsif ($task eq "jlvs") {

        # jlvs
        my $overall_status = get_status(@raw);
        my $dotdot = get_dotdot($dir,0);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status, $dotdot);
        print $fh "<h3>Files:</h3>\n"
            unless $fh == 0;
        link_files($fh,$dir,"jlvs.raw","jlvs.out","jlvs.err");
        sim_diagnostics($fh, $dir, "jlvs.err.diag");
        finish_page($fh);
        
    } elsif ($task eq "index") {

        # index page summarizing all cells
        print "Index generation is done in lve_resummarize\n";
        
    } elsif ($task eq "cell") {
        
        # collect results for all tests on this cell
        my $overall_status = "PASS";
        my %tests = ();
        
        # create page
        my ($root_dir, $cellname) = index_base($dir);
        # if owned by you, make sure it is group writable
        `chmod g+w "$root_dir/index_tmp.table" 2>/dev/null` if -w "$root_dir/index_tmp.table";
        open INDEX_TABLE, ">>$tmp_index_table" or 
            die "cannot open  $tmp_index_table to append\n";
        my $status_str = "CELL:=$cellname ";
        
        foreach my $line (@raw) {
            my ($status, $task, $cell, $path, %results) = parse_raw_line($line);
            $path = "$path/$task";
            my ($basename, $plusminus) = partition_fqcnminus($cell);
            $cell = $basename;
            $cell =~ s/\./\//g;
            $cell .= "$plusminus";
            
            $path =~ s,^\Q$cell\E\/,,;
            $tests{$task}{$path} = combine_status($tests{$task}{$path},$status);
            $overall_status = combine_status($overall_status,$status);
        } 
        my $dotdot = get_dotdot($dir,0);
        my $fh = start_page("$dir/$task.html",$dir,$task,$overall_status,$dotdot);
        if(scalar(keys %{$tests{"jlvs"}}) > 0){
            my $jlvs_status;
            foreach my $key (sort keys %{$tests{"jlvs"}}) {
                web_link($fh,"JLVS: $tests{\"jlvs\"}{$key}", "$key.html");
                $jlvs_status = combine_status($jlvs_status,$tests{"jlvs"}{$key});
            }
            $status_str = $status_str."JLVS:=$jlvs_status ";
        }
        else {
            $status_str = $status_str."JLVS:=NOT_TESTED ";
            print $fh "JLVS: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;
        
        if(scalar(keys %{$tests{"lvs"}}) > 0){
            my $lvs_status;
            foreach my $key (sort keys %{$tests{"lvs"}}) {
                web_link($fh,"LVS: $tests{\"lvs\"}{$key}", "$key.html");
                $lvs_status = combine_status($lvs_status,$tests{"lvs"}{$key});
            }
            $status_str = $status_str."LVS:=$lvs_status ";
        }
        else {
            $status_str = $status_str."LVS:=NOT_TESTED ";
            print $fh "LVS: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;

        if(scalar(keys %{$tests{"extract"}}) > 0){
            my $extract_status;
            foreach my $key (sort keys %{$tests{"extract"}}) {
                web_link($fh,"EXTRACT: $tests{\"extract\"}{$key}", "$key.html");
                $extract_status = combine_status($extract_status,$tests{"extract"}{$key});
            }
            $status_str = $status_str."EXTRACT:=$extract_status ";
        }
        else {
            $status_str = $status_str."EXTRACT:=NOT_TESTED ";
            print $fh "EXTRACT: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;
        
        if(scalar(keys %{$tests{"drc"}}) > 0){
            my $drc_status;
            foreach my $key (sort keys %{$tests{"drc"}}) {
                web_link($fh,"DRC: $tests{\"drc\"}{$key}", "$key.html");
                $drc_status = combine_status($drc_status,$tests{"drc"}{$key});
            }
            $status_str = $status_str."DRC:=$drc_status ";
        }
        else {
            $status_str = $status_str."DRC:=NOT_TESTED ";
            print $fh "DRC: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;

        if(scalar(keys %{$tests{"hdrc"}}) > 0){
            my $hdrc_status;
            foreach my $key (sort keys %{$tests{"hdrc"}}) {
                web_link($fh,"HDRC: $tests{\"hdrc\"}{$key}", "$key.html");
                $hdrc_status = combine_status($hdrc_status,$tests{"hdrc"}{$key});
            }
            $status_str = $status_str."HDRC:=$hdrc_status ";
        }
        else {
            $status_str = $status_str."HDRC:=NOT_TESTED ";
            print $fh "HDRC: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;

        if(scalar(keys %{$tests{"hlvs"}}) > 0){
            my $hlvs_status;
            foreach my $key (sort keys %{$tests{"hlvs"}}) {
                web_link($fh,"HLVS: $tests{\"hlvs\"}{$key}", "$key.html");
                $hlvs_status = combine_status($hlvs_status,$tests{"hlvs"}{$key});
            }
            $status_str = $status_str."HLVS:=$hlvs_status ";
        }
        else {
            $status_str = $status_str."HLVS:=NOT_TESTED ";
            print $fh "HLVS: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;

        if(scalar(keys %{$tests{"frc"}}) > 0){
            my $frc_status;
            foreach my $key (sort keys %{$tests{"frc"}}) {
                web_link($fh,"FRC: $tests{\"frc\"}{$key}", "$key.html");
                $frc_status = combine_status($frc_status,$tests{"frc"}{$key});
            }
            $status_str = $status_str."FRC:=$frc_status ";
        }
        else {
            $status_str = $status_str."FRC:=NOT_TESTED ";
            print $fh "FRC: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;
        
        if(scalar(keys %{$tests{"alint"}}) > 0){
            my $alint_status;
            table($fh,1,"100%",1,1);
            write_row($fh,"#CCCCFF", "ALINT", "View Name", "Mode", "Process Corner",
                      "Voltage", "Temperature");
            foreach my $key (sort keys %{$tests{"alint"}}) {
                if($key =~ /([^\/]+)\/([^\/]+)\/alint\/([^\/]+)\/([^\/]+)\/([^\/]+)\/alint/){
                    write_row($fh,$color_palette{$tests{"alint"}{$key}},
                              "<a href=\"$key.html\"> $tests{\"alint\"}{$key} </a>",
                              $1,$2,$3,$4,$5);
                    $alint_status = combine_status($alint_status,$tests{"alint"}{$key});
                }
            }
            $status_str = $status_str."ALINT:=$alint_status ";
            finish_table($fh); 
        }
        else {
            $status_str = $status_str."ALINT:=NOT_TESTED ";
            print $fh "ALINT: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;
        
        if(scalar(keys %{$tests{"lib"}}) > 0){
            my $lib_status;
            table($fh,1,"100%",1,1);
            write_row($fh,"#CCCCFF", "LIB", "View Name", "Mode", "Process Corner",
                      "Voltage", "Temperature");
            foreach my $key (sort keys %{$tests{"lib"}}) {
                if($key =~ /([^\/]+)\/([^\/]+)\/alint\/([^\/]+)\/([^\/]+)\/([^\/]+)\/lib/){
                    write_row($fh,$color_palette{$tests{"lib"}{$key}},
                              "<a href=\"$key.html\"> $tests{\"lib\"}{$key} </a>",
                              $1,$2,$3,$4,$5);
                    $lib_status = combine_status($lib_status,$tests{"lib"}{$key});
                }
            }
            $status_str = $status_str."LIB:=$lib_status ";
            finish_table($fh); 
        }
        else {
            $status_str = $status_str."LIB:=NOT_TESTED ";
            print $fh "LIB: NOT_TESTED<br>\n"
                unless $fh == 0;
        }
        print $fh "<br>\n"
            unless $fh == 0;
        
        if(scalar(keys %{$tests{"aspice"}}) > 0){
            my $aspice_status;
            table($fh,1,"100%",1,1);
            write_row($fh,"#CCCCFF", "ASPICE", "View Name", "Mode", "Environment" ,"Process Corner",
                      "Voltage", "Temperature", "Duration", "Timed Delay");
            foreach my $key (sort keys %{$tests{"aspice"}}) {
                if($key =~ /([^\/]+)\/([^\/]+)\/aspice\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/aspice/){
                    write_row($fh,$color_palette{$tests{"aspice"}{$key}},
                              "<a href=\"$key.html\"> $tests{\"aspice\"}{$key} </a>",
                              $1,$2,$3,$4,$5,$6,$7,$8);
                    $aspice_status = combine_status($aspice_status,$tests{"aspice"}{$key});
                }
            }
            $status_str = $status_str."ASPICE:=$aspice_status ";
            finish_table($fh); 
        }
        else {
            $aspice_run = `find "$dir" -noleaf -mindepth 3 -maxdepth 3 -name "aspice"`;
            if ($aspice_run =~ /aspice/){
                $status_str = $status_str."ASPICE:=NOT_TESTED ";
                print $fh "ASPICE: NOT_TESTED<br>\n"
                    unless $fh == 0;
            }
            else {
                $status_str = $status_str."ASPICE:=NA ";
                print $fh "ASPICE: NA<br>\n"
                    unless $fh == 0;
            }
        }
        print $fh "<br>\n"
            unless $fh == 0;

        if(scalar(keys %{$tests{"hsim"}}) > 0){
            my $hsim_status;
            table($fh,1,"100%",1,1);
            write_row($fh,"#CCCCFF", "HSIM", "View Name", "Mode", "Environment" ,"Process Corner",
                      "Voltage", "Temperature", "Duration");
            foreach my $key (sort keys %{$tests{"hsim"}}) {
                if($key =~ /([^\/]+)\/([^\/]+)\/hsim\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/hsim/){
                    write_row($fh,$color_palette{$tests{"hsim"}{$key}},
                              "<a href=\"$key.html\"> $tests{\"hsim\"}{$key} </a>",
                              $1,$2,$3,$4,$5,$6,$7);
                    $hsim_status = combine_status($hsim_status,$tests{"hsim"}{$key});
                }
            }
            $status_str = $status_str."HSIM:=$hsim_status ";
            finish_table($fh); 
            print $fh "<br>\n"
                unless $fh == 0;
        }

        if(scalar(keys %{$tests{"asta"}}) > 0){
            my $asta_status;
            table($fh,1,"100%",1,1);
            write_row($fh,"#CCCCFF", "ASTA", "View Name", "Mode", "Process Corner",
                      "Voltage", "Temperature");
            foreach my $key (sort keys %{$tests{"asta"}}) {
                if($key =~ /([^\/]+)\/([^\/]+)\/alint\/([^\/]+)\/([^\/]+)\/([^\/]+)/){
                    write_row($fh,$color_palette{$tests{"asta"}{$key}},
                              "<a href=\"$key.html\"> $tests{\"asta\"}{$key} </a>",
                              $1,$2,$3,$4,$5);
                    $asta_status = combine_status($asta_status,$tests{"asta"}{$key});
                }
            }
            $status_str = $status_str."ASTA:=$asta_status ";
            finish_table($fh); 
        }
        else {
            $status_str = $status_str."ASTA:=NOT_TESTED ";
            print $fh "ASTA: NOT_TESTED<br>\n"
                unless $fh == 0;
        }

        if(scalar(keys %{$tests{"slint"}}) > 0){
            my $slint_status;
            table($fh,1,"100%",1,1);
            write_row($fh,"#CCCCFF", "SLINT", "View Name", "Mode", "Process Corner",
                      "Voltage", "Temperature");
            foreach my $key (sort keys %{$tests{"slint"}}) {
                if($key =~ /([^\/]+)\/([^\/]+)\/alint\/([^\/]+)\/([^\/]+)\/([^\/]+)/){
                    write_row($fh,$color_palette{$tests{"slint"}{$key}},
                              "<a href=\"$key.html\"> $tests{\"slint\"}{$key} </a>",
                              $1,$2,$3,$4,$5);
                    $slint_status = combine_status($slint_status,$tests{"slint"}{$key});
                }
            }
            $status_str = $status_str."SLINT:=$slint_status ";
            finish_table($fh); 
        }
        else {
            $status_str = $status_str."SLINT:=NOT_TESTED ";
            print $fh "SLINT: NOT_TESTED<br>\n"
                unless $fh == 0;
        }

        print $fh "<br>\n"
            unless $fh == 0;

        print INDEX_TABLE "$status_str\n";
        close INDEX_TABLE;
        finish_page($fh);
    
    }
    elsif($task eq "totem" ){
        # fix later
    } else { die "ERROR: unrecognized task $task\n"; }
}

# link a png with a value
sub link_graph {
    my ($dir, $run, $value, $from) = @_;
    foreach my $bin (0..15) {
        if (-e "$dir/alint.bin.$bin/$run.png") { $value = "<a href=\"./alint.bin.$bin/$run.png\">${value}</a>"; last;}
        if (-e "$dir/lib.bin.$bin/$run.png") { $value = "<a href=\"./lib.bin.$bin/$run.png\">${value}</a>"; last;}
    }
    if (! ($value =~ /<a href/)) {
        if (-e "$dir/$run.png") { $value = "<a href=\"./$run.png\">${value}</a>";}
    }
    return $value;
}

# read all alint scenarios from the out file
sub read_scenarios {
    my ($file) = @_;
    my @scenarios = ();
    open IN, "<$file" or die "Can't open $file.\n";
    while (my $line = <IN>) {
        my @tokens = split(" ",$line);
        my $type = shift(@tokens);
        if (($type eq "bump_dn") ||
            ($type eq "bump_up") ||
            ($type eq "fast_dn") ||
            ($type eq "fast_up") ||
            ($type eq "slow_dn") ||
            ($type eq "slow_up")) { push(@scenarios,@tokens); }
    }
    close IN;
    return @scenarios;
}

# return the alint scenario given a type, time, and scenario list
sub find_scenario {
    my ($type, $time, @scenarios) = @_;
    my $best = "";
    foreach $scenario (@scenarios) {
        my @tokens = split(" ",$scenario);
        my $y = shift(@tokens);
        my $t = shift(@tokens);
        if (($y eq $type) && ($t<$time)) { $best=@tokens; }
    }
    return $best;
}

# abbreviate string for inv_nodes
sub abbreviate_string {
    my $name = shift;
    my $length = shift;
    if(length($name) > $length){
        my $shortname = substr($name,0,$length);
        $shortname .= "...";
        return $shortname;
    }
    else {
        return $name;
    }
}

# create an alint bump table
sub alint_bump_table {
    my $dir = shift;
    my $fh = shift;
    my $important_only = shift;
    my @raw = @_;
    my $overall_status;
    return if $fh == 0;

    start_table($fh,"Node","Inv Nodes","stdout","stderr",
                "CC", "Tau (ps)",
                "Bump Dn (%)",
                "Bump Up (%)",
                "Inv Bump Dn (%)",
                "Inv Bump Up (%)");
    foreach my $line (@raw) {
        my ($status, $task, $cell, $path, %results) = @{$line};
        if (($task eq "alint") && 
            (defined $results{node}) && 
            (defined $results{inv_node}) && 
            (defined $results{bump_up}) && 
            (defined $results{bump_dn}) &&
            (defined $results{inv_bump_up}) && 
            (defined $results{inv_bump_dn})) {
            my $node = $results{node};
            my $inv_node = $results{inv_node};
            $overall_status = combine_status($overall_status,$status);
            next if ($important_only && (($status eq PASS) || ($status eq NA)));

            # parse results
            my ($bump_dn,$bump_dn_t) = split("@",$results{bump_dn});
            my ($bump_up,$bump_up_t) = split("@",$results{bump_up});
            if (is_numeric($bump_dn)){$bump_dn = "${bump_dn}%";}
            if (is_numeric($bump_up)){$bump_up = "${bump_up}%";}
            my ($inv_bump_dn,$inv_bump_dn_t) = split("@",$results{inv_bump_dn});
            my ($inv_bump_up,$inv_bump_up_t) = split("@",$results{inv_bump_up});
            if (is_numeric($inv_bump_dn)){$inv_bump_dn = "${inv_bump_dn}%";}
            if (is_numeric($inv_bump_up)){$inv_bump_up = "${inv_bump_up}%";}
            
            # file suffix for cc and tau
            my $suffix = "";
            if (defined $results{tau} && ($results{tau}>0)) {
                $suffix = ":$results{cc}:$results{tau}";
            }
            
            # link graphs if they exist
            if ($status eq FAIL || $status eq SIGNOFF) {
                $bump_dn = link_graph($dir,"$node/bump_dn${suffix}",$bump_dn);
                $bump_up = link_graph($dir,"$node/bump_up${suffix}",$bump_up);
            }
            
            # print row of table
            my $out = $status;
            my $err = $status;
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/out") {
                        $out = "<a href=\"./$task.bin.$bin/$node/out\">out</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/out" ) { $out = "<a href=\"./$node/out\">out</a>"; }
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/err") {
                        $err = "<a href=\"./$task.bin.$bin/$node/err\">err</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/err" ) { $err = "<a href=\"./$node/err\">err</a>"; }
            if ( !defined $results{cc})  { $results{cc}  = "NA"; }
            if ( !defined $results{tau}) { $results{tau} = "NA"; }
            table_row($fh,$status,$node,abbreviate_string($inv_node,32),
                      "$out",
                      "$err",
                      "$results{cc}",
                      "$results{tau}",
                      "$bump_dn",
                      "$bump_up",
                      "$inv_bump_dn",
                      "$inv_bump_up");
        }
    }    
    finish_table($fh);
    if (!defined $overall_status) { $overall_status = "NOT_TESTED"; }
    return $overall_status;
}

# create an alint bump table
sub alint_delay_table {
    my $dir = shift;
    my $fh = shift;
    my $important_only = shift;
    my @raw = @_;
    my $overall_status;
    return if $fh == 0;

    start_table($fh,"Node","stdout","stderr",
                "CC",
                "Tau (ps)",
                "Delay Dn (ps)<br>(spec, slow, fast)",
                "Delay Up (ps)<br>(spec, slow, fast)",
                "Slew Dn (ps)<br>(slow, fast)",
                "Slew Up (ps)<br>(slow, fast)",
                "Skew Dn (ps)",
                "Skew Up (ps)");
    foreach my $line (@raw) {
        my ($status, $task, $cell, $path, %results) = @{$line};
        if ((($task eq "alint") || ($task eq "lib")) && 
            (defined $results{node}) &&
            (defined $results{delay_dn}) && 
            (defined $results{delay_up}) &&
            (defined $results{slow_delay_dn}) && 
            (defined $results{slow_delay_up}) &&
            (defined $results{fast_delay_dn}) &&
            (defined $results{fast_delay_up}) &&
            (defined $results{skew_dn}) &&
            (defined $results{skew_up}) &&
            (defined $results{slow_slew_dn}) &&
            (defined $results{slow_slew_up}) &&
            (defined $results{fast_slew_dn}) &&
            (defined $results{fast_slew_up})) {
            my $node = $results{node};
            $overall_status = combine_status($overall_status,$status);
            next if ($important_only && (($status eq PASS) || ($status eq NA)));

            # parse results
            my $delay_dn = $results{delay_dn};
            my $delay_up = $results{delay_up};

            my ($fast_delay_dn,$fast_delay_dn_t) = split("@",$results{fast_delay_dn});
            my ($fast_delay_up,$fast_delay_up_t) = split("@",$results{fast_delay_up});
            my ($slow_delay_dn,$slow_delay_dn_t) = split("@",$results{slow_delay_dn});
            my ($slow_delay_up,$slow_delay_up_t) = split("@",$results{slow_delay_up});

            my ($fast_slew_dn,$fast_slew_dn_t) = split("@",$results{fast_slew_dn});
            my ($fast_slew_up,$fast_slew_up_t) = split("@",$results{fast_slew_up});
            my ($slow_slew_dn,$slow_slew_dn_t) = split("@",$results{slow_slew_dn});
            my ($slow_slew_up,$slow_slew_up_t) = split("@",$results{slow_slew_up});

            my ($skew_dn,$skew_dn_t) = split("@",$results{skew_dn});
            my ($skew_up,$skew_up_t) = split("@",$results{skew_up});

            # file suffix for cc and tau
            my $suffix = "";
            if (defined $results{tau} && ($results{tau}>0)) {
                $suffix = ":$results{cc}:$results{tau}";
            }

            # link graphs if they exist
            if ($status eq FAIL || $status eq SIGNOFF) {
                $slow_delay_dn = link_graph($dir,"$node/slow_dn${suffix}",$slow_delay_dn);
                $slow_delay_up = link_graph($dir,"$node/slow_up${suffix}",$slow_delay_up);
                $fast_delay_dn = link_graph($dir,"$node/fast_dn${suffix}",$fast_delay_dn);
                $fast_delay_up = link_graph($dir,"$node/fast_up${suffix}",$fast_delay_up);
                $slow_slew_dn  = link_graph($dir,"$node/slow_dn${suffix}",$slow_slew_dn);
                $slow_slew_up  = link_graph($dir,"$node/slow_up${suffix}",$slow_slew_up);
                $fast_slew_dn  = link_graph($dir,"$node/fast_dn${suffix}",$fast_slew_dn);
                $fast_slew_up  = link_graph($dir,"$node/fast_up${suffix}",$fast_slew_up);
                $skew_dn       = link_graph($dir,"$node/fast_dn${suffix}",$skew_dn);
                $skew_up       = link_graph($dir,"$node/fast_up${suffix}",$skew_up);
            }

            # print row of table
            my $out = $status;
            my $err = $status;
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/out") {
                        $out = "<a href=\"./$task.bin.$bin/$node/out\">out</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/out" ) { $out = "<a href=\"./$node/out\">out</a>"; }
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/err") {
                        $err = "<a href=\"./$task.bin.$bin/$node/err\">err</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/err" ) { $err = "<a href=\"./$node/err\">err</a>"; }
            if ( !defined $results{cc})  { $results{cc}  = "NA"; }
            if ( !defined $results{tau}) { $results{tau} = "NA"; }
            table_row($fh,$status,$node,
                      "$out",
                      "$err",
                      "$results{cc}",
                      "$results{tau}",
                      "$delay_dn, $slow_delay_dn, $fast_delay_dn",
                      "$delay_up, $slow_delay_up, $fast_delay_up",
                      "$slow_slew_dn, $fast_slew_dn",
                      "$slow_slew_up, $fast_slew_up",
                      "$skew_dn",
                      "$skew_up");
        }
    }
    finish_table($fh);
    if (!defined $overall_status) { $overall_status = "NOT_TESTED"; }
    return $overall_status;
}

# create an alint leak table
sub alint_leak_table {
    my $dir = shift ;
    my $fh = shift;
    my $important_only = shift;
    my @raw = @_;
    my $overall_status;
    return if $fh == 0;
    
    start_table($fh,"Node","stdout","stderr",
                "Leak Dn (%)",
                "Leak Up (%)");
    foreach my $line (@raw) {
        my ($status, $task, $cell, $path, %results) = @{$line};
        if (($task eq "alint") && 
            (defined $results{node}) && 
            (defined $results{leak_up}) && 
            (defined $results{leak_dn})) {
            my $node = $results{node};
            $overall_status = combine_status($overall_status,$status);
            next if ($important_only && (($status eq PASS) || ($status eq NA)));

            # parse results
            my ($leak_dn,$leak_dn_t) = split("@",$results{leak_dn});
            my ($leak_up,$leak_up_t) = split("@",$results{leak_up});
            $leak_dn = "${leak_dn}%";
            $leak_up = "${leak_up}%";
            
            # link graphs if they exist
            if ($status eq FAIL || $status eq SIGNOFF) {
                $leak_dn = link_graph($dir,"$node/leak_dn",$leak_dn);
                $leak_up = link_graph($dir,"$node/leak_up",$leak_up);
            }

            # print row of table
            my $out = $status;
            my $err = $status;
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/out") {
                        $out = "<a href=\"./$task.bin.$bin/$node/out\">out</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/out" ) { $out = "<a href=\"./$node/out\">out</a>"; }
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/err") {
                        $err = "<a href=\"./$task.bin.$bin/$node/err\">err</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/err" ) { $err = "<a href=\"./$node/err\">err</a>"; }
            table_row($fh,$status,$node,
                      "$out",
                      "$err",
                      "$leak_dn",
                      "$leak_up");
        }
    }    
    finish_table($fh);
    if (!defined $overall_status) { $overall_status = "NOT_TESTED"; }
    return $overall_status;
}

# create an alint EM table
sub alint_em_table {
    my $dir = shift;
    my $fh = shift;
    my $important_only = shift;
    my @raw = @_;
    my $overall_status;
    return if $fh == 0;

    # first pass to find worst em_avg and em_rms per node
    my %worst_avg = ();
    my %worst_rms = ();
    my %num_avg = ();
    my %num_rms = ();
    for (my $num=0; $num<@raw; $num++) {
        my ($status, $task, $cell, $path, %results) = @{$raw[$num]};
        if (($task eq "alint") && 
            (defined $results{node}) && 
            (defined $results{em_freq}) && 
            (defined $results{resistor}) &&
            (defined $results{em_avg}) &&
            (defined $results{em_rms})) {
            my $node = $results{node};
            if (!defined($num_avg{$node}) || ($results{em_avg} > $worst_avg{$node})) {
                $num_avg{$node} = $num;
                $worst_avg{$node} = $results{em_avg};
            }
            if (!defined($num_rms{$node}) || ($results{em_rms} > $worst_rms{$node})) {
                $num_rms{$node} = $num;
                $worst_rms{$node} = $results{em_rms};
            }
        }
    }

    # create table
    start_table($fh,"Node","stdout","stderr","CC","Tau (ps)",
                "Frequency (GHz)","Resistor","Layer",
                "Width (nm)","Avg","Rms");
    for (my $num=0; $num<@raw; $num++) {
        my ($status, $task, $cell, $path, %results) = @{$raw[$num]};
        if (($task eq "alint") && 
            (defined $results{node}) && 
            (defined $results{em_freq}) && 
            (defined $results{resistor}) &&
            (defined $results{em_avg}) &&
            (defined $results{em_rms})) {
            my $node = $results{node};
            $overall_status = combine_status($overall_status,$status);
            next if ($important_only && (($status eq PASS) || ($status eq NA)));

            # only report worst PASS/NA results
            next if ((($status eq PASS) || ($status eq NA)) && 
                     ($num != $num_avg{$node}) && ($num != $num_rms{$node}));
            
            # print row of table
            my $out = $status;
            my $err = $status;
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/out") {
                        $out = "<a href=\"./$task.bin.$bin/$node/out\">out</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/out" ) { $out = "<a href=\"./$node/out\">out</a>"; }
            if ( -d "$dir/$task.bin.0" ) {
                for (my $bin=0; $bin < 16; $bin++) {
                    if (-e "$dir/$task.bin.$bin/$node/err") {
                        $err = "<a href=\"./$task.bin.$bin/$node/err\">err</a>";
                        last;
                    }
                }
            }
            elsif ( -e "$dir/$node/err" ) { $err = "<a href=\"./$node/err\">err</a>"; }
            my $res = $results{resistor};
            $res =~ /(.*)\.([^\.]+)\.([^\.]+)$/;
            my $resistor = $1;
            my $layer = $2;
            my $width = $3;
            table_row($fh,$status,$node,$out,$err,$results{cc},$results{tau},
                      $results{em_freq},$resistor,$layer,$width,
                      $results{em_avg},$results{em_rms});
        }
    }    
    finish_table($fh);
    if (!defined $overall_status) { $overall_status = "NOT_TESTED"; }
    return $overall_status;
}

1;

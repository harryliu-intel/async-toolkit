#############################################################################
# THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.
#
# ---------------------------------------------------------------------------
# INTERNAL USE ONLY - NOT FOR EXTERNAL DISTRIBUTION
# ---------------------------------------------------------------------------
# INTEL CONFIDENTIAL
# Copyright 2014 - 2017 Intel Corporation.  All Rights Reserved.
#
# The source code contained or described herein and all documents related
# to the source code ("Material") are owned by Intel Corporation or its
# suppliers or licensors. Title to the Material remains with Intel
# Corporation or its suppliers and licensors. The Material contains trade
# secrets and proprietary and confidential information of Intel or its
# suppliers and licensors. The Material is protected by worldwide copyright
# and trade secret laws and treaty provisions. No part of the Material may
# be used, copied, reproduced, modified, published, uploaded, posted,
# transmitted, distributed, or disclosed in any way without Intel's prior
# express written permission.
#
# No license under any patent, copyright, trade secret or other intellectual
# property right is granted to or conferred upon you by disclosure or
# delivery of the Materials, either expressly, by implication, inducement,
# estoppel or otherwise. Any license under such intellectual property rights
# must be express and approved by Intel in writing.
#############################################################################/

package Chip::HLP::Registers;
use strict;
use warnings;

use base qw(Exporter);

our @EXPORT_FAIL = qw(_panic _validatePrototype);

###############################################################################
# Local Variables
###############################################################################

use constant INDENT => "  ";

###############################################################################
# Local Functions
###############################################################################

sub _panic($)
{
    my ($format, @arguments) = @_;

    my ($level);

    open(STDOUT, ">&STDERR");
    for ($level = 1; ; $level++)
    {
        my ($package, $file, $line, $subroutine) = caller($level);
        if (!defined($subroutine) || $subroutine eq "(eval)")
        {
            last;
        }
        $file =~ s,(perl|te2)/+,,;
        printf("%s$subroutine at $file line $line:\n", INDENT x ($level - 1));
    }
    printf("%s$format\n", INDENT x ($level - 1), @arguments);
    die();
}

sub _validatePrototype(\@$;$)
{
    my ($arguments, $m, $n) = @_;

    $n = defined($n) ? $n : $m;

    my ($package, $file, $line, $subroutine) = caller(1);
    if (scalar(@{$arguments}) < $m)
    {
        _panic("Not enough arguments for $subroutine");
    }
    elsif ($n != -1 && scalar(@{$arguments}) > $n)
    {
        _panic("Too many arguments for $subroutine");
    }
    for (my $i = 0; $i < $n; $i++)
    {
        if (!defined($arguments->[$i]))
        {
            _panic("$subroutine: argument $i not defined");
        }
        elsif ($arguments->[$i] != int($arguments->[$i]))
        {
            _panic("$subroutine: argument $i not an integer");
        }
    }
}

# Auto generated reg functions begin

# Auto generated reg functions end
1;

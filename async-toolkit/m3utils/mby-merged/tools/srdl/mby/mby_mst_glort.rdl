// INTEL TOP SECRET
// Copyright 2014 Intel Corporation. All Rights Reserved.
//
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

  // Enum: IngressMstTable_STPState
enum ingress_mst_table_stpstate_enum {
  DISABLE              =  2'd0 { desc = ""; };
  LISTENING            =  2'd1 { desc = ""; };
  LEARNING             =  2'd2 { desc = ""; };
  FORWARD              =  2'd3 { desc = ""; };
};


reg egress_vid_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Egress VLAN table";
  desc = "
         Contains egress port membership state for the egress VLAN lookup.
         Indexed first by VLAN ID and then by chunk, where each chunk is
         64 ports worth of the membership port mask.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            For 64 ports of the total 257 bit mask, defines if this port is member of this VLAN or not.
           ";
    ValRandomize = true;
  } MEMBERSHIP[63:0] = 64'h00;
};

regfile egress_vid_table_rf {
  egress_vid_table_r EGRESS_VID_TABLE[5] += 8;
};



reg egress_vid_cfg_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Egress VLAN configuration";
  desc = "Contains a trigger ID per egress VLAN.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            VLAN trigger match condition identifier.
           ";
    ValRandomize = true;
  } TRIG_ID[5:0] = 6'h00;
};



reg ingress_mst_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Ingress spanning-tree forwarding state table";
  desc = "
          INGRESS_MST_TABLE holds the ingress spanning-tree state for all ports. 
          Each port has two bits of spanning tree state associated to it. These states are:

            DISABLE      = 0

            LISTENING    = 1

            LEARNING     = 2

            FORWARD      = 3
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 23.
           ";
    ValRandomize = true;
  } STP_STATE_23[47:46] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 22.
           ";
    ValRandomize = true;
  } STP_STATE_22[45:44] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 21.
           ";
    ValRandomize = true;
  } STP_STATE_21[43:42] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 20.
           ";
    ValRandomize = true;
  } STP_STATE_20[41:40] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 19.
           ";
    ValRandomize = true;
  } STP_STATE_19[39:38] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 18.
           ";
    ValRandomize = true;
  } STP_STATE_18[37:36] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 17.
           ";
    ValRandomize = true;
  } STP_STATE_17[35:34] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 16.
           ";
    ValRandomize = true;
  } STP_STATE_16[33:32] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 15.
           ";
    ValRandomize = true;
  } STP_STATE_15[31:30] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 14.
           ";
    ValRandomize = true;
  } STP_STATE_14[29:28] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 13.
           ";
    ValRandomize = true;
  } STP_STATE_13[27:26] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 12.
           ";
    ValRandomize = true;
  } STP_STATE_12[25:24] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 11.
           ";
    ValRandomize = true;
  } STP_STATE_11[23:22] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 10.
           ";
    ValRandomize = true;
  } STP_STATE_10[21:20] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 9.
           ";
    ValRandomize = true;
  } STP_STATE_9[19:18] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 8.
           ";
    ValRandomize = true;
  } STP_STATE_8[17:16] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 7.
           ";
    ValRandomize = true;
  } STP_STATE_7[15:14] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 6.
           ";
    ValRandomize = true;
  } STP_STATE_6[13:12] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 5.
           ";
    ValRandomize = true;
  } STP_STATE_5[11:10] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 4.
           ";
    ValRandomize = true;
  } STP_STATE_4[9:8] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 3.
           ";
    ValRandomize = true;
  } STP_STATE_3[7:6] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 2.
           ";
    ValRandomize = true;
  } STP_STATE_2[5:4] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 1.
           ";
    ValRandomize = true;
  } STP_STATE_1[3:2] = 2'h00;
  field {
    encode = ingress_mst_table_stpstate_enum;
    AccessType = "RW";
    desc = "
            Two bits of spanning tree state for port 0.
           ";
    ValRandomize = true;
  } STP_STATE_0[1:0] = 2'h00;
};




reg egress_mst_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Egress spanning-tree forwarding state table";
  desc = "
         Contains egress spanning-tree state for each port in the VLAN.
         Each port has one bits of spanning tree forwarding state associated with it.
         Indexed first by VLAN ID and then by chunk, where each chunk is
         64 ports worth of the spanning-tree state.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Defines forwarding state for 64 of 257 ports.
           ";
    ValRandomize = true;
  } FORWARDING[63:0] = 64'h00;
};

regfile egress_mst_table_rf {
  egress_mst_table_r EGRESS_MST_TABLE[5] += 8;
};




  // Enum: GlortRam_Strict
enum glort_ram_strict_enum {
  HASHED  =  2'd0 { desc = "Not strict (hashed)."; };
  RSVD    =  2'd1 { desc = "Reserved."; };
  TARGETED_DETERMINISTIC  =  2'd2 { desc = "determinstic mode with special operation"; };
  DETERMINISTIC   =  2'd3 { desc = "deterministic mode"; };
};

reg glort_dest_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Defines the destination ports for a given glort";
  desc = "
          Defines the destination ports for a given glort. The DestMask is a 
          bit vector indicating which ports will receive normal (not logged or 
          mirrored) copies of the frame. If an IP_MulticastIndex is specified 
          (with value different than 0), then RXQ_MCAST_DEST_TABLE will be 
          used to retrieve lists of VLANs for each port to use during IP 
          multicast replication.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Selects the IP multicast profile: used as an index into 
            RXQ_MCAST_DEST_TABLE.
           ";
    ValRandomize = true;
  } IP_MULTICAST_INDEX[35:24] = 12'h00;
  field {
    AccessType = "RW";
    desc = "
            Contains the destination port mask (for normal copies, not 
            including logged or mirrored copies).
           ";
    ValRandomize = true;
  } DEST_MASK[23:0] = 24'h00;
};

reg glort_cam_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Configures an entry in the GLORT CAM";
  desc = " 
          Configures an entry in the GLORT CAM. The CAM entries are readable but
          the value returned will be masked out according to the mask originally
          written along with the value.
          [br][br]
          A match occurs when the data searched is equal to the key and the 
          entry is valid. The table below shows the encoded data value stored 
          (Content) based on the state of the data (Key) and mask (KeyInvert) 
          values in the TCAM bitcell.
          
          [code]
          +-----------------------------------------------------+
          | Mask storage | Data storage |        Content        |
          =======================================================
          |      0       |      0       |   X (always match)    |
          +-----------------------------------------------------+
          |      0       |      1       |           1           |
          +-----------------------------------------------------+
          |      1       |      0       |           0           |
          +-----------------------------------------------------+
          |      1       |      1       | Always mismatch state |
          +-----------------------------------------------------+
          [/code]
          
          The highest index has precedence in case there is more than one match.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Glort Mask. Write the inverse to match exactly.
           ";
    ValRandomize = true;
  } KEY_INVERT[31:16] = 16'hffff;
  field {
    AccessType = "RW";
    desc = "
            Glort value.
           ";
    ValRandomize = true;
  } KEY[15:0] = 16'hffff;
};

reg glort_ram_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Data associated with each CAM entry";
  desc = "  
          Data associated with each CAM entry. The entry defines how to 
          compute the index for indexing the GLORT_DEST_TABLE to retrieve the 
          final destination. See the Destination Mask Generation chapter
          in the HAS for details on the various fields.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Indicate to skip DGLORT decrement.
           ";
    ValRandomize = true;
  } SKIP_DGLORT_DEC[35:35] = 1'h00;
  field {
    AccessType = "RW";
    desc = "
            Selects hash Rotation A (0) or Rotation B (1) for calculating the
            destination mask index.
           ";
    ValRandomize = true;
  } HASH_ROTATION[34:34] = 1'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines the number of DestMask entries in the GLORT_DEST_TABLE over
            which frames will be hashed. A value of 0 is interpreted as 16. For
            distributed link aggregation pruning, this corresponds to the 
            number of ports in the LAG.
           ";
    ValRandomize = true;
  } DEST_COUNT[33:30] = 4'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines a field GLORTB extracted from the GLORT (bits 3..0 is bit position,
            bits 7..4 is the length) to use as a parameter for indexing into the
            GLORT_DEST_TABLE.
           ";
    ValRandomize = true;
  } RANGE_SUB_INDEX_B[29:22] = 8'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines a field GLORTA extracted from the GLORT (bits 3..0 is bit position,
            bits 7..4 is the length) to use  as a parameter for indexing into the
            GLORT_DEST_TABLE.
           ";
    ValRandomize = true;
  } RANGE_SUB_INDEX_A[21:14] = 8'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines the base index of the first entry into the GLORT_DEST table
            which contains the destination.
           ";
    ValRandomize = true;
  } DEST_INDEX[13:2] = 12'h00;
  field {
    encode = glort_ram_strict_enum;
    AccessType = "RW";
    desc = "
            Determines whether the destination index is chosen explicitly or via hashing.
            [list]
            [*] Hashed(0)
            [*] Reserved (1)
            [*] Targeted Deterministic (2)
            [*] Deterministic (3)
            [/list]
           ";
    ValRandomize = true;
  } STRICT[1:0] = 2'h00;
};


addrmap mby_ppe_mst_glort_map {
  name = "MST and GLORT";
  desc = "Forward and Global Resource Tag Registers";
  addressing = fullalign;
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary=true;
  
  egress_vid_table_rf     EGRESS_VID_TABLE[4096]  ;
  egress_vid_cfg_r        EGRESS_VID_CFG[4096]    ;
  ingress_mst_table_r     INGRESS_MST_TABLE[4096] ;     
  egress_mst_table_rf     EGRESS_MST_TABLE[4096]  ;
  glort_dest_table_r      GLORT_DEST_TABLE[4096]  ;
  glort_ram_r             GLORT_RAM[64]           ;
  glort_cam_r             GLORT_CAM[64]           ;
};


#!/usr/intel/bin/perl -w

use FileHandle;
use IPC::Open2;

#############################################################################
# Custom alint testing of SRAM and TCAM nodes
#############################################################################

# find relevant packaged tools and libraries
BEGIN {
$lve_root = $0;
$lve_root =~ s:/[^/]*$::;
$lib_dir = "$lve_root/../lib/perl";
if (!(-e $lib_dir)) { $lib_dir = "$lve_root/../../lib/perl"; }
@INC = ($lib_dir, @INC);
}
use LveUtil;
use LveAspice;
use LveDelay;
$aspice = "aspice";
$aplot  = "aplot";

# parse options
undef $cell;
$sramType = "10T";
$addresses = 32;
$bits = 16;
undef $addr;
$bit = 0;
$rail = 0;
$lveDir = "/mnt/fulcrum/bali/lve/lve";
$maxBump = 25; # bumps or interference should be this % near rail
$maxWrite = 33; # state-bit writes should pull down at least this % near rail
$maxLeak = 10; # leakage should be this percent % near rail
@true = (1.08);
@corner = ("tt");
@temp = (125);
while (@ARGV>0 && $ARGV[0] =~ /--([^=]*)=(.*)/ ) {
    $key = $1;
    $value = $2;
    shift @ARGV;
    if (!defined($value)) { $value=""; }
    if    ($key eq "lve-dir")   { $lveDir = $value; }
    elsif ($key eq "cell")      { $cell = $value; }
    elsif ($key eq "sram-type") { $sramType = $value; }
    elsif ($key eq "addresses") { $addresses = $value; }
    elsif ($key eq "addr")      { $addr = $value; }
    elsif ($key eq "bit")       { $bit = $value; }
    elsif ($key eq "bits")      { $bits = $value; }
    elsif ($key eq "rail")      { $rail = $value; }
    elsif ($key eq "true")      { @true    = split(",",$value); }
    elsif ($key eq "corner")    { @corner  = split(",",$value); }
    elsif ($key eq "temp")      { @temp    = split(",",$value); }
    elsif ($key eq "maxBump")   { $maxBump = $value; }
    elsif ($key eq "maxWrite")  { $maxWrite = $value; }
    elsif ($key eq "maxLeak")   { $maxLeak = $value; }
}
if (!defined($addr)) { $addr = $addresses-1; }
usage() if (!defined $cell);

# usage banner
sub usage {
    die "USAGE: lve_sram \n" . 
        "  --cell=FQCN\n" . 
        "  --sram-type=[10T|6T|TCAM]\n" .
        "  --lve-dir=$lveDir\n" .
        "  --addresses=$addresses\n" .
        "  --addr=$addr\n" .
        "  --bit=$bit\n" .
        "  --rail=$rail\n" .
        "  --true=@true\n" .
        "  --corner=@corner\n" .
        "  --temp=@temp\n" .
        "  --maxBump=$maxBump\n" .
        "  --maxWrite=$maxWrite\n" .
        "  --maxLeak=$maxLeak\n";
}

# default alint.in
$bumpTau=40;
$delayTau=58;
$alint_in = 
    "leakage 0\n" .
    "bumpCC\n" .
    "delayCC\n" .
    "delayFast 0\n" .
    "bumpTau ${bumpTau}e-12\n" .
    "delayTau ${delayTau}e-12\n" .
    "max_bump_fanin_aggressors 1\n" .
    "max_delay_fanin_aggressors 1\n";

# cell path
$cellDir = $cell;
$cellDir =~ s:\.:/:g;

# sweep
open_aplot("$aplot");
foreach $corner (@corner) {
    foreach $true (@true) {
        foreach $temp (@temp) {
            free_aplot();
            my $view = "layout";
            $view = "layout_pg"  if (-e "$lveDir/$cellDir/layout_pg");
            $view = "layout_tag" if (-e "$lveDir/$cellDir/layout_tag");
            $dir = "$cellDir/$view/extracted/alint/$corner/${true}V/${temp}C";
            system("mkdir -p \"$dir\"");
            system("rm -f \"$dir/cell.aspice\"");
            system("rm -f \"$dir/noprs.asp\"");
            system("rm -f \"$dir/noprs.modify.asp.latest\"");
            system("ln -s \"$lveDir/$cellDir/$view/extracted/cell.aspice\" \"$dir\"");
            system("ln -s \"$lveDir/$cellDir/jflat.routed/aspice/default/noprs.asp.latest\" \"$dir/noprs.asp\"");
            system("ln -s \"$lveDir/$cellDir/jflat.routed/aspice/default/noprs.modify.asp.latest\" \"$dir\"");
            make_alint_asp($dir);
            if    ($sramType eq "10T") { do_10T($dir); }
            elsif ($sramType eq "6T")  { do_6T($dir); }
            elsif ($sramType eq "TCAM") { do_TCAM($dir); }
        }
    }
}
close_aplot();

# write the alint.asp file
sub make_alint_asp {
    my ($dir) = @_;
    open OUT, ">$dir/alint.asp" or die "ERROR: can't write $dir/alint.asp\n";
    print OUT ".true=$true;\n";
    print OUT ".temperature=$temp;\n";
    print OUT ".corner \"$corner\"\n";
    print OUT ".include \"tech.asp\";\n";
    print OUT ".include \"cell.aspice\";\n";
    print OUT ".include \"noprs.asp\";\n";
    print OUT ".poststep=5e-12;\n";
    print OUT ".prstau=40e-12;\n";
    print OUT ".scenario_timemax=2e-9;\n";
    close OUT;
}

# alint delay
sub alint_delay {
    my ($scenarios, $dir, $node, $force) = @_;
    my $str = "";
    $str = ":force" if ($force);
    return
        "leakage 0\n" .
        "bumpCC\n" .
        "delayCC 0\n" .
        "$scenarios\n" .
        "workdir \"$dir\"\n" .
        "output \"$dir/$node/out\"\n" .
        "outerr \"$dir/$node/err\"\n" .
        "alint $node $str\n";
}

# alint bump
sub alint_bump {
    my ($scenarios, $dir, $node) = @_;
    return
        "leakage 0\n" .
        "bumpCC 1\n" .
        "delayCC\n" .
        "$scenarios\n" .
        "workdir \"$dir\"\n" .
        "output \"$dir/$node/out\"\n" .
        "outerr \"$dir/$node/err\"\n" .
        "alint $node\n";
}

# alint leak
sub alint_leak {
    my ($scenarios, $dir, $node) = @_;
    return
        "leakage 1\n" .
        "bumpCC\n" .
        "delayCC\n" .
        "$scenarios\n" .
        "workdir \"$dir\"\n" .
        "output \"$dir/$node/out\"\n" .
        "outerr \"$dir/$node/err\"\n" .
        "alint $node\n";
}

# run alint
sub run_alint {
    my ($dir,$in) = @_;
    system("mkdir -p \"$dir\"");
    open OUT, ">$dir/alint.in"
        or die "ERROR: can't write $dir/alint.in\n";
    print OUT "$alint_in";
    print OUT "$in\n";
    close OUT;
    system("cd \"$dir\";" .
           " $aspice" .
           " -top \"$cell\"" .
           " -path \"$ENV{ASPICE_PATH}:${lveDir}:..\"" .
           " -include alint.in" .
           " alint" .
           " 1> alint.out 2> alint.err");
}

# shortcut
sub my_slew_dn {
    my ($dir, $node, $run) = @_;
    $run = $node if (!defined $run);
    my ($t, $slew_dn) = measure_slew("$dir/$run/slow_dn:0:${delayTau}",
                                     "maxdelay","<","$node",2*$true/3,$true/3);
    ns_to_ps($slew_dn);
    return $slew_dn;
}

# shortcut
sub my_slew_up {
    my ($dir, $node) = @_;
    my ($t, $slew_dn) = measure_slew("$dir/$node/slow_up:0:${delayTau}",
                                     "maxdelay",">","$node",$true/3,2*$true/3);
    ns_to_ps($slew_dn);
    return $slew_dn;
}

# shortcut
sub my_minv {
    my ($run, $node) = @_;
    my ($t, $minv) = measure_minv($run,$node);
    if (is_numeric($minv)) { return int(100 * $minv/$true + 0.5); }
    return "FAIL";
}

# shortcut
sub my_maxv {
    my ($run, $node) = @_;
    my ($t, $maxv) = measure_maxv($run,$node);
    if (is_numeric($maxv)) { return int(100 * $maxv/$true + 0.5); }
    return "FAIL";
}

# check for measurement failures
sub measure_status {
    my $status = "PASS";
    foreach $measurement (@_) {
        $status = "FAIL" if ($measurement eq "FAIL") 
        }
    return $status;
}

# verify a 10T sram
sub do_10T {
    my ($dir) = @_;

    # output
    print "$dir\n";
    
    # some relevant nodes
    $nr = 1-$rail;
    $x0 ="x[$addr,$bit,$rail]";
    $x1 ="x[$addr,$bit,$nr]";
    $jr = "jr.d[$addr]";
    $jw = "jw.d[$addr]";
    $_r0 = "_r[$bit].$rail";
    $_w0 = "_w[$bit].$rail";
    $W0 = "W[$bit].$rail";
    $W1 = "W[$bit].$nr";
    $go = "go[$bit]";
    $all0 = "";
    $all1 = "";
    for ($i=0; $i<$addresses; $i++) {
        $all0 .= " x[$i,$bit,$rail]=0";
        $all1 .= " x[$i,$bit,$rail]=1";
    }

    # bump scenarios
    $in = alint_bump("max_bump_fanin_aggressors 1","bump",$_r0)
        . alint_bump("max_bump_fanin_aggressors 1","bump",$_w0)
        . alint_bump("max_bump_fanin_aggressors 1","bump",$x0);
    
    # write scenarios
    $in .= alint_delay("scenario $jw+  $W1=1\n" .
                       "scenario $jw=1 $W1+\n" .
                       "scenario $jw+  $W1+",
                       "write",$x0,1) 
        .  alint_delay("scenario $jw+  $W0=1\n" .
                       "scenario $jw=1 $W0+\n" .
                       "scenario $jw+  $W0+",
                       "write","$_w0",1);
    # nowrite scenarios
    $in .= alint_delay("scenario $jw+ $x1=1","nowrite",$x0,1);

    # read scenarios
    $in .= alint_delay("scenario $go=1 $jr+  $x0=1\n" .
                      "scenario $go+  $jr+  $x0=1\n" .
                      "scenario $go+  $jr=1 $x0=1",
                      "read","$_r0",1);

    # precharge scenarios
    $in .= alint_delay("scenario $go- $jr-  $x0=1\n" .
                       "scenario $go- $jr=0 $x0=1",
                       "precharge","$_r0",1);

    # precharge_interfering scenarios
    $in .= alint_delay("scenario $go- $jr=1 $x0=1",
                       "precharge_interfering","$_r0",1);

    # leakage scenarios
    $in .= alint_leak("scenario $go=1 $all1\n" .
                      "scenario $go=1 $all0",
                      "leakage","$_r0")
        .  alint_leak("scenario $W0=0 $all1\n" .
                      "scenario $W0=0 $all0\n" .
                      "scenario $W0=1 $all1\n" .
                      "scenario $W0=1 $all0\n",
                      "leakage","$_w0");

    # run alint
    run_alint($dir,$in);

    # measure bump
    $bump_dn = 100-my_minv("$dir/bump/$_r0/bump_dn:1:${bumpTau}",$_r0);
    $bump_up = my_maxv("$dir/bump/$_r0/bump_up:1:${bumpTau}",$_r0);
    $status = measure_status($bump_up,$bump_dn);
    $status = "FAIL" if ($status eq "FAIL" || $bump_up>$maxBump || $bump_dn>$maxBump);
    print "  $status bump $_r0 up=$bump_up dn=$bump_dn\n";

    $bump_dn = 100-my_minv("$dir/bump/$_w0/bump_dn:1:${bumpTau}","$_w0");
    $bump_up = my_maxv("$dir/bump/$_w0/bump_up:1:${bumpTau}","$_w0");
    $status = measure_status($bump_up,$bump_dn);
    $status = "FAIL" if ($status eq "FAIL" || $bump_up>$maxBump || $bump_dn>$maxBump);
    print "  $status bump $_w0 up=$bump_up dn=$bump_dn\n";

    $bump_dn = 100-my_minv("$dir/bump/$x0/bump_dn:1:${bumpTau}","$x0");
    $bump_up = my_maxv("$dir/bump/$x0/bump_up:1:${bumpTau}","$x0");
    $status = measure_status($bump_up,$bump_dn);
    $status = "FAIL" if ($status eq "FAIL" || $bump_up>$maxBump || $bump_dn>$maxBump);
    print "  $status bump $x0 up=$bump_up dn=$bump_dn\n";
    
    # measure write
    $slew_dn = my_slew_dn("$dir/write",$x0);
    $minv = my_minv("$dir/write/$x0/slow_dn:0:${delayTau}",$x0);
    $status = measure_status($slew_dn,$minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxWrite);
    print "  $status write $x0 slew_dn=$slew_dn minv=$minv\n";

    $slew_dn = my_slew_dn("$dir/write","$_w0");
    $minv = measure_minv("$dir/write/$_w0/slow_dn:0:${delayTau}","$_w0");
    $status = measure_status($slew_dn,$minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxBump);
    print "  $status write $_w0 slew_dn=$slew_dn minv=$minv\n";

    # measure nowrite
    $maxv = my_maxv("$dir/nowrite/$x0/slow_up:0:${delayTau}",$x0);
    $status = measure_status($maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv>$maxBump);
    print "  $status nowrite $x0 maxv=$maxv\n";
    
    # measure read
    $slew_dn = my_slew_dn("$dir/read","$_r0");
    $status = measure_status($slew_dn);
    print "  $status read $_r0 slew_dn=$slew_dn\n";
    
    # measure precharge
    $slew_up = my_slew_up("$dir/precharge","$_r0");
    $status = measure_status($slew_up);
    print "  $status precharge $_r0 slew_up=$slew_up\n";
    
    # measure precharge_interfering
    $slew_up = my_slew_up("$dir/precharge_interfering","$_r0");
    $maxv = my_maxv("$dir/precharge_interfering/$_r0/slow_up:0:${delayTau}","$_r0");
    $status = measure_status($slew_up,$maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv<100-$maxBump);
    print "  $status precharge_interfering $_r0 slew_up=$slew_up maxv=$maxv\n";
    
    # measure leakage
    $leak_dn = 100-my_minv("$dir/leakage/$_r0/leak_dn","$_r0");
    $leak_up = my_maxv("$dir/leakage/$_r0/leak_up","$_r0");
    $status = measure_status($leak_dn,$leak_up);
    $status = "FAIL" if ($status eq "FAIL" || $leak_dn>$maxLeak || $leak_up>$maxLeak);
    print "  $status leakage $_r0 leak_dn=$leak_dn leak_up=$leak_up\n";

    $leak_dn = 100-my_minv("$dir/leakage/$_w0/leak_dn","$_w0");
    $leak_up = my_maxv("$dir/leakage/$_w0/leak_up","$_w0");
    $status = measure_status($leak_dn,$leak_up);
    $status = "FAIL" if ($status eq "FAIL" || $leak_dn>$maxLeak || $leak_up>$maxLeak);
    print "  $status leakage $_w0 leak_dn=$leak_dn leak_up=$leak_up\n";
    
    # output
    print "\n";
}

# verify a 6T sram
sub do_6T {
    my ($dir) = @_;

    # output
    print "$dir\n";

    # some relevant nodes
    $a  = "a.d[63]";
    $x0 = "col[31].z[1,0].x[0]";
    $x1 = "col[31].z[1,0].x[1]";
    $b0 = "b[0,0]";
    $b1 = "b[0,1]";
    $r0 = "_r[0,0]";
    $r1 = "_r[0,1]";
    $all0 = "";
    $all1 = "";
    for ($i=0; $i<32; $i++) {
        for ($j=0; $j<2; $j++) {
            $all0 .= " col[$i].z[$j,0].x[1]=0";
            $all1 .= " col[$i].z[$j,0].x[1]=1";
        }
    }

    # bump scenarios
    $in = alint_bump("scenario chunk=1 s.0=1 $a=1 $x1=1 $b1=1 $r0=1\n" .
                     "scenario chunk+  s.0=1 $a=1 $x1=0 $b1-  $r0-",
                     "bump",$b0)
        . alint_bump("scenario chunk=1 s.0=1 $a=1 $x0=1 $b0=1 $r1=1\n" .
                     "scenario chunk=1 s.0+  $a=1 $x0=0 $b0-  $r1-",
                     "bump",$r0);

    # write scenarios
    $in .= alint_delay("scenario chunk+  s.0+  $a+   W[0].1=1 $x1=0 $b1=1\n" .
                       "scenario chunk=1 s.0=1 $a=1  W[0].1+  $x1=0 $b1=0",
                       "write",$x0,1);
    # read scenarios
    $in .= alint_delay("scenario chunk+ s.0+ $a+ $x0=1" .
                       " $b0=1 $r1=1",
                       "read",$r0,0);
    
    # precharge scenarios
    $in .= alint_delay("scenario s.0- $b1=1","precharge",$b0,1)
        .  alint_delay("scenario chunk- s.0-","precharge",$r0,1);

    # precharge_interfering scenarios
    $in .= alint_delay("scenario s.0- $b1=1 $a=1 $x1=1",
                       "precharge_interfering",$x0,1)
        .  alint_delay("scenario s.0- $b1=1 $a=1 $x1=1",
                       "precharge_interfering",$b0,1);

    # leakage scenarios
    $in .= alint_leak("scenario $b1=1 $all0\n" .
                      "scenario $b1=1 $all1\n" .
                      "scenario chunk=1 s.0=1 $a=1 $b1=1 $r0=1 $all0 $x1=1\n" .
                      "scenario chunk=1 s.0=1 $a=1 $b1=1 $r0=1 $all1 $x1=1",
                      "leakage",$b0);

    # run alint
    run_alint($dir,$in);

    # measure bump
    $bump_dn = 100-my_minv("$dir/bump/$r0/bump_dn:1:${bumpTau}",$r0);
    $bump_up = my_maxv("$dir/bump/$r0/bump_up:1:${bumpTau}",$r0);
    $status = measure_status($bump_dn,$bump_up);
    $status = "FAIL" if ($status eq "FAIL" || $bump_dn>$maxBump || $bump_up>$maxBump);
    print "  $status bump $r0 up=$bump_up dn=$bump_dn\n";

    $bump_dn = 100-my_minv("$dir/bump/$b0/bump_dn:1:${bumpTau}",$b0);
    $bump_up = my_maxv("$dir/bump/$b0/bump_up:1:${bumpTau}",$b0);
    $status = measure_status($bump_dn,$bump_up);
    $status = "FAIL" if ($status eq "FAIL" || $bump_dn>$maxBump || $bump_up>$maxBump);
    print "  $status bump $b0 up=$bump_up dn=$bump_dn\n";

    # measure write
    $slew_dn = my_slew_dn("$dir/write",$x0);
    $minv = my_minv("$dir/write/$x0/slow_dn:0:${delayTau}",$x0);
    $status = measure_status($minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxWrite);
    print "  $status write $x0 slew_dn=$slew_dn minv=$minv\n";

    $slew_dn = my_slew_dn("$dir/write",$b0,$x0);
    $minv = my_minv("$dir/write/$x0/slow_dn:0:${delayTau}",$b0);
    $status = measure_status($slew_dn,$minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxBump);
    print "  $status write $b0 slew_dn=$slew_dn minv=$minv\n";

    # measure read
    $slew_dn = my_slew_dn("$dir/read",$r0);
    $status = measure_status($slew_dn);
    print "  $status read $r0 slew_dn=$slew_dn\n";

    # measure precharge
    $slew_up = my_slew_up("$dir/precharge",$b0);
    $status = measure_status($slew_up);
    print "  $status precharge $b0 slew_up=$slew_up\n";

    $slew_up = my_slew_up("$dir/precharge",$r0);
    $status = measure_status($slew_up);
    print "  $status precharge $r0 slew_up=$slew_up\n";

    # measure precharge_interfering
    $slew_up = my_slew_up("$dir/precharge_interfering",$b0);
    $maxv = my_maxv("$dir/precharge_interfering/$b0/slow_up:0:${delayTau}",$b0);
    $status = measure_status($slew_up,$maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv<100-$maxBump);
    print "  $status precharge_interfering $b0 slew_up=$slew_up maxv=$maxv\n";

    $maxv = my_maxv("$dir/precharge_interfering/$x0/slow_up:0:${delayTau}",$x0);
    $status = measure_status($maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv>$maxBump);
    print "  $status precharge_interfering $x0 maxv=$maxv\n";

    # measure leakage
    $leak_dn = 100-my_minv("$dir/leakage/$b0/leak_dn",$b0);
    $leak_up = my_maxv("$dir/leakage/$b0/leak_up",$b0);
    $status = measure_status($leak_dn,$leak_up);
    $status = "FAIL" if ($status eq "FAIL" || $leak_dn>$maxLeak || $leak_up>$maxLeak);
    print "  $status leakage $b0 leak_dn=$leak_dn leak_up=$leak_up\n";

    # output
    print "\n";
}

# verify a TCAM
sub do_TCAM {
    my ($dir) = @_;

    # output
    print "$dir\n";

    # prepare for bit-line testing
    $a  = "a[$addr]";
    my $chunk = int($addr/64);
    my $ad = $addr-64*$chunk;
    $x  = "chunk[$chunk,$bit].bit[$ad].x[$rail]";
    $_x = "chunk[$chunk,$bit].bit[$ad]._x[$rail]";
    $e  = "chunk[$chunk,$bit].e[$rail]";
    $_e = "chunk[$chunk,$bit]._e[$rail]";
    $W0  = "chunk[$chunk,$bit].K[$rail].0";
    $W1  = "chunk[$chunk,$bit].K[$rail].1";
    $EN = "chunk[$chunk,$bit].EN";
    $all0 = "";
    $all1 = "";
    for ($i=0; $i<64; $i++) {
        $all0 .= " chunk[$chunk,$bit].bit[$i].x[$rail]=0";
        $all0 .= " chunk[$chunk,$bit].bit[$i]._x[$rail]=1";
        $all1 .= " chunk[$chunk,$bit].bit[$i].x[$rail]=1";
        $all1 .= " chunk[$chunk,$bit].bit[$i]._x[$rail]=0";
    }

    # prepare for hit-line testing
    $nrail = 1-$rail;
    $half = $bit < int($bits/2) ? 0 : 1;
    $i = int($ad/2); $j = $ad-2*$i;
    $LK   = "out[$chunk].LK";
    $_PC  = "out[$chunk].out[$i,$j]._PC";
    $hit = "hit[$half,$addr]";
    $k  = "chunk[$chunk,$bit].k[$rail]";
    $all_k0 = "";
    $all_k1 = "";
    $all_k0up = "";
    $all_k1up = "";
    $all_x0 = "";
    $all_x1 = "";
    for (my $b=0; $b<$bits+1; $b++) {
        for (my $h=0; $h<2; $h++) {
            $all_x0 .= " chunk[$chunk,$b].bit[$ad].x[$h]=0";
            $all_x0 .= " chunk[$chunk,$b].bit[$ad]._x[$h]=1";
            $all_x1 .= " chunk[$chunk,$b].bit[$ad].x[$h]=1";
            $all_x1 .= " chunk[$chunk,$b].bit[$ad]._x[$h]=0";
        }
        $all_k0   .= " chunk[$chunk,$b].k[$rail]=1";
        $all_k1   .= " chunk[$chunk,$b].k[$nrail]=1";
        $all_k0up .= " chunk[$chunk,$b].k[$rail]+";
        $all_k1up .= " chunk[$chunk,$b].k[$nrail]+";
    }
    
    # bumps on bit-lines scenarios
    $in = alint_bump("scenario $EN=0 $a=0 $_e=1\n" .               # precharged
                     "scenario $EN=1 $a=1 $_x=1 $_e=1\n" .         # reading low
                     "scenario $EN=1 $a=1 $_x=0 $_e=0\n" .         # reading high
                     "scenario $EN=1 $a=1 $_x=0 $_e-\n","bump",$e) # other rail falling
        . alint_bump("scenario $EN=0 $a=0 $e=1\n" .
                     "scenario $EN=1 $a=1 $x=1 $e=1\n" .
                     "scenario $EN=1 $a=1 $x=0 $e=0\n" .
                     "scenario $EN=1 $a=1 $x=0 $e-\n","bump",$_e);

    # write scenarios
    $in .= alint_delay("scenario $EN=1 $a=1 $W0+  $_x=0 $_e=1\n" .
                       "scenario $EN+  $a=1 $W0=1 $_x=0 $_e=1\n",
                       "write",$x,1)
        .  alint_delay("scenario $EN=1 $a=1 $W1+  $x=0 $e=1\n" .
                       "scenario $EN+  $a=1 $W1=1 $x=0 $e=1\n",
                       "write",$_x,1);

    # read scenarios
    $in .= alint_delay("scenario $EN=1 $a+ $_x=1 $_e=1","read",$e,0)
        .  alint_delay("scenario $EN=1 $a+ $x=1 $e=1","read",$_e,0);

    # precharge bit-lines scenarios
    $in .= alint_delay("scenario $EN- $a=0 $_e=1","precharge",$e,0)
        .  alint_delay("scenario $EN- $a=0 $e=1","precharge",$_e,0);
    
    # precharge_interfering bit-lines scenarios
    $in .= alint_delay("scenario $EN- $a=1 $_x=1 $_e=1",
                       "precharge_interfering",$x,1)
        .  alint_delay("scenario $EN- $a=1 $x=1 $e=1",
                       "precharge_interfering",$_x,1)
        .  alint_delay("scenario $EN- $a=1 $_x=1 $_e=1",
                       "precharge_interfering",$e,1)
        .  alint_delay("scenario $EN- $a=1 $x=1  $e=1",
                       "precharge_interfering",$_e,1);

    # leakage on bit-lines scenarios
    $in .= alint_leak("scenario $EN=0 $all0 $_e=1\n" .
                      "scenario $EN=1 $a=1 $all1 $_x=1 $_e=1\n" .
                      "scenario $EN=1 $a=1 $all0 $_x=0 $_e=0\n","leakage",$e)
        .  alint_leak("scenario $EN=0 $all1 $e=1\n" .
                      "scenario $EN=1 $a=1 $all0 $x=1 $e=1\n" .
                      "scenario $EN=1 $a=1 $all1 $x=0 $e=0\n","leakage",$_e);

    # bumps on hit-lines scenarios
    $in .= alint_bump("scenario $LK=1 $_PC=1 $all_x0 $all_k0up\n" .
                      "scenario $LK=1 $_PC=1 $all_x0 $all_k0\n" .
                      "scenario $LK=0 $_PC=0 $all_x0 $all_k0\n","hit_bump",$hit);

    # miss on hit-lines scenarios
    $in .= alint_delay("scenario $LK=1 $_PC=1 $all_x1 $k+\n" .
                       "scenario $LK=1 $_PC=1 $all_x1 $all_k0up\n","hit_delay",$hit,0);

    # precharge hit-lines scenarios
    $in .= alint_delay("scenario $LK- $_PC- $all_x1\n" .
                       "scenario $LK- $_PC- $all_x0\n","hit_precharge",$hit,0);

    # leakage on hit-lines scenarios
    $in .= alint_leak("scenario $LK=1 $_PC=1 $all_x1\n" .
                      "scenario $LK=0 $_PC=0 $all_x1\n" .
                      "scenario $LK=1 $_PC=1 $all_x1 $k=1\n","hit_leakage",$hit);
    
    # run alint
    run_alint($dir,$in);
    
    # measure bumps on bit-lines
    $bump_dn = 100-my_minv("$dir/bump/$e/bump_dn:1:${bumpTau}",$e);
    $bump_up = my_maxv("$dir/bump/$e/bump_up:1:${bumpTau}",$e);
    $status = measure_status($bump_dn,$bump_up);
    $status = "FAIL" if ($status eq "FAIL" || $bump_dn>$maxBump || $bump_up>$maxBump);
    print "  $status bump $e up=$bump_up dn=$bump_dn\n";

    $bump_dn = 100-my_minv("$dir/bump/$_e/bump_dn:1:${bumpTau}",$_e);
    $bump_up = my_maxv("$dir/bump/$_e/bump_up:1:${bumpTau}",$_e);
    $status = measure_status($bump_dn,$bump_up);
    $status = "FAIL" if ($status eq "FAIL" || $bump_dn>$maxBump || $bump_up>$maxBump);
    print "  $status bump $_e up=$bump_up dn=$bump_dn\n";

    # measure write
    $slew_dn = my_slew_dn("$dir/write",$x);
    $minv = my_minv("$dir/write/$x/slow_dn:0:${delayTau}",$x);
    $status = measure_status($minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxWrite);
    print "  $status write $x slew_dn=$slew_dn minv=$minv\n";

    $slew_dn = my_slew_dn("$dir/write",$_x);
    $minv = my_minv("$dir/write/$_x/slow_dn:0:${delayTau}",$_x);
    $status = measure_status($minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxWrite);
    print "  $status write $_x slew_dn=$slew_dn minv=$minv\n";

    $slew_dn = my_slew_dn("$dir/write",$e,$x);
    $minv = my_minv("$dir/write/$x/slow_dn:0:${delayTau}",$e);
    $status = measure_status($slew_dn,$minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxBump);
    print "  $status write $e slew_dn=$slew_dn minv=$minv\n";

    $slew_dn = my_slew_dn("$dir/write",$_e,$_x);
    $minv = my_minv("$dir/write/$_x/slow_dn:0:${delayTau}",$_e);
    $status = measure_status($slew_dn,$minv);
    $status = "FAIL" if ($status eq "FAIL" || $minv>$maxBump);
    print "  $status write $_e slew_dn=$slew_dn minv=$minv\n";

    # measure read
    $slew_dn = my_slew_dn("$dir/read",$e);
    $status = measure_status($slew_dn);
    print "  $status read $e slew_dn=$slew_dn\n";
    $slew_dn = my_slew_dn("$dir/read",$_e);
    $status = measure_status($slew_dn);
    print "  $status read $_e slew_dn=$slew_dn\n";

    # measure precharge bit-lines
    $slew_up = my_slew_up("$dir/precharge",$e);
    $status = measure_status($slew_up);
    print "  $status precharge $e slew_up=$slew_up\n";
    $slew_up = my_slew_up("$dir/precharge",$_e);
    $status = measure_status($slew_up);
    print "  $status precharge $_e slew_up=$slew_up\n";

    # measure precharge_interfering state-bits and bit-lines
    $maxv = my_maxv("$dir/precharge_interfering/$x/slow_up:0:${delayTau}",$x);
    $status = measure_status($maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv>$maxBump);
    print "  $status precharge_interfering $x maxv=$maxv\n";

    $maxv = my_maxv("$dir/precharge_interfering/$_x/slow_up:0:${delayTau}",$_x);
    $status = measure_status($maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv>$maxBump);
    print "  $status precharge_interfering $_x maxv=$maxv\n";

    $slew_up = my_slew_up("$dir/precharge_interfering",$e);
    $maxv = my_maxv("$dir/precharge_interfering/$e/slow_up:0:${delayTau}",$e);
    $status = measure_status($slew_up,$maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv<100-$maxBump);
    print "  $status precharge_interfering $e slew_up=$slew_up maxv=$maxv\n";

    $slew_up = my_slew_up("$dir/precharge_interfering",$_e);
    $maxv = my_maxv("$dir/precharge_interfering/$_e/slow_up:0:${delayTau}",$_e);
    $status = measure_status($slew_up,$maxv);
    $status = "FAIL" if ($status eq "FAIL" || $maxv<100-$maxBump);
    print "  $status precharge_interfering $_e slew_up=$slew_up maxv=$maxv\n";

    # measure leakage on bit-lines
    $leak_dn = 100-my_minv("$dir/leakage/$e/leak_dn",$e);
    $leak_up = my_maxv("$dir/leakage/$e/leak_up",$e);
    $status = measure_status($leak_dn,$leak_up);
    $status = "FAIL" if ($status eq "FAIL" || $leak_dn>$maxLeak || $leak_up>$maxLeak);
    print "  $status leakage $e leak_dn=$leak_dn leak_up=$leak_up\n";

    $leak_dn = 100-my_minv("$dir/leakage/$_e/leak_dn",$_e);
    $leak_up = my_maxv("$dir/leakage/$_e/leak_up",$_e);
    $status = measure_status($leak_dn,$leak_up);
    $status = "FAIL" if ($status eq "FAIL" || $leak_dn>$maxLeak || $leak_up>$maxLeak);
    print "  $status leakage $_e leak_dn=$leak_dn leak_up=$leak_up\n";

    # measure bumps on hit-lines
    $bump_dn = 100-my_minv("$dir/hit_bump/$hit/bump_dn:1:${bumpTau}",$hit);
    $bump_up = my_maxv("$dir/hit_bump/$hit/bump_up:1:${bumpTau}",$hit);
    $status = measure_status($bump_dn,$bump_up);
    $status = "FAIL" if ($status eq "FAIL" || $bump_dn>$maxBump || $bump_up>$maxBump);
    print "  $status hit_bump $hit up=$bump_up dn=$bump_dn\n";

    # measure miss on hit-lines
    $slew_dn = my_slew_dn("$dir/hit_delay",$hit);
    $status = measure_status($slew_dn);
    print "  $status hit_delay $hit slew_dn=$slew_dn\n";

    # measure precharge of hit-lines
    $slew_up = my_slew_up("$dir/hit_precharge",$hit);
    $status = measure_status($slew_up);
    print "  $status hit_precharge $hit slew_up=$slew_up\n";

    # measure leakage on hit-lines
    $leak_dn = 100-my_minv("$dir/hit_leakage/$hit/leak_dn",$hit);
    $leak_up = my_maxv("$dir/hit_leakage/$hit/leak_up",$hit);
    $status = measure_status($leak_dn,$leak_up);
    $status = "FAIL" if ($status eq "FAIL" || $leak_dn>$maxLeak || $leak_up>$maxLeak);
    print "  $status hit_leakage $hit leak_dn=$leak_dn leak_up=$leak_up\n";

    # end
    print "\n";
}

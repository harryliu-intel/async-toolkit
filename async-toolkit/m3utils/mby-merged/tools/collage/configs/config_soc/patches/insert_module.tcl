namespace eval insert_mod {
    
  set orig_port_name_format "%p"

  proc process_module_insertion {args} {
    
    parse_proc_arguments -args $args opts
    set ::insert_mod::insert_module_stage $opts(-stage)
 
    set subsys_ids [::collage_subsystem::_get_registered_subsystems]
    if {[info exists opts(-subsys_ids)]} {
      set subsys_ids $opts(-subsys_ids)
    }
    
    if {$::insert_mod::insert_module_stage == "init"} {

      set ::insert_mod::default_port_name_format ""
      if {[info exists opts(-default_port_name_format)]} {
	set ::insert_mod::default_port_name_format $opts(-default_port_name_format)
      } 
      
      
      #moving dictionary module creation to "init" time so that we can call process_module_insertion multipl
      #times during debug
      set ::module_dict ""
      set ::module_dict [dict create]
      
      foreach f "insert_module_create.tcl insert_module_init.tcl adhoc_insert_module.txt insert_intf_module.cfg" {
	# make sure to clean out the existing file a and that the file exists so that we can append to it later.  Also put a comment about where it came from
	set fp [open ${::auto_conn_dir}/$f "w"]
	puts $fp "#Generated by module insertion code"
	close $fp
      }
    }

    foreach subsys $subsys_ids {
      set subsys_spec_dir [::collage_subsystem::_get_subsys_spec_dir $subsys]
      set subsys_integ_dir [::collage_subsystem::_get_subsys_integ_dir $subsys]
      
      #save subsys variable to namesspace so that the other procs can access it.  Known use is subsystem ip registration
      set ::insert_mod::subsys $subsys
      
      foreach {dir type} "$subsys_spec_dir spec $subsys_integ_dir integ" {
	
	set fn_col $dir/collage/ip.insert_module
	set fn_nocol $dir/ip.insert_module
	
	if {$dir == ""} {continue}
	
	if { [file exists $fn_col] && [file exists $fn_nocol] } {
	  print_error "ip.insert_module defined under both $dir and $dir/collage. Remove one of them."
	  error "ip.insert_module defined under both $dir and $dir/collage. Remove one of them."
	}
	
	if {[file exists $fn_col]} {
	  echo "-I- Sourcing $fn_col with stage $::insert_mod::insert_module_stage"
	  source $fn_col
	} elseif {[file exists $fn_nocol]} {
	  echo "-I- Sourcing $fn_nocol with stage $::insert_mod::insert_module_stage"
	  source $fn_nocol
	} else {
	  echo "-I- Skipping non-existent ip.insert_module for subsys $subsys $type"
	}
      }
    }
  }
  
  define_proc_attributes process_module_insertion \
    -info "Collage - process module insertion file" \
    -define_args {
      {"-stage"       "Usage stage"   "stage" one_of_string {required {values {"init" "inst" "std_conn" "adhoc_conn" }}}}
      {"-subsys_ids"  "Process specified list of subsystems" "" string optional}
      {"-default_port_name_format"  "Port name format to use: default %p (typically usage is to set this to %c_%p)"   "" string optional}
    }
  
  proc debug {comp pin} {

  }
  
  proc test {} {
    register_intf_module CMI::LINK cmi_request_link cmi_respond_link
    #insert_intf_module CMI::LINK `CMI_TOP cmi_link_respond_port_2 {`CMI_RPTR0 `CMI_RPTR1}

    
    register_sig_module HDPORT hdport_flop_repeater { {in_Valid out_Valid} {in_Data out_Data} {in_eof  out_eof} {in_CtpReset_b  out_CtpReset_b} {in_credit_return out_credit_return} {out_PortEnable in_PortEnable} {in_ClkGate_ovrd out_ClkGate_ovrd } }

    insert_sig_module HDPORT `HDPORT_COUNTER {out_Valid out_Data out_eof in_CtpReset_b in_credit_return in_PortEnable in_ClkGate_ovrd} {sa_central_fabric_hdport_flop_repeater_0 sa_central_fabric_hdport_flop_repeater_1 sa_central_fabric_hdport_flop_repeater_2 sa_west_fabric_hdport_flop_repeater_0 sa_west_fabric_hdport_flop_repeater_1 sa_west_fabric_hdport_flop_repeater_2 sa_west_fabric_hdport_flop_repeater_3 disp_fabric_hdport_flop_repeater_0 disp_fabric_hdport_flop_repeater_1 disp_fabric_hdport_flop_repeater_2 disp_fabric_hdport_flop_repeater_3 tc_fabric_hdport_flop_repeater_0 tc_fabric_hdport_flop_repeater_1 tc_fabric_hdport_flop_repeater_2 tc_fabric_hdport_flop_repeater_3 tc_fabric_hdport_flop_repeater_4}
    
    #set repeater_type CMI::LINK 
    #set comp `CMI_TOP 
    #set intf cmi_link_respond_port_2 
    #set repeater_names {`CMI_RPTR0 `CMI_RPTR1}
  }

  proc get_ifc_type {component interface} {

    
    set par [collage_get_ip_hier_par -ip_name $component]
    set path $par/$component
    set ifc [find_interface_instances -component $path -name $interface -quiet]
    #type is provider vs consumer
    set type [get_attribute $ifc -attr InterfaceType]
    
    return $type
  }

  proc test_pin {} {
    set ip `GT_FIVR0
    set pinName  cri_slave_event_h
    
    set ip [::col::get_ip_real_name $ip]
  
    set pinDict [dict create]
    
    collage_eval_in_component [::col::get_ip_hier_par $ip] {
      
      set allBits [get_all_bits $ip/${pinName}]
      if {$allbits == ""} {
	error "Can't get bits for $ip/$pinName"
	return
      }
      set numBits [sizeof_collection $allBits]
      
      foreach_in_collection bit $allBits {
	#set firstBit [index_collection $allBits 0]
	
	#support bit blasted buses.  Assume each bit goes to the same place.
	set conns [get_connections $bit -hierarchy -sort]  
	set numConns [sizeof_collection $conns]
	
	set name [get_attribute $bit -attr RefPortName]
	dict set pinDict  provider_name $provider_name
      }
    }
  }


  proc trace_pin_connections { ip pinName } {
    set ret_val ""
    echo "Tracing pin connections for component $ip pin $pinName"
    set ip [::col::get_ip_real_name $ip]

    collage_eval_in_component -use_hier_par $ip {

      set ip [collage_get_folded_name -name $ip]      
      set allBits [get_all_bits $ip/${pinName}]
      set numBits [sizeof_collection $allBits]
      
      foreach_in_collection firstBit $allBits {
      #set firstBit [index_collection $allBits 0]
      
	#support bit blasted buses.  Assume each bit goes to the same place.
	set conns [get_connections $firstBit -hierarchy -sort]  
	#echo "Get Connections context is $get_connections_contexts"
	set numConns [sizeof_collection $conns]
      
	set compStr "components:  "
	set pinStr "pins:  "
	set dirStr "directions:  "
	
	foreach_in_collection driver $conns {
	  set driverDir  [get_attribute $driver -attr PortDirection]
	  #split based on the exist of [].  this covers the case of multibit signals
	  set driver [get_attribute $driver -attr UserName]
	  echo $driver
	  set driverName [lindex [split $driver "\[" ] 0]
	  set driverComp  [lindex [split $driverName /] 0]
	  set driverPin  [lindex [split $driverName /] end]
	  
	  set compStr "$compStr$driverComp-->"
	  set pinStr "$pinStr$driverPin-->"
	  set dirStr "$dirStr$driverDir-->"
	}
	echo $compStr
	echo $pinStr
	echo $dirStr
      }
    }
  }
  


  proc get_ifc_connection {component interface} {

    
    set par [collage_get_ip_hier_par -ip_name $component]
    set path $par/$component
    set ifc [find_interface_instances -component $path -name $interface -quiet]
    #type is provider vs consumer
    set type [get_attribute $ifc -attr InterfaceType]

    if {$type  == "provider"} {
      echo "-I- type is provider"
      #set direction AllConsumers
      set direction Consumers
    } else {
      echo "-I- type is consumer"
      #set direction AllProviders
      set direction Provider
    }

    # Get the interface and its connected interface

    set connection [get_attribute $ifc -attr TargetConnection -subscript ${direction}]
    
    return $connection
  }

  proc getConnectionPairs {allBits compHier} {
    #return a list of pairs of connections
    #if a pair of connection is a bus and 1.) all bits go to the same place 2.) all indices line up
    #then this will return the colapsed/shorthand name
    
    set retval ""
    set numBits [sizeof_collection $allBits]
    set otherPinList ""
    set alignedVector 1
    
    foreach_in_collection bit $allBits {
      
      set conns [get_connections $bit -hierarchy -sort]
      #echo "Get_connections context is $get_connections_contexts"
      #do we need to check that all connections are the same?
      set numConns [sizeof_collection $conns]
      
      set firstDir  [get_attribute $bit -attr PortDirection]
      set firstFullName [get_attribute $bit -attr UserName]
      #echo [get_attribute $bit]
      #firstCcomp is the component part of the full name.  This is the same regardless of any [index]
      set firstComp  [lindex [split $firstFullName /] 0]
      #puts "firstComp==$firstComp"
      #make this MI aware
      if {$firstDir == "in"} {
	#emperically, get_connections -sort will return the output as the first index
	#thus, if the pin we're looking for is an input, we look at the last index. 
	#otherwise, we look at the first index.  NOTE:  this assumes that output pins with stuff
	#being inserted on them are connected to 1 input since the others will be forgotten.
	#FIXME:  remember all inputs and reconnect everything (possibly optional)
	#set firstCompHier [lindex $get_connections_contexts [expr "[sizeof_collection $conns]-1"]]
	#WORKAROUND coretools weirdness:  in a 1:N connection case, coretools does not seem to always
	#deterministically return the input we're looking for as the last index.  Thus, we need
	#to pass this the hierarchy we're lookkig for into this proc.  This is particular sensative
	#for MI applications where we only know the hierarchy we're looking for from get_connections_contexts
	set firstCompHier $compHier
      } else {
	set firstCompHier [lindex $get_connections_contexts 0]
      }
      #puts "$get_connections_contexts" 
      set firstComp [::col::get_hier_to_flat_name ${firstCompHier}/${firstComp}]
      #set firstComp [::col::get_hier_to_flat_name ${firstCompHier}]
      #puts "firstComp==$firstComp; firstComHier = $firstCompHier"
      #firstFullPinName is the Pin part of Name with any [index]
      set firstFullPinName  [lindex [split $firstFullName /] end]
      
      #firstPinName is the pin name without any [index]
      set firstPinName [lindex [split $firstFullPinName "\[" ] 0]
      if {[string first "\[" $firstFullPinName] != -1} {
	set firstPinIndex "\[[lindex [split $firstFullPinName "\[" ] end]"
      } else {
	set firstPinIndex ""
      }
      
      if { $numConns > 1} {
	#HACK - sometimes pins on a bus that are explicitly connected to open appear as if they are 
	## all connected together.  Intent of this code is to catch this case;
	if {$firstDir == "out"} {
	  set other     [index_collection $conns [expr "[sizeof_collection $conns]-1"]]
	  set otherDir  [get_attribute $other -attr PortDirection]
	  if {$otherDir == "out"} {
	    #If the thing on the "other" side is also an out, then we have multiple outputs
	    #all connected together and we will treat this as an open
	    set numConns 1
	  }
	}
      }
      
      # NOTE:  numConns==1 mean there is nothing connected to this pin
      if {$numConns !=1 } {
	if {$firstDir == "in"} {
	  #emperically, get_connections -sort will return the output as the first index
	  #thus, if the pin we're looking for is an input, we look at index 0. 
	  #otherwise, we look at the last index.  NOTE:  this assumes that output pins with stuff
	  #being inserted on them are connected to 1 input since the others will be forgotten.
	  #FIXME:  remember all inputs and reconnect everything (possibly optional)
	  set other     [index_collection $conns 0]
	  set otherLocal   [isBitTiedOff $bit]
	  set otherCompHier [lindex $get_connections_contexts 0]
	} else {
	  set other     [index_collection $conns [expr "[sizeof_collection $conns]-1"]]
	  set otherLocal ""
	  set otherCompHier [lindex $get_connections_contexts [expr "[sizeof_collection $conns]-1"]]
	}
	#echo "----"
	#echo [get_attribute $other]
	set otherDir  [get_attribute $other -attr PortDirection]
	#split based on the exist of [].  this covers the case of multibit signals
	set otherFullName [get_attribute $other -attr UserName]
	#otherCcomp is the component part of the full name.  This is the same regardless of any [index]
        set otherComp  [lindex [split $otherFullName /] 0]
        #make this MI aware
        #echo "otherComp==$otherComp"
        #set otherCompHier [::col::col_get_component_name $other]
	

	set otherComp [::col::get_hier_to_flat_name ${otherCompHier}/${otherComp}]
        #set otherComp [::col::get_hier_to_flat_name ${otherCompHier}]
        #echo "otherComp==$otherComp; otherCompHier = $otherCompHier"
	#otherFullPinName is the Pin part of Name with any [index]
	if {[string first "/" $otherFullName] == -1} {
	#if the pin name does not have a / in it, then we're probably exporting to a top level pin
	  set otherFullPinName  ""
	} else {
	  set otherFullPinName  [lindex [split $otherFullName /] end]
	}
	#otherPinName is the pin name without any [index]      
	set otherPinName [lindex [split $otherFullPinName "\[" ] 0]
	if {[string first "\[" $otherFullPinName] != -1} {
	  set otherPinIndex "\[[lindex [split $otherFullPinName "\[" ] end]"
	} else {
	  set otherPinIndex ""
	}
	#add to our list of other pins.  we'll use this later to ensure that everything was unique
	lappend otherPinList $otherPinName
	
	#update alignedVector.  Want it to be 0 if the indexes don't line up
	if { ($alignedVector == 1) && ($firstPinIndex != $otherPinIndex)} {
	  set alignedVector 0
	}
	
	if { ($otherLocal == "logic.zero") || ($otherLocal == "logic.one") } {
	  #if the bit is tied off, then we need to ensure than we will report both what it's tied off too and that numConns is 2
	  lappend retval $firstComp $firstFullPinName $firstPinName "" $otherLocal $otherLocal $firstDir 2 $firstPinIndex
	  #add to our list of other pins.  we'll use this later to ensure that everything was unique
	  lappend otherPinList $otherLocal
	} else {
	  #add to our list of other pins.  we'll use this later to ensure that everything was unique
	  lappend otherPinList $otherPinName
	  lappend retval $firstComp $firstFullPinName $firstPinName $otherComp $otherFullPinName $otherPinName $firstDir $numConns $firstPinIndex
	}
      } else {
	#need to check that the bit is not tied off - for some reason the handling of tied off bits is inconsistent.  Sometimes 
	#more than 1 connection is returned and sometimes only 1 is returned
	set otherLocal   [isBitTiedOff $bit]
	if { ($otherLocal == "logic.zero") || ($otherLocal == "logic.one") } {
	  #if the bit is tied off, then we need to ensure than we will report both what its tied off too and that numConns is 2
	  lappend retval $firstComp $firstFullPinName $firstPinName "" $otherLocal $otherLocal $firstDir 2 $firstPinIndex
	  #add to our list of other pins.  we'll use this later to ensure that everything was unique
	  lappend otherPinList $otherLocal
	} else {
	  #add to the other Pin list so that we can detect if some pins are open but others are connected
	  lappend otherPinList "<open>"
	  lappend retval $firstComp $firstFullPinName $firstPinName "" "" "" $firstDir $numConns $firstPinIndex
	}
      }
    }
    
    #if there was more than 1 bits and if they are all connected to the same destination
    if { $numBits > 1 && [llength [lsort -unique $otherPinList]] == 1} {
      #and if the bits are all aligned then we should shorthand the connection instead of doing it bit blasted
      if {$alignedVector == 1} {
	
	set max [expr $numBits -1]
	set index "[$max:0]"
	set firstIndexed [lindex $retval 2]$index
	set otherIndexed [lindex $retval 5]$index
	
       
	set otherLocal   [lindex $retval 5]
	if { ($otherLocal == "logic.zero") || ($otherLocal == "logic.one") } {
	  #if the bit is tied off, then we need to ensure than we will report both what its tied off too and that numConns is 2
	  #note that we're guaranteed that all bits are tied off because we're explicitly checking for it with the lsort above
	  set retval [list [lindex $retval 0] $firstIndexed [lindex $retval 2] [lindex $retval 3] $otherIndexed [lindex $retval 5] [lindex $retval 6] 2 $index]
	} else {
	  set retval [list [lindex $retval 0] $firstIndexed [lindex $retval 2] [lindex $retval 3] $otherIndexed [lindex $retval 5] [lindex $retval 6] [lindex $retval 7] $index]
	}
      } 
      #the bits are not aligned so we will fall through to return our list of pins
      
    }
    
    return $retval
  }

  proc write_cmd {fp cmd} {
    
    if { [string first "-I-" $cmd] != -1} {
      echo $cmd
    } else {
      echo "-I- $cmd"
    }
    
    puts $fp $cmd
    
  }

  proc isBitTiedOff { bit } {
      set conns [get_connections $bit -names]
      foreach conn $conns {
	if {$conn == "logic.zero" || $conn == "logic.one"} {
	  return $conn
	}
      }
      return ""
  }

  proc isBitTiedOffOld { bit } {
      set econns [get_attribute $bit -attrs ElectricalConnections]
      foreach_in_collection econn $econns {
	  set cPort [get_attribute $econn -attrs "ConnectedPortNames"]
	  if {$cPort == "\{logic.zero\}"} {
	      return "logic.zero"
	  } elseif {$cPort == "\{logic.one\}"} {
	      return "logic.one"
	  }
      }
      return ""
  }

  #proc insert_sig_module {type comp pinNames insert_modules {dont_disconnect 0} {port_name_format ""}} {}
  proc insert_sig_module {args} {

    parse_proc_arguments -args $args opts

    set type $opts(type)
    set comp $opts(comp)
    set pinNames $opts(pinNames)
    set insert_modules $opts(insert_modules)
    set dont_disconnect 0

    set design_params "" 
    if {[info exists opts(-design_params)]} {
      set design_params $opts(-design_params)
    }

    
    # Retain positional arg for backward compatibility
    if {[info exists opts(dont_disconnect)]} {
      set dont_disconnect $opts(dont_disconnect)
    }

    if {[info exists opts(-dont_disconnect)]} {
      set dont_disconnect 1
    }
    
    set port_name_format $::insert_mod::default_port_name_format
    if {[info exists opts(-port_name_format)]} {
      set port_name_format $opts(-port_name_format)
    }
    
    if {$::insert_mod::insert_module_stage == "inst"} {
      echo ""
      set fp [open ${::auto_conn_dir}/insert_module_create.tcl "a+"]
      set module_name [get_module_component_name $type]
      
      foreach mod_name $insert_modules {
	set mod [::col::get_ip_real_name $mod_name]
	if { [inserted_module_exists $type $mod] == 0} {
	  #in order to support cascaded module, we need to "cache" that we have instantiated something and then
	  #not instantiated it again
	  register_module_insertion $type $mod
	  
	  write_cmd $fp "collage_instantiate_component $module_name -use_hier -name  $mod -noauto"
	  #Add an attribute on the IP (to populate the information from workspace)
	  write_cmd $fp "::collage_subsystem::_set_subsys_attrib_on_ip $::insert_mod::subsys $mod"
	  
	  
	  write_cmd $fp "collage_set_all_interfaces_unused -hier_lookup -component $mod"

	  if { [llength $design_params] > 0} {
	    puts $fp "collage_eval_in_component \[collage_get_ip_hier_par -ip_name $mod\] \{"

	    foreach {param value} $design_params {
	      write_cmd $fp "  set_configuration_parameter -component $mod $param $value"
	    }
	    
	    puts $fp "\}"
	  }
	  
	  #register the module we're inserting with collage so that the subsystem's reports include the module
	  #that are being insert for the current subsystem being processed.  Note that because of the current
	  #sourcing strategy, the IPs will be registered before tehy are created.  That should be ok, though.
	  ::collage_subsystem::_register_subsys_ip $::insert_mod::subsys $mod

	}
      }
      close $fp
      return
    } elseif {$::insert_mod::insert_module_stage == "adhoc_conn"} {
      echo ""
      #only want to do something for adhoc_conn stage and return otherwise
    } else {
      #only want to do something for adhoc_conn stage and return otherwise
      return
    }
    
    set start_comp [::col::get_ip_real_name $comp]  
    
    
    set fp [open ${::auto_conn_dir}/adhoc_insert_module.txt "a+"]
    set compHier [::col::get_ip_hier_par $start_comp]
    collage_eval_in_component $compHier {
      if {1} {
	write_cmd $fp "##################################################################################"
	write_cmd $fp "# Insert sig module : $type $comp $pinNames $insert_modules $dont_disconnect $port_name_format "
	write_cmd $fp "##################################################################################"
      } else {
	write_cmd $fp "##################################################################################"
	write_cmd $fp "# Insert sig module : TYPE: $type | COMP: $comp | DONT_DISCONNECT: $dont_disconnect | FORMAT: $port_name_format "
	write_cmd $fp "#---------------------------------------------------------------------------------"
	write_cmd $fp "# Pins:"
	foreach pin $pinNames {
	  if {$pin != "" } {
	    write_cmd $fp "# $pin"
	  }
	}
	write_cmd $fp "#---------------------------------------------------------------------------------"
	write_cmd $fp "# Modules Inserted:"
	foreach mod $insert_modules {
	  write_cmd $fp "# $mod"
	}
	write_cmd $fp "##################################################################################"
      }
      
      if {$port_name_format != ""} {
	write_cmd $fp "V catch \{gui_set_pref_value -key manual_port_name_format -value $port_name_format \}"
      }
	 #puts "-I- Insert_sig_module called in current component: [get_current_component]"      
	set pinNum 0
      foreach pinName $pinNames {
	
	set modInPin [get_sig_module_pin $type $pinNum in]
	set modOutPin [get_sig_module_pin $type $pinNum out]
	incr pinNum
	
	if {$pinName == ""} {
	  #add support for skipping - NOTE: this continue must be after the incr pinNme above
	  continue
	}
        #write_cmd $fp "#-I- Insert_sig_module called on $start_comp with folded name [collage_get_folded_name -name $start_comp]"
	#catch a bad pinName spec so that we give a graceful error
        set folded_name [collage_get_folded_name -name $start_comp]
        set allBits [get_all_bits ${folded_name}/${pinName}]
	if { $allBits == "" } {
	  error "Error in insert_sig_module specification for type $type component $start_comp.  Check that pin name $pinName is correct"
	  return
	}
	
	set pinPairs [getConnectionPairs $allBits $compHier]

	foreach {firstComp firstPin firstFullPin otherComp otherPin otherFullPin firstDir numConns index} $pinPairs {
	  set tieFlag 0  
	  if { ( $numConns != "1" ) && ( $dont_disconnect == "0" ) } {
	    if {$otherPin == ""} {
	      set otherName $otherComp
	    } else {
	      set otherName $otherComp/$otherPin
	    }

	    if {$otherPin != "logic.zero" && $otherPin != "logic.one"} {
	      write_cmd $fp "#-I- Disconnecting component $firstComp pin $firstPin connected to $otherName"
	      write_cmd $fp "D $firstComp/$firstPin"
	    } else {
	      write_cmd $fp "#-I- component $firstComp pin $firstPin tied to $otherPin"
	      set tieFlag 1
	    } 
	    if {$firstDir == "out"} {
	      #HACK/FIXME/FIX COLLAGE:  Collage D statement when called on Driver, does not disconnect to receiver. 
	      #also disconnected on receiver.  Thus further reinforces assumptions of 1:1 driver->receiver connectivity    	   
	      write_cmd $fp "D $otherName"
	    } 
	  } elseif { $dont_disconnect != "0" } {
	    write_cmd $fp "#-I- Adding modules $insert_modules to component $firstComp pin $firstPin"
	  } else {
	    write_cmd $fp "#-I- Nothing Connected to component $firstComp pin $firstPin - only adding modules $insert_modules"
	  }
	  
	  set firstName $firstComp
	  
	  foreach mn $insert_modules {
	    set mod [::col::get_ip_real_name $mn]
	    set secondName $mod
	    if {$firstDir == "in"} {
	      set secondPin $modOutPin$index
	    } else {
	      set secondPin $modInPin$index
	    }
	    if { $otherPin == "logic.zero" || $otherPin == "logic.one"} {
	      write_cmd $fp "T open $secondName/${secondPin}"
	      if {$tieFlag == 0} {
		if {$otherPin == "logic.zero"} {
		  write_cmd $fp "T zero $firstName/${firstPin}"
		} else {
		  write_cmd $fp "T one $firstName/${firstPin}"
		}
	      }
	      set tieFlag 0
	    } else {
	      write_cmd $fp "C $firstName/${firstPin} $secondName/${secondPin}"
	    }
	    set firstName $secondName
	    if {$firstDir == "in"} {
	      set firstPin $modInPin$index
	    } else {
	      set firstPin $modOutPin$index
	    }
	  }
	
	  if { ($numConns >1) && ( $dont_disconnect == "0" )} {
	    if { ($otherPin == "logic.zero") || ($otherPin == "logic.one")} {
	      if {$otherPin == "logic.zero" } {
		write_cmd $fp "T zero $firstName/${firstPin}"
	      } else {
		write_cmd $fp "T one $firstName/${firstPin}"
	      }
	    } elseif { [inserted_module_connected $type $firstName] == 0} {
	      if {$otherPin == ""} {
		#if otherPin is "", then the implication is that the final pin was actually an export/top-level port
		#because our initial D would have removed this port, we need to re-export it
		write_cmd $fp "E $firstName/${firstPin} $otherName"
	      } else {
		write_cmd $fp "C $firstName/${firstPin} $otherName"
	      }
	    } else {
	      write_cmd $fp "#-I- reusing connection to module $firstName"
	    }
	  } elseif { ( $dont_disconnect != "0" ) } {
	    write_cmd $fp "#-I- Leaving final connection dangling because modules are only being added"
	  } else {
	    write_cmd $fp "#-I- Leaving final connection dangling because it was dangling to begin with"
	  }
	  echo ""
	  puts $fp ""
	  
	}
      }
      
      #we're totally done. mark everything as connected
      foreach mod $insert_modules {
	#make sure to get the real name of the inserted module
	register_module_connection $type [::col::get_ip_real_name $mod]
      }
      if {$port_name_format != ""} {
	write_cmd $fp "V catch \{gui_set_pref_value -key manual_port_name_format -value $::insert_mod::orig_port_name_format \}\n"
      }
    }
    
    close $fp
  }

define_proc_attributes  insert_sig_module \
    -info "Collage - Evaluate specified code in the context of the specified component in right hierarchy" \
    -define_args {
      {"type"      "Type"   "" string required}
      {"comp"      "Component"   "" string required}
      {"pinNames"  "Pin Names"   "" string required}
      {"insert_modules"    "Instance names to insert"   "" string required}
      {"dont_disconnect"   "Retain existing connections and do not disconnect"   "" string optional}
      {"-dont_disconnect"   "Retain existing connections and do not disconnect"   "" boolean optional}
      {"-port_name_format"  "Port name format to use: default %p (typically usage is to set this to %c_%p)"   "" string optional}
      {"-design_params"    "Design parameters"   "" string optional}
    }

  proc get_interface_params { component interface } {

    set par [collage_get_ip_hier_par -ip_name $component]
    set path $par/[::col::get_ip_real_name $component]

    set ifc [find_interface_instances -component $path -name $interface -quiet]
    
    set params [get_attribute $ifc -attrs Parameters]
    set retVal [list]
    
    foreach_in_collection p $params {
      if { ( [get_attribute $p -attrs DefaultValue] != [get_attribute $p -attrs Value] ) } {
	if { ( [get_attribute $p -attrs ReadOnlyParam] == 0) && ( [get_attribute $p -attrs IsControlValue] == 0)  } {
	  lappend retVal [get_attribute $p -attrs Name]
	  lappend retVal [get_attribute $p -attrs Value]
	}
      }
    }
    return $retVal
  }
	
  proc write_params {fp type comp intfs mod design_params} {
    
print_info "... writing params : $type : $comp : $intfs : $mod : $design_params"
    set intfNum 0
    foreach interface $intfs {
      set params [get_interface_params $comp $interface]
      if { [llength $params] == 0 && [llength $design_params] == 0} {
        #FIXME - why do we need this check and continue? as it prevents writing out the design parameters later
	#continue
      }
      set module_provider_name [get_intf_module_intf_name $type $intfNum provider]
      set module_consumer_name [get_intf_module_intf_name $type $intfNum consumer]
      incr intfNum
      

      puts $fp "collage_eval_in_component \[collage_get_ip_hier_par -ip_name $mod\] \{"
      
      foreach {Name Value} $params {

	write_cmd $fp "   if \{ \[get_interface_parameter_attribute -instance ${mod}/$module_provider_name $Name ReadOnlyParam\] == 0 \} \{set_interface_parameter_attribute -instance ${mod}/$module_provider_name  $Name  Value $Value \}"	
	write_cmd $fp "   if \{ \[get_interface_parameter_attribute -instance ${mod}/$module_consumer_name $Name ReadOnlyParam\] == 0 \} \{ set_interface_parameter_attribute -instance ${mod}/$module_consumer_name  $Name  Value $Value \}" 
	#write_cmd $fp "   set_interface_parameter_attribute -instance ${mod}/$module_provider_name  $Name  Value $Value"	
	#write_cmd $fp "   set_interface_parameter_attribute -instance ${mod}/$module_consumer_name  $Name  Value $Value" 


      }
      
      foreach {param value} $design_params {
	write_cmd $fp "  set_configuration_parameter -component $mod $param $value"
      }

      puts $fp "\}"
      
    }
    
  }
  
  #proc insert_intf_module {type comp intfs insert_modules {design_params ""} {dont_disconnect 0}} {}
  proc insert_intf_module {args} {

    parse_proc_arguments -args $args opts

    set type $opts(type)
    set comp $opts(comp)
    set intfs $opts(intfs)
    set insert_modules $opts(insert_modules)
    set design_params "" 
    if {[info exists opts(design_params)]} {
      set design_params $opts(design_params)
    }
    set dont_disconnect 0
    
    # Retain positional arg for backward compatibility
    if {[info exists opts(dont_disconnect)]} {
      set dont_disconnect $opts(dont_disconnect)
    }

    if {[info exists opts(-dont_disconnect)]} {
      set dont_disconnect 1
    }

    echo "insert_intf_module $type : $comp : $intfs : $insert_modules : $design_params"

    if {$::insert_mod::insert_module_stage == "inst"} {
      echo ""
      set fp [open ${::auto_conn_dir}/insert_module_create.tcl "a+"]
      set module_name [get_module_component_name $type]
      
      foreach mod_name $insert_modules {
	set mod [::col::get_ip_real_name $mod_name]
	if { [inserted_module_exists $type $mod] == 0} {
	  #in order to support cascaded module, we need to "cache" that we have instantiated something and then
	  #not instantiate it again
	  register_module_insertion $type $mod
	  
	  write_cmd $fp "collage_instantiate_component $module_name -use_hier -name  $mod -noauto"
	  #Add an attribute on the IP (to populate the information from workspace)
	  write_cmd $fp "::collage_subsystem::_set_subsys_attrib_on_ip $::insert_mod::subsys $mod"
	  
	  write_cmd $fp "collage_set_all_interfaces_unused -hier_lookup -component $mod"
	  write_params $fp $type $comp $intfs $mod $design_params
	  
	  #register the module we're inserting with collage so that the subsystem's reports include the module
	  #that are being insert for the current subsystem being processed.  Note that because of the current
	  #sourcing strategy, the IPs will be registered before tehy are created.  That should be ok, though.
	  ::collage_subsystem::_register_subsys_ip $::insert_mod::subsys $mod

	}
      }
      close $fp
      return
    } elseif {$::insert_mod::insert_module_stage != "std_conn"} {
      return
    } 
      
    #make this code agnostic to which side of the interface the module is spec'd on
    #the side that this proc is called on will be considered the start side.
    #its connection is end side
    #as we connect up stuff, we will use from and to semantics

    set start_comp [::col::get_ip_real_name $comp]
    set intfNum 0
    foreach intf $intfs {
      #get the start intf type.  We need this to make decisions on the module intf to hook up later
      set intfType [get_ifc_type $start_comp $intf]
    
      set connection [get_ifc_connection $start_comp $intf]
      set reused_final_connection 0
      if { $connection != ""  && ( [inserted_module_connected_on $start_comp $intf] == 0) } {
	#if something is conneted AND I haven'a already inserted something on it, use the
	#thing connected
	set end_component [lindex [split [get_attribute $connection -attr ComponentOfItem] /] end]
	set end_intf [get_attribute $connection -attr Name]
      } elseif { [inserted_module_connected_on $start_comp $intf] != 0 } {
	#otherwise, we might actually have something that we previously connected
	set reused_final_connection 1
	set end_component [lindex [split [inserted_module_connected_on $start_comp $intf] /] 0]
	set end_intf [lindex [split [inserted_module_connected_on $start_comp $intf] /] end]
      } else {

	set end_component "<no component>"
	set end_intf      "<no intf>"
      }
      
      set fp [open ${::auto_conn_dir}/insert_intf_module.cfg "a+"]
      	
      write_cmd $fp "#-I- Inserting module(s) $insert_modules on component $comp interface $intf"
      
      if { ($connection == "") &&  ( [inserted_module_connected_on $start_comp $intf] == 0) } {
	  #nothing is connected on this interface yet and we have added something.  We'll add the module but skip the disconnect 
	  #and last stitch steps
	  
	  write_cmd $fp "#-I- Nothing Connected to component $comp interface $intf - only adding modules $insert_modules"
	} else {
	  write_cmd $fp "D $start_comp $intf $end_component $end_intf"
	}
      
      set module_provider_name [get_intf_module_intf_name $type $intfNum provider]
      set module_consumer_name [get_intf_module_intf_name $type $intfNum consumer]
      incr intfNum
      
      set from_comp $start_comp
      set from_intf $intf
      #if the start intf is a provider, then we connect to the module consumer intf and vice versa
      set to_intf [expr { "$intfType" == "provider" } ? {$module_consumer_name} : {$module_provider_name}]

      #register what we're about to insert on this interface
      #we do this because we're writing out a file that will be processed later instead
      #of processing things on the fly. 
      register_module_connected_on $start_comp $intf "[::col::get_ip_real_name [lindex $insert_modules 0]]/$to_intf"

      
      foreach mod $insert_modules {
	#connect up module on the cut interface.  We start with the "start" interface and walk to each inserted module
	
	set to_comp [::col::get_ip_real_name $mod]
	
	write_cmd $fp "C $from_comp $from_intf $to_comp $to_intf"

	set from_comp $to_comp
	set from_intf [expr { "$intfType" == "provider" } ? {$module_provider_name} : {$module_consumer_name}]
      }

      if { ($connection != "") && ( $dont_disconnect == "0" )} {
	if { [inserted_module_connected $type $from_comp] == 0} {
	  write_cmd $fp "C $from_comp $from_intf $end_component $end_intf"
	} else {
	  write_cmd $fp "#-I- reusing final connection from module $from_comp"
	}
      } elseif { ( $dont_disconnect != "0" ) } {
	write_cmd $fp "#-I- Leaving final connection dangling because modules are only being added"
      } elseif { $reused_final_connection != 0} {
	#keep the info message consistent with what we've actually done
	write_cmd $fp "#-I- reusing final connection from module $from_comp"
      } else {
	write_cmd $fp "#-I- Leaving final connection dangling because it was dangling to begin with"
      }

    }

    #we're totally done. mark everything as connected
    foreach mod $insert_modules {
      #make sure to get the real name of the inserted module
      register_module_connection $type [::col::get_ip_real_name $mod]
    }
        
    close $fp
  }

define_proc_attributes  insert_intf_module \
    -info "Insert module on standard interface" \
    -define_args {
      {"type"      "Type"   "" string required}
      {"comp"      "Component"   "" string required}
      {"intfs"     "Interfaces"   "" string required}
      {"insert_modules"    "Instance names to insert"   "" string required}
      {"design_params"    "Design parameters"   "" string optional}
      {"dont_disconnect"   "Retain existing connections and do not disconnect"   "" string optional}
      {"-dont_disconnect"   "Retain existing connections and do not disconnect"   "" boolean optional}
    }

  proc register_intf_module {module_type module_comp path intfs {simple_module 1} } {
    if { $::insert_mod::insert_module_stage == "init" } { 
      echo "-I- Registering Standard Interface Module of type $module_type for insertion"
      set i 0
      dict set ::module_dict types $module_type $simple_module
      dict set ::module_dict $module_type component  $module_comp
      dict set ::module_dict $module_type path  $path
      foreach pair $intfs {
	dict set ::module_dict $module_type intf$i provider [lindex $pair 0]
	dict set ::module_dict $module_type intf$i consumer [lindex $pair 1]
	incr i
      }

      set module_name [get_module_component_name $module_type]
      set module_path [get_module_path $module_type]

    
      if { ([inserted_module_inited $module_path $module_name] == 0) && ([inserted_module_inited_unique $module_name] == 0) } {
	set fp [open ${::auto_conn_dir}/insert_module_init.tcl "a+"]
	register_module_init $module_path $module_name
	
	write_cmd $fp "collage_install_ip_kit -ip_name $module_name -kit_name $module_name -src_dir $module_path -dest_dir $::install_kits_root"

	close $fp
      } elseif { ([inserted_module_inited $module_path $module_name] == 0) && ([inserted_module_inited_unique $module_name] == 1) } {

	error "Attempting to init the same corekit module $module_name from a different path .  Unique corekit names are required by Collage.  Please fix and rerun"
	return
      }
    }
  }
  
  proc register_sig_module {module_type module_comp path pins {simple_module 1} } {
 
    if {$::insert_mod::insert_module_stage == "init"} { 
      echo "-I- Registering Sig Module of type $module_type for insertion"
      set i 0
      dict set ::module_dict types $module_type $simple_module
      dict set ::module_dict $module_type component  $module_comp
      dict set ::module_dict $module_type path  $path
      foreach {pair} $pins {
	dict set ::module_dict $module_type pin$i in [lindex $pair 0]
	dict set ::module_dict $module_type pin$i out [lindex $pair 1]
	incr i
      }

      set module_name [get_module_component_name $module_type]
      set module_path [get_module_path $module_type]

      if { ([inserted_module_inited $module_path $module_name] == 0) && ([inserted_module_inited_unique $module_name] == 0) } {

	#we want to install the kit if we have never seen the combination of path and name before
	#and the module name is unique.  This implies that we'll install kits if
	#
	#P  M   Install
	#0  0   Yes
	#0  1   No
       	#1  0   Yes because combination of path/module will be unique and haven't seen module yet
	#1  1   No
	
	set fp [open ${::auto_conn_dir}/insert_module_init.tcl "a+"]
	register_module_init $module_path $module_name
	
	write_cmd $fp "collage_install_ip_kit -ip_name $module_name -kit_name $module_name -src_dir $module_path -dest_dir $::install_kits_root"
	close $fp
      } elseif { ([inserted_module_inited $module_path $module_name] == 0) && ([inserted_module_inited_unique $module_name] == 1) } {

	error "Attempting to init the same corekit module $module_name from a different path .  Unique corekit names are required by Collage.  Please fix and rerun"
	return
      }

    }
  }
  
  proc get_top_file_list {} {
    
    set files ""
    foreach {type simple_module} [get_registered_types] {
      #simple_module for each registered type indicates whether this type of module is simple or not
      #"simple" modules get added directly to soc.hdl and their code is copied into the gen output 
      #directory.  the code in the corekit for a simple module is used directly
      #"non-simple" modules do not get copied.  Any module that has a collage_pragma translate_off in 
      #it is non-simple as the version in the corekit can not be used directly.  Non-simple modules
      # will need to have v2kconfig binding added
      if {$simple_module != 1} {
	continue
      }
      if {[dict exists $::module_dict $type instances]} {
	set instances [dict get $::module_dict $type instances]
	#each instance will have a flag set next to it...we only want the leaves
	foreach {leaf flag} $instances {
	  
	  collage_eval_in_component [collage_get_hier_name -ip_name $leaf] {
	    
	    set ip_path [get_hdl_file_list -component $leaf]
	    foreach file $ip_path {lappend files $file}
	  }
	}
      }
    }

    return [lsort -unique $files]
  }

 proc get_complete_file_list {} {
    
    set files ""
    foreach {type simple_module} [get_registered_types] {
      #simple_module for each registered type indicates whether this type of module is simple or not
      #"simple" modules get added directly to soc.hdl and their code is copied into the gen output 
      #directory.  the code in the corekit for a simple module is used directly
      #"non-simple" modules do not get copied.  Any module that has a collage_pragma translate_off in 
      #it is non-simple as the version in the corekit can not be used directly.  Non-simple modules
      # will need to have v2kconfig binding added
      if {$simple_module != 1} {
	continue
      }

      if {[dict exists $::module_dict $type instances]} {
	set instances [dict get $::module_dict $type instances]
	#each instance will have a flag set next to it...we only want the leaves
	foreach {leaf flag} $instances {
	  
	  collage_eval_in_component [collage_get_hier_name -ip_name $leaf] {
	    
	    set ip_path [get_hdl_file_list -component $leaf -all]
	    foreach file $ip_path {lappend files $file}
	  }
	}
      }
    }

    return [lsort -unique $files]
  }


  proc get_registered_types {} {
    if { [dict exists $::module_dict types] == 1} {
      return [dict get $::module_dict types]
    } else {
      return ""
    }
  }

  
  proc register_module_insertion {module_type module_name} {
    dict set ::module_dict instances $module_name 1
    dict set ::module_dict $module_type instances $module_name 1
  }


  proc inserted_module_exists {module_type module_name} {
    return [dict exists $::module_dict instances $module_name]
  }

  proc register_module_connection {module_type module_name} {
    dict set ::module_dict connected $module_name 1
    dict set ::module_dict $module_type connected $module_name 1
  }


  proc inserted_module_connected {module_type module_name} {
    return [dict exists $::module_dict connected $module_name]
  }

  proc register_module_init {path module_name} {
    dict set ::module_dict inited_fullpath $path/$module_name 1
    dict set ::module_dict inited_names $module_name 1
  }


  proc inserted_module_inited {path module_name} {
    return [dict exists $::module_dict inited_fullpath $path/$module_name]
  }

  proc inserted_module_inited_unique {module_name} {
    return [dict exists $::module_dict inited_names $module_name]
  }
  
  proc register_module_connected_on {module_name pin_or_intf connection} {
    dict set ::module_dict connected_on $module_name $pin_or_intf $connection
  }


  proc inserted_module_connected_on {module_name pin_or_intf} {
    if { [dict exists $::module_dict connected_on $module_name $pin_or_intf] } {
      return [dict get $::module_dict connected_on $module_name $pin_or_intf]
    } else {
      return 0
    }
  }

  
  proc get_module_component_name {module_type} {
    return [dict get $::module_dict $module_type component]

  }

  proc get_module_path {module_type} {
    return [dict get $::module_dict $module_type path]

  }

  proc get_intf_module_intf_name {module_type intfNum intfType} {
    return [dict get $::module_dict $module_type intf$intfNum $intfType]
  }
  
  proc get_sig_module_pin {module_type pinNum dir} {
    return [dict get $::module_dict $module_type pin$pinNum $dir]
  }

  proc debug {} {
    echo $::module_dict
  }

  proc instantiate_repeater {repeater_names} {

    foreach rptr repeater_names {
      set inst_name [::col::get_ip_real_name $rptr]
      collage_eval_in_component [collage_get_ip_hier_par -ip_name $inst_name] {
	instantiate_component {Intel Intel cmi_repeater 1.0} -name $inst_name -noauto

	# Note: these parameters are common to both repeaters, so it can be left in the loop
	set_interface_parameter_attribute -instance ${inst_name}/cmi_request_link  FDATA_ID_MSB  Value 19 
	set_interface_parameter_attribute -instance ${inst_name}/cmi_respond_link  FDATA_ID_MSB  Value 19  
	set_interface_parameter_attribute -instance ${inst_name}/cmi_respond_link  LBINFO_MSB  Value 17 
	set_interface_parameter_attribute -instance ${inst_name}/cmi_request_link  LBINFO_MSB  Value 17 
	
      }
    }
    
    
  }
}

/*
 * Copyright 2004 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

package com.avlsi.tools.cadalyze;

import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.avlsi.util.container.Pair;
import com.avlsi.file.cdl.util.rename.CadenceReverseNameInterface;
import com.avlsi.file.cdl.util.rename.CDLRenameException;

/**
 *
 * @author Mike Davies
 * @version $Revision$ $Date$
 **/
public final class LayoutInfo {

    /***************************** INNER CLASSES *****************************/
    
    public static class LeafInfo {
        /** Density factor as reported by Clayton's 'density' tool **/
        private float reportedDensityFactor;

        /** Bounding box area **/
        private float boundingBoxArea;

        /** 
         * Number of CDL transistors as reported by 'density'.  Maintained
         * only for consistency checking.
         **/
        private int numCdlTransistors;

        /** Number of layout transistors as reported by 'density' **/
        private int numTransistors;

        /** 
         * Blindly picks out the space-separated tokens in density's
         * output that are relevant, convert them to the appropriate
         * numeric types.  All areas are assumed to be specified in
         * square microns.
         **/
        LeafInfo(String tokens[]) throws IOException {
            reportedDensityFactor = Float.valueOf(tokens[1]).floatValue();
            boundingBoxArea = Float.valueOf(tokens[3]).floatValue();
            numCdlTransistors = Integer.valueOf(tokens[9]).intValue()
                + Integer.valueOf(tokens[13]).intValue()
                + Integer.valueOf(tokens[17]).intValue();
            numTransistors = Integer.valueOf(tokens[10]).intValue()
                + Integer.valueOf(tokens[14]).intValue()
                + Integer.valueOf(tokens[18]).intValue();
        }

        /** In square microns **/
        public float getBoundingBoxArea() { return boundingBoxArea; }

        /** 
         * Returns the bounding box area [um^2] divided by total transistor
         * area [um^2], i.e. our standard density factor metric, as 
         * reported by Clayton's 'density' program.
         **/
        public float getReportedDensityFactor() { return reportedDensityFactor; }
        public int getNumCdlTransistors() { return numCdlTransistors; }
        public int getNumTransistors() { return numTransistors; }
    }
        
    public static class MidInfo {
        /** Aggregate area of all leaf cell prBounds **/
        private float leafArea;

        /** Bounding box area (not too useful) **/
        private float boundingBoxArea;

        /** Area of leaf cell prBounds bloat-shrinked by 2*bit_pitch **/
        private float mergedLeafArea;

        /** All areas are assumed to be specified in square microns **/
        MidInfo(String tokens[]) throws IOException {
            leafArea = Float.valueOf(tokens[2]).floatValue();
            mergedLeafArea = Float.valueOf(tokens[4]).floatValue();
            boundingBoxArea = Float.valueOf(tokens[10]).floatValue();
        }

        public float getBoundingBoxArea() { return boundingBoxArea; }
        public float getLeafArea() { return leafArea; }
        public float getMergedLeafArea() { return mergedLeafArea; }
    }

    /***************************** DATA MEMBERS ******************************/

    /** Map of leaf cell FQCN (String) to LeafInfo object **/
    final Map leafMap = new HashMap();

    /** Map of mid cell FQCN (String) to MidInfo object **/
    final Map midMap = new HashMap();

    /***************************** CLASS METHODS *****************************/

    /** 
     * Reads the leaf and mid cell report files ('leafFile' and 'midFile')
     * generated by Clayton's 'density' program.
     **/
    public LayoutInfo(final List fileList) {
        if (fileList == null) return;
        for (Iterator fi=fileList.iterator(); fi.hasNext();)
            readLayoutInfoFile((String)fi.next());
    }

    private void readLayoutInfoFile(String filename) {
        int lineNum = 0;
        try {
            BufferedReader in = new BufferedReader(new FileReader(filename));
            CadenceReverseNameInterface renamer =
                new CadenceReverseNameInterface();
            while (in.ready()) {
                lineNum++;
                String line = in.readLine();
                int spc = line.indexOf(" ");
                if (spc != -1) {
                    String cell = renamer.renameCell(line.substring(0,spc));
                    String[] tokens = line.substring(spc+1).split("\\s+");
                    if (tokens.length == 19) {
                        LeafInfo linfo = new LeafInfo(tokens);
                        leafMap.put(cell,linfo);
                    }
                    else if (tokens.length == 11) {
                        MidInfo minfo = new MidInfo(tokens);
                        midMap.put(cell,minfo);
                    }
                    else throw new IOException("Unexpected number of tokens");
                }
                else throw new IOException("Couldn't parse cell name.");
            }
        }
        catch (IOException e) {
            System.err.print("Warning: Error reading layout info file "+
                               filename);
            if (lineNum > 0) System.err.println(" (Line "+lineNum+")");
            else System.err.println(".");
            System.err.println("         Some or all layout info will be"+
                               "missing.");
            System.err.println(e);
        }
        catch (CDLRenameException e) {
            System.err.println("Warning: Garbled cell name encountered in "+
                               "file "+filename+" (Line "+lineNum+")");
            System.err.println("         Some or all layout info will be"+
                               "missing.");
        }
    }

    /** 
     * Returns layout area, or -1.0 if no layout information exists for this
     * cell.
     **/
    public float getLayoutArea(String cell) {
        float area = -1.0F;
        LeafInfo linfo = (LeafInfo) leafMap.get(cell);
        if (linfo != null) area = linfo.getBoundingBoxArea();
        else {
            MidInfo minfo = (MidInfo) midMap.get(cell);
            if (minfo != null) area = minfo.getMergedLeafArea();
        }
        return area;
    }

    /** 
     * Returns the cell's transistor density factor (top level area
     * divided by the cell's given total transistor area).  If the
     * specified cell is a leaf cell, compares the calculated density
     * factor to the one provided by 'density'.  Warns (to System.err)
     * if the values differ by more than 1%.  If no cell information
     * exists for the specified cell, -1.0 is returned.
     **/
    public float getTransistorDensityFactor(String cell, float transistorArea) {
        float dfactor = -1.0F;
        LeafInfo linfo = (LeafInfo) leafMap.get(cell);
        if (linfo != null) {
            dfactor = linfo.getBoundingBoxArea() / transistorArea;
            if (Math.abs(dfactor - linfo.getReportedDensityFactor()) > 0.01) {
                System.err.println("Density factor mismatch in cell "+
                                   cell+":");
                System.err.println("  Calculated "+dfactor+
                                   ", 'density' reported "+
                                   linfo.getReportedDensityFactor());
            }
        }
        else {
            MidInfo minfo = (MidInfo) midMap.get(cell);
            if (minfo != null)
                dfactor = minfo.getMergedLeafArea() / transistorArea;
        }
        return dfactor;
    }

    /**
     * Returns the cell's total area divided by the leaf cell prBound
     * covering area.  A value of 1.0 indicates perfect packing; larger
     * values corresponding to less efficient box packing.  If no cell
     * information exists for the specified cell, -1.0 is returned.
     **/
    public float getLeafPackingFactor(String cell) {
        float pfactor = -1.0F;
        MidInfo minfo = (MidInfo) midMap.get(cell);
        if (minfo != null)
            pfactor = minfo.getMergedLeafArea() / minfo.getLeafArea();
        else {
            LeafInfo linfo = (LeafInfo) leafMap.get(cell);
            if (linfo != null) pfactor = 1.0F;
        }
        return pfactor;
    }

    /** Debug only **/
    private void printAllDensities() {
        for (Iterator li=leafMap.entrySet().iterator(); li.hasNext();) {
            Entry entry = (Entry) li.next();
            String cell = (String) entry.getKey();
            LeafInfo linfo = (LeafInfo) entry.getValue();
            System.out.println("LEAF: "+cell+" "+
                               linfo.getReportedDensityFactor());
        }
        for (Iterator mi=midMap.entrySet().iterator(); mi.hasNext();) {
            Entry entry = (Entry) mi.next();
            String cell = (String) entry.getKey();
            //MidInfo minfo = (MidInfo) entry.getValue();
            System.out.println("MID: "+cell+" "+ getLeafPackingFactor(cell));
        }
    }

    /***************************** STATIC METHODS ****************************/

    public static void main(String[] args) {
        LayoutInfo layoutInfo = new LayoutInfo(Arrays.asList(args));
        layoutInfo.printAllDensities();
    }
}

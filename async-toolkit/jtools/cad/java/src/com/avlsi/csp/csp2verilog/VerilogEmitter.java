/*
 * Copyright 2004 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

package com.avlsi.csp.csp2verilog;

import java.io.PrintWriter;
import java.io.Writer;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import com.avlsi.cell.CellUtils;
import com.avlsi.csp.ast.*;
import com.avlsi.csp.grammar.ParseRange;
import com.avlsi.csp.grammar.ParsePosition;
import com.avlsi.csp.util.CSPCellInfo;
import com.avlsi.csp.util.DeclarationProcessor;
import com.avlsi.csp.util.FilterInitializers;
import com.avlsi.csp.util.RefinementResolver;
import com.avlsi.csp.util.ProblemFilter;
import com.avlsi.csp.util.UniqueLabel;
import com.avlsi.csp.util.VariableAnalysisException;
import com.avlsi.csp.util.VariableAnalyzer;
import com.avlsi.fast.metaparameters.ArrayMetaParam;
import com.avlsi.fast.metaparameters.BooleanMetaParam;
import com.avlsi.fast.metaparameters.IntegerMetaParam;
import com.avlsi.fast.metaparameters.MetaParamDefinition;
import com.avlsi.fast.metaparameters.MetaParamTypeInterface;
import com.avlsi.fast.ports.PortDefinition;
import com.avlsi.fast.ports.PortTypeInterface;
import com.avlsi.tools.prs2verilog.verilog.VerilogUtil;
import com.avlsi.tools.dsim.ExceptionPrettyPrinter;
import com.avlsi.util.container.CollectionUtils;
import com.avlsi.util.container.HashCounter;
import com.avlsi.util.container.Pair;
import com.avlsi.util.container.Triplet;
import com.avlsi.util.math.BigIntegerUtil;
import com.avlsi.util.text.StringUtil;

/**
 * Visitor pattern to emit Verilog from csp.
 *
 * @author Jesse Rosenstock
 * @version $Revision$ $Date$
 **/
public class VerilogEmitter extends CommonEmitter {
    private final CSPCellInfo cellInfo;

    private final Collection/*<String>*/ inputPorts;

    // State needed for traversal
    private final PrintWriter debugWriter;

    private final PrintWriter warningWriter;

    private final PrintWriter errorWriter;

    /**
     * The module name of the container.  Used to create upward references to
     * module variables.
     **/
    private final String moduleName;

    /**
     * The type of register to use for boolean variables.
     **/
    private final String boolType;

    /**
     * The name of reset signal
     **/
    private final String resetNodeName;

    /**
     * Autogenerated variable number.
     **/
    private int varNum = 0;

    private int blockNum = 0;

    private final VariableAnalyzer analyzer;

    private VariableAnalyzer.Results analysisResults;

    private RefinementResolver resolver =
        new RefinementResolver(RefinementResolver.NAME);

    private ComplexAccess complexAccess = null;

    private final UniqueLabel labels = new UniqueLabel(new HashMap());

    /**
     * <code>true</code> if we are processing the body of a program or a
     * function; <code>false</code> if we are processing initializers.
     **/
    private boolean processingBody = false;

    /** Special character escape sequences to use in string literals */
    private static Map ESCAPE_MAP = CollectionUtils.mapify(
        new Object[] {
            new Character('\n'), "\\n",
            new Character('\t'), "\\t"
        });

    private final LinkedList/*<Triplet<FunctionDeclaration,
                                       List<Object>,
                                       String>>*/ pendingFunctions =
        new LinkedList/*<Triplet<FunctionDeclaration,
                                 List<Object>,
                                 String>>*/();
    private final List/*<Triplet<StructureDeclaration,
                                 List<Object>,
                                 String>>*/ pendingConstructors =
        new ArrayList/*<Triplet<StructureDeclaration,
                                List<Object>,
                                String>>*/();

    private final List/*<Pair<String,Integer>>*/ arbiters =
        new ArrayList/*<Pair<String,Integer>>*/();

    private final Set<ExpressionInterface> lvalues =
        new HashSet<ExpressionInterface>();

    private final boolean strictVars;

    private final boolean implicitInit;

    private int scope = 0;

    private final ProblemFilter problems;

    private interface Index {
        void write() throws VisitorException;
    }
    private class ComplexAccess {
        private class FixedIndex implements Index {
            private final String var;
            public FixedIndex(final String var) {
                this.var = var;
            }
            public void write() throws VisitorException {
                out.print(var);
            }
        }
        private class ExpressionIndex implements Index {
            private final ExpressionInterface expr;
            public ExpressionIndex(final ExpressionInterface expr) {
                this.expr = expr;
            }
            public void write() throws VisitorException {
                expr.accept(VerilogEmitter.this);
            }
        }

        private final LinkedList/*<Index>*/ array;
        private final LinkedList/*<String>*/ structure;
        private final Type ty;
        private Object base;
        public ComplexAccess() {
            this((Type) null);
        }
        public ComplexAccess(final ExpressionInterface expr) {
            this(lvalues.contains(expr) ? (Type) null
                                        : analysisResults.getType(expr));
        }
        public ComplexAccess(final Type ty) {
            this.array = new LinkedList/*<Index>*/();
            this.structure = new LinkedList/*<String>*/();
            this.ty = ty;
        }
        public ComplexAccess(final ComplexAccess other) {
            this.array = new LinkedList/*<Index>*/(other.array);
            this.structure = new LinkedList/*<String>*/(other.structure);
            this.base = other.base;
            this.ty = other.ty;
        }
        private void accessArray(final Index idx, final boolean forward) {
            if (forward) array.addLast(idx);
            else array.addFirst(idx);
        }
        public void accessArray(final String var) {
            accessArray(new FixedIndex(var), true);
        }
        public void accessArray(final ExpressionInterface expr) {
            accessArray(new ExpressionIndex(expr), false);
        }
        public void accessStructure(final String fieldName) {
            accessStructure(fieldName, true);
        }
        public void accessStructure(final String fieldName,
                                    final boolean forward) {
            if (forward) structure.addLast(fieldName);
            else structure.addFirst(fieldName);
        }
        public Object getBase() {
            return base;
        }
        public void setBase(final Object token) {
            base = token;
        }
        private void emit(final String hierarchy,
                          final String channelPart,
                          final Type ty) throws VisitorException {
            final StringBuffer buf = new StringBuffer();
            String concat = null;
            if (ty instanceof IntegerType) {
                final IntegerType it = (IntegerType) ty;
                if (it.getDeclaredWidth() != null) {
                    final int width = getIntegerConstant(it.getDeclaredWidth());
                    if (it.isSigned()) {
                        buf.append("(util.sign_extend(");
                        concat = "))";
                    } else {
                        buf.append("($signed({ ");
                        buf.append(Math.max(1, registerBitWidth - width));
                        buf.append("'b0, ");
                        concat = " }))";
                    }
                }
            } else if (ty instanceof NodeType) {
                final NodeType nt = (NodeType) ty;
                if (nt.isArrayed()) {
                    buf.append("($signed({ ");
                    buf.append(Math.max(1, registerBitWidth - nt.getWidth()));
                    buf.append("'b0, ");
                    concat = " }))";
                }
            }

            buf.append(hierarchy);
            buf.append("\\");
            buf.append((String) tokenVerilogNameMap.get(base));
            for (Iterator i = structure.iterator(); i.hasNext(); ) {
                buf.append('.');
                buf.append((String) i.next());
            }
            buf.append(channelPart);
            out.print(buf.toString());
            out.print(' ');
            for (Iterator i = array.iterator(); i.hasNext(); ) {
                out.print("[");
                ((Index) i.next()).write();
                out.print("]");
            }
            if (concat != null) {
                out.print(concat);
            }
        }
        public void write(final String channelPart) throws VisitorException {
            final ComplexAccess mapped = mapComplexArgument(this);
            String hierarchy = mapped.getHierarchy();
            if (hierarchy != null && getHierarchy() == hierarchy)
                hierarchy = null;
            mapped.emit(hierarchy == null ? "" : escape(hierarchy) + ".",
                        channelPart, ty);
        }
        public void write() throws VisitorException {
            write("");
        }
        public Collection getIndices() {
            return array;
        }
        public ComplexAccess map(final ComplexAccess previous) {
            if (previous == null) return this;

            final ComplexAccess result = new ComplexAccess(previous.ty);
            result.array.addAll(previous.array);
            result.array.addAll(array);
            result.structure.addAll(previous.structure);
            result.structure.addAll(structure);
            result.base = previous.base;
            return result;
        }
        public void copyStructure(final ComplexAccess other) {
            structure.clear();
            structure.addAll(other.structure);
        }
        public String getHierarchy() {
            return (String) hierarchyNameMap.get(base);
        }
    }

    private class ComplexDeclaration {
        private final List/*<Range>*/ array;
        private final List/*<String>*/ structure;
        private Type type;
        public ComplexDeclaration() {
            this.array = new ArrayList/*<ExpressionInterface>*/();
            this.structure = new ArrayList/*<String>*/();
        }
        public ComplexDeclaration(final ComplexDeclaration c) {
            this.array = new ArrayList/*<ExpressionInterface>*/(c.array);
            this.structure = new ArrayList/*<String>*/(c.structure);
            this.type = c.type;
        }
        public void declareArray(final Range expr) {
            array.add(expr);
        }
        public void declareStructure(final String fieldName) {
            structure.add(fieldName);
        }
        public void setType(final Type type) {
            this.type = type;
        }
        private String getStructurePart(final String base) {
            final StringBuffer buf = new StringBuffer();
            buf.append(base);
            for (Iterator i = structure.iterator(); i.hasNext(); ) {
                buf.append('.');
                buf.append((String) i.next());
            }
            return escape(buf.toString());
        }
        public void declare(final String base) throws VisitorException {
            if (type instanceof StringType) {
                out.print("`CSP_STRING ");
            } else if (type instanceof BooleanType) {
                out.print(boolType); out.ws();
            } else {
                out.print(getRegisterType((IntegerType) type)); out.ws();
            }
            out.print(getStructurePart(base));
            for (Iterator i = array.iterator(); i.hasNext(); ) {
                final Range r = (Range) i.next();
                out.print('[');
                r.getMinExpression().accept(VerilogEmitter.this);
                out.print(':');
                r.getMaxExpression().accept(VerilogEmitter.this);
                out.print(']');
            }
        }
        private String getIndices() throws VisitorException {
            final StringBuffer buf = new StringBuffer();
            int idx = 0;
            for (Iterator i = array.iterator(); i.hasNext(); ++idx) {
                buf.append("[loop$[" + idx + "]]");
            }
            return buf.toString();
        }
    }

    private String getLoopVarType(final Range r) {
        final ExpressionInterface minExpr = r.getMinExpression();
        final ExpressionInterface maxExpr = r.getMaxExpression();
        if (minExpr instanceof IntegerExpression &&
            maxExpr instanceof IntegerExpression) {
            BigInteger min = new BigInteger(
                    ((IntegerExpression) minExpr).getValue(),
                    ((IntegerExpression) minExpr).getRadix());
            BigInteger max = new BigInteger(
                    ((IntegerExpression) maxExpr).getValue(),
                    ((IntegerExpression) maxExpr).getRadix());
            max = max.add(BigInteger.ONE);
            if (min.signum() == -1) min = min.negate();
            if (max.signum() == -1) max = max.negate();
            int lindex = Math.max(min.bitLength(), max.bitLength());
            return "bit signed [" + lindex + ":0]";
        } else {
            return registerType;
        }
    }

    private void emitForLoop(final String var, final Range r)
        throws VisitorException {
        out.print("for (" + var + " = ");
        r.getMinExpression().accept(this);
        out.print(';'); out.ws(); out.print(var + " <= ");
        r.getMaxExpression().accept(this);
        out.print(';'); out.ws(); out.print(var + " = " + var + " + 1)");
    }

    private void emitChannelPart(final ExpressionInterface chanExpr,
                                 final String part) throws VisitorException {
        complexAccess = new ComplexAccess();
        chanExpr.accept(this);
        final ComplexAccess old = complexAccess;
        complexAccess = null;
        old.write(part);
    }

    private void emitChannelEnable(final ExpressionInterface chanExpr)
        throws VisitorException {
        emitChannelPart(chanExpr, "$enable");
    }

    private void emitChannelData(final ExpressionInterface chanExpr)
        throws VisitorException {
        emitChannelPart(chanExpr, "$data");
    }

    public VerilogEmitter(final CSPCellInfo cellInfo,
                          final Collection/*<String>*/ inputPorts,
                          final PrintWriter out,
                          final PrintWriter warningWriter,
                          final PrintWriter errorWriter,
                          final PrintWriter debugWriter,
                          final String moduleName,
                          final String resetNodeName,
                          final int registerBitWidth,
                          final boolean strictVars,
                          final boolean implicitInit,
                          final ProblemFilter problems) { 
        super(out, registerBitWidth);
        this.cellInfo = cellInfo;
        this.inputPorts = inputPorts;
        this.warningWriter = warningWriter;
        this.errorWriter = errorWriter;
        this.debugWriter = debugWriter;
        this.moduleName = moduleName;
        this.analyzer = new VariableAnalyzer(cellInfo);
        this.analysisResults = null;
        this.boolType = "bit";
        this.resetNodeName = resetNodeName;
        this.strictVars = strictVars;
        this.implicitInit = implicitInit;
        this.problems = problems;
    }

    private void processUnary(final AbstractUnaryExpression expr,
            final String op) throws VisitorException {
        out.print('(' + op);
        expr.getExpression().accept(this);
        out.print(')');
    }

    private void processSpecialBinary(final AbstractBinaryExpression expr,
            final String func)
        throws VisitorException {
        // REVIEW: What is the overhead of functions?  Should we
        // do this inline with a temporary variable?
        out.print(func + '(');
        lvalues.add(expr.getLeft());
        expr.getLeft().accept(this);
        out.print(','); out.ws();
        lvalues.add(expr.getRight());
        expr.getRight().accept(this);
        out.print(')');
    }

    private void prettyMessage(String message, ParseRange pr) {
        ExceptionPrettyPrinter.prettyMessage(message, pr.start.filename,
                                             pr.start.line, pr.start.column+1,
                                             errorWriter);
    }

    /** 
     * Inspect the sets of uninitialized variables returned by variable
     * analysis.  
     **/
    private Set/*<String>*/ processResults(VariableAnalyzer.Results r) {
        final Set/*<String>*/ undeclaredVars = new HashSet/*<String>*/();
        Map m = r.getUndeclaredTypes();
        for (final Iterator i = m.keySet().iterator(); i.hasNext(); ) {
            String name = (String) i.next();
            Type type = (Type) m.get(name);

            if (type == null
             || type instanceof IntegerType
             || type instanceof BooleanType)
                undeclaredVars.add(name);
            else {  
                errorWriter.flush();
                warningWriter.flush();
                throw new Error ("Undeclared variable has unsupported type.");
            }
        }

        return undeclaredVars;
    }

    private void outputProgramBody(CSPProgram e) throws VisitorException {
        declareVariables();

        // call resetNodes() if it is defined
        final Pair/*<CSPProgram,FunctionDeclaration>*/ resetDecl =
            (Pair) resolver.getResolvedFunctions()
                           .get(RefinementResolver.RESET_FUNCTION_CALL);
        if (resetDecl != null) {
            if (resetDecl.getSecond() instanceof FunctionDeclaration) {
                out.println("always @(" + resetNodeName + " )");
                out.println("if (" + resetNodeName + "  == 0) " +
                            "begin : reset_nodes");
                final String funcName =
                    getFullName((FunctionDeclaration) resetDecl.getSecond(),
                                Collections.EMPTY_LIST);
                out.println(funcName + " ;");
                out.println("end");
            } else {
                warningWriter.println(
                    "Invalid definition of special function resetNodes: " +
                    ((AbstractASTNode) e).getParseRange().fullString());

            }
        }

        // start main block on posedge of _RESET 
        out.println("always @(posedge " + resetNodeName + " )");
        out.println("begin : main ");

        final Set/*<String>*/ undeclaredVars = processResults(analysisResults);
        // assign to 0
        if (implicitInit) {
            for (Iterator i = undeclaredVars.iterator(); i.hasNext(); ) {
                final String var = escape((String) i.next());
                out.println(var + " = 0;");
            }
            out.println();
        }

        // handle initializer statement to deal with top-level constants
        // TODO: Share top-level constants, as this wastes memory
        if (e.getInitializerStatement() != null) {
            final FilterInitializers filter =
                new FilterInitializers(analysisResults, allUsedTokens);
            filter.filter(e.getInitializerStatement()).accept(this);
        }

        // csp body
        processingBody = true;
        e.getStatement().accept(this);
        processingBody = false;

        // end initial block
        out.println("end");
        out.println();
    }

    public void visitCSPProgram(CSPProgram e) throws VisitorException {

        resolver.resolve(e);
        e = resolver.getCSPProgram();

        // declare and initialize the undeclared variables
        try {
            analysisResults = analyzer.getResults(e, resolver);
            allUsedTokens.addAll(analysisResults.getUsedTokens());
        } catch (VariableAnalysisException x) {
            throw new VisitorException(x.getMessage());
        }
        problems.process(analysisResults.getErrors(strictVars));

        for (Iterator i = e.getFunctionDeclarations(); i.hasNext(); ) {
            final FunctionDeclaration decl = (FunctionDeclaration) i.next();
            try {
                getAnalyzerResults(decl, e.getInitializerStatement());
            } catch (VariableAnalysisException x) {
                throw new VisitorException(x.getMessage(), x);
            }
        }

        if (!problems.hasError()) {
            updateTokenVerilogMap(moduleName);
            outputProgramBody(e);
            outputFunctions(e.getInitializerStatement());
            outputConstructors();
            outputArbiters();
        }

        out.flush();
    }

    /**
     * Return a new autogenerated variable number.
     **/
    private int genVarNum() {
        return varNum++;
    }

    private String genBlock() {
        return "\\$block" + blockNum++ + ' ';
    }

    public void visitAddExpression(AddExpression e)
        throws VisitorException {
        if (analysisResults.getType(e) instanceof StringType) {
            out.print("csp_string.concat(");
            final boolean lstr =
                analysisResults.getType(e.getLeft()) instanceof StringType;
            if (!lstr) out.print("util.csp_string(");
            e.getLeft().accept(this);
            if (!lstr) out.print(", 10)");

            out.print(", ");

            final boolean rstr =
                analysisResults.getType(e.getRight()) instanceof StringType;
            if (!rstr) out.print("util.csp_string(");
            e.getRight().accept(this);
            if (!rstr) out.print(", 10)");

            out.print(')');
        } else {
            processBinary(e, "+");
        }
    }

    public void visitAndExpression(AndExpression e)
        throws VisitorException {
        processBinary(e, "&");
    }

    public void visitArrayAccessExpression(ArrayAccessExpression e)
        throws VisitorException {
        boolean writeNow = false;
        if (complexAccess == null) {
            complexAccess = new ComplexAccess(e);
            writeNow = true;
        }
        complexAccess.accessArray(e.getIndexExpression());
        e.getArrayExpression().accept(this);
        if (writeNow) {
            final ComplexAccess old = complexAccess;
            complexAccess = null;
            old.write();
        }
    }

    public void visitBitRangeExpression(BitRangeExpression e)
        throws VisitorException {
        // The csp grammar only allows bit extraction from arrays,
        // structures and simple variables.
        assert e.getBitsExpression() instanceof IdentifierExpression ||
               e.getBitsExpression() instanceof ArrayAccessExpression ||
               e.getBitsExpression() instanceof MemberAccessExpression:
               "Invalid bit range expression found at: " + e.getParseRange().fullString();

        lvalues.add(e.getBitsExpression());
        if (needBitRangeFunction(e)) {
            // can't use constant part-select, use special function
            out.print("util.bit_extract" +
                      (e.getMinExpression() == null ? "2" : "3") +
                      "(");
            e.getBitsExpression().accept(this);
            out.print(','); out.ws();
            lvalues.add(e.getMaxExpression());
            e.getMaxExpression().accept(this);
            if (e.getMinExpression() != null) {
                out.print(','); out.ws();
                lvalues.add(e.getMinExpression());
                e.getMinExpression().accept(this);
            }
            out.print(')');
        } else {
            processSimpleBitRange(e, false);
        }
    }

    private void printArg(final ExpressionInterface arg)
        throws VisitorException {
        lvalues.add(arg);
        if (analysisResults.getType(arg) instanceof StringType) {
            arg.accept(this); 
        } else {
            out.print("util.hex_string(");
            arg.accept(this); 
            out.print(")");
        }
    }

    /* Process built in functions - all others are turned into assignmented
       by processFunctionCalls */ 
    public void visitFunctionCallExpression(FunctionCallExpression e)
        throws VisitorException {
        final ExpressionInterface func = e.getFunctionExpression();
        final String funcName =
            func instanceof IdentifierExpression ?
                ((IdentifierExpression) func).getIdentifier() : null;

        if ("print".equals(funcName)) {
            final Iterator<ExpressionInterface> args = e.getActuals();
            final ExpressionInterface arg1 = args.next();
            final ExpressionInterface arg2 =
                args.hasNext() ? args.next() : null;

            if (arg2 == null) {
                out.print("`CAST2VERILOG_CSP_PRINT(");
                printArg(arg1);
            } else {
                out.print("`CAST2VERILOG_CSP_PRINT2(");
                printArg(arg1);
                out.print(", ");
                printArg(arg2);
            }
            out.println(")");
            return;
        } else if ("assert".equals(funcName)) {
            final Iterator args = e.getActuals();
            final ExpressionInterface guard = (ExpressionInterface) args.next();
            lvalues.add(guard);
            final ExpressionInterface message =
                args.hasNext() ? (ExpressionInterface) args.next()
                               : null;
            if (message != null) lvalues.add(message);

            out.print("`CAST2VERILOG_CSP_ASSERT" +
                      (message == null ? "" : "2") + "(\"" +
                      e.getParseRange().fullString() + "\", ");
            guard.accept(this);
            if (message != null) {
                out.print(','); out.ws();
                message.accept(this);
            }
            out.println(")");
            return;
        } else if ("choose".equals(funcName)) {
            Iterator i = e.getActuals(); 
            // XXX: Add null exception handling
            ExpressionInterface arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); 
            out.ws(); out.print('?'); out.ws();
            arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); 
            out.ws(); out.print(':'); out.ws();
            arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); 
            return;
        } else if ("random".equals(funcName) ||
                   "log2".equals(funcName) ||
                   "log4".equals(funcName)) {
            Iterator i = e.getActuals(); 
            out.print("util." + funcName + "(");
            final ExpressionInterface arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); 
            out.println(")");
            return;
        } else if ("wait".equals(funcName)) {
            final Iterator i = e.getActuals(); 
            out.print("`CAST2VERILOG_WAIT(");
            final ExpressionInterface arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); // in DSim units
            out.println(");");
            return;
        } else if ("string".equals(funcName)) {
            out.print("util.csp_string(");
            for (Iterator i = e.getActuals(); i.hasNext(); ) {
                final ExpressionInterface arg = (ExpressionInterface) i.next();
                lvalues.add(arg);
                arg.accept(this); 
                if (i.hasNext()) { out.ws(); out.print(','); out.ws(); }
            }
            out.println(")");
            return;
        } else if ("time".equals(funcName)) {
            out.println("`CAST2VERILOG_TIME");
            return;
        }
        throw new VisitorException("Unsupported function calls found: " + e.getParseRange().fullString());
    }

    public void visitDivideExpression(DivideExpression e)
        throws VisitorException {
        // Handle divide by 0
        processSpecialBinary(e, "util.divide");
    }

    public void visitExponentialExpression(ExponentialExpression e)
        throws VisitorException {
        // XXX: handle 0**x, for x <= 0
        // According to the verilog spec exponentiation involving
        // signed values should give a real result.  Reals are 
        // rounded to nearest, except ties are rounded away from zero.
        // Thus, we should have 2**-1 == 1, but it seems that 2**-1 == 0.
        // Perhaps file a bug with cadence.
        processSpecialBinary(e, "util.pow");
    }

    public void visitLeftShiftExpression(LeftShiftExpression e)
        throws VisitorException {
        // handles negative shift amounts
        processSpecialBinary(e, "util.shift_left");
    }

    public void visitRightShiftExpression(RightShiftExpression e)
        throws VisitorException {
        // handles negative shift amounts
        processSpecialBinary(e, "util.shift_right");
    }

    private String escape(final String s) {
        return VerilogUtil.escapeIfNeeded(s);
    }

    public void visitIdentifierExpression(IdentifierExpression e)
        throws VisitorException {
        if (complexAccess == null) {
            complexAccess = new ComplexAccess(e);
            complexAccess.setBase(analysisResults.getIdentToken(e));
            complexAccess.write();
            complexAccess = null;
        } else complexAccess.setBase(analysisResults.getIdentToken(e));
    }

    public void visitLoopExpression(LoopExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitMultiplyExpression(MultiplyExpression e)
        throws VisitorException {
        processBinary(e, "*");
    }

    public void visitNegateExpression(NegateExpression e)
        throws VisitorException {
        processUnary(e, "-");
    }

    public void visitNotExpression(NotExpression e)
        throws VisitorException {
        processUnary(e, "~");
    }

    public void visitOrExpression(OrExpression e)
        throws VisitorException {
        processBinary(e, "|");
    }

    public void visitXorExpression(XorExpression e)
        throws VisitorException {
        processBinary(e, "^");
    }

    public void visitPeekExpression(PeekExpression e)
        throws VisitorException {
        //  inside guard: #L? == L.d
        // outside guard: #L? == ( [ L.d >= 0 ] ; L.d )
        // FunctionPreprocessor converts peeks outside of guards
        // to assignment statements that are handled specially
        // in this file by visitAssignmentStatement
        // It converts peeks within guards by pre-pending AND of
        // probes to the expression. 
        // Thus, here, we just need to spit L.d
        emitChannelData(e.getChannelExpression());
    }

    public void visitProbeExpression(ProbeExpression e)
        throws VisitorException {
        // #L == (L.d >= 0)
        // #R == R.e

        final ExpressionInterface chanExpr = e.getChannelExpression();
        // The type checking pass should have ensured that this is indeed
        // a channel type.
        final ChannelType type = 
            (ChannelType) analysisResults.getType(chanExpr);
        // Add - to compensate for difference in verilog and csp
        // comparison semantics.
        if (type.getDirection() == PortDirection.IN) {
            out.print("(");
            emitChannelData(chanExpr);
            out.println(" >= 0)");
        } else {
            assert type.getDirection() == PortDirection.OUT;
            emitChannelEnable(chanExpr);
        }
    }

    public void visitReceiveExpression(ReceiveExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitRemainderExpression(RemainderExpression e)
        throws VisitorException {
        // handle x % 0
        processSpecialBinary(e, "util.remainder");
    }

    private void processString(String s) {
        final String esc =
            '"' + StringUtil.quoteASCIIString(s, ESCAPE_MAP) + '"';
        out.print("csp_string.init($bits(" + esc + "),"); out.ws();
        out.print(esc + ")");
    }

    public void visitStringExpression(StringExpression e)
        throws VisitorException {
        processString(e.getValue());
    }

    public void visitSubtractExpression(SubtractExpression e)
        throws VisitorException {
        processBinary(e, "-");
    }

    private void processStructureAccess(final String field,
                                        final ExpressionInterface structExpr,
                                        final ExpressionInterface accessExpr)
        throws VisitorException {
        boolean writeNow = false;
        if (complexAccess == null) {
            complexAccess = new ComplexAccess(accessExpr);
            writeNow = true;
        }
        complexAccess.accessStructure(field, false);
        structExpr.accept(this);
        if (writeNow) {
            final ComplexAccess old = complexAccess;
            complexAccess = null;
            old.write();
        }
    }

    public void visitStructureAccessExpression(StructureAccessExpression e)
        throws VisitorException {
        processStructureAccess(e.getFieldName(), e.getStructureExpression(), e);
    }

    public void visitMemberAccessExpression(MemberAccessExpression e)
        throws VisitorException {
        processStructureAccess(e.getMemberName(), e.getStructureExpression(),
                               e);
    }

    private void processBooleanChannel(ExpressionInterface chanExpr,
                                       ExpressionInterface rhs)
        throws VisitorException {
        if (chanExpr == null) rhs.accept(this);
        else {
            final boolean bool =
                analysisResults.getType(rhs) instanceof BooleanType;
            if (bool) out.print("(");
            emitChannelData(chanExpr);
            if (bool) out.print("!= 0)");
        }
    }

    /**
     * Emit code to assign between two variables of the same type.
     *
     * @param lhs Left hand expression
     * @param rhs Right hand expression
     * @param t type of the expressions
     **/
    private void emitAssignment(final ComplexAccess lhs,
                                final ComplexAccess rhs, final Type t)
        throws VisitorException {
        emitAssignment(lhs, rhs, t, 0);
    }

    private void emitAssignment(final ComplexAccess lhs,
                                final ComplexAccess rhs, final Type t,
                                final int indices) throws VisitorException {
        if (t instanceof IntegerType || t instanceof BooleanType ||
            t instanceof StringType) {
            lhs.write();
            out.ws(); out.print('='); out.ws();
            rhs.write();
            out.println(";");
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            out.println("begin : " + genBlock());
            final String var = "loop$" + indices;
            out.println(getLoopVarType(at.getRange()) + " " + var + ";");
            emitForLoop(var, at.getRange());
            out.println(" begin");
            lhs.accessArray(var);
            rhs.accessArray(var);
            emitAssignment(lhs, rhs, at.getElementType(), indices + 1);
            out.println("end");
            out.println("end");
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nlhs = new ComplexAccess(lhs);
                    final ComplexAccess nrhs = new ComplexAccess(rhs);
                    final String id = d.getIdentifier().getIdentifier();
                    nlhs.accessStructure(id);
                    nrhs.accessStructure(id);
                    emitAssignment(nlhs, nrhs, d.getTypeFragment(), indices);
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot assign between: " + t);
        }
    }

    private void emitPack(final ComplexAccess expr, final Type t)
        throws VisitorException {
        if (t instanceof BooleanType) {
            expr.write();
        } else if (t instanceof IntegerType) {
            final IntegerType it = (IntegerType) t;
            final int width = getIntegerConstant(it.getDeclaredWidth()) - 1;
            expr.write();
            out.print("[" + width + ":0]");
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            final Range r = at.getRange();
            final int min = getIntegerConstant(r.getMinExpression());
            final int max = getIntegerConstant(r.getMaxExpression());
            boolean first = true;
            for (int i = max; i >= min; --i) {
                if (first) first = false;
                else { out.print(','); out.ws(); }
                final ComplexAccess nexpr = new ComplexAccess(expr);
                nexpr.accessArray(Integer.toString(i));
                emitPack(nexpr, at.getElementType());
            }
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final boolean[] first = new boolean[] { true };
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nexpr = new ComplexAccess(expr);
                    final String id = d.getIdentifier().getIdentifier();
                    nexpr.accessStructure(id);
                    if (first[0]) first[0] = false;
                    else { out.print(','); out.ws(); }
                    emitPack(nexpr, d.getTypeFragment());
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot pack: " + t);
        }
    }

    private ComplexAccess getComplexAccess(final ExpressionInterface expr)
        throws VisitorException {
        complexAccess = new ComplexAccess(expr);
        expr.accept(this);
        final ComplexAccess result = complexAccess;
        complexAccess = null;
        return result;
    }

    private void emitPack(final ExpressionInterface structure)
        throws VisitorException {
        emitPack(getComplexAccess(structure),
                 (Type) analysisResults.getType(structure));
    }

    // Fix up booleans, specifically, true is unpacked as 1, but needs to be
    // turned to -1
    private void emitUnpack(final ComplexAccess expr, final Type t)
        throws VisitorException {
        if (t instanceof BooleanType) {
        } else if (t instanceof IntegerType) {
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            final Range r = at.getRange();
            final int min = getIntegerConstant(r.getMinExpression());
            final int max = getIntegerConstant(r.getMaxExpression());
            for (int i = max; i >= min; --i) {
                final ComplexAccess nexpr = new ComplexAccess(expr);
                nexpr.accessArray(Integer.toString(i));
                emitUnpack(nexpr, at.getElementType());
            }
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nexpr = new ComplexAccess(expr);
                    final String id = d.getIdentifier().getIdentifier();
                    nexpr.accessStructure(id);
                    emitUnpack(nexpr, d.getTypeFragment());
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot unpack: " + t);
        }
    }

    private void emitUnpack(final ExpressionInterface structure)
        throws VisitorException {
        emitUnpack(getComplexAccess(structure),
                   (Type) analysisResults.getType(structure));
    }

    /**
     * Process an assignment statement.
     *
     * @param lhs left hand side of the assignment statement
     * @param rhs right hand side of the assignment statement;
     * <code>null</code> if the right hand side is the value from a channel
     * @param chanExpr <code>null</code> if the right hand side is not the
     * value from a channel; otherwise, it contains the channel expression to
     * read from.
     **/
    private void processAssignmentStatement(ExpressionInterface lhs,
                                            ExpressionInterface rhs,
                                            ExpressionInterface chanExpr,
                                            AssignmentStatement stmt)
        throws VisitorException {
        lvalues.add(lhs);
        final boolean op =
            stmt != null && stmt.getKind() != AssignmentStatement.EQUAL;
        if (lhs instanceof BitRangeExpression &&
            needBitRangeFunction((BitRangeExpression) lhs)) {
            final BitRangeExpression bitRangeExpression =
                (BitRangeExpression) lhs;
            out.print("util.bit_insert_" +
                      (op ? stmt.getKindString() : "") +
                      (bitRangeExpression.getMinExpression() == null ?
                          "3" : "4") +
                      "(");
            lvalues.add(bitRangeExpression.getBitsExpression());
            bitRangeExpression.getBitsExpression().accept(this);
            out.print(','); out.ws();
            lvalues.add(rhs);
            processBooleanChannel(chanExpr, rhs);
            out.print(','); out.ws();
            lvalues.add(bitRangeExpression.getMaxExpression());
            bitRangeExpression.getMaxExpression().accept(this);
            if (bitRangeExpression.getMinExpression() != null) {
                out.print(','); out.ws();
                lvalues.add(bitRangeExpression.getMinExpression());
                bitRangeExpression.getMinExpression().accept(this);
            }
            out.println(");");
        } else if (analysisResults.getType(lhs) instanceof StructureType ||
                   analysisResults.getType(lhs) instanceof ArrayType) {
            // This can only be an assignment between two structure or array
            // variables
            complexAccess = new ComplexAccess();
            lhs.accept(this);
            final ComplexAccess lca = complexAccess;

            complexAccess = new ComplexAccess();
            rhs.accept(this);
            final ComplexAccess rca = complexAccess;
            complexAccess = null;

            final Type t = (Type) analysisResults.getType(lhs);
            emitAssignment(lca, rca, t);
        } else {
            final boolean lstr =
                stmt != null && stmt.getKind() == AssignmentStatement.ADD &&
                (analysisResults.getType(lhs) instanceof StringType);
            final boolean rstr =
                lstr && !(analysisResults.getType(rhs) instanceof StringType);

            if (op) out.print("util.assign_" +
                              (lstr ? "concat" : stmt.getKindString()) + "(");
            if (lhs instanceof BitRangeExpression) {
                final BitRangeExpression bre = (BitRangeExpression) lhs;
                lvalues.add(bre.getBitsExpression());
                processSimpleBitRange(bre, true);
            } else {
                lhs.accept(this);
            }
            if (op) { out.ws(); out.print(','); out.ws(); }
            else {
                out.print(" = ");
            }
            if (rstr) out.print("util.csp_string(");
            lvalues.add(rhs);
            processBooleanChannel(chanExpr, rhs);
            if (rstr) out.print(", 10)");
            if (op) out.print(" )");
            out.println(';');

            if (false) {
                // debugging display
                out.print("$display(\"");
                lhs.accept(this);
                out.print(": %d\\n\", ");
                lhs.accept(this);
                out.println(");");
            }
        }
    }

    private static final Map/*<String,String>*/ BUILTIN_FUNCTIONS =
        CollectionUtils.mapify(
            new String[] { "print", "util.display_hex",
                           "assert", "assert",
                           "eventQueueIsEmpty", null,
                           "random", "random",
                           "srandom", "srandom",
                           "choose", "choose",
                           "log2", "log2",
                           "log4", "log4",
                           "wait", "wait",
                           // without function in guards, this isn't very useful
                           "stable", null,
                           "string", "string",
                           "enableDSimErrors", null,
                           "time", "time",
                           "pack", "pack",
                           "unpack", "unpack",
                           "energy", "energy" });

    private String getFullName(
            final FunctionDeclaration decl,
            final List/*<Object>*/ arrayArg) throws VisitorException {
        final Pair/*<FunctionDeclaration,List<Object>>*/ p =
            new Pair/*<FunctionDeclaration,List<Object>>*/(decl, arrayArg);
        final String result = decl.getName() + "$" + labels.getLabel(p);
        pendingFunctions.addFirst(new Triplet/*<FunctionDeclaration,
                                           List<Object>,
                                           String>*/(decl, arrayArg, result));

        return result;
    }

    private String getFullName(
            final StructureDeclaration decl,
            final List/*<Object>*/ arrayArg) throws VisitorException {
        final Pair/*<StructureDeclaration,List<Object>>*/ p =
            new Pair/*<StructureDeclaration,List<Object>>*/(decl, arrayArg);
        final String result = decl.getName() + "$" + labels.getLabel(p);
        pendingConstructors.add(new Triplet/*<StructureDeclaration,
                                             List<Object>,
                                             String>*/(decl, arrayArg, result));

        return result;
    }

    private final Map/*<FunctionDeclaration,VariableAnalyzer.Results>*/
        functionAnalyzerCache =
            new HashMap/*<FunctionDeclaration,VariableAnalyzer.Results>*/();

    private VariableAnalyzer.Results
    getAnalyzerResults(final FunctionDeclaration decl,
                       final SequentialStatement initStmt)
    throws VariableAnalysisException {
        VariableAnalyzer.Results results =
            (VariableAnalyzer.Results) functionAnalyzerCache.get(decl);
        if (results == null) {
            results = analyzer.getResults(decl, initStmt, resolver);
            allUsedTokens.addAll(results.getUsedTokens());
            problems.process(results.getErrors(strictVars));
            functionAnalyzerCache.put(decl, results);
        }
        return results;
    }

    private final Map/*<Object,Object>*/ arrayMapping =
        new HashMap/*<Object,Object>*/();

    private ComplexAccess mapComplexArgument(final ComplexAccess access) {
        final ComplexAccess mapped =
            (ComplexAccess) arrayMapping.get(access.getBase());
        return access.map(mapped);
    }

    private void outputFormalParameter(final IdentifierExpression ident,
                                       final Type t,
                                       final Iterator/*<ComplexAccess>*/ args,
                                       final UniqueLabel label,
                                       final String inout,
                                       final boolean[] comma)
        throws VisitorException {
        if (t instanceof ArrayType || t instanceof StructureType) {
            final ComplexAccess access = (ComplexAccess) args.next();
            final int num = label.getLabel(access);
            final ComplexAccess fixed = new ComplexAccess();
            fixed.copyStructure(access);
            fixed.setBase(access.getBase());
            final int indices = access.getIndices().size();
            if (indices > 0 && comma[0]) out.println(",");
            for (int i = 0; i < indices; ++i) {
                comma[0] = true;
                final String var = "i$" + num + "$" + i;
                declareVariable("input ", var, new IntegerType(), ",");
                if (i < indices - 1) out.println(",");
                fixed.accessArray(var);
            }
            arrayMapping.put(t, fixed);
        } else {
            if (comma[0]) out.println(",");
            declareVariable(inout, ident.getIdentifier(), t, ",");
            comma[0] = true;
        }
    }

    private void outputConstructor(final StructureDeclaration decl,
                                   final List/*<Object>*/ arrayArg,
                                   final String name) throws VisitorException {
        final Iterator argIter = arrayArg.iterator();
        final UniqueLabel label = new UniqueLabel();
        final boolean[] comma = new boolean[] { false };
        out.println("task " + escape(name) + " (");
        (new DeclarationProcessor() {
            public void process(final Declarator d) throws VisitorException {
                final IdentifierExpression ident = d.getIdentifier();
                final Type t = d.getTypeFragment();
                tokenVerilogNameMap.put(t, ident.getIdentifier());
                hierarchyNameMap.put(t, name);
                outputFormalParameter(ident, t, argIter, label, "input ",
                                      comma);
            }
        }).process(decl.getDeclarations());
        final IdentifierExpression rident = new IdentifierExpression("ret$");
        final StructureType rtype = new StructureType(false, decl.getName());
        tokenVerilogNameMap.put(rtype, rident.getIdentifier());
        hierarchyNameMap.put(rtype, name);
        outputFormalParameter(rident, rtype, argIter, label, "output ", comma);
        out.println(");");
        out.println();

        out.println("begin : main");
        final ComplexAccess lhs = new ComplexAccess();
        lhs.setBase(rtype);
        (new DeclarationProcessor() {
            public void process(final Declarator d)
                throws VisitorException {
                final ComplexAccess nlhs = new ComplexAccess(lhs);
                final String id = d.getIdentifier().getIdentifier();
                nlhs.accessStructure(id);

                final ComplexAccess nrhs = new ComplexAccess();
                nrhs.setBase(d.getTypeFragment());
                emitAssignment(nlhs, nrhs, d.getTypeFragment(), 0);
            }
        }).process(decl.getDeclarations());
        out.println("end");
        out.println("endtask");
    }

    private void outputFunction(final FunctionDeclaration decl,
                                final SequentialStatement initStmt,
                                final List/*<Object>*/ arrayArg,
                                final String name) throws VisitorException {
        final VariableAnalyzer.Results old = analysisResults;
        try {
            analysisResults = getAnalyzerResults(decl, initStmt);
        } catch (VariableAnalysisException x) {
            throw new VisitorException(x.getMessage(), x);
        }

        updateTokenVerilogMap(name);

        arrayMapping.clear();
        out.println("task " + escape(name) + " (");
        final Iterator argIter = arrayArg.iterator();
        final UniqueLabel label = new UniqueLabel();
        final boolean[] comma = new boolean[] { false };
        for (Iterator i = decl.getFormals().getDeclarations(); i.hasNext(); ) {
            final DeclaratorList d =
                ((Declaration) i.next()).getDeclaratorList();
            for (Iterator j = d.getDeclarators(); j.hasNext(); ) {
                final Declarator dor = (Declarator) j.next();
                final IdentifierExpression ident = dor.getIdentifier();
                final Type t = (Type) analysisResults.getIdentToken(ident);
                lastVerilogTokenMap.remove(t);
                outputFormalParameter(ident, t, argIter, label,
                        dor.getDirection() == Declarator.IN ? "input "
                                                            : "inout ",
                        comma);
            }
        }
        // return value
        final Type rtype = decl.getReturnType();
        if (rtype != null) {
            outputFormalParameter(decl.getNameIdentifier(), rtype,
                                  argIter, label, "output ", comma);
        }
        out.println(");");
        out.println();
        if (rtype != null)
            lastVerilogTokenMap.remove(analysisResults.getIdentToken(decl.getNameIdentifier()));

        declareVariables();

        // start initial block
        out.println("begin : main");

        // declare and initialize the undeclared variables
        final Set/*<String>*/ undeclaredVars = processResults(analysisResults);

        // assign to 0 - undeclared variables
        for (Iterator i = undeclaredVars.iterator(); i.hasNext(); ) {
            final String var = escape((String) i.next());
            out.println(var + " = 0;");
        }
        // assign to 0 - return value
        if (decl.getReturnType() != null)
            initVar(decl.getReturnType(), decl.getNameIdentifier(), 0, null);
        // assign to 0 - output parameters
        for (Iterator i = decl.getFormals().getDeclarations(); i.hasNext(); ) {
            final DeclaratorList d =
                ((Declaration) i.next()).getDeclaratorList();
            for (Iterator j = d.getDeclarators(); j.hasNext(); ) {
                final Declarator dor = (Declarator) j.next();
                if (dor.getDirection() == Declarator.OUT) {
                    final IdentifierExpression ident = dor.getIdentifier();
                    final Type t = (Type) analysisResults.getIdentToken(ident);
                    initVar(t, ident, 0, null);
                }
            }
        }
        out.println();

        // csp body
        processingBody = true;
        decl.getBodyStatement().accept(this);
        processingBody = false;

        // end initial block
        out.println("end");
        out.println();

        // end module
        out.println("endtask");
        analysisResults = old;
    }

    private void outputFunctions(final SequentialStatement initStmt)
        throws VisitorException {
        final HashSet/*<Triplet<FunctionDeclaration,
                                List<Object>,
                                String>>*/ seen =
            new HashSet/*<FunctionDeclaration,List<Object>,String>>*/();
        while (!pendingFunctions.isEmpty()) {
            final Triplet/*<FunctionDeclaration,List<Object>,String>>*/ t =
                (Triplet) pendingFunctions.remove(0);
            if (!seen.add(t)) continue;
            final FunctionDeclaration decl = (FunctionDeclaration) t.getFirst();
            final List/*<Object>*/ arrayArg = (List) t.getSecond();
            final String name = (String) t.getThird();
            outputFunction(decl, initStmt, arrayArg, name);
        }
    }

    private void outputConstructors() throws VisitorException {
        final HashSet/*<Triplet<StructureDeclaration,
                                List<Object>,
                                String>>*/ seen =
            new HashSet/*<StructureDeclaration,List<Object>,String>>*/();
        while (!pendingConstructors.isEmpty()) {
            final Triplet/*<StructureDeclaration,List<Object>,String>>*/ t =
                (Triplet) pendingConstructors.remove(0);
            if (!seen.add(t)) continue;
            final StructureDeclaration decl =
                (StructureDeclaration) t.getFirst();
            final List/*<Object>*/ arrayArg = (List) t.getSecond();
            final String name = (String) t.getThird();
            outputConstructor(decl, arrayArg, name);
        }
    }

    private void outputArbiters() {
        for (Iterator i = arbiters.iterator(); i.hasNext(); ) {
            final Pair p = (Pair) i.next();
            final String inst = (String) p.getFirst();
            final Integer guards = (Integer) p.getSecond();
            out.println("`CAST2VERILOG_ARBITER #(" + guards + ") " +
                        inst + "(" + resetNodeName + " );");
        }
    }

    private void processFunctionArgument(
            final ExpressionInterface arg,
            final Collection/*<Object>*/ realArgs,
            final Collection/*<ExpressionInterface>*/ arrayArgs)
        throws VisitorException {
        final Type type = analysisResults.getType(arg);
        if (type instanceof ArrayType || type instanceof StructureType) {
            complexAccess = new ComplexAccess();
            arg.accept(this);
            final ComplexAccess mapped = mapComplexArgument(complexAccess);
            complexAccess = null;
            arrayArgs.add(mapped);
            realArgs.addAll(mapped.getIndices());
        } else {
            realArgs.add(arg);
        }
    }

    private void processFunctionCall(final FunctionCallExpression e,
                                     final ExpressionInterface lhs)
        throws VisitorException {
        for (Iterator arg = e.getActuals(); arg.hasNext(); ) {
            lvalues.add((ExpressionInterface) arg.next());
        }
        if (lhs != null) lvalues.add(lhs);

        final Pair/*<CSPProgram,FunctionDeclaration>*/ p =
            (Pair) resolver.getResolvedFunctions().get(e);
        final Object decl = p == null ? null : p.getSecond();
        String name = null;
        if (p == null || RefinementResolver.isBuiltin(decl)) {
            final ExpressionInterface func = e.getFunctionExpression();
            if (func instanceof IdentifierExpression) {
                name = ((IdentifierExpression) func).getIdentifier();
                name = (String) BUILTIN_FUNCTIONS.get(name);
                if (name == null) {
                    throw new VisitorException(
                            "Unsupported builtin function at " +
                            e.getParseRange().fullString());
                } else if (name == "util.display_hex" || name == "wait" ||
                           name == "assert") { 
                    visitFunctionCallExpression(e); // process builtin funcs 
                } else if (name == "srandom") {
                    System.out.println("N.B. srandom() function being skipped");
                } else if (name == "choose" || name == "random" ||
                           name == "string" || name == "log2" ||
                           name == "log4" || name == "time") { 
                    lhs.accept(this);
                    out.print(" = ");
                    visitFunctionCallExpression(e); // process builtin funcs 
                    out.println(" ; ");
                } else if (name == "pack") {
                    lhs.accept(this);
                    out.print(" = { ");
                    final Iterator i = e.getActuals();
                    emitPack((ExpressionInterface) i.next());
                    out.println(" }; ");
                } else if (name == "unpack") {
                    out.print("{ ");
                    final Iterator i = e.getActuals();
                    final ExpressionInterface structure =
                        (ExpressionInterface) i.next();
                    emitPack(structure);
                    out.print(" } = ");
                    ((ExpressionInterface) i.next()).accept(this);
                    out.println(" ;");
                    emitUnpack(structure);
                } else if (name == "energy") {
                    // do nothing
                }
            } else {
                throw new VisitorException("Call to unknown function at " +
                                           e.getParseRange().fullString());
            }
            return;
        }

        final Collection realArgs = new ArrayList/*<Object>*/();
        if (decl instanceof FunctionDeclaration ||
            decl instanceof StructureDeclaration) {
            final List/*<Object>*/ arrayArg = new ArrayList/*<Object>*/();
            for (Iterator i = e.getActuals(); i.hasNext(); ) {
                final ExpressionInterface arg = (ExpressionInterface) i.next();
                processFunctionArgument(arg, realArgs, arrayArg);
            }
            if (lhs != null) processFunctionArgument(lhs, realArgs, arrayArg);

            if (decl instanceof FunctionDeclaration) {
                name = getFullName((FunctionDeclaration) decl, arrayArg);
            } else {
                name = getFullName((StructureDeclaration) decl, arrayArg);
            }
        } else {
            throw new VisitorException("Call to unknown function at " +
                                       e.getParseRange().fullString());
        }

        out.print(name);
        if (!realArgs.isEmpty()) {
            out.print("(");
            for (Iterator i = realArgs.iterator(); i.hasNext(); ) {
                final Object o = i.next();
                if (o instanceof ExpressionInterface) {
                    ((ExpressionInterface) o).accept(this);
                } else {
                    ((Index) o).write();
                }
                if (i.hasNext()) { out.print(','); out.ws(); }
            }
            out.print(")");
        }
        out.println(";");
    }
    public void visitAssignmentStatement(AssignmentStatement s)
        throws VisitorException {
        final ExpressionInterface rhs = s.getRightHandSide();
        // Here we handle peeks outside of guards as a special case of the rhs of assignments 
        // because the FunctionPreprocessor transforms peeks outside of guards as
        // x = #X? + 0 into temp = #X?; x = temp + 0
        // Peeks inside guards are handled in visitPeekExpressions
        if (rhs instanceof PeekExpression) {
            // outside guard: #L? == ( [ L.d >= 0 ] ; L.d )
            final ExpressionInterface chanExpr =
                ((PeekExpression) rhs).getChannelExpression();
            out.print("wait(");
            emitChannelData(chanExpr);
            out.println(" >= 0);");
            processAssignmentStatement(s.getLeftHandSide(), rhs,
                                       chanExpr, null);
        } else if (rhs instanceof FunctionCallExpression) {
            processFunctionCall((FunctionCallExpression) rhs,
                                s.getLeftHandSide());
        } else {
            processAssignmentStatement(s.getLeftHandSide(), rhs, null, s);
        }
    }

    /**
     * Returns true if the guarded statement has one guard
     * and no else clause.
     **/
    private static boolean hasOneGuard(AbstractGuardedStatement s) {
        final Iterator i = s.getGuardedCommands();
        assert i.hasNext();
        i.next();
        return !i.hasNext() && s.getElseStatement() == null;
    }

    /**
     * Returns number of guards in guarded statement 
     **/
    private static int numGuards(AbstractGuardedStatement s) {
        final Iterator i = s.getGuardedCommands();
        int numGuards = 0;
        assert i.hasNext();
        while (i.hasNext()) {
                numGuards++; 
                i.next();
        }
        return(numGuards);
    }

    public void processSelectionOrRepetition(
            final AbstractGuardedStatement s,
            final boolean isRepetition,
            final boolean isDeterministic)
        throws VisitorException {
        if (isRepetition && hasOneGuard(s)) {
            // Special case the 1 guard case into a simple while loop
            final GuardedCommand gc =
                (GuardedCommand) s.getGuardedCommands().next();
            final StatementInterface guardStmt;
            if (gc instanceof GuardedCommandWithStatement) {
                guardStmt =
                    ((GuardedCommandWithStatement) gc).getGuardStatement();
            } else {
                guardStmt = null;
            }
            if (guardStmt != null) {
                guardStmt.accept(this);
            }
            out.print("while (");
            gc.getGuard().accept(this);
            out.println(") begin");
            gc.getCommand().accept(this);
            if (guardStmt != null) {
                guardStmt.accept(this);
            }
            out.println("end");
        } else {
            out.println("begin : " + genBlock());
            final String chosenGuard = "chosen_guard$" + genVarNum();
            out.println("integer " + chosenGuard + ';');
            final String numTrueGuards = "num_true_guards$" + genVarNum();
            out.println("integer " + numTrueGuards + ';');

            // for non-determistic case declare an array of true guard nums
            final int numGuards = numGuards(s);
            final String arbiterInst, trueGuards;
            if (isDeterministic) {
                arbiterInst = null;
                trueGuards = "true_guards$" + genVarNum();
                out.println("integer " + trueGuards +
                            "[0:" + numGuards + " - 1];");
            } else {
                arbiterInst = "arbiter$" + genVarNum();
                trueGuards = arbiterInst + ".true_guards";
                arbiters.add(new Pair(arbiterInst, new Integer(numGuards)));
            }

            if (!isRepetition || s.getElseStatement() == null) {
                // hack around lack of do ... while loop by setting
                // chosenGuard to 0 initially
                out.println(chosenGuard + " = 0;");
                out.println("while (" + chosenGuard + " != -1) begin");
            } else
                out.println("while (1) begin");

            out.println(chosenGuard + " = -1;");
            out.println(numTrueGuards + " = 0;");


            // handle guards
            int guardNum = 0;
            for (Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
                final GuardedCommand gc = (GuardedCommand) i.next();

                if (gc instanceof GuardedCommandWithStatement) {
                    final GuardedCommandWithStatement gcws =
                        (GuardedCommandWithStatement) gc;
                    gcws.getGuardStatement().accept(this);
                }

                out.print("if (");
                gc.getGuard().accept(this);
                out.println(')');

                out.println("begin");
                if (isDeterministic) // remember true guard
                    out.println(chosenGuard + " = " + guardNum + ';');

                // trueGuards[numTrueGuards] = guardNum; 
                out.println(trueGuards + "[" + numTrueGuards + "] = " +
                    guardNum + ";"); 

                out.println(numTrueGuards + " = " + numTrueGuards + "+ 1;");
                out.println("end");

                ++guardNum;
            }

             // emit error checking code for more than 1 guard being true
             // in deterministic case
             if (isDeterministic) {
                  out.println("// error checking code"); 
                  out.println("if (" + numTrueGuards + " > 1) begin");
                  out.println("`CAST2VERILOG_MULTIPLE_GUARDS_TRUE_ERROR2(\"" +
                              s.getParseRange().fullString() + "\", " +
                              numTrueGuards + ", " + trueGuards + ")");
                  out.println("end // error checking code"); 
            }

            // pick guard randomly among true guards
            if (!isDeterministic) {
                out.println("if (" + numTrueGuards + "> 0)");
                out.println(chosenGuard + " = " + arbiterInst + ".select(" +
                            numTrueGuards + ");");
            }

            // handle bodies
            out.println("case (" + chosenGuard + ')');
            // handle else or do nothing case
            out.println("-1 : begin");
            if (s.getElseStatement() != null) {
                s.getElseStatement().accept(this);
            } else if (!isRepetition) {
                // handle case that no guards are true
                // REVIEW: This might not be the best way to handle waiting
                out.print("@(");
                boolean first = true;
                for (Iterator i = inputPorts.iterator(); i.hasNext(); ) {
                    final String inputPort = (String) i.next();
                    if (!first) {
                        out.ws(); out.print("or"); out.ws();
                    }
                    first = false;
                    out.print(inputPort + " ");
                }
                if (first) {
                    // if there are no inputs at all to the cell, deadlock by
                    // waiting for the chosenGuard variable to change, which
                    // cannot happen
                    out.print(chosenGuard + " ");
                }
                out.println(");");

                // HACK: stay in loop by setting chosenGuard to 0
                out.println(chosenGuard + " = 0;");
            }
            out.println("end");
            // handle other bodies
            guardNum = 0;
            for (Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
                final GuardedCommand gc = (GuardedCommand) i.next();
                out.println(guardNum + " : begin");
                gc.getCommand().accept(this);
                if (!isRepetition) {
                    // HACK: end loop by setting chosenGuard to -1
                    out.println(chosenGuard + " = -1;");
                }
                out.println("end");

                ++guardNum;
            }
            out.println("endcase");

            out.println("end");
            out.println("end");
        }
    }


    public void visitDeterministicRepetitionStatement(
            DeterministicRepetitionStatement s)
        throws VisitorException {
        processSelectionOrRepetition(s, true, true);
    }


    public void visitDeterministicSelectionStatement(
            DeterministicSelectionStatement s)
        throws VisitorException {
        processSelectionOrRepetition(s, false, true);
    }

    public void visitExpressionStatement(ExpressionStatement s)
        throws VisitorException {
        final ExpressionInterface expr = s.getExpression();
        if (expr instanceof FunctionCallExpression) {
            processFunctionCall((FunctionCallExpression) expr, null);
            return;
        }
        unsupported(s);
    }

    public void visitLoopStatement(LoopStatement s) throws VisitorException {
        // Only sequential loops are translated directly; parallel loops is
        // only handled via loop unrolling
        if (s.getSeparator() == LoopStatement.SEQUENTIAL) {
            out.println("begin : " + genBlock());
            final String loopMax = "loopMax$" + genVarNum();
            out.println(registerType + " " + loopMax + ";");
            out.print(loopMax + " = ");
            s.getRange().getMaxExpression().accept(this); 
            out.println(" ;");

            out.print("for (");
            s.getIndexVarExpression().accept(this);
            out.print("=");
            s.getRange().getMinExpression().accept(this);
            out.print(" ; ");
            s.getIndexVarExpression().accept(this);
            out.print(" <= " + loopMax + " ; ");
            s.getIndexVarExpression().accept(this);
            out.print("=");
            s.getIndexVarExpression().accept(this);
            out.println(" + 1) begin ");
            s.getStatement().accept(this); 
            out.println("end");
            out.println("end");
        } else {
            throw new VisitorException("Range not compile time constants in loop at " + s.getParseRange().fullString());
        }
    }

    public void visitNonDeterministicRepetitionStatement(
            NonDeterministicRepetitionStatement s)
        throws VisitorException {
        unsupported(s);
    }


    public void visitNonDeterministicSelectionStatement(
            NonDeterministicSelectionStatement s)
        throws VisitorException {
        /* Through exception on else. Currently this also causes a grammer exception */
        if (s.getElseStatement() != null) {
            throw new AssertionError("Else in non-deterministic selection not supported");
        }
        processSelectionOrRepetition(s, false, false);
    }

    public void visitLinkageLoopTerm(final LinkageLoopTerm term)
        throws VisitorException {
        unsupported(term);
    }

    public void visitLinkageExpressionTerm(final LinkageExpressionTerm term)
        throws VisitorException {
        unsupported(term);
    }

    public void visitLinkageArrayAccessExpression(
            final LinkageArrayAccessExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitLinkageIdentifierExpression(
            final LinkageIdentifierExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitLinkageStructureAccessExpression(
            final LinkageStructureAccessExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitParallelStatement(ParallelStatement s)
        throws VisitorException {
        out.println("fork");

        for (Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();

            out.println("begin");

            // emit the parallel code
            stmt.accept(this);

            out.println("end");
        }

        out.println("join");
    }

    public void visitReceiveStatement(ReceiveStatement s)
        throws VisitorException {
        // This expansion requires slack of at least 1 to get probe
        // sends to behave properly.
        // L?x == ( [ L.d >= 0 ] ; x = L.d ; L.e = 0
        //        ; [ L.d <  0 ] ; L.e = 1 )
        // Good test cases include:
        // 1. L[getTime() % N]?x
        // 2. L[x]?x
        // These will ensure channel is evaluated only once
        
        final ExpressionInterface chanExpr = s.getChannelExpression();

        out.print("wait(");
        emitChannelData(chanExpr);
        out.println(" >= 0);");

        if (s.getRightHandSide() != null)
            processAssignmentStatement(s.getRightHandSide(),
                                       s.getRightHandSide(), chanExpr,
                                       null);

        emitChannelEnable(chanExpr);
        out.println(" = 0;");

        out.print("wait(");
        emitChannelData(chanExpr);
        out.println(" < 0);");

        emitChannelEnable(chanExpr);
        out.println(" = 1;");
    }

    private void processConcat(final String var, final String literal) {
        out.print(var + " = csp_string.concat(" + var + ", ");
        processString(literal);
        out.println(");");
    }

    public void visitSendStatement(SendStatement s)
        throws VisitorException {
        // R!x == ( [  R.e ] ; R.d = POSMOD(x, numValues)
        //        ; [ !R.e ] ; R.d = -1 )
        // Good test cases include:
        // 1. R[getTime() % N]!x
        // This will ensure channel is evaluated only once
        
        final ExpressionInterface chanExpr = s.getChannelExpression();

        // The type checking pass should have ensured that this is indeed
        // a channel type and that the direction is appropriate
        final ChannelType type =
            (ChannelType) analysisResults.getType(chanExpr);
        assert type.getDirection() == PortDirection.OUT;
        final BigInteger numValues = type.getNumValues();
        assert numValues.signum() == 1;

        out.print("wait(");
        emitChannelEnable(chanExpr);
        out.println(");");

        lvalues.add(s.getRightHandSide());

        final boolean pow2 = BigIntegerUtil.isPowerOf2(numValues);

        if (!pow2) {
            out.print("if ((");
            // it's okay to evaluate the rhs multiple times because rhs is
            // guaranteed to be a simple variable
            s.getRightHandSide().accept(this);
            out.print(" < 1'sb0) || (");
            s.getRightHandSide().accept(this);
            out.print(" >= ");
            processBigInteger(numValues, 10);
            out.println("))");
            out.print("`CAST2VERILOG_CSP_WARNING(\"" +
                      s.getParseRange().fullString() + "\", " +
                      "util.posmod_warning(");
            s.getRightHandSide().accept(this);
            out.print(", ");
            processBigInteger(numValues.subtract(BigInteger.ONE), 10);
            out.println("))");
        }

        emitChannelData(chanExpr);
        out.print(" = ");
        if (numValues.equals(BigInteger.ONE)) {
            out.print("0");
        } else {
            if (pow2) {
                processBigInteger(numValues.subtract(BigInteger.ONE), 16);
                out.print(" & (");
            } else {
                out.print("util.posmod(");
            }
            s.getRightHandSide().accept(this);
            if (!pow2) {
                out.println(", ");
                processBigInteger(numValues, 16);
            }
            out.print(")");
        }
        out.println(';');

        out.print("wait(!");
        emitChannelEnable(chanExpr);
        out.println(");");

        emitChannelData(chanExpr);
        out.println(" = -1;");
    }

    public void visitSequentialStatement(SequentialStatement s)
        throws VisitorException {
        ++scope;
        for (final Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();
            stmt.accept(this);
        }   
        --scope;
    }

    public void visitErrorStatement(ErrorStatement s)
        throws VisitorException {
        out.println("`CAST2VERILOG_CSP_ERROR(\"" +
                    s.getParseRange().fullString() + "\")");
    }

    public void visitSkipStatement(SkipStatement s)
        throws VisitorException {
        // do nothing
    }

    private void declareType(final Type t,
                             final ComplexDeclaration decl,
                             final Collection/*<ComplexDeclaration>*/ results)
        throws VisitorException {
        if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            decl.declareArray(at.getRange());
            declareType(at.getElementType(), decl, results);
        } else if (t instanceof IntegerType || t instanceof BooleanType ||
                   t instanceof StringType) {
            decl.setType(t);
            results.add(decl);
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            // VariableAnalyzer should have made sure all structures are valid
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexDeclaration cdecl =
                        new ComplexDeclaration(decl);
                    cdecl.declareStructure(d.getIdentifier().getIdentifier());
                    declareType(d.getTypeFragment(), cdecl, results);
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Unsupported type: " + t);
        }
    }

    private void declareVariable(final String id, final Type t)
        throws VisitorException {
        declareVariable("", id, t, ";");
        out.println(";");
    }

    private void declareVariable(final String inout, final String id,
                                 final Type t, final String delim)
        throws VisitorException {
        final Collection/*<ComplexDeclaration>*/ results =
            new ArrayList/*<ComplexDeclaration>*/();
        final ComplexDeclaration decl = new ComplexDeclaration();
        declareType(t, decl, results);

        // just emit declaration
        for (Iterator i = results.iterator(); i.hasNext(); ) {
            final ComplexDeclaration cdecl = (ComplexDeclaration) i.next();
            out.print(inout);
            cdecl.declare(id);
            if (i.hasNext()) out.println(delim);
        }
    }

    private Map/*<Type,String>*/ tokenVerilogNameMap =
        new HashMap/*<Type,String>*/();
    private Map/*<Type,String>*/ lastVerilogTokenMap =
        new LinkedHashMap/*<Type,String>*/();
    private Map/*<Type,String>*/ hierarchyNameMap =
        new HashMap/*<Type,String>*/();
    private Set<Type> allUsedTokens = new HashSet<Type>();
    private void updateTokenVerilogMap(final String hierarchy) {
        lastVerilogTokenMap.clear();
        final Map/*<Type,String>*/ tokenIdentMap =
            analysisResults.getTokenIdentMap();
        final Set<Type> initializerTokens =
            analysisResults.getInitializerTokens();
        final HashCounter counter = new HashCounter();
        for (Iterator i = tokenIdentMap.entrySet().iterator(); i.hasNext(); ) {
            final Map.Entry/*<Type,String>*/ entry = (Map.Entry) i.next();
            final Type type = (Type) entry.getKey();
            final String id = (String) entry.getValue();
            final int count = counter.getCount(id);
            counter.add(id);
            final String realId = id + (count == 0 ? "" : "$$" + count);
            tokenVerilogNameMap.put(type, realId);
            // ChannelTypes and ChannelStructureTypes cannot be passed to
            // functions as arguments, and therefore can only be accessed if
            // they are in the cell's port list.  The cell ports translate to
            // module ports, which are visible to tasks defined in the module,
            // so we do not need to do anything to them.
            Type baseType = type;
            while (baseType instanceof ArrayType)
                baseType = ((ArrayType) baseType).getElementType();
            if ((baseType instanceof IntegerType ||
                 baseType instanceof BooleanType ||
                 baseType instanceof StringType ||
                 baseType instanceof StructureType) &&
                !initializerTokens.contains(type) &&
                allUsedTokens.contains(type))
                lastVerilogTokenMap.put(type, realId);
            hierarchyNameMap.put(type, hierarchy);
        }
    }

    private void declareVariables() throws VisitorException {
        for (Iterator i = lastVerilogTokenMap.entrySet().iterator();
             i.hasNext(); ) {
            final Map.Entry/*<String,Token>*/ entry = (Map.Entry) i.next();
            declareVariable((String) entry.getValue(), (Type) entry.getKey());
        }
    }

    private void initVar(final Type t, final IdentifierExpression ident,
                         final int dims, final ExpressionInterface init)
        throws VisitorException {
        complexAccess = new ComplexAccess();
        ident.accept(this);
        final ComplexAccess access = complexAccess;
        complexAccess = null;
        initVar(t, access, dims, init);
    }

    private void initVar(final Type t, final ComplexAccess ident,
                         final int dims, final ExpressionInterface init) 
        throws VisitorException {
        if (t instanceof IntegerType || t instanceof BooleanType) {
            ident.write();
            out.print(" = ");
            if (init == null) out.print('0');
            else init.accept(this);
            out.println(";");
        } else if (t instanceof StringType) {
            ident.write();
            out.print(" = ");
            if (init == null) out.print("csp_string.init($bits(\"\"),\"\")");
            else init.accept(this);
            out.println(";");
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            out.println("begin : " + genBlock());
            final String var = "loop$" + dims;
            out.println(getLoopVarType(at.getRange()) + " " + var + ";");
            emitForLoop(var, at.getRange());
            out.println(" begin");
            ident.accessArray(var);
            initVar(at.getElementType(), ident, dims + 1, init);
            out.println("end");
            out.println("end");
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nident = new ComplexAccess(ident);
                    nident.accessStructure(d.getIdentifier().getIdentifier());
                    initVar(d.getTypeFragment(), nident, dims + 1,
                            d.getInitializer());
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot initialize type: " + t);
        }
    }

    public void visitVarStatement(VarStatement s)
        throws VisitorException {
        for (Iterator i = s.getDeclarationList().getDeclarations();
             i.hasNext(); ) {
            final Declaration declaration = (Declaration) i.next();

            for (Iterator j =
                     declaration.getDeclaratorList().getDeclarators();
                 j.hasNext(); ) {
                final Declarator declarator = (Declarator) j.next();
                final Type t = declarator.getTypeFragment();

                // declaration has been emitted at top of block by
                // declareVariables(), just assign here
                final ExpressionInterface init  = declarator.getInitializer();
                if (implicitInit || init != null || scope > 1) {
                    initVar(t, declarator.getIdentifier(), 0, init);
                }
            }
        }

        // only support new style declarations
        assert s.getStatement() == null;
    }

    public void visitArrayType(ArrayType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitChannelType(ChannelType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitChannelStructureType(ChannelStructureType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitIntegerType(IntegerType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitBooleanType(BooleanType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitNodeType(NodeType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitStringType(StringType t) throws VisitorException {
        unsupported(t);
    }

    public void visitStructureType(StructureType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitIdentifierList(IdentifierList il)
        throws VisitorException {
        unsupported(il);
    }

    public void visitLoopGuard(LoopGuard s) throws VisitorException {
        unsupported(s);
    }

    public void visitIncDecStatement(IncDecStatement s)
        throws VisitorException {
        unsupported(s);
    }

    private void unsupported(AbstractASTNode n) throws VisitorException {
        throw new VisitorException("CSP construct not yet supported at " +
                                   n.getParseRange().fullString());
    }
}

/*
 * Copyright 2002, 2003 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

/*
 * Copyright 2001 Asynchronous Digital Design.  All rights reserved.
 *
 * $Id$
 */

package com.avlsi.csp.csp2java;

import java.math.BigInteger;

import java.io.PrintWriter;
import java.io.File;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.Set;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;

import com.avlsi.cell.CellUtils;
import com.avlsi.csp.ast.*;
import com.avlsi.csp.coverage.ProbeInfo;

import com.avlsi.tools.cosim.CoSimInfo;

import com.avlsi.fast.ports.ChannelType;
import com.avlsi.fast.ports.NodeType;
import com.avlsi.fast.ports.PortTypeInterface;
import com.avlsi.fast.ports.PortDefinition;
/* import com.avlsi.fast.ports.ArrayType; */

import com.avlsi.fast.metaparameters.ArrayMetaParam;
import com.avlsi.fast.metaparameters.BooleanMetaParam;
import com.avlsi.fast.metaparameters.FloatMetaParam;
import com.avlsi.fast.metaparameters.IntegerMetaParam;
import com.avlsi.fast.metaparameters.MetaParamDefinition;
import com.avlsi.fast.metaparameters.MetaParamTypeInterface;

import com.avlsi.csp.grammar.ParseRange;
import com.avlsi.csp.grammar.ParsePosition;
import com.avlsi.csp.util.CSPCellInfo;
import com.avlsi.csp.util.CspUtils;
import com.avlsi.csp.util.DeclarationProcessor;
import com.avlsi.csp.util.Problem;
import com.avlsi.csp.util.ProblemFilter;
import com.avlsi.csp.util.RefinementResolver;
import com.avlsi.csp.util.RemoveScalars;
import com.avlsi.csp.util.UniqueLabel;
import com.avlsi.csp.util.VariableAnalysisException;
import com.avlsi.csp.util.VariableAnalyzer;
import com.avlsi.csp.util.VisitorExceptionWithLocation;

// yeah, this ought to be factored out of dsim
import com.avlsi.tools.dsim.ExceptionPrettyPrinter;

import com.avlsi.util.container.CollectionUtils;
import com.avlsi.util.container.Pair;
import com.avlsi.util.functions.BinaryFunction;
import com.avlsi.util.functions.NullaryAction;
import com.avlsi.util.functions.UnaryPredicate;
import com.avlsi.util.math.BigIntegerUtil;
import com.avlsi.util.text.StringUtil;
import com.avlsi.io.Printable;
import com.avlsi.io.WrapPrintWriter;

/**
 * Visitor pattern to emit java from csp.
 *
 * We maintain the convention that all expressions must print something
 * that is parenthesized when visited.
 *
 * @author Jesse Rosenstock
 * @version $Revision$ $Date$
 **/
public class JavaEmitter implements VisitorInterface {
    private final String packageName;
    private final String className;
    private final CSPCellInfo cellInfo;
    // State needed for traversal
    PrintWriter out;

    private final PrintWriter debugWriter;

    private final PrintWriter warningWriter;

    private final PrintWriter errorWriter;

    private final boolean strictVars; // forbids undeclared vars (bug 6085)

    private final boolean disableDftHandler;

    /** Autogenerated variable number. **/
    private int varNum = 0;
    /** True if we are processing the program body. **/
    private boolean bodyP = false;
    /** True if we are processing the body of a function. **/
    private boolean funcP = false;
    /** Results of variable and expression analysis **/
    protected VariableAnalyzer.Results analysisResults = null;

    private UniqueLabel linkageLabel = new UniqueLabel();

    private int probeCount = 0;

    /** Used to generate unique Element classes for non-channel arrays. **/
    private int arrayElementCount = 0;

    private boolean emitCoverageProbes=false;
    private boolean emitSnoopStatements;
    private final boolean synthesizable;

    private ArrayList probes = new ArrayList(); // array of ProbeInfo

    /**
     * Only used if emitSnoopStatements.
     **/
    private boolean foundLoop = false; 

    private RefinementResolver resolver =
        new RefinementResolver(RefinementResolver.NAME);

    private UniqueLabel labels = new UniqueLabel();

    /** See recurseDeterministicGuards and recurseDeterministicBodies */
    private Map loopVarHash = new IdentityHashMap();

    /** A suffix to the structure type definitions */
    private Map structureTypeHash = new IdentityHashMap();

    /** Special character escape sequences to use in string literals */
    private static Map ESCAPE_MAP = CollectionUtils.mapify(
        new Object[] {
            new Character('\b'), "\\b",
            new Character('\t'), "\\t",
            new Character('\n'), "\\n",
            new Character('\f'), "\\f",
            new Character('\r'), "\\r"
        });

    /**
     * Is the current ArrayAccessExpression part of an expression that will
     * access a channel in the port list?
     **/
    private boolean isPortArray = false;

    /** Used by ensureNewline() to see if it's already printed a newline. */
    private boolean didNewline = false;

    /**
     * A set of all identifers that have been referenced.  Any constant
     * initializers that do not initialize a variable in this set will be
     * eliminated.  Correctness is not affected if this set happens to contain
     * identifiers that weren't used.
     **/
    private final Set identUsed = new HashSet();

    private final ProblemFilter probFilter;

    public JavaEmitter(final String packageName,
                       final String className,
                       final CSPCellInfo cellInfo,
                       final PrintWriter out,
                       final PrintWriter warningWriter,
                       final PrintWriter errorWriter,
                       final PrintWriter debugWriter,
                       final boolean emitCoverageProbes,
                       final boolean emitSnoopStatements,
                       final boolean strictVars,
                       final boolean disableDftHandler,
                       final boolean synthesizable) {
        this.packageName = packageName;
        this.className = className;
        this.cellInfo = cellInfo;
        this.out = out;
        this.warningWriter = warningWriter;
        this.errorWriter = errorWriter;
        this.debugWriter = debugWriter;
        this.emitCoverageProbes = emitCoverageProbes;
        this.emitSnoopStatements = emitSnoopStatements;
        final Printable prntble = new com.avlsi.io.WrapPrintWriter(errorWriter);
        this.probFilter = new ProblemFilter(
            ProblemFilter.getClassifier(
                new HashSet(Arrays.asList(
                    new Object[] { "type.checker.undeclared.set.unused",
                                   "type.checker.invalid.guard" }))),
            new BinaryFunction() {
                public Object execute(final Object o1, final Object o2) {
                    JavaEmitter.this.ensureNewline();
                    return prntble;
                }
            });
        this.strictVars = strictVars;
        this.disableDftHandler = disableDftHandler;
        this.synthesizable = synthesizable;
    }


    private String getTypeString(final PortDefinition p) {
        String result = (String) structureTypeHash.get(p);
        if (result == null) {
            result = "type_" + p.getName() + "_" + structureTypeHash.size();
            structureTypeHash.put(p, result);
        }
        return result;
    }

    /**
     * Outputs body of a class definition for an arrayed port type.  Note that
     * 1-dimensional arrays of channels are handled by a runtime type.  If this
     * member is called with a 1-dimensional array of channels, a
     * VisitorException will be thrown.
     *
     * @param name Name of class to define
     * @param type Array port type
     * @param direction Direction modifier for the port:
     *  <ul>
     *      <li> &gt; 0 is forward
     *      <li> = 0 is bidirectional
     *      <li> &lt; 0 is reverse
     *  </ul>
     **/
    private void outputArrayPortClass (String name, 
            com.avlsi.fast.ports.ArrayType type, int direction)
            throws VisitorException {

        PortTypeInterface elementType = type.getArrayedType();
        int minIndex = type.getMinIndex();
        int maxIndex = type.getMaxIndex();
        int diffIndex = maxIndex - minIndex + 1;
        String runtimeElementType = "";
        String runtimeElementConstructor = "";
        String runtimeOffsetUpdate = "";

        if (diffIndex <= 0)
            throw new VisitorException ("Invalid Array Size");

        if (!(elementType instanceof com.avlsi.fast.ports.StructureType
           || elementType instanceof com.avlsi.fast.ports.ArrayType))
            throw new VisitorException ("Bad element type.");

        /* Special case of elements which are 1-dimensional arrays.  */

        if (elementType instanceof com.avlsi.fast.ports.ArrayType
         && ((com.avlsi.fast.ports.ArrayType) elementType).getArrayedType()
                instanceof ChannelType) {
            com.avlsi.fast.ports.ArrayType at =
                (com.avlsi.fast.ports.ArrayType) elementType;
            ChannelType ct = (ChannelType) at.getArrayedType();
            String dirString = "";
            int diffIndex2 = at.getMaxIndex() - at.getMinIndex() + 1;

            if (direction < 0) {
                // IN 
                runtimeElementType = "CspChannelInArray1";
                dirString = "in";
            } else if (direction > 0) {
                // OUT
                runtimeElementType = "CspChannelOutArray1";
                dirString = "out";
            } else {
                throw new VisitorException ("Invalid direction.");
            }
            runtimeElementConstructor = runtimeElementType 
                                      + "("
                                      + at.getMinIndex() + ", "
                                      + at.getMaxIndex() + ", \""
                                      + ct.getTypeName() + "\", "
                                      + dirString + ", "
                                      + dirString + "putOffset)";
            runtimeOffsetUpdate = dirString + "putOffset += " 
                                + diffIndex2 + ";";
        } else if (elementType instanceof com.avlsi.fast.ports.ArrayType
         && ((com.avlsi.fast.ports.ArrayType) elementType).getArrayedType()
                instanceof NodeType) {
            com.avlsi.fast.ports.ArrayType at =
                (com.avlsi.fast.ports.ArrayType) elementType;
            int diffIndex2 = at.getMaxIndex() - at.getMinIndex() + 1;
            runtimeElementType = "CspNodeArray1";
            runtimeElementConstructor = runtimeElementType
                                      + "("
                                      + at.getMinIndex() + ", "
                                      + at.getMaxIndex() + ", "
                                      + "wideNodes, nodeOffset)";
            runtimeOffsetUpdate = "nodeOffset += " + diffIndex2 + ";";
        } else {
            runtimeElementType = "Element_" + (arrayElementCount++);
            outputPortClass (runtimeElementType, elementType, direction);
            runtimeElementConstructor = runtimeElementType + "()";
            runtimeOffsetUpdate = "";
        }

        /* Array storage */

        out.println ("private " + runtimeElementType + "[] elements;");

        /* Constructor */

        out.println ("public " + name + " () {");
        out.println ("\telements = new " + runtimeElementType 
                   + "[" + diffIndex + "];");
        out.println ("\tfor (int i = 0; i < " + diffIndex + "; i++) {");
        out.println ("\t\telements[i] = new " + runtimeElementConstructor +";");
        out.println ("\t\t" + runtimeOffsetUpdate);
        out.println ("\t}");
        out.println ("}");

        /* get function */

        out.println ("public " + runtimeElementType +
                " get (final CspInteger index, String filename, int line, int column)");
        out.println ("\tthrows CspArrayBoundsException {");
        out.println ("\tint intIndex = index.intValue();");
        out.println ("\ttry {");
        out.println ("\t\treturn elements[intIndex - " + minIndex + "];");
        out.println ("\t} catch (ArrayIndexOutOfBoundsException e) {");
        out.println ("\t\tthrow (CspArrayBoundsException) new CspArrayBoundsException(index, " + minIndex + ", " + maxIndex + ", filename, line, column).initCause(e);");
        out.println ("\t}");
        out.println ("}");

        /* There is no assignment to channels at this time.  */

        out.println ("/* set() does not exist for this class */");
    }

    /**
     * Outputs body of a class definition for a structured port type.
     *
     * @param name Name of class to define
     * @param type Structured port type
     * @param direction Direction modifier for the port:
     *  <ul>
     *      <li> &gt; 0 is forward
     *      <li> = 0 is bidirectional
     *      <li> &lt; 0 is reverse
     *  </ul>
     **/
    private void outputStructuredPortClass (String name,
            com.avlsi.fast.ports.StructureType type,
            int direction) throws VisitorException {

        /* Declare members */

        for (Iterator i = type.iterator(); i.hasNext(); ) {
            PortDefinition p = (PortDefinition) i.next();
            outputPortDecl (p, direction);
        }

        /* Constructor */

        out.println ("public " + name + " () {");

        for (Iterator i = type.iterator(); i.hasNext(); ) {
            PortDefinition p = (PortDefinition) i.next();
            outputPortInit (p, direction);
        }

        out.println ("} /* end constructor for " + name + " */");
    }

    /**
     * Outputs a class definition for a port type.
     *
     * @param name Name of class to define
     * @param type Port type
     * @param direction Direction modifier for the port:
     *      &gt; 0 is forward
     *      = 0 is bidirectional
     *      &lt; 0 is reverse
     **/
    private void outputPortClass (String name, PortTypeInterface type, 
            int direction) throws VisitorException {

        out.println ("public class " + name + "{");

        if (type instanceof com.avlsi.fast.ports.ArrayType) {
            outputArrayPortClass (name, (com.avlsi.fast.ports.ArrayType) type,
                    direction);
        } else if (type instanceof com.avlsi.fast.ports.StructureType) {
            outputStructuredPortClass (name, (com.avlsi.fast.ports.StructureType) type, direction);
        } else {
            throw new VisitorException ("Can't output class for type: " + type);
        }

        out.println ("} /* End of class definition for " + name + " */");
    }

    /**
     * Outputs code to declare a port.  Use the method with a direction
     * parameter for sub-channels.
     * 
     * @param p Definition of a port
     **/
    private void outputPortDecl (PortDefinition p) 
            throws VisitorException {
        outputPortDecl (p, 1);     /* Forward direction modifier */
    }

    private PortTypeInterface getBaseType(PortTypeInterface t) {
        while (t instanceof com.avlsi.fast.ports.ArrayType) {
            t = ((com.avlsi.fast.ports.ArrayType) t).getArrayedType();
        }
        return t;
    }

    /**
     * Outputs code to declare a port.  Operates recursively on structured
     * and arrayed channels.
     * 
     * @param p Definition of a port
     * @param direction Direction modifier for the port:
     *  <ul>
     *      <li> &gt; 0 is forward
     *      <li> = 0 is bidirectional
     *      <li> &lt; 0 is reverse
     *  </ul>
     **/
    private void outputPortDecl (PortDefinition p, int direction)
            throws VisitorException {
        PortTypeInterface t = p.getType();
        String dirString = "";

        /* Combine the direction argument and the port direction.  */

        if (p.getDirection() == PortDefinition.FORWARD) {
            direction = direction * +1;
        } else if (p.getDirection() == PortDefinition.REVERSE) {
            direction = direction * -1;
        } else {
            throw new VisitorException ("Invalid direction.");
        }

        /* Set dirString based on the new direction.  */

        if (direction < 0) {
            /* IN, by convention */
            dirString = "In";
        } else if (direction > 0) {
            /* OUT, by convention */
            dirString = "Out";
        } else {
            throw new VisitorException ("Invalid direction.");
        }

        /* Handle channels and 1-dimensional arrays of channels as special
         * cases.  Handle other cases recursively.  */

        if (t instanceof ChannelType) {

            /* channel */
            out.println("public final Channel" 
                      + dirString + "put _" + p.getName() + ";");

        } else if (t instanceof com.avlsi.fast.ports.ArrayType
                && ((com.avlsi.fast.ports.ArrayType) t).getArrayedType()
                        instanceof ChannelType) {

            /* 1-dimensional array of channels */
            out.println ("public final CspChannel" + dirString + "Array1"
                       + " _" + p.getName() + ";");
            
        } else if (t instanceof com.avlsi.fast.ports.ArrayType
                && ((com.avlsi.fast.ports.ArrayType) t).getArrayedType()
                        instanceof NodeType) {
            out.println ("public final CspNodeArray1" + " _" + p.getName() +
                         ";");
        } else if (t instanceof NodeType) {
            out.println("public final CspNode _" + p.getName() + ";");
        } else {

            /* structured or array type which is not a special case */

            // DFT channels are handled specially
            if (isDftType(getBaseType(t)))
                return;

            final String type = getTypeString(p);
            outputPortClass (type, t, direction);
            out.println ("public final " + type + " _" +  p.getName() + ";");

        }
    }

    // DFT channels are handled specially
    private boolean isDftType(PortTypeInterface t) {
        return !disableDftHandler &&
               t instanceof com.avlsi.fast.ports.StructureType &&
               CellUtils.isDftChannel(((com.avlsi.fast.ports.StructureType) t).getTag());
    }

    private void declareChannelVars() throws VisitorException {
        debugWriter.println("\ndeclareChannelVars()");
        debugWriter.println("cell: " + cellInfo.getType());
        for (Iterator i = cellInfo.getPortDefinitions(); i.hasNext(); ) {
            PortDefinition p = (PortDefinition) i.next();
            debugWriter.println("in declareChannelVars: " + p);
            outputPortDecl (p);
        }
    }

    /**
     * Outputs code to initialize a port.  Use the method with a direction
     * parameter for sub-channels.  
     * 
     * @param p Definition of a port
     **/
    private void outputPortInit (PortDefinition p) 
            throws VisitorException {
        outputPortInit (p, 1);     /* Forward direction modifier */
    }

    /**
     * Outputs code to initialize a port.  Operates recursively on
     * structured channels.
     * 
     * @param p Definition of a port
     * @param direction Direction modifier for the port:
     *  <ul>
     *      <li> &gt; 0 is forward
     *      <li> = 0 is bidirectional
     *      <li> &lt; 0 is reverse
     *  </ul>
     **/
    private void outputPortInit (PortDefinition p, int direction)
            throws VisitorException {
        PortTypeInterface t = p.getType();
        String dirString = "";
        String dirStringLC = "";        /* dirString.toLowerCase() */

        /* Combine the direction argument and the port direction.  */

        if (p.getDirection() == PortDefinition.FORWARD) {
            direction = direction * +1;
        } else if (p.getDirection() == PortDefinition.REVERSE) {
            direction = direction * -1;
        } else {
            throw new VisitorException ("Invalid direction.");
        }

        /* Set dirString based on the new direction.  */

        if (direction < 0) {
            /* IN, by convention */
            dirString = "In";
        } else if (direction > 0) {
            /* OUT, by convention */
            dirString = "Out";
        } else {
            throw new VisitorException ("Invalid direction.");
        }
        dirStringLC = dirString.toLowerCase();

        if (t instanceof ChannelType) {

            /*
             * Initialize a channel
             */
            out.println ("this._" + p.getName() + " = " 
                       +  dirStringLC + "[" + dirStringLC + "putOffset++];");

        } else if (t instanceof com.avlsi.fast.ports.ArrayType
                && ((com.avlsi.fast.ports.ArrayType) t).getArrayedType()
                        instanceof ChannelType) {

            /* 
             * Special handling for 1-dimensional Arrays 
             */

            com.avlsi.fast.ports.ArrayType at = 
                (com.avlsi.fast.ports.ArrayType) t;
            ChannelType c = (ChannelType) at.getArrayedType();

            out.println ("this._" + p.getName() + " = "
                    + "new CspChannel" + dirString + "Array1("
                    +  at.getMinIndex() + ", "
                    +  at.getMaxIndex() + ", "
                    + "\"" + c.getTypeName() + "\"" + ", "
                    + dirStringLC + ", " 
                    + dirStringLC + "putOffset);");
            out.println (dirStringLC + "putOffset += " 
                       +  (at.getMaxIndex() - at.getMinIndex() + 1) + ";");

        } else if (t instanceof com.avlsi.fast.ports.ArrayType
                && ((com.avlsi.fast.ports.ArrayType) t).getArrayedType()
                        instanceof NodeType) {
            com.avlsi.fast.ports.ArrayType at = 
                (com.avlsi.fast.ports.ArrayType) t;
            NodeType c = (NodeType) at.getArrayedType();

            out.println ("this._" + p.getName() + " = "
                    + "new CspNodeArray1("
                    +  at.getMinIndex() + ", "
                    +  at.getMaxIndex() + ", "
                    + "wideNodes, nodeOffset);");
            out.println ("nodeOffset += " 
                       +  (at.getMaxIndex() - at.getMinIndex() + 1) + ";");

        } else if (t instanceof NodeType) {

            out.println ("this._" + p.getName() +
                         " = new CspNode(wideNodes[nodeOffset++]);");

        } else {

            /*
             * Initialize an Array or Structure which is not a special case
             */

            // DFT channels are handled specially
            if (isDftType(getBaseType(t)))
                return;

            final String type = getTypeString(p);
            out.println("this._" + p.getName() + " = "
                      + "this.new " + type + "();");
        }
    }

    private void assignChannelVars() 
            throws VisitorException {
        for (Iterator i = cellInfo.getPortDefinitions(); i.hasNext(); ) {
            PortDefinition p = (PortDefinition) i.next();
            outputPortInit (p);
        }
    }

    private void processFuncDecl(final FunctionDeclaration funcDecl,
                                 final SequentialStatement initStmt)
        throws VisitorException {
        // Functions used to be static.  I'm making them non-static,
        // we'll see if this causes a problem. --jmr 2002.12.09
        final VariableAnalyzer.Results funcResult;
        try {
            VariableAnalyzer va = new VariableAnalyzer(cellInfo);
            funcResult = va.getResults (funcDecl, initStmt, resolver);
        } catch (VariableAnalysisException x) {
            throw new VisitorException(x.getMessage(), x);
        }

        probFilter.process(funcResult.getErrors(strictVars));
        if (probFilter.hasError()) return;

        final String funcName =
            funcDecl.getName() + "_" + labels.getLabel(funcDecl);

        // emit the real function
        out.print("public ");
        if (funcDecl.getReturnType() != null)
            funcDecl.getReturnType().accept(this);
        else
            out.print("void");
        out.print(' ');
        processIdentifier(funcName + "_real");
        out.print('(');
        // handle formal parameters
        processDeclarationList(funcDecl.getFormals(), true);
        // now that channels can be used inside functions,
        // may throw InterruptedException -- aml 2002.12.12
        out.println(") throws InterruptedException {");
            if (funcDecl.getReturnType() != null) {
                // Declare variable for function return value.
                // By some miracle, you can have a variable with the same
                // name as a function and everything works as expected.
                final DeclaratorList drl =
                    new DeclaratorList();
                drl.addDeclarator(
                    new Declarator(
                        new IdentifierExpression(funcDecl.getName()),
                        funcDecl.getReturnType(),
                        null));

                final Declaration decl = new Declaration(drl);
                // REVIEW: Previously, Why could we visit Declarations?  
                // It's not needed...  But maybe cleaner?  Ask Aaron/Chris.
                // It made it harder to pass the formalP arg...
                processDeclaration(decl, false);
            }

            // initialize any output formal arguments
            final DeclaratorList drl = new DeclaratorList();
            (new DeclarationProcessor() {
                public void process(final Declarator d)
                throws VisitorException {
                    if (d.getDirection() == Declarator.OUT) {
                        drl.addDeclarator(d);
                    }
                }
            }).process(funcDecl.getFormals());
            processDeclaration(new Declaration(drl), false,
                               new DeclaratorProcessor() {
                                   public void emitModifier(Declarator dr)
                                   throws VisitorException { }
                                   public void emitType(Declarator dr)
                                   throws VisitorException { }
                                   public String getInitPreamble() {
                                       return ".setValue(";
                                   }
                                   public String getInitPostamble() {
                                       return ");";
                                   }
                               });

            final VariableAnalyzer.Results savedResult = analysisResults;
            // generate code for implied variable set
            processResults (funcResult);
            declareUndeclared (funcResult);

            // generate code for body
            funcP = true;
            funcDecl.getBodyStatement().accept(this);
            funcP = false;

            // copy-out inout finite precision integer parameters, in case they
            // weren't assigned; this is needed because of possible truncation,
            // see bug 20398
            (new DeclarationProcessor() {
                public void process(final Declarator d)
                throws VisitorException {
                    final Type varT = d.getTypeFragment();
                    if (d.getDirection() == Declarator.INOUT &&
                        varT instanceof IntegerType &&
                        ((IntegerType) varT).getDeclaredWidth() != null) {
                        d.getIdentifier().accept(JavaEmitter.this);
                        out.print(".setValue(");
                        d.getIdentifier().accept(JavaEmitter.this);
                        out.println(");");
                    }
                }
            }).process(funcDecl.getFormals());

            if (funcDecl.getReturnType() != null) {
                // Return the value.
                out.print("return ");
                processIdentifier(funcDecl.getName());
                out.println(';');
            }
            analysisResults = savedResult;
        out.println('}');

        // emit a wrapper around the function, to avoid having a problem with
        // "code too large for try block"
        out.print("public ");
        if (funcDecl.getReturnType() != null)
            funcDecl.getReturnType().accept(this);
        else
            out.print("void");
        out.print(' ');
        processIdentifier(funcName);
        out.print('(');
        processDeclarationList(funcDecl.getFormals(), true);
        out.println(") throws InterruptedException {");
            out.println("try {");
                out.println("enterFrame(\"" + funcDecl.getName() + "\");");
                if (funcDecl.getReturnType() != null)
                    out.print("return ");
                processIdentifier(funcName + "_real");
                out.print('(');
                processDeclarationList(funcDecl.getFormals(), true,
                        new DeclaratorProcessor() {
                            public void emitModifier(Declarator dr)
                            throws VisitorException { }
                            public void emitType(Declarator dr)
                            throws VisitorException { }
                        });
                out.println(");");
            out.println("} finally { leaveFrame(); } ");
        out.println('}');
    }

    private int getIntegerConstant(final ExpressionInterface e) 
        throws VisitorException {
        if (e instanceof IntegerExpression) {
            final IntegerExpression ie = (IntegerExpression) e;
            return Integer.parseInt(ie.getValue(), ie.getRadix());
        } else {
            throw new VisitorExceptionWithLocation(
                    "Compile time constant integer expression expected", e);
        }
    }

    private void processStructDecl(final StructureDeclaration decl)
        throws VisitorException {
        final String name = decl.getName() + "_" + labels.getLabel(decl);
        out.print("public class ");
        processIdentifier(name);
        out.println(" implements CspCloneableValue, CspStructure {");

        final DeclarationList list = decl.getDeclarations();
        processDeclarationList(
            list,
            false,
            new DeclaratorProcessor() {
                public void emitModifier(Declarator dr)
                throws VisitorException {
                    out.print("public ");
                }
                public String getTerminator() { return ";\n"; }
                public boolean outputInit() { return false; }
                public boolean generateLoggedType() { return false; }
            }
        );
        out.println();

        // default constructor
        out.print("public ");
        processIdentifier(name);
        out.println("() {");
        out.println("this(true);");
        out.println("}");

        out.print("public ");
        processIdentifier(name);
        out.println("(final boolean init) {");
        out.println("if (init) {");
        processDeclarationList(
            list,
            false,
            new DeclaratorProcessor() {
                public void emitModifier(Declarator dr)
                throws VisitorException { }
                public void emitType(Declarator dr)
                throws VisitorException { }
                public boolean generateLoggedType() { return false; }
            }
        );
        out.println("}");
        out.println("}");

        // member-valued constructor
        out.print("public ");
        processIdentifier(name);
        out.print("(");
        processDeclarationList(list, true);
        out.println(") {");
        out.println("this();");
        for (final Iterator i = list.getDeclarations(); i.hasNext(); ) {
            final Declaration d = (Declaration) i.next();
            for (Iterator j = d.getDeclaratorList().getDeclarators(); 
                    j.hasNext(); ) {
                final Declarator dr = (Declarator) j.next();
                out.print("this.");
                dr.getIdentifier().accept(this);
                out.print(".setValue(");
                dr.getIdentifier().accept(this);
                out.println(");");
            }
        }
        out.println("}");

        // copy constructor
        out.print("public ");
        processIdentifier(name);
        out.print("(");
        processIdentifier(name);
        out.println(" other) {");
        out.println("setValue(other);");
        out.println("}");

        // setValue (general)
        out.println("public void setValue(CspValue other) {");
        out.print("setValue((");
        processIdentifier(name);
        out.print(") ");
        out.println("other);");
        out.println("}");

        // setValue (value, modifier)
        out.println("public void setValue(CspValue value, " +
                    "Fold.BinaryFunction modifier) {");
        out.println("throw new UnsupportedOperationException();");
        out.println("}");
        
        // setValue
        out.print("public void setValue(");
        processIdentifier(name);
        out.println(" other) {");
        for (final Iterator i = list.getDeclarations(); i.hasNext(); ) {
            final Declaration d = (Declaration) i.next();
            for (Iterator j = d.getDeclaratorList().getDeclarators(); 
                    j.hasNext(); ) {
                final Declarator dr = (Declarator) j.next();
                out.print("this.");
                dr.getIdentifier().accept(this);
                out.print(".setValue(other.");
                dr.getIdentifier().accept(this);
                out.println(");");
            }
        }
        out.println("}");

        // clone
        out.println("public CspCloneableValue duplicate() {");
        processIdentifier(name);
        out.println(" result = new ");
        processIdentifier(name);
        out.println("(false);");
        for (final Iterator i = list.getDeclarations(); i.hasNext(); ) {
            final Declaration d = (Declaration) i.next();
            for (Iterator j = d.getDeclaratorList().getDeclarators(); 
                    j.hasNext(); ) {
                final Declarator dr = (Declarator) j.next();
                out.print("result.");
                dr.getIdentifier().accept(this);
                out.print(" = (");
                dr.getTypeFragment().accept(this);
                out.print(") this.");
                dr.getIdentifier().accept(this);
                out.println(".duplicate();");
            }
        }
        out.println("return result;");
        out.println("}");

        final LinkedList<Declarator> reversed = new LinkedList<Declarator>();
        (new DeclarationProcessor() {
            public void process(final Declarator d)
                throws VisitorException {
                reversed.addFirst(d);
            }
        }).process(list);

        // pack
        out.println("public int pack(CspInteger packed, int start) {");
        for (Declarator dr : reversed) {
            final Type t = dr.getTypeFragment();
            out.print("start = ((Packable) ");
            dr.getIdentifier().accept(this);
            out.println(").pack(packed, start);");
        }
        out.println("return start;");
        out.println("}");

        // unpack
        out.println("public int unpack(CspInteger packed, int start) {");
        for (Declarator dr : reversed) {
            final Type t = dr.getTypeFragment();
            out.print("start = ((Packable) ");
            dr.getIdentifier().accept(this);
            out.println(").unpack(packed, start);");
        }
        out.println("return start;");
        out.println("}");

        // end of structure definition
        out.println("}");

        // A logged version of the structure
        final String loggedName = "Logged" + name;
        out.print("public class ");
        processIdentifier(loggedName);
        out.print(" extends ");
        processIdentifier(name);
        out.println(" {");
        // default constructor
        out.print("public ");
        processIdentifier(loggedName);
        out.println("(final String varName) {");
        out.println("super(false);");
        processDeclarationList(
            list,
            false,
            new DeclaratorProcessor() {
                public void emitModifier(Declarator dr)
                throws VisitorException { }
                public void emitType(Declarator dr)
                throws VisitorException { }
                public boolean generateLoggedType() { return true; }
                public String getPrefix() { return "(varName + \".\")"; }
            }
        );
        out.println("}");

        out.print("public ");
        processIdentifier(loggedName);
        out.println("(final String varName, final String parsePos) {");
            out.println("this(varName);");
            out.println("topFrame().addVariable(varName, parsePos, this);");
        out.println("}");


        out.print("public ");
        processIdentifier(loggedName);
        out.print("(final String varName, ");
        processIdentifier(name);
        out.println(" val) {");
        out.println("this(varName);");
        out.println("setValue(val);");
        out.println("}");

        out.print("public ");
        processIdentifier(loggedName);
        out.print("(final String varName, final String parsePos, ");
        processIdentifier(name);
        out.println(" val) {");
            out.println("this(varName, val);");
            out.println("topFrame().addVariable(varName, parsePos, this);");
        out.println("}");

        out.println("}");
    }

    private void outputConstructor(final ArbiterVisitor arbiterVisitor)
            throws VisitorException {
        out.println("public " + className
                + "(final DeviceParameters deviceParams,"
                + " final ChannelInput[] in,"
                + " final ChannelOutput[] out,"
                + " final WideNode[] nodes");
        if (emitSnoopStatements)
            out.print(",\nfinal CspSnoopingInterface cspSnooper");
        out.println(") throws InterruptedException {");
            out.println("super(deviceParams.getName(), " +
                    "in, " +
                    "out, " +
                    "nodes, " +
                    "deviceParams.isOutputSuppressed(), " +
                    "deviceParams.getArbitrationMode());");
            out.println("_srandom(new CspInteger(" +
                            "new BigInteger(Long.toString(" +
                                "deviceParams.getSeed()))));");
            out.println("setDigitalTau(deviceParams.getDigitalTau());");
            assignChannelVars();
            arbiterVisitor.initLinkages(out);

            if(emitCoverageProbes)
                out.println("registerProbes();");
            if (emitSnoopStatements)
                out.println("this.cspSnooper = cspSnooper;");
            else if (synthesizable)
                out.println("this.cspSnooper = getProteusSnooper();");

        out.println("}");
        out.println();
    }

    public void visitCSPProgram(CSPProgram e) throws VisitorException {
        resolver.resolve(e);
        e = resolver.getCSPProgram();

        String filename = e.getParseRange().start.filename;

        // package
        if (packageName != null)
            out.println("package " + packageName + ";\n");

        // imports
        out.println("import java.math.BigInteger;");
        out.println("import java.util.LinkedList;");
        out.println("import java.util.Random;");
        out.println("import com.avlsi.csp.csp2java.runtime.*;");
        out.println("import com.avlsi.tools.cosim.DeviceParameters;");
        out.println("import com.avlsi.tools.dsim.DSim;");
        out.println("import com.avlsi.tools.sigscan.LoggedLogicArray;");
        out.println("import com.avlsi.tools.sigscan.LoggedLong;");
        out.println("import com.avlsi.tools.sigscan.LoggedString;");
        out.println("import com.avlsi.tools.tsim.AbstractDevice;");
        out.println("import com.avlsi.tools.tsim.Arbiter;");
        out.println("import com.avlsi.tools.tsim.Arbiter.Action;");
        out.println("import com.avlsi.tools.tsim.Arbiter.Alternative;");
        out.println("import com.avlsi.tools.tsim.Arbiter.Linkage;");
        out.println("import com.avlsi.tools.tsim.Arbiter.NullaryPredicate;");
        out.println("import com.avlsi.tools.tsim.Arbiter.Term;");
        out.println("import com.avlsi.tools.tsim.ChannelInput;");
        out.println("import com.avlsi.tools.tsim.ChannelOutput;");
        out.println("import com.avlsi.tools.tsim.EmptyWaitSetException;");
        out.println("import com.avlsi.tools.tsim.Wait;");
        out.println("import com.avlsi.tools.tsim.WaitFactory;");
        out.println("import com.avlsi.tools.tsim.Waitable;");
        out.println("import com.avlsi.tools.tsim.WideNode;");
        out.println("import com.avlsi.util.container.Pair;");
        out.println("import com.avlsi.fast.metaparameters.*;");
        if(emitCoverageProbes)
            out.println("import com.avlsi.csp.coverage.*;");
        out.println("import com.avlsi.csp.grammar.*;");
        out.println();

        // class definition
        out.println("public final class " + className
                + " extends CspRuntimeAbstractDevice {");
        out.println();

            // instance variables
            out.println("private int outputOffset = 0;");
            out.println("private int inputOffset = 0;");
            out.println("private int nodeOffset = 0;");
            if(emitCoverageProbes)
                out.println("private static int hitTableOffset;");
            if (emitSnoopStatements || synthesizable)
                out.println("private final CspSnoopingInterface cspSnooper;");
            declareChannelVars();

            final VariableAnalyzer.Results bodyResult;
            try {
                VariableAnalyzer va = new VariableAnalyzer(cellInfo);
                bodyResult = va.getResults (e, resolver);
            } catch (VariableAnalysisException x) {
                throw new VisitorException(x.getMessage(), x);
            }

            probFilter.process(bodyResult.getErrors(strictVars));
            if (!probFilter.hasError()) processResults (bodyResult);
            final SequentialStatement initStmt = e.getInitializerStatement();

            // find nodes used in linked arbitration
            ArbiterVisitor arbiterVisitor =
                new ArbiterVisitor(this, linkageLabel);
            arbiterVisitor.visitCSPProgram(e);
            arbiterVisitor.declareLinkages(out);

            // constructors
            outputConstructor(arbiterVisitor);

            out.println();

            // function declarations
            for (final Iterator i = e.getFunctionDeclarations();
                    i.hasNext(); ) {
                final FunctionDeclaration funcDecl =
                    (FunctionDeclaration) i.next();
                // XXX: This is incorrect, because each function should be
                // considered with respect to the initializer statements for
                // the cell in which it is defined.  But even so, the current
                // JavaEmitter would not handle this case correctly, since only
                // the initializers for the current function are emitted.
                processFuncDecl(funcDecl, initStmt);
            }

            if (probFilter.hasError())
                throw new VisitorException("Fatal errors found");

            // structure declaration 
            for (final Iterator i = e.getStructureIterator(); i.hasNext(); ) {
                final StructureDeclaration structDecl =
                    (StructureDeclaration) i.next();
                processStructDecl(structDecl);
            }

            final SequentialStatement reducedInit = RemoveScalars.process(
                    initStmt,
                    new UnaryPredicate() {
                        public boolean evaluate(Object o) {
                            final Declarator d = (Declarator) o;
                            return !identUsed.contains(d.getIdentifier()
                                                        .getIdentifier());
                        }
                    });
            if (reducedInit != null) {
                // static vars
                reducedInit.accept(new ConstantDeclarationEmitter
                    (packageName, className, cellInfo, out,
                     warningWriter, errorWriter, debugWriter,
                     emitCoverageProbes, disableDftHandler, analysisResults));
                out.println();

                // static initializers
                ConstantInitializerEmitter constEmitter =
                    new ConstantInitializerEmitter
                        (packageName, className, cellInfo, out,
                         warningWriter, errorWriter, debugWriter,
                         emitCoverageProbes, disableDftHandler,
                         analysisResults);
                reducedInit.accept(constEmitter);
                constEmitter.done();
                out.println("static {");
                out.println("  staticInitializer();");
                out.println("}");
                out.println();
            }

            // cleanup() method
            out.println("protected void cleanup() {");
            arbiterVisitor.destroyLinkages(out);
            out.println("}");
            out.println();

            // go() method
            out.println("public void go() throws InterruptedException {");
            if (emitSnoopStatements || synthesizable)
                out.println("cspSnooper.onStart();");
            out.println("try{");
                out.println("enterFrame(null);");
                declareUndeclared(bodyResult);
                bodyP = true;
                if (e.getStatement() != null) {
                    e.getStatement().accept(this);
                }
                // wait forever in case program wasn't an infinite loop
                out.println("waitForever();");
            out.println("}catch(NonDeterminismException e){");
            out.println("outerr(e.toString());");
            out.println("}catch(CspNode.UnstableException e){");
            out.println("printUnstableException();");
            out.println("}catch(CspArrayBoundsException e){");
            out.println("handleBoundsException(e, " +
                        (emitSnoopStatements ? "cspSnooper" : "null") +
                        ");");
            out.println("}finally{");
            out.println("leaveFrame();");
            out.println("}");

            if (emitSnoopStatements || synthesizable)
                out.println("cspSnooper.onEnd();");
            out.println("}");
            out.println();

            // generate resetNodes()
            final Pair p =
                (Pair) resolver.getResolvedFunctions()
                               .get(RefinementResolver.RESET_FUNCTION_CALL);
            if (p != null) {
                String name;
                final Object decl = p.getSecond();
                if (decl instanceof FunctionDeclaration) {
                    name = ((FunctionDeclaration) decl).getName() + "_" +
                           labels.getLabel(decl);
                } else {
                    throw new VisitorException(
                        "Invalid definition of special function resetNodes: " +
                        ((AbstractASTNode) e).getParseRange().fullString());
                }
                out.println("protected void resetNodes() throws InterruptedException {");
                processIdentifier(name);
                out.println("();");
                out.println("}");
            }

            if(emitCoverageProbes) {
                out.println("private static void registerProbes() {");
                // spit out a call to Monitor.global.register here, listing all
                // the probes that we emitted above
                out.println("hitTableOffset=Monitor.global.register(\""+cellInfo.getAbbreviatedType()+"\",");
                out.println("       new ProbeInfo[] {");
                for(int i=0; i<probes.size(); i++)
                    out.println(((ProbeInfo)probes.get(i)).constructorString()+",");
                out.println("       },");
                File sourceFile=new File(filename);
                long lastModified=sourceFile.lastModified();
                if(lastModified==0) {
                    System.err.println("processDeterministicBodies: source file "+filename+" not found");
                } // report error but use lastModified of 0 anway if file doesn't exist
                out.println("       "+lastModified+"L);");
                out.println("}");
                out.println();
            }

            String[] loopVars =
                (String[]) loopVarHash.values().toArray(new String[0]);
            if (loopVars.length > 0) {
                Arrays.sort(loopVars);
                out.println("private BigInteger " +
                            StringUtil.join(loopVars, ',') + ";");
            }

            out.println("public class LoggedCspInteger extends CspInteger {");
                out.println("private final LoggedLong logged;");
                out.println("public LoggedCspInteger(String varName) {");
                    out.println("this(varName, BigInteger.ZERO);");
                out.println("}");
                out.println("public LoggedCspInteger(String varName, BigInteger val) {");
                    out.println("super(val);");
                    out.println("CspRuntimeAbstractDevice parent = getSelf();");
                    out.println("logged = parent.getSigscan() == null ? null : new LoggedLong(getLoggingScope(), varName, parent.getSigscan(), parent.getDebugOpts(), true);");
                    out.println("if (logged != null) logged.set(val.longValue(), getTime());");
                out.println("}");
                out.println("public LoggedCspInteger(String varName, String parsePos, BigInteger val) {");
                    out.println("this(varName, val);");
                    out.println("topFrame().addVariable(varName, parsePos, this);");
                out.println("}");
                out.println("protected void setValue(final BigInteger val) {");
                    out.println("super.setValue(val);");
                    out.println("if (logged != null) logged.set(val.longValue(), getTime());");
                out.println("}");
            out.println("}");

            out.println("public LoggedCspArray.ElementConstructor getElementConstructor(final int width, final boolean isSigned) {");
                out.println("return new LoggedCspArray.ElementConstructor() {");
                    out.println("public CspValue create(CspRuntimeAbstractDevice parent, String varName) {");
                        out.println("return new LoggedFiniteCspInteger(varName, BigInteger.ZERO, width, isSigned);");
                    out.println("}");
                out.println("};");
            out.println("}");

            out.println("public class LoggedFiniteCspInteger extends FiniteCspInteger {");
                out.println("private final LoggedLogicArray logged;");
                out.println("public LoggedFiniteCspInteger(String varName, BigInteger val, int width, boolean isSigned) {");
                    out.println("super(val, width, isSigned);");
                    out.println("CspRuntimeAbstractDevice parent = getSelf();");
                    out.println("logged = parent.getSigscan() == null ? null : new LoggedLogicArray(getLoggingScope(), varName, 0, width - 1, parent.getSigscan(), parent.getDebugOpts(), true);");
                    out.println("if (logged != null) logged.set(getLogicArray(), getTime());");
                out.println("}");
                out.println("public LoggedFiniteCspInteger(String varName, String parsePos, BigInteger val, int width, boolean isSigned) {");
                    out.println("this(varName, val, width, isSigned);");
                    out.println("topFrame().addVariable(varName, parsePos, this);");
                out.println("}");
                out.println("protected void setValue(final BigInteger val) {");
                    out.println("super.setValue(val);");
                    out.println("if (logged != null) logged.set(getLogicArray(), getTime());");
                out.println("}");
            out.println("}");

            out.println("public class LoggedCspBoolean extends CspBoolean {");
                out.println("private final LoggedLong logged;");
                out.println("public LoggedCspBoolean(String varName) {");
                    out.println("this(varName, BigInteger.ZERO);");
                out.println("}");
                out.println("public LoggedCspBoolean(String varName, BigInteger val) {");
                    out.println("super(val);");
                    out.println("CspRuntimeAbstractDevice parent = getSelf();");
                    out.println("logged = parent.getSigscan() == null ? null : new LoggedLong(getLoggingScope(), varName, parent.getSigscan(), parent.getDebugOpts(), true);");
                    out.println("if (logged != null) logged.set(val.longValue(), getTime());");
                out.println("}");
                out.println("public LoggedCspBoolean(String varName, String parsePos, BigInteger val) {");
                    out.println("this(varName, val);");
                    out.println("topFrame().addVariable(varName, parsePos, this);");
                out.println("}");
                out.println("protected void setValue(final BigInteger val) {");
                    out.println("super.setValue(val);");
                    out.println("if (logged != null) logged.set(val.longValue(), getTime());");
                out.println("}");
            out.println("}");

            out.println("public class LoggedCspString extends CspString {");
                out.println("private final LoggedString logged;");
                out.println("public LoggedCspString(String varName) {");
                    out.println("this(varName, new CspString());");
                out.println("}");
                out.println("public LoggedCspString(String varName, CspString val) {");
                    out.println("super(val.toString());");
                    out.println("CspRuntimeAbstractDevice parent = getSelf();");
                    out.println("logged = parent.getSigscan() == null ? null : new LoggedString(getLoggingScope(), varName, parent.getSigscan(), parent.getDebugOpts(), true);");
                    out.println("if (logged != null) logged.set(val.toString(), getTime());");
                out.println("}");
                out.println("public LoggedCspString(String varName, String parsePos, CspString val) {");
                    out.println("this(varName, val);");
                    out.println("topFrame().addVariable(varName, parsePos, this);");
                out.println("}");
                out.println("public void setValue(final CspString val) {");
                    out.println("super.setValue(val);");
                    out.println("if (logged != null) logged.set(val.toString(), getTime());");
                out.println("}");
            out.println("}");

        out.println("}");
    }

    /**
     * Return a new autogenerated variable number.
     **/
    private int genVarNum() {
        return varNum++;
    }

    private void processUnary(final AbstractUnaryExpression expr,
            final String method) throws VisitorException {
        out.print('(');
        expr.getExpression().accept(this);
        out.print('.' + method + "())");
    }

    private void processBinary(final AbstractBinaryExpression expr,
            final String method)
        throws VisitorException {
        out.print('(');
        expr.getLeft().accept(this);
        out.print('.' + method + '(');
        expr.getRight().accept(this);
        out.print("))");
    }

    private void processReceiveOrPeek(final ExpressionInterface chanExpr, 
            final ExpressionInterface typeExpr,
            String which) 
        throws VisitorException {
        out.print("(new CspInteger(" + which + "(");
        chanExpr.accept(this);
        out.print(')');
        // receive() returns a Message, so we need to do getValue()
        // peek() returns a BigInteger
        if (which == "receive")
            out.print(".getValue()");
        out.print(')');


        if (analysisResults.getType(typeExpr) instanceof BooleanType) {
            // Handle receive into boolean
            out.print(".booleanValue()"
                    + " ? CspInteger.TRUE"
                    + " : CspInteger.FALSE)");
        } else 
            out.print(")");
    }

    private void processShift(final AbstractBinaryExpression expr,
            final String shiftMethod)
        throws VisitorException {
        // This is wrong if the value to shift by does not
        // fit in an int.  Hopefully that will never happen.
        // We could write a helper function to do this.  
        out.print('(');
        expr.getLeft().accept(this);
        out.print('.' + shiftMethod + '(');
        expr.getRight().accept(this);
        out.print(".intValue()))");
    }

    private void processIdentifier(String ident) {
        // Just prefix ident with _ for now, may use symbol table
        // later, or do something special for arrays.
        // XXX: channels must be looked up!, or aliases made
        // in constructor.
        out.print('_' + ident);
    }

    private void processGuardedStatement(AbstractGuardedStatement s,
            final boolean breakP)
        throws VisitorException {
        boolean firstP = true;
        for (final Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
            Object maybe_gc = i.next();

            if (!(maybe_gc instanceof GuardedCommand)) {
                AbstractASTNode blame = s;
                if (maybe_gc instanceof AbstractASTNode)
                    blame = (AbstractASTNode) maybe_gc;
                String[] clname =
                    StringUtil.split(maybe_gc.getClass().getName(), '.');
                throw new VisitorExceptionWithLocation("expected GuardedCommand, got " + clname[clname.length - 1] + "\n\t(are you missing a level of square brackets?)", blame);
            }

            final GuardedCommand gc = (GuardedCommand) maybe_gc;

            if (firstP)
                firstP = false;
            else
                out.print("else ");

            out.print("if (");
            gc.getGuard().accept(this);
            out.println(".booleanValue()) {");
                emitOneProbe((AbstractASTNode)gc.getCommand(),
                             "nondeterministic repetition statement alternative");
                gc.getCommand().accept(this);
                if (breakP)
                    out.println("break;");
            out.println("}");
        }

        // It would be nice if the else stuff could be put here too.
    }

    public void visitAddExpression(AddExpression e)
        throws VisitorException {
        if (analysisResults.getType(e) instanceof StringType) {
            final boolean lstr =
                analysisResults.getType(e.getLeft()) instanceof StringType;
            if (!lstr) out.print("new CspString(");
            e.getLeft().accept(this);
            if (!lstr) out.print(".toString())");

            out.print(".add(");

            final boolean rstr =
                analysisResults.getType(e.getRight()) instanceof StringType;
            if (!rstr) out.print("new CspString(");
            e.getRight().accept(this);
            if (!rstr) out.print(".toString())");

            out.print(')');
        } else {
            processBinary(e, "add");
        }
    }

    public void visitAndExpression(AndExpression e)
        throws VisitorException {
        processBinary(e, "and");
    }

    public void visitArrayAccessExpression(ArrayAccessExpression e)
        throws VisitorException {

        // This handles array accesses.  Assignment to array elements is
        // handled separately by the assignment statement.

        if (!isPortArray) {
            final Type elemType = analysisResults.getType(e);
            // cast to the correct type [1]; don't do anything if it is a
            // channel, since the arrays used to handle channels already return
            // the correct types
            assert elemType != null;
            final boolean nonChannelType =
                !(elemType instanceof com.avlsi.csp.ast.ChannelStructureType ||
                  elemType instanceof com.avlsi.csp.ast.ChannelType ||
                  elemType instanceof com.avlsi.csp.ast.NodeType);
            if (nonChannelType) {
                out.print("((");
                elemType.accept(this);
                out.print(")");
            } else {
                isPortArray = true;
            }
        }

        final boolean oldPortArray = isPortArray;
        e.getArrayExpression().accept(this);
        out.print(".get(");

        isPortArray = false;
        e.getIndexExpression().accept(this);
        ParsePosition pp = e.getIndexExpression().getParseRange().start;
        out.print(", \"" + pp.filename + "\", " +
                  pp.line + ", " + pp.column);
        out.print(")");

        // [1]
        if (!oldPortArray)
            out.print(")");
    }

    public void visitBitRangeExpression(BitRangeExpression e)
        throws VisitorException {
        // Calculate the extracted value.  Assigning a value to a bit range 
        // expression is handled separately by the assignment statement.

        e.getBitsExpression().accept(this);
        out.print(".extractBits(");
        if (e.getMinExpression() != null) {
            e.getMinExpression().accept(this);
            out.print(",");
        }
        e.getMaxExpression().accept(this);
        out.print(")");
    }

    public void visitConditionalAndExpression(ConditionalAndExpression expr)
        throws VisitorException {
        out.print("CspInteger.valueOf(");
        expr.getLeft().accept(this);
        out.print(".booleanValue() && ");
        expr.getRight().accept(this);
        out.print(".booleanValue())");
    }

    public void visitConditionalOrExpression(ConditionalOrExpression expr)
        throws VisitorException {
        out.print("CspInteger.valueOf(");
        expr.getLeft().accept(this);
        out.print(".booleanValue() || ");
        expr.getRight().accept(this);
        out.print(".booleanValue())");
    }

    private void processAssert(FunctionCallExpression e)
        throws VisitorException {
        final Iterator i = e.getActuals();
        final ExpressionInterface guard = (ExpressionInterface) i.next();
        final ExpressionInterface message =
            i.hasNext() ? (ExpressionInterface) i.next() : null;
        out.print("handleAssert(whereAmI, ");
        guard.accept(this);
        out.print(", ");
        if (message == null) {
            out.print("null");
        } else {
            message.accept(this);
        }
        out.println(");");
    }

    private void processPack(FunctionCallExpression e)
        throws VisitorException {
        final Iterator i = e.getActuals();
        final ExpressionInterface structExpr = (ExpressionInterface) i.next();
        out.print("pack(");
        structExpr.accept(this);
        out.print(")");
    }

    private void processUnpack(FunctionCallExpression e)
        throws VisitorException {
        final Iterator i = e.getActuals();
        final ExpressionInterface structExpr = (ExpressionInterface) i.next();
        final ExpressionInterface packed = (ExpressionInterface) i.next();
        out.print("unpack(");
        structExpr.accept(this);
        out.print(", ");
        packed.accept(this);
        out.println(")");
    }

    private void processWidth(final ExpressionInterface e) 
        throws VisitorException {
        final BigInteger bi = CspUtils.getIntegerConstant(e);
        if (bi == null) {
            out.print("(");
            e.accept(this);
            out.print(").intValue()");
        } else {
            // TODO: throw error for width > Integer.MAX_VALUE
            out.print(bi.intValue());
        }
    }

    public void visitFunctionCallExpression(FunctionCallExpression e)
        throws VisitorException {
        // processing: func(x, y, z)

        // func
        boolean isConstructor = false;
        final Pair p = (Pair) resolver.getResolvedFunctions().get(e);
        final ArrayList<Declarator> args;
        String name;
        if (p == null) {
            final ExpressionInterface func = e.getFunctionExpression();
            name = ((IdentifierExpression) func).getIdentifier();
            args = null;
            if (name.equals("assert")) {
                processAssert(e);
                return;
            } else if (name.equals("pack")) {
                processPack(e);
                return;
            } else if (name.equals("unpack")) {
                processUnpack(e);
                return;
            }
        } else {
            final Object decl = p.getSecond();
            if (decl instanceof FunctionDeclaration) {
                final FunctionDeclaration fdecl = (FunctionDeclaration) decl;
                args = new ArrayList<Declarator>();
                name = fdecl.getName();
                (new DeclarationProcessor() {
                    public void process(final Declarator d)
                    throws VisitorException {
                        args.add(d);
                    }
                }).process(fdecl.getFormals());
            } else if (decl instanceof StructureDeclaration) {
                isConstructor = true;
                args = null;
                name = ((StructureDeclaration) decl).getName();
            } else {
                throw new VisitorExceptionWithLocation("Call to unknown function", e);
            }
            if (!RefinementResolver.isBuiltin(decl))
                name = name + "_" + labels.getLabel(decl);
        }
        if (isConstructor) out.print("(new ");
        processIdentifier(name);

        // "("
        out.print('(');

        // actuals: x, y, z
        int count = 0;
        for (final Iterator i = e.getActuals(); i.hasNext(); ++count) {
            final ExpressionInterface actual = (ExpressionInterface) i.next();

            // ","
            if (count > 0) out.print(", ");
            final Declarator arg = args == null ? null : args.get(count);
            final boolean copy =
                args == null ? false : arg.getDirection() == Declarator.IN;

            // actual
            if (arg != null && arg.getTypeFragment() instanceof IntegerType) {
                final IntegerType ty = (IntegerType) arg.getTypeFragment();
                if (copy) {
                    out.print("RuntimeUtils.copyInt(");
                    if (ty.getDeclaredWidth() != null) {
                        processWidth(ty.getDeclaredWidth());
                        out.print(", " + ty.isSigned() + ", ");
                    }
                    actual.accept(this);
                    out.print(")");
                } else {
                    final boolean bit = actual instanceof BitRangeExpression;
                    out.print("(new ShadowCspInteger");
                    if (bit) out.print(".BitRange");
                    else out.print(".Simple");
                    out.print("(");
                    if (ty.getDeclaredWidth() != null) {
                        processWidth(ty.getDeclaredWidth());
                        out.print(", " + ty.isSigned() + ", ");
                    }
                    if (bit) {
                        final BitRangeExpression bre =
                            (BitRangeExpression) actual;
                        bre.getMinExpression().accept(this);
                        out.print(", ");
                        bre.getMaxExpression().accept(this);
                        out.print(", ");
                        bre.getBitsExpression().accept(this);
                    } else {
                        actual.accept(this);
                    }
                    out.print("))");
                }
            } else if (arg != null &&
                       arg.getTypeFragment() instanceof ArrayType &&
                       CspUtils.getBaseType(arg.getTypeFragment())
                           instanceof IntegerType) {
                final IntegerType ty =
                    (IntegerType) CspUtils.getBaseType(arg.getTypeFragment());
                out.print("RuntimeUtils." + (copy ? "copy" : "shadow") + "IntArray(");
                if (ty.getDeclaredWidth() != null) {
                    processWidth(ty.getDeclaredWidth());
                    out.print(", " + ty.isSigned() + ", ");
                }
                actual.accept(this);
                out.print(")");
            } else {
                if (copy) {
                    final Type t = analysisResults.getType(actual);
                    out.print("((");
                    t.accept(this);
                    out.print(") (");
                }
                actual.accept(this);
                if (copy) out.print(").duplicate())");
            }
        }

        // ")"
        out.print(')');
        if (isConstructor) out.print(")");
    }

    public void visitDivideExpression(DivideExpression e)
        throws VisitorException {
        // may want to handle divide specially to get
        // different rounding, or catch divide by 0 exception
        processBinary(e, "divide");
    }

    public void visitExponentialExpression(ExponentialExpression e)
        throws VisitorException {
        // This is wrong if the value to exponentiate by does not
        // fit in an int.  Hopefully that will never happen.
        // We could write a helper function to do this.  
        out.print('(');
        e.getLeft().accept(this);
        out.print(".pow(");
        e.getRight().accept(this);
        out.print(".intValue()))");
    }

    private void processCompare(AbstractBinaryExpression expr,
            final String compare) throws VisitorException {
        out.print('(');
        processBinary(expr, "compareTo");
        out.print(compare + " 0" +
                " ? CspInteger.TRUE" +
                " : CspInteger.FALSE)");
    }

    public void visitEqualityExpression(EqualityExpression e)
        throws VisitorException {
        // could be optimized to use .equals() instead of compareTo
        processCompare(e, "==");
    }

    public void visitGreaterEqualExpression(GreaterEqualExpression e)
        throws VisitorException {
        processCompare(e, ">=");
    }

    public void visitGreaterThanExpression(GreaterThanExpression e)
        throws VisitorException {
        processCompare(e, ">");
    }

    public void visitInequalityExpression(InequalityExpression e)
        throws VisitorException {
        // could be optimized to use .equals() instead of compareTo
        processCompare(e, "!=");
    }

    public void visitLessEqualExpression(LessEqualExpression e)
        throws VisitorException {
        processCompare(e, "<=");
    }

    public void visitLessThanExpression(LessThanExpression e)
        throws VisitorException {
        processCompare(e, "<");
    }

    public void visitIntegerExpression(IntegerExpression e)
        throws VisitorException {
        String value = e.getValue();
        int radix = e.getRadix();
        try {
            /* Reduce code size by just using a bipush when possible,
             * rather than putting another string in the constant table.
             * (bug 3896) */
            byte b = Byte.parseByte(value, radix);
            out.print("new CspInteger((byte)" + b + ')');
        } catch (NumberFormatException nf) { // Bigger than a byte
            if (radix == 10) { // omit radix if possible
                out.print("new CspInteger(new BigInteger(\"" + value + "\"))");
            } else {
                out.print("new CspInteger(new BigInteger(\"" + value
                          + "\", " + radix + "))");
            }
        }
    }

    public void visitLeftShiftExpression(LeftShiftExpression e)
        throws VisitorException {
        processShift(e, "shiftLeft");
    }

    public void visitRightShiftExpression(RightShiftExpression e)
        throws VisitorException {
        processShift(e, "shiftRight");
    }

    public void visitIdentifierExpression(IdentifierExpression e) {
        processIdentifier(e.getIdentifier());
    }

    public void visitLoopExpression(LoopExpression e)
        throws VisitorException {

        final String[] units = new String[] {
            "BigInteger.ZERO.not()",    // AND
            "BigInteger.ZERO",          // OR
            "BigInteger.ONE",           // TIMES
            "BigInteger.ZERO",          // PLUS
            "BigInteger.ZERO" };        // XOR
        final String[] functions = new String[] {
            "Fold.AND_FUNCTION",        // AND
            "Fold.OR_FUNCTION",         // OR
            "Fold.MULTIPLY_FUNCTION",   // TIMES
            "Fold.ADD_FUNCTION",        // PLUS
            "Fold.XOR_FUNCTION" };      // XOR

        final boolean stringType =
            analysisResults.getType(e) instanceof StringType;
        out.print("(");
        if (stringType) out.print("(CspString) ");
        else out.print("(CspInteger) ");
        out.println("new Fold() {");
            out.print("public CspValue evaluate(final CspInteger ");
            processIdentifier(e.getIndexVar());
            out.println(") throws InterruptedException {");
                out.print("return ");
                e.getExpression().accept(this);
                out.println(';');
            out.println('}');
        final int sep = e.getSeparator();

        // should have caught other invalid operations on strings in
        // VariableAnalyzer
        assert !stringType || sep == LoopExpression.PLUS;

        out.print("}.fold(" +
                (stringType ? "new CspString()"
                            : "new CspInteger(" + units[sep] + ")") +
                ", " + functions[sep] + ", ");
        e.getRange().getMinExpression().accept(this);
        out.print(", ");
        e.getRange().getMaxExpression().accept(this);
        out.print("))");
    }

    public void visitMultiplyExpression(MultiplyExpression e)
        throws VisitorException {
        processBinary(e, "multiply");
    }

    public void visitNegateExpression(NegateExpression e)
        throws VisitorException {
        processUnary(e, "negate");
    }

    public void visitNotExpression(NotExpression e)
        throws VisitorException {
        processUnary(e, "not");
    }

    public void visitOrExpression(OrExpression e)
        throws VisitorException {
        processBinary(e, "or");
    }

    public void visitXorExpression(XorExpression e)
        throws VisitorException {
        processBinary(e, "xor");
    }

    public void visitPeekExpression(PeekExpression e)
        throws VisitorException {
        processReceiveOrPeek(e.getChannelExpression(), e, "peek");
    }

    public void visitProbeExpression(ProbeExpression e)
        throws VisitorException {
        out.print("(probe(");
        e.getChannelExpression().accept(this);
        out.print(") ? CspInteger.TRUE" +
                   " : CspInteger.FALSE)");
    }

    public void visitReceiveExpression(ReceiveExpression e)
        throws VisitorException {
        processReceiveOrPeek(e.getChannelExpression(), e, "receive");
    }

    public void visitRemainderExpression(RemainderExpression e)
        throws VisitorException {
        // may want to handle divide specially to get
        // different rounding, or catch divide by 0 exception
        processBinary(e, "remainder");
    }

    public void visitStringExpression(StringExpression e)
        throws VisitorException {
        out.print("new CspString(\"" +
                  StringUtil.quoteASCIIString(e.getValue(), ESCAPE_MAP) +
                  "\")");
    }

    public void visitSubtractExpression(SubtractExpression e)
        throws VisitorException {
        processBinary(e, "subtract");
    }

    public void visitStructureAccessExpression(StructureAccessExpression e)
        throws VisitorException {
        e.getStructureExpression().accept(this);
        out.print("._");
        out.print(e.getFieldName());
    }

    public void visitMemberAccessExpression(MemberAccessExpression e)
        throws VisitorException {
        e.getStructureExpression().accept(this);
        out.print(".");
        processIdentifier(e.getMemberName());
    }

    public void visitIncDecStatement(IncDecStatement s)
        throws VisitorException {
        s.getAssignmentStatement().accept(this);
    }

    public void visitAssignmentStatement(AssignmentStatement s)
        throws VisitorException {
        // This assumes that the lhs expression emitter always emits
        // an lvalue.  This may not be true for arrays, in which
        // case something will have to be done for get() / set().
        final ExpressionInterface lhs = s.getLeftHandSide();
        final ExpressionInterface rhs = s.getRightHandSide();

        if (lhs instanceof BitRangeExpression){

            // We are assigning to a bit field.  Make a transformation so
            // that no bit field is involved.

            BitRangeExpression bre = (BitRangeExpression) lhs;

            bre.getBitsExpression().accept(this);
            out.print(".assignBits(");
            if (bre.getMinExpression() != null) {
                bre.getMinExpression().accept(this);
                out.print(",");
            }
            bre.getMaxExpression().accept(this);
            out.print(",");
            rhs.accept(this);
            if (s.getKind() != AssignmentStatement.EQUAL) {
                out.print(", Fold." + s.getKindString().toUpperCase() +
                          "_FUNCTION");
            }
            out.println(");");
        } else {

            // We are not assigning to a bit range

            lhs.accept(this);
            final boolean str =
                s.getKind() == AssignmentStatement.ADD &&
                (analysisResults.getType(lhs) instanceof StringType) &&
                !(analysisResults.getType(rhs) instanceof StringType);
            out.print(".setValue(");

            if (str) out.print("new CspString(");
            rhs.accept(this);
            if (str) out.print(".toString())");

            if (s.getKind() != AssignmentStatement.EQUAL) {
                out.print(", Fold." + s.getKindString().toUpperCase() +
                          "_FUNCTION");
            }
            out.println(");");
        }
    }

    public void visitDeterministicRepetitionStatement(
            DeterministicRepetitionStatement s)
        throws VisitorException {

        final String label = "label" + genVarNum();
        out.println(label + ':');

        out.println("for (;;) {");
            final String trueIdx = "trueIdx" + genVarNum();
            out.println("int " + trueIdx + " = -1;");

            // evaluate guards
            processDeterministicGuards(s, trueIdx);

            if ((emitSnoopStatements || synthesizable) && bodyP && !foundLoop) {
                foundLoop = true;
                out.println("cspSnooper.onOutermostLoopStart();");
            }

            // execute body
            out.println("switch (" + trueIdx + ") {");
                // a case that never occurs but prevents the Java compiler from
                // concluding later code as unreacahble
                out.println("case -2:");
                out.println("break " + label + ";");

                // handle else, if any
                out.println("case -1:");
                    if (s.getElseStatement() == null) {
                        out.println("break " + label + ";");
                    } else {
                        emitOneProbe((AbstractASTNode)s.getElseStatement(),
                                     "deterministic repetition statement else clause");
                        s.getElseStatement().accept(this);
                        out.println("break;");
                    }

                // handle bodies
                processDeterministicBodies(s, null);
            out.println('}');
            if (!emitSnoopStatements) {
                // the simulation could be interrupted at yield, so we need to
                // reset the annotate position to avoid confusing the user
                annotatePosition(s);
                out.println("yield();");
            }

        out.println('}');
    }

    private int recurseDeterministicGuards(Iterator guards,
                                           AbstractASTNodeInterface where,
                                           String trueIdx, int idx)
        throws VisitorException {
        // evaluate guards
        for (final Iterator i = guards; i.hasNext(); ) {
            final GuardedCommandInterface gci =
                (GuardedCommandInterface) i.next();

            if (gci instanceof LoopGuard) {
                final LoopGuard lg = (LoopGuard) gci;
                final String loopVar = "loopVar" + genVarNum();
                final String indexVar = lg.getIndexVar();
                final Range range = lg.getRange();
                loopVarHash.put(lg, loopVar);
                out.println("if (" + trueIdx + " == -1) " +
                            loopVar + " = null;");

                out.print("for (final CspInteger ");
                processIdentifier(indexVar);
                out.print(" = new CspInteger(");
                range.getMinExpression().accept(this);
                out.println("); ");
                processIdentifier(indexVar);
                out.print(".compareTo(");
                range.getMaxExpression().accept(this);
                out.println(") <= 0; ");
                processIdentifier(indexVar);
                out.print(".setValue(");
                processIdentifier(indexVar);
                out.println(".add(CspInteger.ONE))) {"); // [2]

                idx = recurseDeterministicGuards(lg.getGuards().iterator(),
                                                 where, trueIdx, idx);

                out.print("if (" + loopVar + " == null && " +
                          trueIdx + " != -1) " + loopVar + " = ");
                processIdentifier(indexVar);
                out.println(".toBigInteger();");
                out.println('}');       // matches [2]
            } else {
                final GuardedCommand gc = (GuardedCommand) gci;

                out.print("if (");
                gc.getGuard().accept(this);
                out.println(".booleanValue()) {");
                // first guard doesn't need multiple true check
                if (idx == 0) {
                    out.println(trueIdx + " = " + idx + ';');
                } else {
                    // Don't include idx in string keep from creating
                    // many strings in class.
                    out.println("if (" + trueIdx + " == -1)");
                    out.println(trueIdx + " = " + idx + ';');
                    out.println("else {");
                    out.println("throw new NonDeterminismException(\"" +
                                "Error -- Multiple guards \" + " + trueIdx +
                                " + \" and \" + " + idx +
                                " + \" true for deterministic repetition" +
                                " or selection at \" + \"" +
                                where.getParseRange().start.filename +
                                ':' + where.getParseRange().toString()+
                                "\");");
                    out.println("}");
                }
                out.println('}');
                ++idx;
            }
        }

        return idx;
    }

    /**
     * Process the guards for a deterministic repetition or selection
     * statement.
     *
     * @param s  DeterministicRepetitionStatement or
     *   DeterministicSelectionStatement whose guards are to be evaluated
     * @param trueIdx  variable name to store index of true variable
     **/
    private void processDeterministicGuards(final AbstractGuardedStatement s,
            final String trueIdx) throws VisitorException {
        recurseDeterministicGuards(s.getGuardedCommands(), s, trueIdx, 0);
    }

    protected void emitOneProbe(AbstractASTNode node,
                                String type) {
        if(emitCoverageProbes) {
            ParseRange pr=node.getParseRange();
            out.println("/* coverage probe (line "+
                        pr.start.line+", column "+pr.start.column+
                        " to line "+pr.end.line+", column "+pr.end.column+") */");
            out.println("Monitor.global.setHit(hitTableOffset+"+probeCount+");");
            probes.add(new ProbeInfo(pr, type,
                                     cellInfo.getAbbreviatedType()));
            probeCount++;
        }
    }
                                
    private int recurseDeterministicBodies(Iterator guards, String breakLabel,
                                           int idx, NullaryAction[] vardecl)
        throws VisitorException {
        for (final Iterator i = guards; i.hasNext(); ) {
            final GuardedCommandInterface gci =
                (GuardedCommandInterface) i.next();

            if (gci instanceof LoopGuard) {
                final LoopGuard lg = (LoopGuard) gci;
                final String indexVar = lg.getIndexVar();
                final String loopVar = (String) loopVarHash.get(lg);
                final NullaryAction[] newVardecl =
                    new NullaryAction[vardecl.length + 1];
                System.arraycopy(vardecl, 0, newVardecl, 0, vardecl.length);
                newVardecl[vardecl.length] = new NullaryAction() {
                        public void execute() {
                            out.print("final CspInteger ");
                            processIdentifier(indexVar);
                            out.println(" = new CspInteger(" + loopVar + ");");
                        }
                    };
                idx = recurseDeterministicBodies(lg.getGuards().iterator(),
                                                 breakLabel, idx, newVardecl);
            } else {
                final GuardedCommand gc = (GuardedCommand) gci;

                out.println("case " + idx + ':');
                out.println("{"); // [1]
                for (int j = 0; j < vardecl.length; j++)
                    vardecl[j].execute();
                emitOneProbe((AbstractASTNode)gc.getCommand(),
                             "repetition or selection statement alternative");
                gc.getCommand().accept(this);
                if (breakLabel != null)
                    out.println("break " + breakLabel + ';');
                else
                    out.println("break;");
                out.println("}"); // matches [1]
                ++idx;
            }
        }

        return idx;
    }

    /**
     * Process the bodies for a deterministic repetition or selection
     * statement.
     *
     * @param s  DeterministicRepetitionStatement or
     *   DeterministicSelectionStatement whose statements are to be emitted
     **/
    private void processDeterministicBodies(
            final AbstractGuardedStatement s,
            final String breakLabel) throws VisitorException {
        recurseDeterministicBodies(s.getGuardedCommands(), breakLabel, 0,
                                   new NullaryAction[0]);
    }

    public void visitDeterministicSelectionStatement(
            DeterministicSelectionStatement s)
        throws VisitorException {
        // TODO: 
        // Check for probes in the guard statements.  If there are
        // probes, we must generate a Wait inside a for loop.
        // If not, ifs are fine.

        // Whether we should emit wait statements
        // Always emit wait statements for now, before we resolve the question
        // on what semantics functions should have.  See bug 7111.
        final boolean waitP = true; // bodyP; // why is this bodyP? --frederik

        out.println('{');

        final String waitVar;
        final String waitableVar;
        final String pairVar;
        final String label;
        if (waitP) {
            final int varNum = genVarNum();
            waitVar = "w" + varNum;
            waitableVar = "wa" + varNum;
            pairVar = "p" + varNum;
            out.println("Wait " + waitVar + " = null;");

            label = "label" + genVarNum();
            out.println(label + ':');
            out.println("for (;;) {");
        } else {
            waitVar = null;
            waitableVar = null;
            pairVar = null;
            label = null;
        }

            final String trueIdx = "trueIdx" + genVarNum();
            out.println("int " + trueIdx + " = -1;");

            // evaluate guards
            processDeterministicGuards(s, trueIdx);

            // execute body
            out.println("switch (" + trueIdx + ") {");
                // handle else, if any
                out.println("case -1:");
                    if (waitP) {
                        if (s.getElseStatement() == null) {
                            if (emitSnoopStatements || synthesizable) {
                                out.println(
                                    "cspSnooper.onDeadlock(\"No guards true " +
                                    "in deterministic selection\", whereAmI);");
                            }
                            // Probe looks at the time, so we must update
                            // the time even for deterministic selection
                            // statements, otherwise all probes could
                            // return false and we would get empty
                            // wait set exceptions.
                            out.println("if (" + waitVar + " == null)");
                                out.println(waitVar +
                                        " = WaitFactory.newWait(in, out," +
                                        " getNodesWithDifferentValue(true)," +
                                        " getNodesWithDifferentValue(false));");
                            out.println("final Pair/*<Waitable,Long>*/ " +
                                        pairVar + " = select2(" +
                                        waitVar + ");");
                            out.println("updateTime(((Long)" + pairVar +
                                        ".getSecond()).longValue());");
                            out.println("final Waitable " + waitableVar +
                                        " = (Waitable) " + pairVar +
                                        ".getFirst();");
                            out.println("Arbiter.removeFromWait(" + waitVar +
                                        ", " + waitableVar + ");");
                            out.println("break;");
                        } else {
                            emitOneProbe((AbstractASTNode)s.getElseStatement(),
                                         "deterministic selection statement else clause");
                            s.getElseStatement().accept(this);
                            out.println("break " + label + ';');
                        }
                    } else {
                        if (s.getElseStatement() != null) {
                            emitOneProbe((AbstractASTNode)s.getElseStatement(),
                                         "deterministic selection statement else clause");
                            s.getElseStatement().accept(this);
                            out.println("break;");
                        } else {
                            // If we are not waiting, and no alternatives are
                            // true, then they never will be true, so flag an
                            // error.
                            out.println("throw new RuntimeException(\"" +
                                    "No true guards in unwaited " +
                                    "selection.\");");
                        }
                    }

                // handle bodies
                processDeterministicBodies(s, label);
            out.println('}');


        if (waitP) {
            out.println('}');
            // let the wait be garbage collected
            out.println(waitVar + " = null;");
        }

        out.println('}');
    }

    public void visitExpressionStatement(ExpressionStatement s)
        throws VisitorException {
        s.getExpression().accept(this);
        out.println(';');
    }

    public void visitLoopStatement(LoopStatement s) throws VisitorException {
        // Treat parallel as sequential for now.
        if (s.getSeparator() == LoopStatement.PARALLEL) {
            warningWriter.println("Warning: Sequentializing parallel loop.");
            out.println("/* Warning: should have been a parallel loop. */");
        }

        final String loopMax = "loopMax" + genVarNum();
        out.print("for (final CspInteger ");
        processIdentifier(s.getIndexVar());
        out.print(" = new CspInteger(");
        s.getRange().getMinExpression().accept(this);
        out.print("), " + loopMax + " = ");
        s.getRange().getMaxExpression().accept(this);
        out.println("; ");
        processIdentifier(s.getIndexVar());
        out.println(".compareTo(" + loopMax + ") <= 0; ");
        processIdentifier(s.getIndexVar());
        out.print(".setValue(");
        processIdentifier(s.getIndexVar());
        out.println(".add(CspInteger.ONE))) {");
            s.getStatement().accept(this);
        out.println('}');
    }

    public void visitNonDeterministicRepetitionStatement(
            NonDeterministicRepetitionStatement s)
        throws VisitorException {
        // Be unfair in choice for now
        out.println("for (;;) {");
            processGuardedStatement(s, false);

            out.println("else {");
                if (s.getElseStatement() == null) {
                    out.println("break;");
                } else {
                    emitOneProbe((AbstractASTNode)s.getElseStatement(),
                                 "nondeterministic repetition else statement");
                    s.getElseStatement().accept(this);
                }
            out.println('}');
        out.println('}');
    }

    public void visitNonDeterministicSelectionStatement(
            NonDeterministicSelectionStatement s)
        throws VisitorException {
        final String alternatives = "alternatives" + genVarNum();
        out.println("LinkedList " + alternatives + " = new LinkedList();");

        // use arbiter maker?

            processAlternatives(s.getGuardedCommands(), alternatives);
        if (emitSnoopStatements || synthesizable) {
            out.println("checkAlternative(" + alternatives + ", cspSnooper);");
        }
        out.println("arbitrate(new Arbiter((Alternative[])" + alternatives +
                    ".toArray(new Alternative[0]),");
            if (s.getNeutralState() != null)
                out.println("linkage" +
                            linkageLabel.getLabel(s.getNeutralState()) + ",");
            else
                out.println("(Linkage) null,");
            // If @(linkage) was not specified, make the arbiter non-linked
            // We only need to check one because the grammar ensures
            // that either all or none of the linkage specifiers are there.
            if (s.getNeutralState() == null)
                out.print("Arbiter.NON_LINKED, ");
            else
                out.print("arbitrationMode, ");
            out.print("in, out, ");
            if (s.getNeutralState() == null) {
                out.print("getNodesWithDifferentValue(true), " +
                          "getNodesWithDifferentValue(false), ");
            }
            out.println("arbiterRandom, " + className + ".this)," +
                "\"" + getLocation(s) + "\");");
    }

    private void processAlternatives(Iterator guards, String alternatives)
            throws VisitorException {
        // stuff to construct arbiter
        for (final Iterator i = guards; i.hasNext(); ) {
            final GuardedCommandInterface gci =
                (GuardedCommandInterface) i.next();

            if (gci instanceof LoopGuard) {
                final LoopGuard lg = (LoopGuard) gci;
                final String loopVar = "loopVar" + genVarNum();
                final String indexVar = lg.getIndexVar();
                final Range range = lg.getRange();

                out.print("for (final CspInteger " + loopVar);
                out.print(" = new CspInteger(");
                range.getMinExpression().accept(this);
                out.println("); ");
                out.print(loopVar + ".compareTo(");
                range.getMaxExpression().accept(this);
                out.println(") <= 0; ");
                out.print(loopVar + ".setValue(" + loopVar);
                out.println(".add(CspInteger.ONE))) {"); // [1]
                
                out.print("final CspInteger ");
                processIdentifier(indexVar);
                out.print(" = new CspInteger(" + loopVar +
                          ".toBigInteger());");
                processAlternatives(lg.getGuards().iterator(), alternatives);
                out.println("}");       // matches [1]
            } else {
                final GuardedCommand gc = (GuardedCommand) gci;

                out.println(alternatives + ".add(new Alternative(");
                // guard
                out.println("new NullaryPredicate() {");
                out.println("public boolean evaluate()" +
                            " throws InterruptedException {");
                out.print("return ");
                gc.getGuard().accept(this);
                out.println(".booleanValue();");
                out.println("}");
                out.println("}, ");
                // linkage terms are handled by Arbiter.Linkage
                // action
                out.println("new Action() {");
                out.println("public void execute() " +
                            "throws InterruptedException {");
                emitOneProbe((AbstractASTNode)gc.getCommand(),
                             "nondeterministic selection "+
                             "statement alternative");
                gc.getCommand().accept(this);
                out.println("}");
                out.println("}");
                out.println("));");
            }
        }
    }

    public void visitLinkageLoopTerm(final LinkageLoopTerm term)
        throws VisitorException {
        throw new VisitorException("should never be called");
    }

    public void visitLinkageExpressionTerm(final LinkageExpressionTerm term)
        throws VisitorException {
        throw new VisitorException("should never be called");
    }

    public void visitLinkageArrayAccessExpression(
            final LinkageArrayAccessExpression e)
        throws VisitorException {
        throw new VisitorException("should never be called");
    }

    public void visitLinkageIdentifierExpression(
            final LinkageIdentifierExpression e)
        throws VisitorException {
        throw new VisitorException("should never be called");
    }

    public void visitLinkageStructureAccessExpression(
            final LinkageStructureAccessExpression e)
        throws VisitorException {
        throw new VisitorException("should never be called");
    }

    public void visitParallelStatement(ParallelStatement s)
        throws VisitorException {
        int nStmts = 0;
        for (final Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();
            annotatePosition(stmt);
            // The statements will already be terminated with a ;
            stmt.accept(this);
            // Check for number of statements because we may have one
            // statement in parallel, in which case nothing special need
            // be done.
            if (nStmts >= 1)
                out.println("/* ^ Should have been parallel. */");
            if (nStmts == 1)
                warningWriter.println("Warning: " +
                        "Sequentializing parallel statements.");
            
            nStmts++;
        }
    }

    public void visitReceiveStatement(ReceiveStatement s)
        throws VisitorException {
        final ExpressionInterface target = s.getRightHandSide();
        final ExpressionInterface source = s.getChannelExpression();

        if (target != null) {
            // This case is expressible as an assignment statement, so we
            // construct this equivalent statement as the source for Java
            // translation.
            final ExpressionInterface recv = new ReceiveExpression(source);
            final Type targetType = analysisResults.getType(target);
            analysisResults.setType(recv, targetType);
            if (targetType instanceof StructureType ||
                targetType instanceof ArrayType) {
                out.print("unpack(");
                target.accept(this);
                out.print(", ");
                recv.accept(this);
                out.println(");");
            } else {
                new AssignmentStatement(target, recv).accept(this);
            }
        } else {
            // target == null, so remove a token from the channel
            // Put receive statement in an if statement with an empty body
            // because (receive(chan).getValue()) is not a statement.
            // receive(chan).getValue() is, but it would be more work to
            // control the generation of ()'s, so we just wrap it in an
            // if statement.
            out.print("if (");
            processReceiveOrPeek(source, target, "receive");
            out.println(" != null)");
            out.println("/* do nothing */;");
        }
    }

    public void visitSendStatement(SendStatement s)
        throws VisitorException {
        final ExpressionInterface expr = s.getRightHandSide();
        final com.avlsi.csp.ast.ChannelType chanType =
            (com.avlsi.csp.ast.ChannelType)
            analysisResults.getType(s.getChannelExpression());
        out.print("send(");
        if (!BigIntegerUtil.isPowerOf2(chanType.getNumValues())) {
            final ParseRange pr = s.getParseRange();
            out.print("\"" + cellInfo.getAbbreviatedType() + "\", \"" +
                      pr.fullString() + "\", ");
        }
        s.getChannelExpression().accept(this);
        out.print(", ");
        final Type ty = analysisResults.getType(expr);
        final boolean needPack = ty instanceof StructureType ||
                                 ty instanceof ArrayType;
        if (needPack) out.print("pack(");
        expr.accept(this);
        if (needPack) out.print(")");
        out.println(".toBigInteger());");
    }

    void sequentialStatementBeginScopeHook() {
        out.println("{");       // provide scope for variables
    }

    void sequentialStatementEndScopeHook() {
        out.println("}");
    }

    private String getLocation(AbstractASTNodeInterface node) {
        final ParseRange pr = node.getParseRange();
        final String fname = pr.start.filename;
        return fname + ' ' + pr.toString();
    }

    private void annotatePosition(StatementInterface stmt) {
        if (bodyP || funcP) {
            out.println("setWhereAmI(\"" + getLocation(stmt) + "\");");
        }
    }

    public void visitSequentialStatement(SequentialStatement s)
        throws VisitorException {
        sequentialStatementBeginScopeHook();
        for (final Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();
            annotatePosition(stmt);
            // The statements will already be terminated with a ;
            stmt.accept(this);
        }
        sequentialStatementEndScopeHook();
    }

    public void visitErrorStatement(ErrorStatement s)
        throws VisitorException {
        out.println("handleError(\"" + cellInfo.getAbbreviatedType() +
                    "\", \"" +
                    s.getFilename() + "\", " + s.getLine() + ", " +
                    s.getColumn() + ");");
    }

    public void visitSkipStatement(SkipStatement s)
        throws VisitorException {
        out.println("/* skip */");
    }

    public void visitVarStatement(VarStatement s)
        throws VisitorException {

        if (s.getStatement() != null) {
            // Scoped var statement

            out.println("{ /* begin block */");
        }

        // Handle variables

        processDeclarationList(s.getDeclarationList(), false,
                new TopLevelDeclaratorProcessor());

        if (s.getStatement() != null) {
            // Handle code
            s.getStatement().accept(this);

            out.println("} /* end block */");
        }
    }

    private void processDeclarationList(DeclarationList dl, boolean formalP)
        throws VisitorException {
        processDeclarationList(dl, formalP, new DeclaratorProcessor());
    }

    private void processDeclarationList(DeclarationList dl, boolean formalP,
                                        DeclaratorProcessor proc)
        throws VisitorException {

        boolean firstP = true;
        for (final Iterator i = dl.getDeclarations(); i.hasNext(); ) {
            final Declaration d = (Declaration) i.next();
            if (formalP) {
                if (firstP)
                    firstP = false;
                else {
                    // comma separates formals
                    out.println(',');
                }
            }
            processDeclaration(d, formalP, proc);
        }
    }

    void declarationModifierHook() {
        // All types must be declared final due to interaction with
        // inner class Fold.

        out.print("final ");
    }

    boolean useLoggedType() { return true; }

    private class DeclaratorProcessor {
        public void emitModifier(Declarator dr) throws VisitorException {
            declarationModifierHook();
        }
        public void emitType(Declarator dr) throws VisitorException {
            dr.getTypeFragment().accept(JavaEmitter.this);
        }
        public String getInitPreamble() {
            return " = ";
        }
        public String getInitPostamble() {
            return ";";
        }
        public String getTerminator() {
            return "";
        }
        public boolean outputInit() {
            return true;
        }
        public boolean generateLoggedType() {
            return useLoggedType();
        }
        public boolean isTopLevel() {
            return false;
        }
        public String getPrefix() {
            return "\"\"";
        }
    }

    private class TopLevelDeclaratorProcessor extends DeclaratorProcessor {
        public boolean isTopLevel() {
            return true;
        }
    }

    private void processDeclaration(Declaration d, boolean formalP)
        throws VisitorException {
        processDeclaration(d, formalP, new DeclaratorProcessor());
    }

    private void processLoggedType(final Type t) throws VisitorException {
        if (t instanceof IntegerType) {
            final IntegerType it = (IntegerType) t;
            if (it.getDeclaredWidth() != null) {
                out.print("getElementConstructor(");
                processWidth(it.getDeclaredWidth());
                out.print(", " + it.isSigned() + ")");
            } else {
                out.print("LoggedCspInteger.class");
            }
        } else {
            if (t instanceof BooleanType) {
                out.print("LoggedCspBoolean");
            } else if (t instanceof StringType) {
                out.print("LoggedCspString");
            } else if (t instanceof StructureType) {
                final StructureType st = (StructureType) t;
                final Pair p = (Pair) resolver.getResolvedStructures().get(st);
                assert p != null;
                final StructureDeclaration decl =
                    (StructureDeclaration) p.getSecond();
                processIdentifier("Logged" + decl.getName() + "_" +
                                  labels.getLabel(decl));
            } else {
                t.accept(this);
            }
            out.print(".class");
        }
    }

    private void processDeclaration(Declaration d, boolean formalP,
                                    DeclaratorProcessor proc)
        throws VisitorException {

        boolean firstP = true;
        for (Iterator i = d.getDeclaratorList().getDeclarators(); 
                i.hasNext(); ) {

            final Declarator dr = (Declarator) i.next();

            if (formalP) {
                if (firstP)
                    firstP = false;
                else {
                    // comma separates formals
                    out.println(',');
                }
            }

            proc.emitModifier(dr);

            // Print java type 

            proc.emitType(dr);

            // Whitespace separates type and identifier

            out.print(" ");

            // Print identifier

            dr.getIdentifier().accept(this);

            if (!formalP && proc.outputInit()) {
                out.print(proc.getInitPreamble());

                // Add appropriate initializer (ignore arrays for now)
                // REVIEW: use one Type visitor for initializers,
                // another for variable declarations.

                Type varT = dr.getTypeFragment();
                ExpressionInterface init = dr.getInitializer();

                if (varT instanceof IntegerType) {
                    // Integer type
                    IntegerType integerT = (IntegerType) varT;
                    final ExpressionInterface width =
                        integerT.getDeclaredWidth();
                    if (init == null && integerT.isConst()) {
                        // no initializer present for a const declarator
                        throw new VisitorException(
                                "Missing initializer for const variable.");
                    } else {
                        final String intType =
                            width != null ? "FiniteCspInteger" : "CspInteger";
                        out.print("new ");
                        if (proc.generateLoggedType()) {
                            out.print("Logged" + intType + "(" +
                                      proc.getPrefix() + " + \"" +
                                      dr.getIdentifier().getIdentifier() +
                                      "\", ");
                            if (proc.isTopLevel()) {
                                out.print("\"" +
                                          getLocation(dr.getIdentifier()) +
                                          "\", ");
                            }
                        } else {
                            out.print(intType + "(");
                        }
                        if (init == null) {
                            // no initializer present for a non-constant
                            // declarator
                            out.print("BigInteger.ZERO");
                        } else {
                            init.accept(this);
                            out.print(".toBigInteger()");
                        }
                        if (width != null) {
                            out.print(", (");
                            width.accept(this);
                            out.print(").intValue(), ");
                            out.print(integerT.isSigned());
                        }
                        out.print(")");
                    }
                } else if (varT instanceof BooleanType) {
                    BooleanType boolT = (BooleanType) varT;
                    if (init == null && boolT.isConst()) {
                        // no initializer present for a const declarator
                        throw new VisitorException(
                                "Missing initializer for const variable.");
                    } else {
                        out.print("new ");
                        if (proc.generateLoggedType()) {
                            out.print("LoggedCspBoolean(" +
                                      proc.getPrefix() + " + \"" +
                                      dr.getIdentifier().getIdentifier() +
                                      "\", ");
                            if (proc.isTopLevel()) {
                                out.print("\"" +
                                          getLocation(dr.getIdentifier()) +
                                          "\", ");
                            }
                        } else {
                            out.print("CspBoolean(");
                        }
                        if (init == null) {
                            // no initializer present for a non-constant
                            // declarator
                            out.print("BigInteger.ZERO");
                        } else {
                            init.accept(this);
                            out.print(".toBigInteger()");
                        }
                        out.print(")");
                    }
                } else if (varT instanceof StringType) {
                    if (proc.generateLoggedType()) {
                        out.print("new LoggedCspString(" +
                                  proc.getPrefix() + " + \"" +
                                  dr.getIdentifier().getIdentifier() +
                                  "\", ");
                        if (proc.isTopLevel()) {
                            out.print("\"" +
                                      getLocation(dr.getIdentifier()) +
                                      "\", ");
                        }
                    } else {
                        out.print("(");
                    }
                    if (init == null) {
                        out.print("new CspString()");
                    } else {
                        init.accept(this);
                    }
                    out.print(")");
                } else if (varT instanceof ArrayType) {

                    // Array type

                    // Arrays currently do not accept initializers
                    if (init != null)
                        throw new VisitorException(
                                "Array initializers are not supported at " +
                                init.getParseRange().fullString());

                    ArrayType at = (ArrayType) varT;
                    int dim = at.dimension();

                    if (proc.generateLoggedType()) out.print("Logged");
                    out.print ("CspArray.makeArray(");
                    if (proc.generateLoggedType()) {
                        out.print("getSelf(), " + proc.getPrefix() + " + \"" +
                                  dr.getIdentifier().getIdentifier() +
                                  "\", ");
                        if (proc.isTopLevel()) {
                            out.print("\"" +
                                      getLocation(dr.getIdentifier()) +
                                      "\", ");
                        }
                    }
                    out.print ("new CspInteger[] { ");

                    {
                        ArrayType subarray = at;
                        for (int j = 0; j < dim; j++) {
                            if (j > 0) {
                                subarray = (ArrayType) 
                                    subarray.getElementType();
                                out.print(", ");
                            }
                            subarray.getRange().getMinExpression().accept(this);
                            out.print(", ");
                            subarray.getRange().getMaxExpression().accept(this);
                        }
                    }

                    out.print(" }, ");

                    final Type et = CspUtils.getBaseType(at.getElementType());
                    if (proc.generateLoggedType()) processLoggedType(et);
                    else {
                        et.accept(this);
                        out.print(".class");
                    }

                    out.print (")");
                } else if (varT instanceof StructureType) {
                    StructureType st = (StructureType) varT;
                    final Pair p =
                        (Pair) resolver.getResolvedStructures().get(st);
                    assert p != null;
                    if (init == null && st.isConst()) {
                        // no initializer present for a const declarator
                        throw new VisitorException(
                                "Missing initializer for const variable.");
                    } else {
                        // a non-constant declarator
                        out.print("new ");
                        final StructureDeclaration decl =
                            (StructureDeclaration) p.getSecond();
                        processIdentifier(
                            (proc.generateLoggedType() ? "Logged" : "") +
                            decl.getName() + "_" + labels.getLabel(decl));
                        out.print("(");
                        if (proc.generateLoggedType()) {
                            out.print(proc.getPrefix() + " + \"" +
                                      dr.getIdentifier().getIdentifier() +
                                      "\"");
                            if (proc.isTopLevel()) {
                                out.print(", \"" +
                                          getLocation(dr.getIdentifier()) +
                                          "\"");
                            }
                            out.print(init == null ? "" : ", ");
                        }
                        if (init != null) init.accept(this);
                        out.print(")");
                    }
                }

                // Semicolon terminates declaration
                out.print(proc.getInitPostamble());
            }

            out.print(proc.getTerminator());
        }
    }

    /** Print a newline, only the first time, to get off "Applying models ." */
    private void ensureNewline() {
        if (!didNewline) {
            errorWriter.println();
            didNewline = true;
        }
    }

    /** Pretty-print an error message to errorWriter */
    private void prettyMessage(String message, ParseRange pr) {
        ensureNewline();
        ExceptionPrettyPrinter.prettyMessage(message, pr.start.filename,
                                             pr.start.line, pr.start.column+1,
                                             errorWriter);
    }

    /**
     * Generate declarations for undeclared variables.
     **/
    private void declareUndeclared(VariableAnalyzer.Results r)
        throws VisitorException {
        Map m = r.getUndeclaredTypes();
        for (final Iterator i = m.keySet().iterator(); i.hasNext(); ) {
            String name = (String) i.next();
            Type type = (Type) m.get(name);
            
            if (type == null
                || type instanceof IntegerType
                || type instanceof BooleanType) {
                final DeclaratorList dlist = new DeclaratorList();
                dlist.addDeclarator(
                    new Declarator(new IdentifierExpression(name), type, null));
                processDeclaration(new Declaration(dlist), false,
                        new TopLevelDeclaratorProcessor());
            } else {
                errorWriter.flush();
                warningWriter.flush();
                throw new VisitorException
                    ("Undeclared variable has unsupported type.");
            }
        }
    }

    /** 
     * Inspect the sets of uninitialized variables returned by variable
     * analysis.  
     **/
    private void processResults(VariableAnalyzer.Results r)
        throws VisitorException {
        identUsed.addAll(r.getUsedIdentifiers());
        analysisResults = r;
    }

    public void visitChannelType(com.avlsi.csp.ast.ChannelType t)
        throws VisitorException {
        throw new AssertionError("Declarations of channels not supported.");
    }

    public void visitChannelStructureType(ChannelStructureType t)
        throws VisitorException {
        throw new AssertionError("Declarations of channels not supported.");
    }

    public void visitNodeType(com.avlsi.csp.ast.NodeType t)
        throws VisitorException {
        out.print("CspNode");
    }


    public void visitArrayType(ArrayType t)
        throws VisitorException {
        out.print("CspArray");
    }

    public void visitIntegerType(IntegerType t)
        throws VisitorException {
        // XXX: ignore t.isConst(), handling of constants is broken
        out.print("CspInteger");
    }

    public void visitBooleanType(BooleanType t)
        throws VisitorException {
        // XXX: ignore t.isConst(), handling of constants is broken
        out.print("CspInteger");
    }

    public void visitStringType(StringType t) throws VisitorException {
        out.print("CspString");
    }

    public void visitStructureType(StructureType t)
        throws VisitorException {
        final Pair p = (Pair) resolver.getResolvedStructures().get(t);
        assert p != null;
        final StructureDeclaration decl = (StructureDeclaration) p.getSecond();
        processIdentifier(decl.getName() + "_" + labels.getLabel(decl));
    }

    public void visitIdentifierList(IdentifierList il)
        throws VisitorException {

        // Note that this is not called when the identifier list is contained
        // in a VarStatement DeclarationList.  

        Iterator i = il.getIdentifiers();

        if (!i.hasNext()) {
            throw new VisitorException ("IdentifierList is empty.");
        } 

        while (i.hasNext()) {
            final IdentifierExpression id = (IdentifierExpression) i.next();
            id.accept(this);
            if (i.hasNext()) {
                out.print(", ");
            }
        }
    }

    public void visitLoopGuard(LoopGuard s) throws VisitorException {
        throw new VisitorException("should never be called");
    }

    void setOutputWriter(final PrintWriter out) {
        this.out = out;
    }

    PrintWriter getOutputWriter() {
        return out;
    }

    /**
     * Emits static declarations for top-level constants.
     * <p> Hack hack hack.
     **/
    private static class ConstantDeclarationEmitter extends JavaEmitter {
        public ConstantDeclarationEmitter(final String packageName,
                           final String className,
                           final CSPCellInfo cellInfo,
                           final PrintWriter out,
                           final PrintWriter warningWriter,
                           final PrintWriter errorWriter,
                           final PrintWriter debugWriter,
                           final boolean emitCoverageProbes,
                           final boolean disableDftHandler,
                           final VariableAnalyzer.Results analysisResults) {
            super(packageName, className, cellInfo, out, warningWriter,
                  errorWriter, debugWriter, emitCoverageProbes, false, false,
                  disableDftHandler, false);
            this.analysisResults = analysisResults;
        }

        void declarationModifierHook() {
            out.print("static final ");
        }

        void sequentialStatementBeginScopeHook() {
            // do nothing
        }

        void sequentialStatementEndScopeHook() {
            // do nothing
        }

        public void visitAssignmentStatement(AssignmentStatement s) {
            // do nothing
        }

        boolean useLoggedType() { return false; }
    }

    /**
     * Emits static initializations for top-level constants.
     * <p> Hack hack hack.
     **/
    private static class ConstantInitializerEmitter extends JavaEmitter {
        private static final int MAX_ASSIGNMENT_PER_FUNCTION = 100;
        private int assignCount;
        private int funcCount;
        public ConstantInitializerEmitter(final String packageName,
                           final String className,
                           final CSPCellInfo cellInfo,
                           final PrintWriter out,
                           final PrintWriter warningWriter,
                           final PrintWriter errorWriter,
                           final PrintWriter debugWriter,
                           final boolean emitCoverageProbes,
                           final boolean disableDftHandler,
                           final VariableAnalyzer.Results analysisResults) {
            super(packageName, className, cellInfo, out, warningWriter,
                  errorWriter, debugWriter, emitCoverageProbes, false, false,
                  disableDftHandler, false);
            this.analysisResults = analysisResults;
            this.assignCount = 0;
        }

        public void visitVarStatement(VarStatement s) {
            // do nothing
        }
        public void visitAssignmentStatement(AssignmentStatement s)
            throws VisitorException {
            if (assignCount == 0) {
                final String name = "StaticInitializer_" + funcCount;
                out.println("private static class " + name + " {");
                out.println("public static void init() {");
                ++funcCount;
            }
            super.visitAssignmentStatement(s);
            ++assignCount;
            if (assignCount > MAX_ASSIGNMENT_PER_FUNCTION) {
                out.println("}");
                out.println("}");
                assignCount = 0;
            }
        }
        public void done() {
            if (assignCount != 0) {
                out.println("}");
                out.println("}");
            }
            out.println("private static void staticInitializer() {");
            for (int i = 0; i < funcCount; ++i) {
                out.println("StaticInitializer_" + i + ".init();");
            }
            out.println("}");
        }

        void sequentialStatementBeginScopeHook() { }

        void sequentialStatementEndScopeHook() { }
    }
}

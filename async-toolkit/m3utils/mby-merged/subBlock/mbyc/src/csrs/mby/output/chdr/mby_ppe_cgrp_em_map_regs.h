/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_cgrp_em_map_regs.h                                 
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_CGRP_EM_MAP_REGS_H_
#define _MBY_PPE_CGRP_EM_MAP_REGS_H_

#define EM_MSGPORT     0x0
#define EM_HASH_CAM_MSGREGADDR 0x0
#define EM_HASH_CAM_EN_MSGREGADDR 0x800
#define EM_KEY_SEL0_MSGREGADDR 0x0C00
#define EM_KEY_SEL1_MSGREGADDR 0x1000
#define EM_KEY_MASK_MSGREGADDR 0x1400
#define EM_HASH_MISS_MSGREGADDR 0x1800
#define EM_HASH_CFG_MSGREGADDR 0x1C00

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_FLAG
// HASH_CAM desc:  The second index is the entry number, and the third index is the
// word number. The entry format is big-endian. Byte 0 is bits 63..56 of
// word 0. [br][br] In 64B entry mode, the entry is 64 bytes wide.
// There is a single action resolution and one or two actions from the
// highest-numbered matching entry are used. To form a 64B entry, a key
// 56 bytes or less is padded with zeros to 56B and followed by up to
// two actions, or a key may be 60 bytes with only one action at[br]
// EM_HASH_CAM[mgp][rule][7][31:0]. [br][br] In 32B entry mode,[br]
// EM_HASH_CAM[mgp][rule][0..3][br] is the row0 entry, and[br]
// EM_HASH_CAM[mgp][rule][4..7][br] is the row1 entry. The two rows are
// resolved independently: the 1-2 actions from the highest-numbered
// matching entry within each row are used. To form a 32B entry, a key
// 24 bytes or less is padded with zeros to 24B and followed by two
// actions, or a key may be 28 bytes with only one action. [br][br]
typedef union {
    struct {
        uint64_t  DATA                 :  64;    // 

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_DATA_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_DATA_MSB 0x003f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_DATA_RANGE 0x0040
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_DATA_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_DATA_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_FLAG
// HASH_CAM_EN desc:  When EM_HASH_CAM_EN[mgp][row][rule].mask[p] is set, then
// EM_HASH_CAM[mgp][rule][row*4+3:row*4] is used in packet profile p.
typedef union {
    struct {
        uint64_t  MASK                 :  64;    //  Select packet profiles for
                                                 // this rule. Uses little-endian
                                                 // bit numbering.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_MASK_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_MASK_MSB 0x003f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_MASK_RANGE 0x0040
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_FLAG
// KEY_SEL0 desc:  Configure how the exact match hash functions (hash0,hash1) should be
// calculated. [br][br] This register is indexed first by hash number
// 0..1, then by packet profile. [br][br] Before matching, the selected
// keys are compacted in big endian form. If the result is an odd number
// of bytes, a zero padding byte is added.
typedef union {
    struct {
        uint64_t  KEY8_MASK            :  32;    //  Selects the KEY8s to
                                                 // participate in hashing and
                                                 // matching:[br] KEY8_MASK[i]
                                                 // selects KEY8[i].
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_KEY8_MASK_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_KEY8_MASK_MSB 0x001f
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_KEY8_MASK_RANGE 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_KEY8_MASK_MASK 0xffffffff
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_KEY8_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_FLAG
// KEY_SEL1 desc:  Configure how the exact match hash functions (hash0,hash1) should be
// calculated. [br][br] This register is indexed first by hash number
// 0..1, then by packet profile. [br][br] Before matching, the selected
// keys are compacted in big endian form. If the result is an odd number
// of bytes, a zero padding byte is added.
typedef union {
    struct {
        uint64_t  KEY16_MASK           :  32;    //  Selects the KEY16s to
                                                 // participate in hashing and
                                                 // matching:[br] KEY16_MASK[i]
                                                 // selects KEY16[i].
        uint64_t  KEY32_MASK           :  16;    //  Selects the KEY32s to
                                                 // participate in hashing and
                                                 // matching:[br] KEY32_MASK[i]
                                                 // selects KEY32[i].
        uint64_t  KEY_MASK_SEL         :   4;    //  Selects one of sixteen
                                                 // 128-bit masks stored in
                                                 // EM_KEY_MASK to apply to the
                                                 // key during comparison.
        uint64_t  RSVD_0               :  12;    // Nebulon auto filled RSVD [63:52]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_BITFIELD_COUNT 0x03
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY16_MASK_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY16_MASK_MSB 0x001f
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY16_MASK_RANGE 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY16_MASK_MASK 0xffffffff
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY16_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY32_MASK_LSB 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY32_MASK_MSB 0x002f
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY32_MASK_RANGE 0x0010
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY32_MASK_MASK 0xffff00000000
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY32_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY_MASK_SEL_LSB 0x0030
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY_MASK_SEL_MSB 0x0033
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY_MASK_SEL_RANGE 0x0004
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY_MASK_SEL_MASK 0xf000000000000
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_KEY_MASK_SEL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_FLAG
// KEY_MASK desc:  Provides a 128 bit hash key mask for each of 16 hash key profiles.
// Indexed first by hash number (0..1), then by: [code] (KEY_MASK_SEL *
// 2) + DW [/code] where there are 2 DWs per profile (128 bits)
typedef union {
    struct {
        uint64_t  MASK                 :  64;    //  64 of the 128 bits in the
                                                 // mask. Indicates which bits
                                                 // are included in the hash
                                                 // calculation.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_MASK_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_MASK_MSB 0x003f
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_MASK_RANGE 0x0040
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_FLAG
// HASH_MISS desc:  EM_HASH_MISS[r][profile] provides 2 actions for row r=0..1.
// [br][br] If there is no key match in ENTRY_RAM or CAM, then both
// actions are taken. The format of the action is the same as EM_ACTION,
// HASH_ENTRY_RAM, and EM_HASH_CAM.
typedef union {
    struct {
        uint64_t  ACTION0              :  32;    // 
        uint64_t  ACTION1              :  32;    // 

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_BITFIELD_COUNT 0x02
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION0_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION0_MSB 0x001f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION0_RANGE 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION0_MASK 0xffffffff
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION1_LSB 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION1_MSB 0x003f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION1_RANGE 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION1_MASK 0xffffffff00000000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_ACTION1_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_FLAG
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_FLAG
// HASH_CFG desc:  This register is indexed by the packet profile.
typedef union {
    struct {
        uint64_t  ENTRY_SIZE_1         :   5;    //  Size of each entry, given as
                                                 // a multiple of 4B. The entry
                                                 // size must be a multiple of 4
                                                 // in the range 8..64. The entry
                                                 // bytes following the padded key
                                                 // are actions. [br][br] Set
                                                 // entry_size[r]==0 to disable
                                                 // row r lookups for this packet
                                                 // profile.
        uint64_t  ENTRY_SIZE_0         :   5;    //  Size of each entry, given as
                                                 // a multiple of 4B. The entry
                                                 // size must be a multiple of 4
                                                 // in the range 8..64. The entry
                                                 // bytes following the padded key
                                                 // are actions. [br][br] Set
                                                 // entry_size[r]==0 to disable
                                                 // row r lookups for this packet
                                                 // profile.
        uint64_t  HASH_SIZE_1          :   5;    //  Number of hash bits to use
                                                 // in lookup address calculation.
                                                 // [br][br] lookup_ptr =
                                                 // base_ptr[ROW] + hash %
                                                 // 2^hash_size[ROW] [br][br]
                                                 // For example, hash_size=10
                                                 // yields a table with 1024
                                                 // buckets.
        uint64_t  HASH_SIZE_0          :   5;    //  Number of hash bits to use
                                                 // in lookup address calculation:
                                                 // [br][br] lookup_ptr =
                                                 // base_ptr[ROW] + hash %
                                                 // 2^hash_size[ROW] [br][br]
                                                 // For example, hash_size=10
                                                 // yields a table with 1024
                                                 // buckets.
        uint64_t  BASE_PTR_1           :  13;    //  Start of hash table.[br]
                                                 // Must be a multiple of
                                                 // 2^hash_size[ROW].
        uint64_t  BASE_PTR_0           :  13;    //  Start of hash table.[br]
                                                 // Must be a multiple of
                                                 // 2^hash_size[ROW].
        uint64_t  MODE                 :   1;    //  Define lookup (or entry)
                                                 // modes: [list] [*] 0: Split
                                                 // mode (32B per entry) [*] 1:
                                                 // Non-split mode (64B per entry)
                                                 // [/list]
        uint64_t  HASH_LO              :   1;    //  For non-split mode, and for
                                                 // the low half of split mode,
                                                 // selects which hash function
                                                 // to use: [list] [*] 0: Hash0
                                                 // - CRC32 [*] 1: Hash1 - CRC32C
                                                 // [/list]
        uint64_t  HASH_HI              :   1;    //  For the high half of split
                                                 // mode only, selects which hash
                                                 // function to use: [list] [*]
                                                 // 0: Hash0 - CRC32 [*] 1: Hash1
                                                 // - CRC32C [/list]
        uint64_t  RSVD_0               :  15;    // Nebulon auto filled RSVD [63:49]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_t;
#endif
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_OFFSET 0x00
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_SCOPE 0x01
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_SIZE 64
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BITFIELD_COUNT 0x09
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_RESET 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_1_LSB 0x0000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_1_MSB 0x0004
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_1_RANGE 0x0005
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_1_MASK 0x0000001f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_1_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_0_LSB 0x0005
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_0_MSB 0x0009
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_0_RANGE 0x0005
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_0_MASK 0x000003e0
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_ENTRY_SIZE_0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_1_LSB 0x000a
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_1_MSB 0x000e
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_1_RANGE 0x0005
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_1_MASK 0x00007c00
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_1_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_0_LSB 0x000f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_0_MSB 0x0013
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_0_RANGE 0x0005
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_0_MASK 0x000f8000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_SIZE_0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_1_LSB 0x0014
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_1_MSB 0x0020
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_1_RANGE 0x000d
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_1_MASK 0x1fff00000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_1_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_0_LSB 0x0021
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_0_MSB 0x002d
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_0_RANGE 0x000d
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_0_MASK 0x3ffe00000000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_BASE_PTR_0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_MODE_LSB 0x002e
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_MODE_MSB 0x002e
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_MODE_RANGE 0x0001
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_MODE_MASK 0x400000000000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_MODE_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_LO_LSB 0x002f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_LO_MSB 0x002f
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_LO_RANGE 0x0001
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_LO_MASK 0x800000000000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_LO_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_HI_LSB 0x0030
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_HI_MSB 0x0030
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_HI_RANGE 0x0001
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_HI_MASK 0x1000000000000
#define MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_HASH_HI_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_t HASH_CAM[8];      // offset 4'h0, width 64
    } HASH_CAM[32];                              // offset 4'h0, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_EM_MAP_MSG_HASH_CAM_EN_t HASH_CAM_EN[32];  // offset 4'h0, width 64
    } HASH_CAM_EN[2];                            // offset 12'h800, size: 256
    uint8_t                    rsvd0[512];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL0_t KEY_SEL0[64];     // offset 4'h0, width 64
    } KEY_SEL0[2];                               // offset 16'h0C00, size: 512
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_EM_MAP_MSG_KEY_SEL1_t KEY_SEL1[64];     // offset 4'h0, width 64
    } KEY_SEL1[2];                               // offset 16'h1000, size: 512
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_EM_MAP_MSG_KEY_MASK_t KEY_MASK[32];     // offset 4'h0, width 64
    } KEY_MASK[2];                               // offset 16'h1400, size: 256
    uint8_t                    rsvd1[512];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_EM_MAP_MSG_HASH_MISS_t HASH_MISS[64];    // offset 4'h0, width 64
    } HASH_MISS[2];                              // offset 16'h1800, size: 512
    MBY_PPE_CGRP_EM_MAP_MSG_HASH_CFG_t HASH_CFG[64];     // offset 16'h1C00, width 64
} mby_ppe_cgrp_em_map_t;                         // size:  16'h1E00


#endif // _MBY_PPE_CGRP_EM_MAP_REGS_H_


/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_mapper_map_regs.h                                  
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_MAPPER_MAP_REGS_H_
#define _MBY_PPE_MAPPER_MAP_REGS_H_

#define MAPPER_MSGPORT     0x0
#define MAPPER_MAP_PORT_CFG_MSGREGADDR 0x0
#define MAPPER_MAP_PORT_DEFAULT_MSGREGADDR 0x200
#define MAPPER_MAP_DOMAIN_TCAM_MSGREGADDR 0x10000
#define MAPPER_MAP_DOMAIN_ACTION0_MSGREGADDR 0x20000
#define MAPPER_MAP_DOMAIN_ACTION1_MSGREGADDR 0x28000
#define MAPPER_MAP_DOMAIN_PROFILE_MSGREGADDR 0x30000
#define MAPPER_MAP_PORT_MSGREGADDR 0x31000
#define MAPPER_MAP_MAC_MSGREGADDR 0x31800
#define MAPPER_MAP_IP_LO_MSGREGADDR 0x32080
#define MAPPER_MAP_IP_HI_MSGREGADDR 0x32100
#define MAPPER_MAP_IP_CFG_MSGREGADDR 0x32180
#define MAPPER_MAP_PROT_MSGREGADDR 0x32200
#define MAPPER_MAP_L4_SRC_MSGREGADDR 0x32400
#define MAPPER_MAP_L4_DST_MSGREGADDR 0x32600
#define MAPPER_MAP_EXP_TC_MSGREGADDR 0x32800
#define MAPPER_MAP_DSCP_TC_MSGREGADDR 0x34000
#define MAPPER_MAP_VPRI_TC_MSGREGADDR 0x38000
#define MAPPER_MAP_VPRI_MSGREGADDR 0x38100
#define MAPPER_MAP_PROFILE_KEY0_MSGREGADDR 0x38400
#define MAPPER_MAP_PROFILE_KEY_INVERT0_MSGREGADDR 0x38800
#define MAPPER_MAP_PROFILE_KEY1_MSGREGADDR 0x38C00
#define MAPPER_MAP_PROFILE_KEY_INVERT1_MSGREGADDR 0x39000
#define MAPPER_MAP_PROFILE_ACTION_MSGREGADDR 0x39400
#define MAPPER_MAP_DOMAIN_POL_CFG_MSGREGADDR 0x39800
#define MAPPER_MAP_REWRITE_MSGREGADDR 0x3A000

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_FLAG
// MAP_PORT_CFG desc: 
typedef union {
    struct {
        uint64_t  PORT_PROFILE         :   8;    //  Bits to feed into packet
                                                 // profile CAM.
        uint64_t  DEFAULT_SGLORT_EN    :   1;    //  overwrite the SGLORT parser
                                                 // key (after the IP rearrange
                                                 // step creates space).
        uint64_t  DEFAULT_SGLORT       :  16;    //  default SGLORT value, used
                                                 // if default_sglort_en is set.
        uint64_t  RSVD_0               :  39;    // Nebulon auto filled RSVD [63:25]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_BITFIELD_COUNT 0x03
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_PORT_PROFILE_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_PORT_PROFILE_MSB 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_PORT_PROFILE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_PORT_PROFILE_MASK 0x000000ff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_PORT_PROFILE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_EN_LSB 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_EN_MSB 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_EN_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_EN_MASK 0x00000100
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_EN_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_LSB 0x0009
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_MSB 0x0018
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_RANGE 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_MASK 0x01fffe00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_DEFAULT_SGLORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_FLAG
// MAP_PORT_DEFAULT desc:  For each packet, 6 entries are used: MAP_PORT_DEFAULT[port][0..5]
// Apply the defaults in the following order: [list] [*] For target
// field less than 96, set key_valid for keys modified by the value
// field. [*] Copy dscp/vpri/vid to actions, overriding the default
// values inserted above for keys_valid [*] Insert the rest of default
// targets in 96..223. [/list]
typedef union {
    struct {
        uint64_t  TARGET               :   8;    //  target indicates where to
                                                 // put the value. [list] [*]
                                                 // 0..79 = keys (if not already
                                                 // valid) [*] 80..95 = force
                                                 // into key 12..27 (ignore
                                                 // validity from parser) [*]
                                                 // 96..191 = initial Classifier
                                                 // actions. [*] 96..111 = act24
                                                 // lower 16 [*] 112..127 = act24
                                                 // upper 8
                                                 // (act24[target-112][23:16] =
                                                 // value[7:0]) [*] 128..159 =
                                                 // act4, 4 consecutive nybbles.
                                                 // Must be a multiple of 4. [*]
                                                 // 160..191 = act4, 2 consecutive
                                                 // nybbles. Must be a multiple of
                                                 // 2. [*] 192..223 = act4, 1
                                                 // nybble [*] 224 = set
                                                 // flags[15:0] [*] 225..254 =
                                                 // reserved [*] 255 = NOP
                                                 // (discard the value) [/list]
        uint64_t  RSVD_0               :   8;    // Nebulon auto filled RSVD [15:8]
        uint64_t  VALUE                :  16;    //  The immediate value to use.
        uint64_t  RSVD_1               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_BITFIELD_COUNT 0x02
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_RESET 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_TARGET_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_TARGET_MSB 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_TARGET_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_TARGET_MASK 0x000000ff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_TARGET_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_VALUE_LSB 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_VALUE_MSB 0x001f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_VALUE_RANGE 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_VALUE_MASK 0xffff0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_VALUE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_FLAG
// MAP_DOMAIN_TCAM desc:  Configures an entry in the TCAM. [br][br] A match occurs when the
// data searched is equal to the content, as defined in the table below.
// [br][br] A key is loaded by writing the key into 'Key' (KEY /
// KEY_TOP) and loading its 1s compliment in KeyInvert (KEY_INVERT /
// KEY_TOP_INVERT). Writing both 'Key' and 'KeyInvert' with 1 on same
// bit in both fields will invalidate the entry while writing 0 on same
// bit in both field is equivalent of ignoring this bit in the seach.
// [br][br] The table below shows the encoded data value stored
// (Content) based on the Key and KeyInvert values. [code]
// +-----------------------------------------------------+ | KeyInvert |
// Key | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// highest index has precedence in case there is more than one match.
// [br][br] Note, when performing the match function, in addition to the
// main fields and their corresponding invert ones, _RSVD0_ and _RSVD1_
// fields are partially used in hit generation. To make the hit
// independent of those fields, they should be programmed to zero (always
// match) so they do not affect the hit.
typedef union {
    struct {
        uint128_t  VID1_KEY             :  12;    //  Outer VLAN1
        uint128_t  VID1_VALID           :   1;    //  Valid state for outer VLAN1
        uint128_t  VID2_KEY             :  12;    //  Outer VLAN2
        uint128_t  VID2_VALID           :   1;    //  Valid state for outer VLAN2
        uint128_t  PORT_KEY             :  18;    //  Ingress port mask. Set to
                                                 // all zeros and control matching
                                                 // with port_key_invert.
        uint128_t  _RSVD0_              :  20;    //  Reserved
        uint128_t  VID1_KEY_INVERT      :  12;    //  Inverted outer VLAN1
        uint128_t  VID1_VALID_INVERT    :   1;    //  Inverted validity for outer
                                                 // VLAN1
        uint128_t  VID2_KEY_INVERT      :  12;    //  Inverted outer VLAN2
        uint128_t  VID2_VALID_INVERT    :   1;    //  Inverted validity for outer
                                                 // VLAN2
        uint128_t  PORT_KEY_INVERT      :  18;    //  Inverted ingress port mask.
                                                 // With port_key set to all
                                                 // zeros, set a 1 bit in this
                                                 // field only for ports to be
                                                 // excluded from matching.
        uint128_t  _RSVD1_              :  20;    //  Reserved

    }                                field;
    uint128_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_SIZE 128
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_BITFIELD_COUNT 0x0c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_RESET 0xfffffffffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_MSB 0x000b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_MASK 0x00000fff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_RESET_VALUE 0x00000fff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_LSB 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_MSB 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_MASK 0x00001000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_LSB 0x000d
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_MSB 0x0018
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_MASK 0x01ffe000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_RESET_VALUE 0x00000fff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_LSB 0x0019
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_MSB 0x0019
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_MASK 0x02000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_LSB 0x001a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_MSB 0x002b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_RANGE 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_MASK 0xffffc000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_RESET_VALUE 0x0003ffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD0__LSB 0x002c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD0__MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD0__RANGE 0x0014
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD0__MASK 0xfffff00000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_INVERT_LSB 0x0040
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_INVERT_MSB 0x004b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_INVERT_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_INVERT_MASK 0x00000fff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_KEY_INVERT_RESET_VALUE 0x00000fff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_INVERT_LSB 0x004c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_INVERT_MSB 0x004c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_INVERT_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_INVERT_MASK 0x00001000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID1_VALID_INVERT_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_INVERT_LSB 0x004d
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_INVERT_MSB 0x0058
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_INVERT_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_INVERT_MASK 0x01ffe000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_KEY_INVERT_RESET_VALUE 0x00000fff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_INVERT_LSB 0x0059
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_INVERT_MSB 0x0059
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_INVERT_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_INVERT_MASK 0x02000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_VID2_VALID_INVERT_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_INVERT_LSB 0x005a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_INVERT_MSB 0x006b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_INVERT_RANGE 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_INVERT_MASK 0xffffc000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_PORT_KEY_INVERT_RESET_VALUE 0x0003ffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD1__LSB 0x006c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD1__MSB 0x007f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD1__RANGE 0x0014
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD1__MASK 0xfffff00000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM__RSVD1__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FLAG
// MAP_DOMAIN_ACTION0 desc: 
typedef union {
    struct {
        uint64_t  DEFAULT_PRI          :   3;    //  default TC value, used if
                                                 // none of the precedence sources
                                                 // are present and metadata does
                                                 // not provide TC
        uint64_t  FORCE_DEFAULT_PRI    :   1;    //  Force 3b DEFAULT_PRI as the
                                                 // default TC value, overriding
                                                 // all precedence sources
        uint64_t  PRI_SOURCE           :   8;    //  Defines TC precedence
                                                 // sources [list] [*]
                                                 // pri_source[7:6] = highest
                                                 // precedence TC source ID [*]
                                                 // pri_source[1:0] = lowest
                                                 // precedence TC source ID
                                                 // [/list] where each 2b field
                                                 // is uniquely one of: [code]
                                                 // 00: MAP_VPRI_TC 01:
                                                 // MAP_EXP_TC 10: MAP_DSCP_TC
                                                 // 11: TC specified in metadata
                                                 // from CPU [/code]
        uint64_t  PRIORITY_PROFILE     :   5;    //  A profile index for
                                                 // remapping ingress priorities.
                                                 // Used when update_domains=1.
        uint64_t  LEARN_MODE           :   1;    //  Select shared(0) or
                                                 // independent(1) VLAN learning
                                                 // notification.
        uint64_t  LEARN_EN             :   1;    //  Learning notification
                                                 // enable/disable. This is used
                                                 // as the default value for the
                                                 // Classifier 'LEARN' action.
        uint64_t  UPDATE_DOMAINS       :   1;    //  Used only for packets sent
                                                 // to the CPP. When set, use the
                                                 // domains, priority_profile,
                                                 // and NAD the action, and write
                                                 // the domain and NAD fields into
                                                 // the metadata that will be
                                                 // sent to the CPP. If
                                                 // update_domains=0, then use the
                                                 // l2_domain, l3_domain, and NAD
                                                 // fields received in the
                                                 // packet's ONPI metadata. Do not
                                                 // overwrite those fields. And
                                                 // use the priority_profile
                                                 // retrieved from
                                                 // MAP_DOMAIN_PROFILE instead.
        uint64_t  NAD                  :   4;    //  A network addressing domain
                                                 // or NAD . Used when
                                                 // update_domains=1.
        uint64_t  L3_DOMAIN            :   6;    //  An L3 domain value used
                                                 // downstream. Used when
                                                 // update_domains=1.
        uint64_t  L2_DOMAIN            :   8;    //  An L2 domain value used
                                                 // downstream. Used when
                                                 // update_domains=1.
        uint64_t  RSVD_0               :  26;    // Nebulon auto filled RSVD [63:38]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_BITFIELD_COUNT 0x0a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_DEFAULT_PRI_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_DEFAULT_PRI_MSB 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_DEFAULT_PRI_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_DEFAULT_PRI_MASK 0x00000007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_DEFAULT_PRI_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FORCE_DEFAULT_PRI_LSB 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FORCE_DEFAULT_PRI_MSB 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FORCE_DEFAULT_PRI_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FORCE_DEFAULT_PRI_MASK 0x00000008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_FORCE_DEFAULT_PRI_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRI_SOURCE_LSB 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRI_SOURCE_MSB 0x000b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRI_SOURCE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRI_SOURCE_MASK 0x00000ff0
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRI_SOURCE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRIORITY_PROFILE_LSB 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRIORITY_PROFILE_MSB 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRIORITY_PROFILE_RANGE 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRIORITY_PROFILE_MASK 0x0001f000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_PRIORITY_PROFILE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_MODE_LSB 0x0011
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_MODE_MSB 0x0011
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_MODE_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_MODE_MASK 0x00020000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_MODE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_EN_LSB 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_EN_MSB 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_EN_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_EN_MASK 0x00040000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_LEARN_EN_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_UPDATE_DOMAINS_LSB 0x0013
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_UPDATE_DOMAINS_MSB 0x0013
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_UPDATE_DOMAINS_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_UPDATE_DOMAINS_MASK 0x00080000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_UPDATE_DOMAINS_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_NAD_LSB 0x0014
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_NAD_MSB 0x0017
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_NAD_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_NAD_MASK 0x00f00000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_NAD_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L3_DOMAIN_LSB 0x0018
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L3_DOMAIN_MSB 0x001d
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L3_DOMAIN_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L3_DOMAIN_MASK 0x3f000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L3_DOMAIN_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L2_DOMAIN_LSB 0x001e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L2_DOMAIN_MSB 0x0025
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L2_DOMAIN_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L2_DOMAIN_MASK 0x3fc0000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_L2_DOMAIN_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_FLAG
// MAP_DOMAIN_ACTION1 desc: 
typedef union {
    struct {
        uint64_t  VLAN_COUNTER         :  12;    //  A VLAN counter index
                                                 // indicating the VLAN counter to
                                                 // be used for counting RX stats
                                                 // on this tuple.
        uint64_t  L3_POLICER           :  12;    //  A policer index associated
                                                 // with the L3 domain. If
                                                 // l3_policer is nonzero, then
                                                 // the default POLICER[1] action
                                                 // is (bank=5, index=l3_policer).
        uint64_t  L2_POLICER           :  12;    //  A policer index associated
                                                 // with the L2 domain. If
                                                 // l2_policer is nonzero, then
                                                 // the default POLICER[0] action
                                                 // is (bank=0, index=l2_policer).
        uint64_t  DOMAIN_PROFILE       :   8;    //  Bits to feed into packet
                                                 // profile CAM.
        uint64_t  RSVD_0               :  20;    // Nebulon auto filled RSVD [63:44]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_BITFIELD_COUNT 0x04
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_VLAN_COUNTER_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_VLAN_COUNTER_MSB 0x000b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_VLAN_COUNTER_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_VLAN_COUNTER_MASK 0x00000fff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_VLAN_COUNTER_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L3_POLICER_LSB 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L3_POLICER_MSB 0x0017
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L3_POLICER_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L3_POLICER_MASK 0x00fff000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L3_POLICER_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L2_POLICER_LSB 0x0018
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L2_POLICER_MSB 0x0023
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L2_POLICER_RANGE 0x000c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L2_POLICER_MASK 0xfff000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_L2_POLICER_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_DOMAIN_PROFILE_LSB 0x0024
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_DOMAIN_PROFILE_MSB 0x002b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_DOMAIN_PROFILE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_DOMAIN_PROFILE_MASK 0xff000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_DOMAIN_PROFILE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_FLAG
// MAP_DOMAIN_PROFILE desc:  Indexed by l2_domain.
typedef union {
    struct {
        uint64_t  PRIORITY_PROFILE     :   5;    //  A profile index for
                                                 // remapping ingress priorities.
                                                 // Used when
                                                 // DOMAIN_ACTION[].update_domains=0.
        uint64_t  RSVD_0               :  59;    // Nebulon auto filled RSVD [63:5]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_PRIORITY_PROFILE_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_PRIORITY_PROFILE_MSB 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_PRIORITY_PROFILE_RANGE 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_PRIORITY_PROFILE_MASK 0x0000001f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_PRIORITY_PROFILE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_FLAG
// MAP_PORT desc: 
typedef union {
    struct {
        uint64_t  MAP_PORT             :   8;    //  Resulting MAP_PORT per
                                                 // source port
        uint64_t  RSVD_0               :  56;    // Nebulon auto filled RSVD [63:8]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_MAP_PORT_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_MAP_PORT_MSB 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_MAP_PORT_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_MAP_PORT_MASK 0x000000ff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_MAP_PORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_FLAG
// MAP_MAC desc: 
typedef union {
    struct {
        uint128_t  MAC                  :  48;    //  Ethernet MAC Key. Ignored
                                                 // bits must be set to 0.
        uint128_t  IGNORE_LENGTH        :   6;    //  Ignore this many LSB bits
                                                 // when matching
        uint128_t  VALID                :   4;    //  [list] [*] bit 0 = entry
                                                 // valid for outer DMAC [*] bit
                                                 // 1 = entry valid for outer SMAC
                                                 // [*] bit 2 = entry valid for
                                                 // inner DMAC [*] bit 3 = entry
                                                 // valid for inner SMAC [/list]
        uint128_t  MAP_MAC              :   8;    //  8-bit mapped MAC
        uint128_t  MAC_ROUTABLE         :   1;    //  Is this a virtual router
                                                 // destination MAC?
        uint128_t  RSVD_0               :  61;    // Nebulon auto filled RSVD [127:67]

    }                                field;
    uint128_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_SIZE 128
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_BITFIELD_COUNT 0x05
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_MSB 0x002f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_RANGE 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_MASK 0xffffffffffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_IGNORE_LENGTH_LSB 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_IGNORE_LENGTH_MSB 0x0035
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_IGNORE_LENGTH_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_IGNORE_LENGTH_MASK 0x3f000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_IGNORE_LENGTH_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_VALID_LSB 0x0036
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_VALID_MSB 0x0039
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_VALID_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_VALID_MASK 0x3c0000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_VALID_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAP_MAC_LSB 0x003a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAP_MAC_MSB 0x0041
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAP_MAC_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAP_MAC_MASK 0xfc00000000000003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAP_MAC_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_ROUTABLE_LSB 0x0042
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_ROUTABLE_MSB 0x0042
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_ROUTABLE_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_ROUTABLE_MASK 0x00000004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_MAC_ROUTABLE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_FLAG
// MAP_IP_LO desc:  Configures low 64-bit key of 128-bit to 4-bit IP address mapping.
// [br][br] For IPv4, set to all zeros and use MAP_IP_HI.IP_HI[63:32]
// for the address prefix key.
typedef union {
    struct {
        uint64_t  IP_LO                :  64;    //  Low 64 bits of IP address
                                                 // prefix key. Ignored bits must
                                                 // be set to 0.

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_OFFSET 0x80
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_IP_LO_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_IP_LO_MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_IP_LO_RANGE 0x0040
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_IP_LO_MASK 0xffffffffffffffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_IP_LO_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_FLAG
// MAP_IP_HI desc:  Configures high 64-bit key of 128-bit to 4-bit IP address mapping
typedef union {
    struct {
        uint64_t  IP_HI                :  64;    //  High 64 bits of IP address
                                                 // prefix key. For IPv4, only
                                                 // bits 63:32 are used. Ignored
                                                 // bits must be set to 0.

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_IP_HI_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_IP_HI_MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_IP_HI_RANGE 0x0040
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_IP_HI_MASK 0xffffffffffffffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_IP_HI_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_FLAG
// MAP_IP_CFG desc: 
typedef union {
    struct {
        uint64_t  IS_IPV6              :   1;    //  [list] [*] If set, header
                                                 // must be ipv6 to match. [*] If
                                                 // clear, header must be ipv4 to
                                                 // match. [/list]
        uint64_t  IP_PROFILE           :   2;    //  2-bit value to feed into
                                                 // packet profile CAM
        uint64_t  MAP_IP               :   4;    //  4-bit mapped IP address
        uint64_t  VALID                :   4;    //  [list] [*] bit 0 = entry
                                                 // valid for outer DIP [*] bit 1
                                                 // = entry valid for outer SIP
                                                 // [*] bit 2 = entry valid for
                                                 // inner DIP [*] bit 3 = entry
                                                 // valid for inner SIP [/list]
        uint64_t  MATCH_LENGTH         :   8;    //  Ignore (128 - MATCH_LENGTH)
                                                 // many LSB bits when matching
        uint64_t  RSVD_0               :  45;    // Nebulon auto filled RSVD [63:19]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_OFFSET 0x80
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_BITFIELD_COUNT 0x05
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IS_IPV6_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IS_IPV6_MSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IS_IPV6_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IS_IPV6_MASK 0x00000001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IS_IPV6_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IP_PROFILE_LSB 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IP_PROFILE_MSB 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IP_PROFILE_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IP_PROFILE_MASK 0x00000006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_IP_PROFILE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MAP_IP_LSB 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MAP_IP_MSB 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MAP_IP_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MAP_IP_MASK 0x00000078
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MAP_IP_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_VALID_LSB 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_VALID_MSB 0x000a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_VALID_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_VALID_MASK 0x00000780
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_VALID_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MATCH_LENGTH_LSB 0x000b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MATCH_LENGTH_MSB 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MATCH_LENGTH_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MATCH_LENGTH_MASK 0x0007f800
#define MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_MATCH_LENGTH_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_FLAG
// MAP_PROT desc:  The same mapping is used for both inner and outer PROT.
typedef union {
    struct {
        uint64_t  PROT                 :   8;    //  Input IP protocol number
        uint64_t  MAP_PROT             :   3;    //  3-bit mapped IP protocol
                                                 // number
        uint64_t  RSVD_0               :  53;    // Nebulon auto filled RSVD [63:11]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_BITFIELD_COUNT 0x02
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_PROT_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_PROT_MSB 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_PROT_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_PROT_MASK 0x000000ff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_PROT_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_MAP_PROT_LSB 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_MAP_PROT_MSB 0x000a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_MAP_PROT_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_MAP_PROT_MASK 0x00000700
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_MAP_PROT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_FLAG
// MAP_L4_SRC desc: 
typedef union {
    struct {
        uint64_t  L4_SRC               :  16;    //  L4 source port key
        uint64_t  MAP_PROT             :   3;    //  3-bit MAP_PROT key that must
                                                 // match to enable this entry
        uint64_t  VALID                :   2;    //  [list] [*] bit 0 = this
                                                 // entry valid for outer L4_src
                                                 // [*] bit 1 = this entry valid
                                                 // for inner L4_src [/list]
        uint64_t  MAP_L4_SRC           :  16;    //  Mapped result
        uint64_t  RSVD_0               :  27;    // Nebulon auto filled RSVD [63:37]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_BITFIELD_COUNT 0x04
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_L4_SRC_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_L4_SRC_MSB 0x000f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_L4_SRC_RANGE 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_L4_SRC_MASK 0x0000ffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_L4_SRC_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_PROT_LSB 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_PROT_MSB 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_PROT_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_PROT_MASK 0x00070000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_PROT_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_VALID_LSB 0x0013
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_VALID_MSB 0x0014
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_VALID_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_VALID_MASK 0x00180000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_VALID_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_L4_SRC_LSB 0x0015
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_L4_SRC_MSB 0x0024
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_L4_SRC_RANGE 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_L4_SRC_MASK 0x1fffe00000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_MAP_L4_SRC_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_FLAG
// MAP_L4_DST desc: 
typedef union {
    struct {
        uint64_t  L4_DST               :  16;    //  L4 destination port key
        uint64_t  MAP_PROT             :   3;    //  3-bit MAP_PROT key that must
                                                 // match to enable this entry
        uint64_t  VALID                :   2;    //  [list] [*] bit 0 = this
                                                 // entry valid for outer L4_dst
                                                 // [*] bit 1 = this entry valid
                                                 // for inner L4_dst [/list]
        uint64_t  MAP_L4_DST           :  16;    //  Mapped result
        uint64_t  RSVD_0               :  27;    // Nebulon auto filled RSVD [63:37]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_BITFIELD_COUNT 0x04
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_L4_DST_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_L4_DST_MSB 0x000f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_L4_DST_RANGE 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_L4_DST_MASK 0x0000ffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_L4_DST_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_PROT_LSB 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_PROT_MSB 0x0012
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_PROT_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_PROT_MASK 0x00070000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_PROT_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_VALID_LSB 0x0013
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_VALID_MSB 0x0014
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_VALID_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_VALID_MASK 0x00180000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_VALID_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_L4_DST_LSB 0x0015
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_L4_DST_MSB 0x0024
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_L4_DST_RANGE 0x0010
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_L4_DST_MASK 0x1fffe00000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_MAP_L4_DST_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_FLAG
// MAP_EXP_TC desc:  Indexed by 5-bit priority_profile.Refer to QoS Chapter Priority
// Management for programming guide. One field for each possible ingress
// EXP value.
typedef union {
    struct {
        uint64_t  TC_BY_EXP            :  24;    //  Defines the TC associated
                                                 // with this ingress EXP. Laid
                                                 // out as an array of 8 3-bit
                                                 // integers, in little-endian
                                                 // order. The TC associated with
                                                 // EXP x is located at bits [ 3x
                                                 // : 3(x+1) )
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_TC_BY_EXP_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_TC_BY_EXP_MSB 0x0017
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_TC_BY_EXP_RANGE 0x0018
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_TC_BY_EXP_MASK 0x00ffffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_TC_BY_EXP_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_FLAG
// MAP_DSCP_TC desc:  Indexed by {priority_profile[4:0], dscp[5:0]}. Refer to QoS Chapter
// Priority Management for programming guide.
typedef union {
    struct {
        uint64_t  DSCP                 :   6;    //  internal DSCP to set for
                                                 // this ingress DSCP
        uint64_t  TC                   :   3;    //  TC to set for this ingress
                                                 // DSCP
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_BITFIELD_COUNT 0x02
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_DSCP_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_DSCP_MSB 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_DSCP_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_DSCP_MASK 0x0000003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_DSCP_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_TC_LSB 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_TC_MSB 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_TC_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_TC_MASK 0x000001c0
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_TC_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_FLAG
// MAP_VPRI_TC desc:  Indexed by 5-bit priority_profile. Refer to QoS Chapter Priority
// Management for programming guide. One field for each possible ingress
// VPRI value.
typedef union {
    struct {
        uint64_t  TC_BY_VPRI           :  48;    //  Defines the TC associated
                                                 // with this ingress VPRI. Laid
                                                 // out as an array of 16 3-bit
                                                 // integers, in little-endian
                                                 // order. The TC associated with
                                                 // VPRI v is located at bits [ 3v
                                                 // : 3(v+1) )
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_TC_BY_VPRI_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_TC_BY_VPRI_MSB 0x002f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_TC_BY_VPRI_RANGE 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_TC_BY_VPRI_MASK 0xffffffffffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_TC_BY_VPRI_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_FLAG
// MAP_VPRI desc:  Indexed by 5-bit priority_profile. One field for each possible
// ingress VPRI value.
typedef union {
    struct {
        uint64_t  VPRI_BY_VPRI         :  64;    //  Defines the internal VPRI
                                                 // associated with each ingress
                                                 // VPRI. Laid out as an array of
                                                 // 16 4-bit integers, in
                                                 // little-endian order. The
                                                 // internal VPRI associated with
                                                 // ingress VPRI v is located at
                                                 // bits [ 4v : 4(v+1) )

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_VPRI_BY_VPRI_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_VPRI_BY_VPRI_MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_VPRI_BY_VPRI_RANGE 0x0040
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_VPRI_BY_VPRI_MASK 0xffffffffffffffff
#define MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_VPRI_BY_VPRI_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAG
// MAP_PROFILE_KEY0 desc:  Packet profile KEY0 is parser flags. This register provides the key
// values to compare against. The same format is used for key and key
// invert. [br][br] The table below shows the encoded data value stored
// (Content) based on the Key and KeyInvert values. [code]
// +-----------------------------------------------------+ | KeyInvert |
// Key | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code]
// [br][br] The MAP_PROFILE_ACTION having the same index as the
// highest-numbered matching key is used.
typedef union {
    struct {
        uint64_t  RSVD                 :   1;    //  Reserved. Set to 0. Parser
                                                 // flag 0 is not used.
        uint64_t  FLAGS                :  47;    //  parser flags 47..1
        uint64_t  IHL_FITS             :   1;    //  Indicates that the payload
                                                 // length is at least 4*IHL, or
                                                 // the packet is not IPv4.
        uint64_t  IHL_OK               :   1;    //  Indicates that the IHL is at
                                                 // least 5 or the packet is not
                                                 // IPv4.
        uint64_t  _RSVD0_              :   4;    //  Reserved
        uint64_t  CSUM                 :   2;    //  For non-IPv4 packets, both
                                                 // of these bits are 1. For IPv4
                                                 // packets, these bits indicate
                                                 // the validity of the IP header
                                                 // checksum field: [list] [*]
                                                 // csum[0] indicates if the outer
                                                 // IP header checksum is valid
                                                 // [*] csum[1] indicates if the
                                                 // inner IP header checksum is
                                                 // valid [/list]
        uint64_t  EX                   :   3;    //  ex[2]=depth_exceed,
                                                 // ex[1]=trunc_header,
                                                 // ex[0]=parsing_done
        uint64_t  PTRS_ERR             :   1;    //  An error occured in pointer
                                                 // calculation for parser_info,
                                                 // indicating a header length is
                                                 // too small. ptrs_err=0 in
                                                 // windowed parsing mode.
        uint64_t  _RSVD1_              :   4;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_BITFIELD_COUNT 0x09
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_RESET 0xfc4000000000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_RSVD_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_RSVD_MSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_RSVD_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_RSVD_MASK 0x00000001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_RSVD_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAGS_LSB 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAGS_MSB 0x002f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAGS_RANGE 0x002f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAGS_MASK 0xfffffffffffe
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_FLAGS_RESET_VALUE 0x7fffffffffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_FITS_LSB 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_FITS_MSB 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_FITS_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_FITS_MASK 0x1000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_FITS_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_OK_LSB 0x0031
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_OK_MSB 0x0031
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_OK_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_OK_MASK 0x2000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_IHL_OK_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD0__LSB 0x0032
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD0__MSB 0x0035
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD0__RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD0__MASK 0x3c000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_CSUM_LSB 0x0036
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_CSUM_MSB 0x0037
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_CSUM_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_CSUM_MASK 0xc0000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_CSUM_RESET_VALUE 0x00000003

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_EX_LSB 0x0038
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_EX_MSB 0x003a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_EX_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_EX_MASK 0x700000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_EX_RESET_VALUE 0x00000007

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_PTRS_ERR_LSB 0x003b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_PTRS_ERR_MSB 0x003b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_PTRS_ERR_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_PTRS_ERR_MASK 0x800000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_PTRS_ERR_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD1__LSB 0x003c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD1__MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD1__RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD1__MASK 0xf000000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0__RSVD1__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAG
// MAP_PROFILE_KEY_INVERT0 desc:  Packet profile KEY0 is parser flags. This register selects which
// key bits to compare. The same format is used for key and key invert.
// [br][br] The table below shows the encoded data value stored
// (Content) based on the Key and KeyInvert values. [code]
// +-----------------------------------------------------+ | KeyInvert |
// Key | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// MAP_PROFILE_ACTION having the same index as the highest-numbered
// matching key is used.
typedef union {
    struct {
        uint64_t  RSVD                 :   1;    //  Reserved. Set to 0. Parser
                                                 // flag 0 is not used.
        uint64_t  FLAGS                :  47;    //  parser flags 47..1
        uint64_t  IHL_FITS             :   1;    //  Indicates that the payload
                                                 // length is at least 4*IHL, or
                                                 // the packet is not IPv4.
        uint64_t  IHL_OK               :   1;    //  Indicates that the IHL is at
                                                 // least 5 or the packet is not
                                                 // IPv4.
        uint64_t  _RSVD0_              :   4;    //  Reserved
        uint64_t  CSUM                 :   2;    //  parser IPv4 checksum results
        uint64_t  EX                   :   3;    //  ex[2]=depth_exceed,
                                                 // ex[1]=trunc_header,
                                                 // ex[0]=parsing_done
        uint64_t  PTRS_ERR             :   1;    //  An error occured in pointer
                                                 // calculation for parser_info,
                                                 // indicating a header length
                                                 // too small or not having the
                                                 // expected residue mod 4.
                                                 // ptrs_err=0 in windowed parsing
                                                 // mode.
        uint64_t  _RSVD1_              :   4;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_BITFIELD_COUNT 0x09
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_RESET 0xfc4000000000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_RSVD_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_RSVD_MSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_RSVD_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_RSVD_MASK 0x00000001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_RSVD_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAGS_LSB 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAGS_MSB 0x002f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAGS_RANGE 0x002f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAGS_MASK 0xfffffffffffe
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_FLAGS_RESET_VALUE 0x7fffffffffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_FITS_LSB 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_FITS_MSB 0x0030
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_FITS_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_FITS_MASK 0x1000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_FITS_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_OK_LSB 0x0031
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_OK_MSB 0x0031
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_OK_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_OK_MASK 0x2000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_IHL_OK_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD0__LSB 0x0032
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD0__MSB 0x0035
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD0__RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD0__MASK 0x3c000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_CSUM_LSB 0x0036
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_CSUM_MSB 0x0037
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_CSUM_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_CSUM_MASK 0xc0000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_CSUM_RESET_VALUE 0x00000003

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_EX_LSB 0x0038
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_EX_MSB 0x003a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_EX_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_EX_MASK 0x700000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_EX_RESET_VALUE 0x00000007

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_PTRS_ERR_LSB 0x003b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_PTRS_ERR_MSB 0x003b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_PTRS_ERR_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_PTRS_ERR_MASK 0x800000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_PTRS_ERR_RESET_VALUE 0x00000001

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD1__LSB 0x003c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD1__MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD1__RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD1__MASK 0xf000000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0__RSVD1__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_FLAG
// MAP_PROFILE_KEY1 desc:  Packet profile KEY1 is mapping. This register provides the key
// values to compare against. The same format is used for key and key
// invert. [br][br] The table below shows the encoded data value stored
// (Content) based on the Key and KeyInvert values. [code]
// +-----------------------------------------------------+ | KeyInvert |
// Key | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// MAP_PROFILE_ACTION having the same index as the highest-numbered
// matching key is used.
typedef union {
    struct {
        uint64_t  MAC_MBCAST           :   2;    //  [list] [*] mac_mbcast[0] =
                                                 // outer DMAC multicast bit set
                                                 // [*] mac_mbcast[1] = outer DMAC
                                                 // is broadcast address [/list]
        uint64_t  MAC_ROUTABLE         :   4;    //  [list] [*] mac_routable[0]
                                                 // = outer DMAC routable [*]
                                                 // mac_routable[1] = outer SMAC
                                                 // routable [*] mac_routable[2]
                                                 // = inner DMAC routable [*]
                                                 // mac_routable[3] = inner SMAC
                                                 // routable [/list]
        uint64_t  DOMAIN_PROFILE       :   8;    //  8 bits from
                                                 // MAP_DOMAIN_ACTION
        uint64_t  PORT_PROFILE         :   8;    //  8 bits from MAP_PORT_CFG
        uint64_t  _RSVD0_              :   4;    //  Reserved
        uint64_t  L3_DOMAIN            :   6;    //  Provided by
                                                 // MAP_DOMAIN_ACTION0.
        uint64_t  L2_DOMAIN            :   8;    //  Provided by
                                                 // MAP_DOMAIN_ACTION0 or
                                                 // specified by the CPU in
                                                 // packet metadata.
        uint64_t  PTYPE                :  10;    //  From parser, representing a
                                                 // digest of the parser flags
        uint64_t  _RSVD1_              :  14;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_BITFIELD_COUNT 0x09
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_RESET 0xfffc3fffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_MBCAST_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_MBCAST_MSB 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_MBCAST_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_MBCAST_MASK 0x00000003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_MBCAST_RESET_VALUE 0x00000003

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_ROUTABLE_LSB 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_ROUTABLE_MSB 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_ROUTABLE_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_ROUTABLE_MASK 0x0000003c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_MAC_ROUTABLE_RESET_VALUE 0x0000000f

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_DOMAIN_PROFILE_LSB 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_DOMAIN_PROFILE_MSB 0x000d
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_DOMAIN_PROFILE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_DOMAIN_PROFILE_MASK 0x00003fc0
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_DOMAIN_PROFILE_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PORT_PROFILE_LSB 0x000e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PORT_PROFILE_MSB 0x0015
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PORT_PROFILE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PORT_PROFILE_MASK 0x003fc000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PORT_PROFILE_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD0__LSB 0x0016
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD0__MSB 0x0019
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD0__RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD0__MASK 0x03c00000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L3_DOMAIN_LSB 0x001a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L3_DOMAIN_MSB 0x001f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L3_DOMAIN_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L3_DOMAIN_MASK 0xfc000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L3_DOMAIN_RESET_VALUE 0x0000003f

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L2_DOMAIN_LSB 0x0020
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L2_DOMAIN_MSB 0x0027
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L2_DOMAIN_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L2_DOMAIN_MASK 0xff00000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_L2_DOMAIN_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PTYPE_LSB 0x0028
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PTYPE_MSB 0x0031
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PTYPE_RANGE 0x000a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PTYPE_MASK 0x3ff0000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_PTYPE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD1__LSB 0x0032
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD1__MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD1__RANGE 0x000e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD1__MASK 0xfffc000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1__RSVD1__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_FLAG
// MAP_PROFILE_KEY_INVERT1 desc:  Packet profile KEY1 is mapping. This register selects which key
// bits to compare. The same format is used for key and key invert.
// [br][br] The table below shows the encoded data value stored
// (Content) based on the Key and KeyInvert values. [code]
// +-----------------------------------------------------+ | KeyInvert |
// Key | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// MAP_PROFILE_ACTION having the same index as the highest-numbered
// matching key is used.
typedef union {
    struct {
        uint64_t  MAC_MBCAST           :   2;    //  [list] [*] mac_mbcast[0] =
                                                 // outer DMAC multicast bit set
                                                 // [*] mac_mbcast[1] = outer DMAC
                                                 // is broadcast address [/list]
        uint64_t  MAC_ROUTABLE         :   4;    //  [list] [*] mac_routable[0]
                                                 // = outer DMAC routable [*]
                                                 // mac_routable[1] = outer SMAC
                                                 // routable [*] mac_routable[2]
                                                 // = inner DMAC routable [*]
                                                 // mac_routable[3] = inner SMAC
                                                 // routable [/list]
        uint64_t  DOMAIN_PROFILE       :   8;    //  8 bits from port
                                                 // configuration
        uint64_t  PORT_PROFILE         :   8;    //  8 bits from MAP_PORT_CFG
        uint64_t  _RSVD0_              :   4;    //  Reserved
        uint64_t  L3_DOMAIN            :   6;    //  Provided by
                                                 // MAP_DOMAIN_ACTION0.
        uint64_t  L2_DOMAIN            :   8;    //  Provided by
                                                 // MAP_DOMAIN_ACTION0 or
                                                 // specified by the CPU in
                                                 // packet metadata.
        uint64_t  PTYPE                :  10;    //  From parser, representing a
                                                 // digest of the parser flags
        uint64_t  _RSVD1_              :  14;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_BITFIELD_COUNT 0x09
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_RESET 0xfffc3fffff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_MBCAST_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_MBCAST_MSB 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_MBCAST_RANGE 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_MBCAST_MASK 0x00000003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_MBCAST_RESET_VALUE 0x00000003

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_ROUTABLE_LSB 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_ROUTABLE_MSB 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_ROUTABLE_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_ROUTABLE_MASK 0x0000003c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_MAC_ROUTABLE_RESET_VALUE 0x0000000f

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_DOMAIN_PROFILE_LSB 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_DOMAIN_PROFILE_MSB 0x000d
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_DOMAIN_PROFILE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_DOMAIN_PROFILE_MASK 0x00003fc0
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_DOMAIN_PROFILE_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PORT_PROFILE_LSB 0x000e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PORT_PROFILE_MSB 0x0015
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PORT_PROFILE_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PORT_PROFILE_MASK 0x003fc000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PORT_PROFILE_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD0__LSB 0x0016
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD0__MSB 0x0019
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD0__RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD0__MASK 0x03c00000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L3_DOMAIN_LSB 0x001a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L3_DOMAIN_MSB 0x001f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L3_DOMAIN_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L3_DOMAIN_MASK 0xfc000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L3_DOMAIN_RESET_VALUE 0x0000003f

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L2_DOMAIN_LSB 0x0020
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L2_DOMAIN_MSB 0x0027
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L2_DOMAIN_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L2_DOMAIN_MASK 0xff00000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_L2_DOMAIN_RESET_VALUE 0x000000ff

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PTYPE_LSB 0x0028
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PTYPE_MSB 0x0031
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PTYPE_RANGE 0x000a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PTYPE_MASK 0x3ff0000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_PTYPE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD1__LSB 0x0032
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD1__MSB 0x003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD1__RANGE 0x000e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD1__MASK 0xfffc000000000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1__RSVD1__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_FLAG
// MAP_PROFILE_ACTION desc:  The packet profile mapper is used for three functions: [list] [*]
// For packet profile and key-rewrite generation the mapper produces a
// packet profile value and key rewrite profile, based on the highest
// matching rule that has profile_valid=1 [*] For trigger ID generation,
// the mapper produces a downstream trigger ID value, based on the
// higest matching rule that has trig_valid=1 [*] For priority profile
// selection, the mapper provides input as to how VPRI and DSCP are
// remapped, based on the highest matching rule that has prios_valid=1
// [/list] An entry may have multiple valid bits set, allowing the entry
// to participate in more than one resolution (and thus produce more
// then one set of outputs). For example a rule may generate both packet
// profile and a trigger ID.
typedef union {
    struct {
        uint64_t  DSCP_TGT             :   3;    //  Bit vector selecting which
                                                 // DSCPs to apply the
                                                 // p=priority_profile translation
                                                 // to. [br][br] If bit 0 is
                                                 // set: key8[OUTER_DS].vpri =
                                                 // MAP_DSCP_TC[p, key8
                                                 // [OUTER_DS].dscp].dscp
                                                 // [br][br] If bit 1 is set:
                                                 // key8 [INNER_DS].dscp =
                                                 // MAP_DSCP_TC[p, key8
                                                 // [INNER_DS].dscp].dscp
                                                 // [br][br] If bit 2 is set:
                                                 // act4[DSCP_HI:DSCP_LO] =
                                                 // MAP_DSCP_TC[p, key8
                                                 // [OUTER_DS].dscp].dscp
                                                 // [br][br] dscp_tgt takes
                                                 // precedence over key rewrite in
                                                 // the case of conflict. Multiple
                                                 // bits may be set.
        uint64_t  VPRI_TGT             :   3;    //  Bit vector selecting which
                                                 // VPRIs to apply the
                                                 // p=priority_profile translation
                                                 // to. [br][br] If bit 0 is
                                                 // set: key16[OUTER_VLAN1].vpri
                                                 // = MAP_VPRI[p,
                                                 // key16[OUTER_VLAN1].vpri]
                                                 // [br][br] If bit 1 is set:
                                                 // key16[INNER_VLAN1].vpri =
                                                 // MAP_VPRI[p,
                                                 // key16[INNER_VLAN1].vpri]
                                                 // [br][br] If bit 2 is set:
                                                 // act4[VPRI0] = act4[VPRI1] =
                                                 // MAP_VPRI[p,
                                                 // key16[OUTER_VLAN1].vpri]
                                                 // [br][br] vpri_tgt takes
                                                 // precedence over key rewrite in
                                                 // the case of conflict. Multiple
                                                 // bits may be set.
        uint64_t  PRIOS_VALID          :   1;    //  When prios_valid is set,
                                                 // this rule participates in
                                                 // MAP_PROFILE_ACTION priority
                                                 // resolution. The vpri_tgt and
                                                 // dscp_tgt for the
                                                 // highest-numbered matching rule
                                                 // having prios_valid are used.
        uint64_t  IP_OPTIONS_MASK      :   7;    //  Mask to select which parser
                                                 // flags will generate
                                                 // TRAP_IP_OPTIONS. The formula
                                                 // is as follows, where:[br]
                                                 // otr_opt_flags[6] = IPv4
                                                 // case[br] otr_opt_flags[5:0]
                                                 // from parser[br]
                                                 // inr_opt_flags[6] = IPv4
                                                 // case[br] inr_opt_flags[5:0]
                                                 // from parser [list] [*]
                                                 // otr_opt_flags = {otr_l3_v &&
                                                 // !otr_v6 && otr_l3_len > 20,
                                                 // parser_flags[37:32]} [*]
                                                 // inr_opt_flags = {inr_l3_v &&
                                                 // !inr_v6 && inr_l3_len > 20,
                                                 // parser_flags[43:38]} [*]
                                                 // ip_options[0] =
                                                 // |(ip_options_mask &
                                                 // otr_opt_flags) [*]
                                                 // ip_options[1] =
                                                 // |(ip_options_mask &
                                                 // inr_opt_flags) [/list]
                                                 // Finally trap_ip_options =
                                                 // ip_options[mod_idx.decap]
        uint64_t  PARSER_ERROR         :   1;    //  Generate a parser_error
                                                 // action in Fwd, which will drop
                                                 // the packet. parser_error is
                                                 // logged in RX_STATS bank 2, bin
                                                 // 3.
        uint64_t  PROFILE_TRIG         :   8;    //  Default triggers value to
                                                 // use. (for handling
                                                 // DHCP/BOOTP/ARP/ICMP, tagging
                                                 // violation, parse error, etc.)
        uint64_t  TRIG_VALID           :   1;    //  When trig_valid is set, this
                                                 // rule participates in
                                                 // MAP_PROFILE_ACTION triggers
                                                 // resolution. The profile_trig
                                                 // value, parser_error, and
                                                 // ip_options_mask for the
                                                 // highest-numbered matching rule
                                                 // having trig_valid are used.
        uint64_t  REWRITE_PROFILE      :   4;    //  When profile_valid is set,
                                                 // this field selects which
                                                 // profile in MAP_REWRITE to use.
        uint64_t  PROFILE              :   6;    //  Initial packet profile value
                                                 // for Classifier
        uint64_t  PROFILE_VALID        :   1;    //  When profile_valid is set,
                                                 // this rule participates in
                                                 // MAP_PROFILE_ACTION profile
                                                 // resolution. The packet
                                                 // profile and MAP_REWRITE values
                                                 // for the highest-numbered
                                                 // matching rule having
                                                 // profile_valid are used.
        uint64_t  RSVD_0               :  29;    // Nebulon auto filled RSVD [63:35]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_BITFIELD_COUNT 0x0a
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_DSCP_TGT_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_DSCP_TGT_MSB 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_DSCP_TGT_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_DSCP_TGT_MASK 0x00000007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_DSCP_TGT_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_VPRI_TGT_LSB 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_VPRI_TGT_MSB 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_VPRI_TGT_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_VPRI_TGT_MASK 0x00000038
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_VPRI_TGT_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PRIOS_VALID_LSB 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PRIOS_VALID_MSB 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PRIOS_VALID_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PRIOS_VALID_MASK 0x00000040
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PRIOS_VALID_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_IP_OPTIONS_MASK_LSB 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_IP_OPTIONS_MASK_MSB 0x000d
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_IP_OPTIONS_MASK_RANGE 0x0007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_IP_OPTIONS_MASK_MASK 0x00003f80
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_IP_OPTIONS_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PARSER_ERROR_LSB 0x000e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PARSER_ERROR_MSB 0x000e
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PARSER_ERROR_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PARSER_ERROR_MASK 0x00004000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PARSER_ERROR_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_TRIG_LSB 0x000f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_TRIG_MSB 0x0016
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_TRIG_RANGE 0x0008
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_TRIG_MASK 0x007f8000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_TRIG_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_TRIG_VALID_LSB 0x0017
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_TRIG_VALID_MSB 0x0017
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_TRIG_VALID_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_TRIG_VALID_MASK 0x00800000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_TRIG_VALID_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_REWRITE_PROFILE_LSB 0x0018
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_REWRITE_PROFILE_MSB 0x001b
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_REWRITE_PROFILE_RANGE 0x0004
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_REWRITE_PROFILE_MASK 0x0f000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_REWRITE_PROFILE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_LSB 0x001c
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_MSB 0x0021
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_MASK 0x3f0000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_VALID_LSB 0x0022
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_VALID_MSB 0x0022
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_VALID_RANGE 0x0001
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_VALID_MASK 0x400000000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_PROFILE_VALID_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_FLAG
// MAP_DOMAIN_POL_CFG desc: 
typedef union {
    struct {
        uint64_t  L2_COLOR_CFG         :   3;    //  Provides the G/Y/R
                                                 // linked-counter enables for the
                                                 // policer command associated
                                                 // with the L2 policer output of
                                                 // MAP_DOMAIN_ACTION1.
        uint64_t  L3_COLOR_CFG         :   3;    //  Provides the G/Y/R
                                                 // linked-counter enables for the
                                                 // policer command associated
                                                 // with the L3 policer output of
                                                 // MAP_DOMAIN_ACTION1.
        uint64_t  RSVD_0               :  58;    // Nebulon auto filled RSVD [63:6]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_BITFIELD_COUNT 0x02
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L2_COLOR_CFG_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L2_COLOR_CFG_MSB 0x0002
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L2_COLOR_CFG_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L2_COLOR_CFG_MASK 0x00000007
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L2_COLOR_CFG_RESET_VALUE 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L3_COLOR_CFG_LSB 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L3_COLOR_CFG_MSB 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L3_COLOR_CFG_RANGE 0x0003
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L3_COLOR_CFG_MASK 0x00000038
#define MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_L3_COLOR_CFG_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_FLAG
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_FLAG
// MAP_REWRITE desc:  This register is indexed by the output of the rewrite_profile output
// of the packet profile CAM.rule number, and by target nybble.
typedef union {
    struct {
        uint64_t  SRC_ID               :   6;    //  Select which rewrite source
                                                 // nybble to use for this target
                                                 // nybble. If src_id=0, then do
                                                 // not rewrite the target nybble
                                                 // (leave as received from
                                                 // parser).
        uint64_t  RSVD_0               :  58;    // Nebulon auto filled RSVD [63:6]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_t;
#endif
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_OFFSET 0x00
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SCOPE 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SIZE 64
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_BITFIELD_COUNT 0x01
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_RESET 0x00000000

#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SRC_ID_LSB 0x0000
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SRC_ID_MSB 0x0005
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SRC_ID_RANGE 0x0006
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SRC_ID_MASK 0x0000003f
#define MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_SRC_ID_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_CFG_t MAP_PORT_CFG[18]; // offset 4'h0, width 64
    uint8_t                    rsvd0[368];
    // starting the regfile section
    struct {
        MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_DEFAULT_t MAP_PORT_DEFAULT[6]; // offset 4'h0, width 64
    } MAP_PORT_DEFAULT[18];                      // offset 12'h200, size: 48
    uint8_t                    rsvd1[64160];
    MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_TCAM_t MAP_DOMAIN_TCAM[4096]; // offset 20'h10000, width 128
    MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION0_t MAP_DOMAIN_ACTION0[4096]; // offset 20'h20000, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_ACTION1_t MAP_DOMAIN_ACTION1[4096]; // offset 20'h28000, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_PROFILE_t MAP_DOMAIN_PROFILE[256]; // offset 20'h30000, width 64
    uint8_t                    rsvd2[2048];
    MBY_PPE_MAPPER_MAP_MSG_MAP_PORT_t MAP_PORT[18];     // offset 20'h31000, width 64
    uint8_t                    rsvd3[1904];
    MBY_PPE_MAPPER_MAP_MSG_MAP_MAC_t MAP_MAC[96];      // offset 20'h31800, width 128
    uint8_t                    rsvd4[640];
    MBY_PPE_MAPPER_MAP_MSG_MAP_IP_LO_t MAP_IP_LO[16];    // offset 20'h32080, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_IP_HI_t MAP_IP_HI[16];    // offset 20'h32100, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_IP_CFG_t MAP_IP_CFG[16];   // offset 20'h32180, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_PROT_t MAP_PROT[8];      // offset 20'h32200, width 64
    uint8_t                    rsvd5[448];
    MBY_PPE_MAPPER_MAP_MSG_MAP_L4_SRC_t MAP_L4_SRC[64];   // offset 20'h32400, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_L4_DST_t MAP_L4_DST[64];   // offset 20'h32600, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_EXP_TC_t MAP_EXP_TC[32];   // offset 20'h32800, width 64
    uint8_t                    rsvd6[5888];
    MBY_PPE_MAPPER_MAP_MSG_MAP_DSCP_TC_t MAP_DSCP_TC[2048]; // offset 20'h34000, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_TC_t MAP_VPRI_TC[32];  // offset 20'h38000, width 64
    MBY_PPE_MAPPER_MAP_MSG_MAP_VPRI_t MAP_VPRI[32];     // offset 20'h38100, width 64
    uint8_t                    rsvd7[512];
    MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY0_t MAP_PROFILE_KEY0[96]; // offset 20'h38400, width 64
    uint8_t                    rsvd8[256];
    MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT0_t MAP_PROFILE_KEY_INVERT0[96]; // offset 20'h38800, width 64
    uint8_t                    rsvd9[256];
    MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY1_t MAP_PROFILE_KEY1[96]; // offset 20'h38C00, width 64
    uint8_t                    rsvd10[256];
    MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_KEY_INVERT1_t MAP_PROFILE_KEY_INVERT1[96]; // offset 20'h39000, width 64
    uint8_t                    rsvd11[256];
    MBY_PPE_MAPPER_MAP_MSG_MAP_PROFILE_ACTION_t MAP_PROFILE_ACTION[96]; // offset 20'h39400, width 64
    uint8_t                    rsvd12[256];
    MBY_PPE_MAPPER_MAP_MSG_MAP_DOMAIN_POL_CFG_t MAP_DOMAIN_POL_CFG; // offset 20'h39800, width 64
    uint8_t                    rsvd13[2040];
    // starting the regfile section
    struct {
        MBY_PPE_MAPPER_MAP_MSG_MAP_REWRITE_t MAP_REWRITE[32];  // offset 4'h0, width 64
    } MAP_REWRITE[16];                           // offset 20'h3A000, size: 256
} mby_ppe_mapper_map_t;                          // size:  20'h3B000


#endif // _MBY_PPE_MAPPER_MAP_REGS_H_


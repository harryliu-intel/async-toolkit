//                                                                             
// File:            mby_ppe_cm_apply_map_regs.h                                
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_CM_APPLY_MAP_REGS_H_
#define _MBY_PPE_CM_APPLY_MAP_REGS_H_

#define CM_APPLY_MSGPORT     0x0
#define CM_APPLY_CM_APPLY_TX_SOFTDROP_CFG_MSGREGADDR 0x0
#define CM_APPLY_CM_APPLY_TX_TC_STATE_MSGREGADDR 0x1000
#define CM_APPLY_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_MSGREGADDR 0x2000
#define CM_APPLY_CM_APPLY_RX_SMP_STATE_MSGREGADDR 0x3000
#define CM_APPLY_CM_APPLY_MIRROR_PROFILE_TABLE_MSGREGADDR 0x3200
#define CM_APPLY_CM_APPLY_DROP_COUNT_MSGREGADDR 0x3400
#define CM_APPLY_CM_APPLY_LOOPBACK_SUPPRESS_MSGREGADDR 0x3500
#define CM_APPLY_CM_APPLY_SOFTDROP_CFG_MSGREGADDR 0x3600
#define CM_APPLY_CM_APPLY_SOFTDROP_STATE_MSGREGADDR 0x3640
#define CM_APPLY_CM_APPLY_TRAP_GLORT_MSGREGADDR 0x3680
#define CM_APPLY_CM_APPLY_TC_TO_SMP_MSGREGADDR 0x3700
#define CM_APPLY_CM_APPLY_MCAST_EPOCH_MSGREGADDR 0x3708
#define CM_APPLY_CM_APPLY_STATE_MSGREGADDR 0x3710
#define CM_APPLY_CM_APPLY_CPU_TRAP_MASK_MSGREGADDR 0x3718
#define CM_APPLY_CM_APPLY_LOG_MIRROR_PROFILE_MSGREGADDR 0x3720
#define CM_APPLY_CM_APPLY_QCN_CFG_MSGREGADDR 0x3728

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_FLAG
// CM_APPLY_TX_SOFTDROP_CFG desc:  Specifies soft drop configuration per TX port and switch priority.
typedef union {
    struct {
        uint64_t  SOFT_DROP_ON_SMP_FREE :   1;    //  Enables dynamic soft drop
                                                 // with drop probabilities
                                                 // proportional to the remaining
                                                 // free space in the SMP.
        uint64_t  SOFT_DROP_ON_PRIVATE :   1;    //  If SoftDropOnSmpFree is not
                                                 // set, then this enables soft
                                                 // drop when CM_TX_TC_PRIVATE_WM
                                                 // is exceeded.
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_SMP_FREE_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_SMP_FREE_MSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_SMP_FREE_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_SMP_FREE_MASK 0x00000001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_SMP_FREE_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_PRIVATE_LSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_PRIVATE_MSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_PRIVATE_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_PRIVATE_MASK 0x00000002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_SOFT_DROP_ON_PRIVATE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_FLAG
// CM_APPLY_TX_TC_STATE desc:  Tx port, TC watermark state register
typedef union {
    struct {
        uint64_t  TX_PRIVATE           :   1;    //  CM_TX_TC_PRIVATE_WM
                                                 // exceeded.
        uint64_t  TX_HOG               :   1;    //  CM_TX_SMP_HOG_WM exceeded.
        uint64_t  OVER_SMP_FREE        :   1;    //  CM_TX_TC_USAGE over soft
                                                 // drop SMP free amount.
        uint64_t  OVER_SMP_FREE2       :   1;    //  CM_TX_TC_USAGE over half of
                                                 // soft drop SMP free amount.
        uint64_t  QUEUE_DEPTH          :  15;    //  TX TC queue depth from
                                                 // cm_usage.
        uint64_t  RSVD_0               :  45;    // Nebulon auto filled RSVD [63:19]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_BITFIELD_COUNT 0x05
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_PRIVATE_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_PRIVATE_MSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_PRIVATE_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_PRIVATE_MASK 0x00000001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_PRIVATE_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_HOG_LSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_HOG_MSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_HOG_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_HOG_MASK 0x00000002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_TX_HOG_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE_LSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE_MSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE_MASK 0x00000004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE2_LSB 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE2_MSB 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE2_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE2_MASK 0x00000008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_OVER_SMP_FREE2_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_QUEUE_DEPTH_LSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_QUEUE_DEPTH_MSB 0x0012
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_QUEUE_DEPTH_RANGE 0x000f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_QUEUE_DEPTH_MASK 0x0007fff0
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_QUEUE_DEPTH_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_FLAG
// CM_APPLY_TX_TC_QCN_WM_THRESHOLD desc:  Tx port, TC watermater threshold register for QCN
typedef union {
    struct {
        uint64_t  WM_THRESHOLD         :  15;    //  Watermark threshold for QCN.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_WM_THRESHOLD_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_WM_THRESHOLD_MSB 0x000e
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_WM_THRESHOLD_RANGE 0x000f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_WM_THRESHOLD_MASK 0x00007fff
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_WM_THRESHOLD_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_FLAG
// CM_APPLY_RX_SMP_STATE desc:  Rx Port SMP watermark state register
typedef union {
    struct {
        uint64_t  RX_PRIVATE           :   1;    //  CM_RX_SMP_PRIVATE_WM
                                                 // exceeded.
        uint64_t  RX_HOG               :   1;    //  CM_RX_SMP_HOG_WM exceeded.
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_PRIVATE_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_PRIVATE_MSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_PRIVATE_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_PRIVATE_MASK 0x00000001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_PRIVATE_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_HOG_LSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_HOG_MSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_HOG_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_HOG_MASK 0x00000002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_RX_HOG_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_FLAG
// CM_APPLY_MIRROR_PROFILE_TABLE desc:  Mirror profile entries for frame handler
typedef union {
    struct {
        uint64_t  PORT                 :   5;    //  Destination port for the
                                                 // mirror profile entry
        uint64_t  RSVD_0               :  59;    // Nebulon auto filled RSVD [63:5]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_PORT_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_PORT_MSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_PORT_RANGE 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_PORT_MASK 0x0000001f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_PORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FLAG
// CM_APPLY_DROP_COUNT desc:  TX port CM drop frame counter register
typedef union {
    struct {
        uint64_t  FRAMES               :  48;    //  Per-port TX CM DROP frame
                                                 // counter
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FRAMES_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FRAMES_MSB 0x002f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FRAMES_RANGE 0x0030
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FRAMES_MASK 0xffffffffffff
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_FRAMES_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_FLAG
// CM_APPLY_LOOPBACK_SUPPRESS desc:  At the edge of the system, we must avoid retransmitting a frame over
// the same LAG it arrived on, even if the LAG is distributed across
// multiple edge chips. This is done by comparing the GloRTs for the
// source and destination LAG/port. if the GloRTs match, not counting the
// port-specific bits, then the LAGs are the same. Note that the
// destination port's GloRT is not necessarily the same as the
// destination GloRT (which might be multicast), so this comparison
// needs to be done for all external destination ports in parallel. The
// comparison is turned off for internal ports. This register is indexed
// by logical port.
typedef union {
    struct {
        uint64_t  GLORT                :  16;    //  GloRT value
        uint64_t  GLORT_MASK           :  16;    //  GloRT mask
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_RESET 0x0000ffff

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MSB 0x000f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_RANGE 0x0010
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MASK 0x0000ffff
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_RESET_VALUE 0x0000ffff

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MASK_LSB 0x0010
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MASK_MSB 0x001f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MASK_RANGE 0x0010
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MASK_MASK 0xffff0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_GLORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_FLAG
// CM_APPLY_SOFTDROP_CFG desc:  Specifies software configuration
typedef union {
    struct {
        uint64_t  JITTER_BITS          :   3;    //  Selects the number of random
                                                 // jitter bits that will be added
                                                 // to SoftDropSegmentLimit
                                                 // (0..7).
        uint64_t  RSVD_0               :  61;    // Nebulon auto filled RSVD [63:3]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_JITTER_BITS_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_JITTER_BITS_MSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_JITTER_BITS_RANGE 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_JITTER_BITS_MASK 0x00000007
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_JITTER_BITS_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_FLAG
// CM_APPLY_SOFTDROP_STATE desc:  Softdrop state register indexed by switch priority
typedef union {
    struct {
        uint64_t  USAGE_OVER_LIMIT     :   8;    //  Amount of
                                                 // CM_SHARED_SMP_USAGE in excess
                                                 // of the SoftDropSegmentLimit.
                                                 // Data valid if overLimit==1.
        uint64_t  OVER_LIMIT           :   1;    //  True if CM_SHARED_SMP_USAGE
                                                 // in excess of the
                                                 // SoftDropSegmentLimit
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_OFFSET 0x40
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_USAGE_OVER_LIMIT_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_USAGE_OVER_LIMIT_MSB 0x0007
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_USAGE_OVER_LIMIT_RANGE 0x0008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_USAGE_OVER_LIMIT_MASK 0x000000ff
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_USAGE_OVER_LIMIT_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_OVER_LIMIT_LSB 0x0008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_OVER_LIMIT_MSB 0x0008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_OVER_LIMIT_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_OVER_LIMIT_MASK 0x00000100
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_OVER_LIMIT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_FLAG
// CM_APPLY_TRAP_GLORT desc:  Trap glort when a frame must be trapped. It is indexed by operator id
// from metadata
typedef union {
    struct {
        uint64_t  TRAP_GLORT           :  16;    //  Destination glort for frames
                                                 // trapped to the CPU.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_OFFSET 0x80
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_TRAP_GLORT_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_TRAP_GLORT_MSB 0x000f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_TRAP_GLORT_RANGE 0x0010
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_TRAP_GLORT_MASK 0x0000ffff
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_TRAP_GLORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_FLAG
// CM_APPLY_TC_TO_SMP desc:  Defines the SMP membership per traffic class. The choices are: 0:
// SMP 0; 1: SMP 1
typedef union {
    struct {
        uint64_t  SMP_0                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_1                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_2                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_3                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_4                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_5                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_6                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_7                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  RSVD_0               :  56;    // Nebulon auto filled RSVD [63:8]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_OFFSET 0x00
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_BITFIELD_COUNT 0x08
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_0_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_0_MSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_0_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_0_MASK 0x00000001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_0_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_1_LSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_1_MSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_1_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_1_MASK 0x00000002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_1_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_2_LSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_2_MSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_2_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_2_MASK 0x00000004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_2_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_3_LSB 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_3_MSB 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_3_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_3_MASK 0x00000008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_3_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_4_LSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_4_MSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_4_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_4_MASK 0x00000010
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_4_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_5_LSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_5_MSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_5_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_5_MASK 0x00000020
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_5_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_6_LSB 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_6_MSB 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_6_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_6_MASK 0x00000040
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_6_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_7_LSB 0x0007
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_7_MSB 0x0007
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_7_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_7_MASK 0x00000080
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_SMP_7_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_FLAG
// CM_APPLY_MCAST_EPOCH desc:  Register that defines current epoch for multicast garbage
// collection.
typedef union {
    struct {
        uint64_t  CURRENT              :   1;    //  Defines current epoch for
                                                 // multicast garbage collection.
        uint64_t  RSVD_0               :  63;    // Nebulon auto filled RSVD [63:1]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_OFFSET 0x08
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_CURRENT_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_CURRENT_MSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_CURRENT_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_CURRENT_MASK 0x00000001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_CURRENT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_FLAG
// CM_APPLY_STATE desc:  Cached sweeper state register
typedef union {
    struct {
        uint64_t  GLOBAL_EX            :   1;    //  CM_GLOBAL_WM exceeded.
        uint64_t  RXS_0                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_1                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_2                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_3                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_4                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_5                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_6                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RXS_7                :   1;    //  CM_SHARED_WM exceeded, per
                                                 // tc.
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_OFFSET 0x10
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_BITFIELD_COUNT 0x09
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_GLOBAL_EX_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_GLOBAL_EX_MSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_GLOBAL_EX_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_GLOBAL_EX_MASK 0x00000001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_GLOBAL_EX_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_0_LSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_0_MSB 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_0_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_0_MASK 0x00000002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_0_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_1_LSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_1_MSB 0x0002
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_1_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_1_MASK 0x00000004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_1_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_2_LSB 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_2_MSB 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_2_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_2_MASK 0x00000008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_2_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_3_LSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_3_MSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_3_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_3_MASK 0x00000010
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_3_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_4_LSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_4_MSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_4_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_4_MASK 0x00000020
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_4_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_5_LSB 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_5_MSB 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_5_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_5_MASK 0x00000040
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_5_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_6_LSB 0x0007
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_6_MSB 0x0007
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_6_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_6_MASK 0x00000080
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_6_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_7_LSB 0x0008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_7_MSB 0x0008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_7_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_7_MASK 0x00000100
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_RXS_7_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_FLAG
// CM_APPLY_CPU_TRAP_MASK desc:  When a trapped frame is sent to the CPU, it is sent out on these
// ports. (This is a mask rather than a single port number, so that it
// is possible to multicast to multiple CPUs if desired.)
typedef union {
    struct {
        uint64_t  DEST_MASK            :  24;    //  Destination mask for CPU.
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_OFFSET 0x18
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_RESET 0x00000001

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_DEST_MASK_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_DEST_MASK_MSB 0x0017
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_DEST_MASK_RANGE 0x0018
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_DEST_MASK_MASK 0x00ffffff
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_DEST_MASK_RESET_VALUE 0x00000001


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FLAG
// CM_APPLY_LOG_MIRROR_PROFILE desc:  Mirror 0 profile index register for various logging conditions.
typedef union {
    struct {
        uint64_t  FFU                  :   6;    //  Mirror 0 profile index due
                                                 // to a Classifier Group log
                                                 // action.
        uint64_t  RESERVED_MAC         :   6;    //  Mirror 0 profile index when
                                                 // a frame with an IEEE Reserved
                                                 // destination MAC address is
                                                 // logged, per
                                                 // IEEE_RESERVED_MAC_ACTION.
        uint64_t  ARP_REDIRECT         :   6;    //  Mirror 0 profile index on an
                                                 // ARP log (unicast frame routed
                                                 // back to ingress VLAN).
        uint64_t  ICMP                 :   6;    //  Mirror 0 profile index when
                                                 // a multicast ICMP frame is
                                                 // logged because of ICMP.
        uint64_t  TTL                  :   6;    //  Mirror 0 profile index when
                                                 // any multicast frame is logged
                                                 // because TTL1.
        uint64_t  TRIGGER              :   6;    //  Mirror 0 profile index when
                                                 // any multicast frame is logged
                                                 // because of trigger action.
        uint64_t  RSVD_0               :  28;    // Nebulon auto filled RSVD [63:36]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_OFFSET 0x20
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_BITFIELD_COUNT 0x06
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FFU_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FFU_MSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FFU_RANGE 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FFU_MASK 0x0000003f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_FFU_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_RESERVED_MAC_LSB 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_RESERVED_MAC_MSB 0x000b
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_RESERVED_MAC_RANGE 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_RESERVED_MAC_MASK 0x00000fc0
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_RESERVED_MAC_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ARP_REDIRECT_LSB 0x000c
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ARP_REDIRECT_MSB 0x0011
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ARP_REDIRECT_RANGE 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ARP_REDIRECT_MASK 0x0003f000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ARP_REDIRECT_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ICMP_LSB 0x0012
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ICMP_MSB 0x0017
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ICMP_RANGE 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ICMP_MASK 0x00fc0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_ICMP_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TTL_LSB 0x0018
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TTL_MSB 0x001d
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TTL_RANGE 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TTL_MASK 0x3f000000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TTL_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TRIGGER_LSB 0x001e
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TRIGGER_MSB 0x0023
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TRIGGER_RANGE 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TRIGGER_MASK 0xfc0000000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_TRIGGER_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_FLAG
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_FLAG
// CM_APPLY_QCN_CFG desc:  Defining QCN sample rate
typedef union {
    struct {
        uint64_t  SAMPLE_RATE_EXP      :   5;    //  Defining sample rate by its
                                                 // exponent. 2**SrampleRateExp is
                                                 // the real sample rate
        uint64_t  SELECT_COMP          :   1;    //  Selection of comparision. 1
                                                 // to use less-or-eq, 0 to use
                                                 // greater-or-eq
        uint64_t  QUEUE_DEPTH_START_BIT :   3;    //  The starting bit position of
                                                 // choosing 8b data from 15b QCN
                                                 // queue depth.
        uint64_t  QUEUE_DEPTH_MODE     :   1;    //  The mode of choosing 8b data
                                                 // from 15b QCN queue depth. 1:
                                                 // direct mode, 0: exponential
                                                 // mode.
        uint64_t  RSVD_0               :  54;    // Nebulon auto filled RSVD [63:10]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_t;
#endif
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_OFFSET 0x28
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SCOPE 0x01
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SIZE 64
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_BITFIELD_COUNT 0x04
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_RESET 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SAMPLE_RATE_EXP_LSB 0x0000
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SAMPLE_RATE_EXP_MSB 0x0004
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SAMPLE_RATE_EXP_RANGE 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SAMPLE_RATE_EXP_MASK 0x0000001f
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SAMPLE_RATE_EXP_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SELECT_COMP_LSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SELECT_COMP_MSB 0x0005
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SELECT_COMP_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SELECT_COMP_MASK 0x00000020
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_SELECT_COMP_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_START_BIT_LSB 0x0006
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_START_BIT_MSB 0x0008
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_START_BIT_RANGE 0x0003
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_START_BIT_MASK 0x000001c0
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_START_BIT_RESET_VALUE 0x00000000

#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_MODE_LSB 0x0009
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_MODE_MSB 0x0009
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_MODE_RANGE 0x0001
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_MODE_MASK 0x00000200
#define MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_QUEUE_DEPTH_MODE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    // starting the regfile section
    struct {
        MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_SOFTDROP_CFG_t CM_APPLY_TX_SOFTDROP_CFG[8]; // offset 4'h0, width 64
    } CM_APPLY_TX_SOFTDROP_CFG[64];              // offset 4'h0, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_STATE_t CM_APPLY_TX_TC_STATE[8]; // offset 4'h0, width 64
    } CM_APPLY_TX_TC_STATE[64];                  // offset 16'h1000, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TX_TC_QCN_WM_THRESHOLD_t CM_APPLY_TX_TC_QCN_WM_THRESHOLD[8]; // offset 4'h0, width 64
    } CM_APPLY_TX_TC_QCN_WM_THRESHOLD[64];       // offset 16'h2000, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_RX_SMP_STATE_t CM_APPLY_RX_SMP_STATE[2]; // offset 4'h0, width 64
    } CM_APPLY_RX_SMP_STATE[32];                 // offset 16'h3000, size: 16
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MIRROR_PROFILE_TABLE_t CM_APPLY_MIRROR_PROFILE_TABLE[64]; // offset 16'h3200, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_DROP_COUNT_t CM_APPLY_DROP_COUNT[32]; // offset 16'h3400, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOOPBACK_SUPPRESS_t CM_APPLY_LOOPBACK_SUPPRESS[32]; // offset 16'h3500, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_CFG_t CM_APPLY_SOFTDROP_CFG[8]; // offset 16'h3600, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_SOFTDROP_STATE_t CM_APPLY_SOFTDROP_STATE[8]; // offset 16'h3640, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TRAP_GLORT_t CM_APPLY_TRAP_GLORT[16]; // offset 16'h3680, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_TC_TO_SMP_t CM_APPLY_TC_TO_SMP; // offset 16'h3700, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_MCAST_EPOCH_t CM_APPLY_MCAST_EPOCH; // offset 16'h3708, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_STATE_t CM_APPLY_STATE;   // offset 16'h3710, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_CPU_TRAP_MASK_t CM_APPLY_CPU_TRAP_MASK; // offset 16'h3718, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_LOG_MIRROR_PROFILE_t CM_APPLY_LOG_MIRROR_PROFILE; // offset 16'h3720, width 64
    MBY_PPE_CM_APPLY_MAP_MSG_CM_APPLY_QCN_CFG_t CM_APPLY_QCN_CFG; // offset 16'h3728, width 64
} mby_ppe_cm_apply_map_t;                        // size:  16'h3730


#endif // _MBY_PPE_CM_APPLY_MAP_REGS_H_


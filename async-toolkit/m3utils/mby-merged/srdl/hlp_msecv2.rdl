//
// Register Definitions
//
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

//------------------------------------------------------------------------------
// msecv2_defines.rdl
//
// This is the include file for MSECV2 RDL parameters.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// msecv2_top_mgmt_reg_def.rdl
//
// This file contains the register descriptions for MSECV2 Global registers.
//------------------------------------------------------------------------------
reg msecv2_cport_en_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Controlled Port Enable";
  desc = "Enables or disables Controlled Port for a lane. When Controlled Port is disabled, the frames are not sent nor received via Controlled Port.
          During that time, the Controlled Port frames that enter the transmitting side are discarded, while the MACsec frames that enter the receiving side are sent over Uncontrolled Port.
          Regardless of this register value, the transmit/receive Uncontrolled frames are always sent through Uncontrolled Port.
          The MSECV2 initialization is finished by setting this bit to one. 
          If during the regular MSECV2 operation this register is reset to zero, the frames that are internally queued for processing are all completed,
	  while all the new ones are processed as described above.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved1";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV1[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ControlledPortEnabled: 1 - Enabled, 0 - Disabled";
  }  CONTROLLEDPORTENABLED[0:0]  = 1'h0;

}; // msecv2_cport_en_r

reg msecv2_key_len_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Key Length";
  desc = "Selects between 128-bit or 256-bit key lengths for the MACsec cipher operation.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved2";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV2[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "keyLength: 0 - 128-bit key, 1 - 256-bit key .";
  }  KEYLENGTH[0:0]  = 1'h0;

}; // msecv2_key_len_r

reg msecv2_confid_off_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Confidentiality offset";
  desc = " The cipher confidentiality offset. Selects how many initial MSDU octets after SecTAG in MPDU are only integrity protected, while the 
           others are both confidentiality and integrity protected. Supported values are from 0 to 127 bytes (0, 30, 50 bytes required by standards).";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved3";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV3[63:8] = 56'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "confidOff: 0 (0x0) - bytes, 30 (0x1E)- 30 bytes, 50 (0x32)- 50 bytes.";
  }  CONFIDOFF[7:0]  = 8'h0;

}; // msecv2_confid_off_r

reg msecv2_zero_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Zeroization";
  desc = "Signals the start of the security zeroization process. The security keys and other important security data are internally reset to zero.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved4";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV4[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "zero: 1 - Zeroize, 0 - Don't zeroize.";
  }  ZERO[0:0]  = 1'h0;

}; // msecv2_zero_r

reg msecv2_zero_sts_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Zeroization Status";
  desc = "Set to 1 while the zeroization is in progress. Reset to 0 after the zeroization finished.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved5";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV5[63:1] = 63'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "zeroStatus: 1 - the zeroization in progress, 0 - the zeroization completed";
  }  ZEROSTATUS[0:0]  = 1'h0;

}; // msecv2_zero_sts_r

reg msecv2_scratch_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Scratchpad";
  desc = "A scratchpad register.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved6";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV6[63:32] = 32'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Scratchpad register";
  }  SCRATCHPAD[31:0]  = 32'h0;

}; // msecv2_scratch_r

reg msecv2_version_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Version";
  desc = "This register contains the MSECV2 identifying version number.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved7";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV7[63:8] = 56'h0;
  field {
    AccessType = "RO";
    ValRandomize = true;
    desc = "Version Number";
  }  BITS[7:0]  = 8'h4;

}; // msecv2_version_r

reg msecv2_ciph_id_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Cipher ID";
  desc = "A read-only, 64-bit value containing an identifier of a cipher suite used. The underlying cipher is AES in the GCM mode of operation.
          A cipher suites used are GCM-AES-128, GCM-AES-256, GCM-AES-XPN-128, GCM-AES-XPN-256. The computed ICV always has a length of 16 bytes.
		  This register changes its value based on the key_len and xpn_mode selection.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "msecv2_ciph_id_r";
  }  BITS[63:0] = 64'h0080C20001000001;
}; // msecv2_ciph_id_r

reg msecv2_sw_reset_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Software reset";
  desc = "Resets the core logic, leaving the configuration registers unchanged. MSECV2 is in the reset state as long as this bit is set to 0.
          While in this state, no traffic is allowed in either MSECV2 direction. 
		  This register has a higher precedence than 'Bypass' register (i.e. if both are active, MSECV2 is in the software reset state).";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved8";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV8[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "1 - Don't reset, 0 - Reset .";
  }  SW_RESET[0:0]  = 1'h1;

}; // msecv2_sw_reset_r

reg msecv2_bypass_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "Directly connects MSECV2 inputs and outputs, thus bypassing the internals. Intended as the debuging help only.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved9";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV9[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "1 - Bypass mode, 0 - Regular mode .";
  }  BYPASS[0:0]  = 1'h0;

}; // msecv2_bypass_r

reg msecv2_cport_oper_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Controlled Port Operational";
  desc = "A read-only indication of MSECV2 Controlled Port operational state. 
          If 1, MSECV2 Controlled Port is operational, and its rules are fully applied to frames in both directions.
          If 0, Tx Controlled frames are discarded, while Rx Controlled frames are sent out via the Uncontrolled port (MSECV2 is in the non-operational state described for Interrupt Register, or Controlled Port Enable is zero).
		  Regardless of this value, the Uncontrolled Port is always operational in both directions.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved10";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV10[63:1] = 63'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "1 - Controlled Port operational, 0 - Controlled Port not operational ";
  }  CPORT_OPER[0:0]  = 1'h0;

}; // msecv2_cport_oper_r

reg msecv2_xpn_mode_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC XPN Mode";
  desc = "Enables Extended Packet Numbering mode of operation. In this mode packet numbers are 64-bits wide.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved11";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV11[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "xpn_mode: 0 - regular PN mode, 1 - extended PN mode.";
  }  XPN_MODE[0:0]  = 1'h0;

}; // msecv2_xpn_mode_r

//* interrupt - begin
reg msecv2_isr_status_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Interrupt status register";
  desc = "All the ALARM bits support setting of MAC_Operational parameter at the higher level. 
	 If any of the ALARM bits is set, the design goes to a non-operational state, until the underlying cause is cleared.
	 Setting of any of ALARM bits causes both Tx and Rx Controlled Port sides to stop processing, after a current Tx/Rx frame is completed.
	 While in this condition, Tx Controlled frames are discarded, while Rx Controlled frames go out via the Uncontrolled port.
	 The Uncontrolled traffic at both sides goes as normal.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved12";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV12[63:32] = 32'h0;
  field {
    AccessType = "RO";
    ValRandomize = true;
    desc = "RSVD";
  }  RSVD[31:23]  = 9'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: A parity error condition.";
  }  PARITY[22:22]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 1. Rx SC 1 not receiving (doesn't contain any SA enabled for use).";
  }  LN1_RX_SC1_NOT_RCVING[21:21]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 1. Rx SC 0 not receiving (doesn't contain any SA enabled for use).";
  }  LN1_RX_SC0_NOT_RCVING[20:20]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA identified by 'Encoding SA' not enabled (not in use), if protectFrames=1 (Tx Basic Control Register).";
  }  LN1_TX_SA_DISABLED[19:19]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 3 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3.";
  }  LN1_TX_SA3_ZERO[18:18]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 2 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2.";
  }  LN1_TX_SA2_ZERO[17:17]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 1 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1.";
  }  LN1_TX_SA1_ZERO[16:16]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 0 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0.";
  }  LN1_TX_SA0_ZERO[15:15]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 3 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3. A fresh key needs to be supplied.";
  }  LN1_TX_SA3_PN_EXHAUST[14:14]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 2 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2. A fresh key needs to be supplied.";
  }  LN1_TX_SA2_PN_EXHAUST[13:13]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 1 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1. A fresh key needs to be supplied.";
  }  LN1_TX_SA1_PN_EXHAUST[12:12]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 0 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0. A fresh key needs to be supplied.";
  }  LN1_TX_SA0_PN_EXHAUST[11:11]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 0. Rx SC 1 not receiving (doesn't contain any SA enabled for use).";
  }  LN0_RX_SC1_NOT_RCVING[10:10]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 0. Rx SC 0 not receiving (doesn't contain any SA enabled for use).";
  }  LN0_RX_SC0_NOT_RCVING[9:9]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA identified by 'Encoding SA' not enabled (not in use), if protectFrames=1 (Tx Basic Control Register).";
  }  LN0_TX_SA_DISABLED[8:8]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 3 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3.";
  }  LN0_TX_SA3_ZERO[7:7]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 2 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2.";
  }  LN0_TX_SA2_ZERO[6:6]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 1 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1.";
  }  LN0_TX_SA1_ZERO[5:5]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 0 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0.";
  }  LN0_TX_SA0_ZERO[4:4]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 3 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3. A fresh key needs to be supplied.";
  }  LN0_TX_SA3_PN_EXHAUST[3:3]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 2 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2. A fresh key needs to be supplied.";
  }  LN0_TX_SA2_PN_EXHAUST[2:2]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 1 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1. A fresh key needs to be supplied.";
  }  LN0_TX_SA1_PN_EXHAUST[1:1]  = 1'h0;

  field {
    AccessType = "RW/1C/V";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 0 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0. A fresh key needs to be supplied.";
  }  LN0_TX_SA0_PN_EXHAUST[0:0]  = 1'h0;

}; // msecv2_isr_status_r

reg msecv2_isr_enable_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Interrupt enable register";
  desc = "Enables interrupts.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved13";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV13[63:32] = 32'h0;
  field {
    AccessType = "RO";
    ValRandomize = true;
    desc = "RSVD";
  }  RSVD[31:23]  = 9'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: A parity error condition.";
  }  PARITY[22:22]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Rx SC 1 not receiving (doesn't contain any SA enabled for use).";
  }  LN1_RX_SC1_NOT_RCVING[21:21]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Rx SC 0 not receiving (doesn't contain any SA enabled for use).";
  }  LN1_RX_SC0_NOT_RCVING[20:20]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA identified by 'Encoding SA' not enabled (not in use), if protectFrames=1 (Tx Basic Control Register).";
  }  LN1_TX_SA_DISABLED[19:19]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 3 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3.";
  }  LN1_TX_SA3_ZERO[18:18]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 2 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2.";
  }  LN1_TX_SA2_ZERO[17:17]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 1 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1.";
  }  LN1_TX_SA1_ZERO[16:16]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 0 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0.";
  }  LN1_TX_SA0_ZERO[15:15]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 3 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3. A fresh key needs to be supplied.";
  }  LN1_TX_SA3_PN_EXHAUST[14:14]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 2 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2. A fresh key needs to be supplied.";
  }  LN1_TX_SA2_PN_EXHAUST[13:13]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 1 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1. A fresh key needs to be supplied.";
  }  LN1_TX_SA1_PN_EXHAUST[12:12]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 0 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0. A fresh key needs to be supplied.";
  }  LN1_TX_SA0_PN_EXHAUST[11:11]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Rx SC 1 not receiving (doesn't contain any SA enabled for use).";
  }  LN0_RX_SC1_NOT_RCVING[10:10]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Rx SC 0 not receiving (doesn't contain any SA enabled for use).";
  }  LN0_RX_SC0_NOT_RCVING[9:9]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA identified by 'Encoding SA' not enabled (not in use), if protectFrames=1 (Tx Basic Control Register).";
  }  LN0_TX_SA_DISABLED[8:8]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 3 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3.";
  }  LN0_TX_SA3_ZERO[7:7]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 2 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2.";
  }  LN0_TX_SA2_ZERO[6:6]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 1 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1.";
  }  LN0_TX_SA1_ZERO[5:5]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 0 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0.";
  }  LN0_TX_SA0_ZERO[4:4]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 3 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3. A fresh key needs to be supplied.";
  }  LN0_TX_SA3_PN_EXHAUST[3:3]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 2 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2. A fresh key needs to be supplied.";
  }  LN0_TX_SA2_PN_EXHAUST[2:2]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 1 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1. A fresh key needs to be supplied.";
  }  LN0_TX_SA1_PN_EXHAUST[1:1]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 0 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0. A fresh key needs to be supplied.";
  }  LN0_TX_SA0_PN_EXHAUST[0:0]  = 1'h0;

}; // msecv2_isr_enable_r

reg msecv2_isr_force_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Interrupt force register";
  desc = "This address is an alias for the Interrupt Status register that allows normal CFG writes (as opposed to the Clear-On-Write-One behavior if the Interrupt Status register address is used). 
          This allows CFG to set interrupt bits for testing purposes. 
		  Reading this address returns the current value of the Interrupt Status Register.
		  All the ALARM bits support setting of MAC_Operational parameter at the higher level.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved14";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV14[63:32] = 32'h0;
  field {
    AccessType = "RO";
    ValRandomize = true;
    desc = "RSVD";
  }  RSVD[31:23]  = 9'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: A parity error condition.";
  }  PARITY[22:22]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Rx SC 1 not receiving (doesn't contain any SA enabled for use).";
  }  LN1_RX_SC1_NOT_RCVING[21:21]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Rx SC 0 not receiving (doesn't contain any SA enabled for use).";
  }  LN1_RX_SC0_NOT_RCVING[20:20]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA identified by 'Encoding SA' not enabled (not in use), if protectFrames=1 (Tx Basic Control Register).";
  }  LN1_TX_SA_DISABLED[19:19]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 3 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3.";
  }  LN1_TX_SA3_ZERO[18:18]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 2 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2.";
  }  LN1_TX_SA2_ZERO[17:17]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 1 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1.";
  }  LN1_TX_SA1_ZERO[16:16]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 1. Tx SA 0 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0.";
  }  LN1_TX_SA0_ZERO[15:15]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 3 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3. A fresh key needs to be supplied.";
  }  LN1_TX_SA3_PN_EXHAUST[14:14]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 2 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2. A fresh key needs to be supplied.";
  }  LN1_TX_SA2_PN_EXHAUST[13:13]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 1 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1. A fresh key needs to be supplied.";
  }  LN1_TX_SA1_PN_EXHAUST[12:12]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 1. Tx SA 0 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0. A fresh key needs to be supplied.";
  }  LN1_TX_SA0_PN_EXHAUST[11:11]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Rx SC 1 not receiving (doesn't contain any SA enabled for use).";
  }  LN0_RX_SC1_NOT_RCVING[10:10]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Rx SC 0 not receiving (doesn't contain any SA enabled for use).";
  }  LN0_RX_SC0_NOT_RCVING[9:9]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA identified by 'Encoding SA' not enabled (not in use), if protectFrames=1 (Tx Basic Control Register).";
  }  LN0_TX_SA_DISABLED[8:8]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 3 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3.";
  }  LN0_TX_SA3_ZERO[7:7]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 2 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2.";
  }  LN0_TX_SA2_ZERO[6:6]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 1 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1.";
  }  LN0_TX_SA1_ZERO[5:5]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "ALARM: Lane 0. Tx SA 0 'Next PN' is zero, if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0.";
  }  LN0_TX_SA0_ZERO[4:4]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 3 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x3. A fresh key needs to be supplied.";
  }  LN0_TX_SA3_PN_EXHAUST[3:3]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 2 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x2. A fresh key needs to be supplied.";
  }  LN0_TX_SA2_PN_EXHAUST[2:2]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 1 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x1. A fresh key needs to be supplied.";
  }  LN0_TX_SA1_PN_EXHAUST[1:1]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "INFO: Lane 0. Tx SA 0 'Next PN' reached the pre-exhaustion limit 'Tx PN Limit', if protectFrames=1 (Tx Basic Control Register) and 'Encoding SA'=0x0. A fresh key needs to be supplied.";
  }  LN0_TX_SA0_PN_EXHAUST[0:0]  = 1'h0;

}; // msecv2_isr_force_r

//* interrupt - end
reg msecv2_rly_mode_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Relay Mode";
  desc = "A mode for inserting relay tags and labels between MAC address and MACsec SecTAG in the transmit direction, 
          and removing them in the receive direction before MACsec processing.
		  In Copy Single, Copy Dual and Replace modes Search EtherType needs to be present in order to perform the operation.
		  In Copy Generic, the number of bytes specified in Relay Tag Length is inserted/removed in Tx/Rx without any checks.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved15";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV15[63:3] = 61'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "rly_mode: 0 - No tagging, 1 - Copy Single (4 bytes), 2 - Copy Dual (8 bytes), 3 - Replace (4 bytes), 4 - Copy Generic";
  }  RLY_MODE[2:0] = 3'h0;
}; // msecv2_rly_mode_r

reg msecv2_src_et_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Search EtherType";
  desc = "EtherType to search for in an incoming Tx frame. If exists, a relay tag/label is inserted/removed in Tx/Rx direction, depending on Relay Mode."; 
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved16";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV16[63:16] = 48'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Search EtherType";
  }  SRC_ET[15:0] = 16'h0000;
}; // msecv2_src_et_r

reg msecv2_dst_et_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Replace EtherType";
  desc = "EtherType to replace Search EtherType with if rly_mode = Replace."; 
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved17";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV17[63:16] = 48'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Replace EtherType";
  }  DST_ET[15:0] = 16'h0000;
}; // msecv2_dst_et_r

reg msecv2_rly_len_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Relay Tag Length";
  desc = "The number of bytes to insert/remove in Tx/Rx between MAC address and MACsec SecTAG if relay tagging active. 
         Should be set to 4 for Copy Single and Replace modes, and to 8 for Copy Dual. In Copy Generic mode, it should be a value from 1 to 8."; 
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved18";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV18[63:4] = 60'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Relay Tag Length";
  }  RLY_LEN[3:0] = 4'h0;
}; // msecv2_rly_len_r

reg msecv2_top_stat_cport_tx_untag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Untagged Tx Packets";
  desc = "A 64-bit counter of the Tx packets without SecTAG becuase protectFrames=0 (Tx Basic Control Register). 
          Corresponds to OutPktsUntagged from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_tx_untag_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_tx_untag_r

reg msecv2_top_stat_cport_tx_toolong_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Too Long Tx Packets";
  desc = "A 64-bit counter of the Tx packets discarded because their length is greater than 'Tx Max Packet Bytes'. 
          Corresponds to OutPktsTooLong from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_tx_toolong_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_tx_toolong_r

reg msecv2_top_stat_cport_rx_untag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Untagged Rx Packets";
  desc = "A 64-bit counter of received packets without SecTAG when validateFrames!=Strict (Rx Basic Control Register).
          Corresponds to InPktsUntagged from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_rx_untag_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_rx_untag_r

reg msecv2_top_stat_cport_rx_notag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC No Tag Rx Packets";
  desc = "A 64-bit counter of received discarded packets without SecTAG when validateFrames=Strict (Rx Basic Control Register).
          Corresponds to InPktsNoTag from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_rx_notag_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_rx_notag_r

reg msecv2_top_stat_cport_rx_badtag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Bad Tag Rx Packets";
  desc = "A 64-bit counter of received discarded packets with an invalid SecTAG or invalid ICV or a zero value PN.
          Corresponds to InPktsBadTag from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_rx_badtag_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_rx_badtag_r

reg msecv2_top_stat_cport_rx_unksci_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Unknown SCI Rx Packets";
  desc = "A 64-bit counter of received packets with unknown SCI when validateFrames!=Strict (Rx Basic Control Register) and SecTAG's C bit is not set.
          Corresponds to InPktsUnknownSCI from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_rx_unksci_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_rx_unksci_r

reg msecv2_top_stat_cport_rx_nosci_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC No SCI Rx Packets";
  desc = "A 64-bit counter of received discarded packets with unknown SCI when validateFrames=Strict (Rx Basic Control Register) or SecTAG's C bit is set.
          Corresponds to InPktsNoSCI from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_rx_nosci_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_rx_nosci_r

reg msecv2_top_stat_cport_rx_orun_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Overrun Rx Packets";
  desc = "A 64-bit counter of received discarded packets because their number exceeds the cipher performance capabilities. 
          Corresponds to InPktsOverrun from IEEE 802.1AE-2006.
	  Internally tied to zero because the backpressuring mechanism prevents the situation from hapenning.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_top_stat_cport_rx_orun_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_top_stat_cport_rx_orun_r

//------------------------------------------------------------------------------
// msecv2_tx_mgmt_reg_def.rdl
//
// This file contains the register descriptions for MSECV2 Tx registers.
//------------------------------------------------------------------------------
reg msecv2_tx_cntrl_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx Basic control register";
  desc = "Allows setting of basic MACsec Tx parameters.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved19";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV19[63:16] = 48'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Reserved";
  }  RESERVED[15:4]  = 12'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Single Copy Broadcast (SCB) indicator. Active high.";
  }  USESCB[3:3]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "End Station (ES) usage indicator. Active high.";
  }  USEES[2:2]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Indicates whether SCI should be included in the security tag.  Active high.";
  }  ALWAYSINCLUDESCI[1:1]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Indicates whether the frames should be protected. If 1, the frames are integrity/encription protected, depending on other settings.            If 0, the frames pass through unchanged, and a global counter, 'Untagged Tx Packets', is incremented.";
  }  PROTECTFRAMES[0:0]  = 1'h0;

}; // msecv2_tx_cntrl_r

reg msecv2_tx_pn_limit_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx PN Limit";
  desc = "Allows setting of the 'Next PN' limit, before 'Next PN' is exhausted for SA. 
          When 'Next PN' reaches this value, an interrupt is raised to warn about the need for a new key (SA). ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "The limit value of the next packet number.";
  }  PN_LIMIT[63:0] = 64'h00000000C0000000;
}; // msecv2_tx_pn_limit_r

reg msecv2_tx_max_pckt_bytes_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx Maximum Packet Bytes";
  desc = "The maximum supported packet size in bytes. 
          It should contain the sum of MAC Addresses size (12 bytes) and the maximum supported MSDU size by MAC.
		  If the output frame is longer than this value, an error will be indicated, and the top level stat counter cport_tx_toolong is incremented.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved20";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV20[63:16] = 48'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "The maximum allowed packet size in bytes.";
  }  MAX_BYTES[15:0] = 16'd16384;
}; // msecv2_tx_max_pckt_bytes_r

reg msecv2_tx_add_fcs_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx Add FCS";
  desc = "Determines if 4 bytes of FCS are added at the end of a MACsec frame. In the current implementation, MSECV2 doesn't add FCS in the Tx direction, so this bit should be 0.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved21";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV21[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Add FCS to a frame: 1 - add FCS, 0 - don't add FCS";
  }  BITS[0:0]  = 1'h0;

}; // msecv2_tx_add_fcs_r

reg msecv2_tx_jit_wm_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx Jitter Watermark";
  desc = "Specifies the number of valid data cycles at the output to hold a frame off before starting to send it out.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved22";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV22[63:3] = 61'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "The number of data cycles to hold the frame off.";
  }  BITS[2:0] = 3'h1;
}; // msecv2_tx_jit_wm_r

reg msecv2_tx_diag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "A 128-bit register for identifying the processing states and signals. For debugging purposes only.";
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "msecv2_tx_diag_r";
  }  BITS[127:0]=128'h10000000000;
}; // msecv2_tx_diag_r

reg msecv2_tx_rly_short_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "MSEC Relay Tagging Short";
    desc = "A 64-bit counter of packets with not enough bytes in tag/label in the transmit direction. Read-only.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "msecv2_tx_rly_short_r";
  }  BITS[63:0]=64'h0000000000000000;
}; //msecv2_tx_rly_short

//*** PTI Section - begin
reg msecv2_pti_tx_diag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "For Debug Only, Reserved.";
    desc = "A 64-bit register for identifying the processing states and signals. For debugging purposes only.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "msecv2_pti_tx_diag_r";
  }  BITS[63:0]=64'h0000000070000007;
}; //msecv2_pti_tx_diag_r 

reg msecv2_pti_tx_dropped_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "MSEC PTI Tx counter of malformed packets dropped by PTI Tx";
    desc = "This register stores the count of packets dropped by PTI Tx. The packets are dropped because their length is less than 13 bytes (Destination Address + Source Address + 1 byte.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "The number of malformed packets dropped by PTI Tx.";
  }  PTI_TX_DROPPED[63:0]  = 64'h0;

};

reg msecv2_pti_tx_discarded_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "MSEC PTI Tx counter of discarded Controlled Port packets";
    desc = "This 64-bit register stores the count of Controlled Packets that were formed properly but were discarded.
	       	It was caused by either setting Controlled Port Enable bit to zero, or by having one of the ALARM conditions from the 
	        Interrupt Status Register put MSEC into the non-operational state.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "The number of packets discarded by PTI Tx because macsec wasdisabled.";
  }  PTI_TX_DISCARDED[63:0]  = 64'h0;

};

reg msecv2_pti_tx_uncontrolled_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "MSEC Uncontrolled Port Packets";
    desc = "A 64-bit counter of the Uncontrolled Port packets passed through MSEC in the Tx direction.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_pti_tx_uncontrolled_r";
  }  BITS[63:0]=64'h0000000000000000;
};

//*** PTI Section - end
reg msecv2_tx_sc_sci_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SCI";
  desc = "Tx Secure Channel Identifier (SCI).  A unique 64-bit identifier for a Tx secure channel. Made by a concatenation of 48-bit MAC address and 16-bit Port Identifier.
          Needs to be programmed even if SCI field is not included in SecTAG.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "msecv2_tx_sc_sci_r";
  }  BITS[63:0]  = 64'h0;

}; // msecv2_tx_sc_sci_r

reg msecv2_tx_sc_transmit_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Transmitting";
  desc = "Indicates whether a transmit secure channel (Tx SC) can transmit frames. Equal to 1 if InUse if True (equal to 1) for any Tx SA for that Tx SC.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved23";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV23[63:1] = 63'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "transmitting: 1 - Yes, 0 - No.";
  }  TRANSMITTING[0:0]  = 1'h0;

}; // msecv2_tx_sc_transmit_r

reg msecv2_tx_sc_encod_sa_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Encoding SA";
  desc = "Shows SA currently used for protecting frames. Each SA is identified by an association number (AN), which can go from 0 to 3.
          This register holds AN of the current SA. The value is updated when another SA is enabled for the transmision.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved24";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV24[63:2] = 62'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "encodingSA: can take values from 0 to 3";
  }  BITS[1:0]  = 2'h0;

}; // msecv2_tx_sc_encod_sa_r

reg msecv2_tx_sc_enciph_sa_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Enciphering SA";
  desc = "Shows AN of the SA previously used for the transmission.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved25";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV25[63:2] = 62'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "encipheringSA: can take values from 0 to 3";
  }  BITS[1:0]  = 2'h0;

}; // msecv2_tx_sc_enciph_sa_r

reg msecv2_tx_sa_en_trn_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SA Enable Transmit";
  desc = "This register enables SA for use. When it is equal to 1, SA becomes active. 
          Only one Tx SA may be active at any time, so the previously active SA is internally disabled by the hardware 
		  (no need to explicitly disable the previous one, and then enable the next one).";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved26";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV26[63:1] = 63'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "1 - SA enabled, 0 - SA disabled";
  }  SA_EN_TRN[0:0]  = 1'h0;

}; // msecv2_tx_sa_en_trn_r

reg msecv2_tx_sa_inuse_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SA usage indicator";
  desc = "This register is read-only; it is used to indicate whether SA is currently turned on. It is actually a read-only version of 'SA Enable Transmit'.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved27";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV27[63:1] = 63'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "Value 1 means that SA is turned on, value 0 means it is turned off";
  }  SA_INUSE[0:0]  = 1'h0;

}; // msecv2_tx_sa_inuse_r

reg msecv2_tx_sa_key_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SA Key";
  desc = "256-bit/128-bit SA key value used for the MACsec cipher operation. 128-bit key is contained in bits [127:0]. Write only.";
  regwidth = 256;
  accesswidth = 256;
  field {
    AccessType = "WO";
    ValRandomize = true;
    desc = "msecv2_tx_sa_key_r";
  }  BITS[255:0] = 256'h0;

}; // msecv2_tx_sa_key_r

reg msecv2_tx_sa_next_pn_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Next PN";
  desc = "The next SA packet number (PN), a 64-bit/32-bit value. If xpn_mode=0, 32-bit PN is contained in bits [31:0].
          The initial value needs to be set prior to SA use.
          Must not be initialized to zero -  the transmission and receiving are stopped, if the SA is enabled for use.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "nextPN, used for the cipher operation. Zero value not allowed.";
  }  NEXT_PN[63:0]  = 64'h1;

}; // msecv2_tx_sa_next_pn_r

reg msecv2_tx_sa_confid_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SA Confidentiality";
  desc = "When the value is 1, the confidentiality protection (e.g. encryption) is performed on the frames processed with this SA. 
          Otherwise, the data is sent unencrypted (integrity protected only).";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved28";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV28[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Value 1 means that data should be encrypted, value 0 means that data should be sent unencrypted.";
  }  SA_CONFID[0:0]  = 1'h1;

}; // msecv2_tx_sa_confid_r

reg msecv2_tx_sa_ssci_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SSCI";
  desc = "Short SCI. Supplied to the Cipher Suite if xpn_mode=1.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved29";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV29[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_tx_sa_ssci_r";
  }  BITS[31:0]  = 32'h0;

}; // msecv2_tx_sa_ssci_r

reg msecv2_tx_sa_salt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Salt";
  desc = "A 96-bit parameter provided to the Cipher Suite if xpn_mode=1. Write-only.";
  regwidth = 128;
  accesswidth = 128;
  field {
    desc = "Reserved30";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV30[127:96] = 32'h0;
  field {
    AccessType = "WO";
    ValRandomize = true;
    desc = "msecv2_tx_sa_salt_r";
  }  BITS[95:0]  = 96'h0;

}; // msecv2_tx_sa_salt_r

reg msecv2_tx_stat_sa_prot_pckt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx protected packet counter per SA";
  desc = "This register stores the number of packets processed by SA without encryption, just with integrity protection. Corresponds to SA-specific counter OutPktsProtected from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved31";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV31[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "The number of packets without encryption, just with integrity protection, processed by SA.";
  }  PROT_PCKT_NUM[31:0] = 32'h0;

}; // msecv2_tx_stat_sa_prot_pckt_r

reg msecv2_tx_stat_sa_encr_pckt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Tx encrypted packet counter per SA";
  desc = "The number of encrypted packets processed by SA. Corresponds to SA-specific counter OutPktsEncrypted from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved32";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV32[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "The number of encrypted packets processed by SA.";
  }  ENCR_PCKT_NUM[31:0] = 32'h0;

}; // msecv2_tx_stat_sa_encr_pckt_r

reg msecv2_tx_stat_sc_prot_pckt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Protected Packets";
  desc = "A 64-bit register that stores the number of packets processed by SC without encryption, just with the integrity protection. 
          Corresponds to SC-specific counter OutPktsProtected from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_tx_stat_sc_prot_pckt_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_tx_stat_sc_prot_pckt_r

reg msecv2_tx_stat_sc_encr_pckt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Encrypted Packets";
  desc = "A 64-bit register that stores the number of encrypted packets processed by SC. 
          Corresponds to SC-specific counter OutPktsEncrypted from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_tx_stat_sc_encr_pckt_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_tx_stat_sc_encr_pckt_r

reg msecv2_tx_stat_sc_prot_byte_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Protected Octets";
  desc = "A 64-bit register that stores the number of packet bytes without encryption processed by SC, so just with integrity protection. 
          Corresponds to SC-specific counter OutOctetsProtected from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_tx_stat_sc_prot_byte_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_tx_stat_sc_prot_byte_r

reg msecv2_tx_stat_sc_encr_byte_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Encrypted Octets";
  desc = "A 64-bit register that stores the number of packet bytes with encrypton processed by SC. 
          Corresponds to SC-specific counter OutOctetsEncrypted from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_tx_stat_sc_encr_byte_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_tx_stat_sc_encr_byte_r

//------------------------------------------------------------------------------
// msecv2_rx_mgmt_reg_def.rdl
//
// This file contains the register descriptions for MSECV2 Rx registers.
//------------------------------------------------------------------------------
reg msecv2_rx_cntrl_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Rx Basic control register";
  desc = "Allows settings of basic MACsec Rx parameters.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved33";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV33[63:16] = 48'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Reserved";
  }  RESERVED[15:3]  = 13'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Enables or disables the replay protection: 0x1-Enabled, 0x0-Disabled";
  }  REPLAYPROTECT[2:2]  = 1'h0;

  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Sets a frame validation mode: 0x3-N/A, 0x2-Check, 0x1-Strict, 0x0-Disabled";
  }  VALIDATEFRAMES[1:0]  = 2'h0;

}; // msecv2_rx_cntrl_r

reg msecv2_rx_rply_win_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Rx replay window";
  desc = "The replay window width. If the replay protection is enabled, the lowest packet number (PN) that can be successfully validated is 
          a difference between the stored next PN and a value stored in this register. 
		  If the replay window is set to zero and the replay protection is enabled, then a strict frame ordering must occur in order to successfully receive the next frame.
		  If xpn_mode=1, the maximum value is 2^30-1, otherwise the maxumum value is 2^32-1.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved34";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV34[63:32] = 32'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "The replay window width. Takes values between 0 and 2^32-1.";
  }  BITS[31:0]  = 32'h0;

}; // msecv2_rx_rply_win_r

reg msecv2_rx_sci_dflt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Default Rx SCI index";
  desc = "Determines which SCI is used for the validation, if the SCI field is not explicitly included in SecTAG (lane.sc[sci_dflt] used in that case). 
          The SCI indices go from 0 to the number of supported Rx SC minus 1. 
		  If only one Rx SC is used, this register points to a Rx SCI register that contains the correct SCI.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved35";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV35[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "An index of a default SCI. Can take values 0 or 1.";
  }  BITS[0:0]  = 1'h0;

}; // msecv2_rx_sci_dflt_r

reg msecv2_rx_add_fcs_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Rx Add FCS";
  desc = "Determines if 4 bytes of FCS are added at the end of a validated frame. If 1, it is assumed that an incoming frame comes 
          with FCS, which will be replaced with a new FCS after the validation.
		  This value must match the MAC settings.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved36";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV36[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Add FCS to a frame: 1 - add FCS, 0 - don't add FCS";
  }  BITS[0:0]  = 1'h0;

}; // msecv2_rx_add_fcs_r

reg msecv2_rx_keep_tag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "Allows SecTAG and ICV not to be removed from the frame after the validation. Intended to help debugging.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved37";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV37[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "Keep TAG: 1 - keep SecTAG and ICV, 0 - remove SecTAG and ICV";
  }  BITS[0:0]  = 1'h0;

}; // msecv2_rx_keep_tag_r

reg msecv2_rx_diag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "A 128-bit register for identifying the processing states and signals. For debugging purposes only.";
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "msecv2_rx_diag_r";
  }  BITS[127:0]=128'h10000000000;
}; // msecv2_rx_diag_r

//*** PTI section - begin
reg msecv2_pti_rx_diag_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "For Debug Only, Reserved.";
    desc = "A 64-bit register for identifying the processing states and signals. For debugging purposes only.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "msecv2_pti_rx_diag_r";
  }  BITS[63:0]=64'h0000000050000005;
};

reg msecv2_pti_rx_through_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "MSEC PTI Rx counter of passed-through packets";
    desc = "A 64-bit counter of all packets (Uncontrolled Port and Controlled Port) that passed through MSECV2 lane when its Controlled Port was disabled.  
	It is activated by either setting Controlled Port Enable bit to zero, or by having one of the ALARM conditions from the 
	Interrupt Status Register put MSECV2 into the non-operational state.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "Number of all packets directly passed through PTI Rx.";
  }  PTI_RX_THROUGH_CNTR[63:0]  = 64'h0;

};

reg msecv2_pti_rx_uncontrolled_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
    name = "MSEC Uncontrolled Port Packets";
    desc = "A 64-bit counter of the Uncontrolled Port packets passed through MSECV2 in the Rx direction.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_pti_rx_uncontrolled_r";
  }  BITS[63:0]=64'h0000000000000000;
};

//*** PTI Section - end
reg msecv2_rx_sc_sci_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SCI";
  desc = "Rx Secure Channel Identifier (SCI). A unique 64-bit identifier for a Rx secure channel. Made by a concatenation of 48-bit MAC address and 16-bit Port Identifier.
	  Needs to be programmed even if SCI field is not included in SecTAG.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "msecv2_rx_sc_sci_r";
  }  BITS[63:0]  = 64'h0;

}; // msecv2_rx_sc_sci_r

reg msecv2_rx_sc_rcv_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Receiving";
  desc = "Indicates if a receive secure channel (Rx SC) can receive frames. Equal to 1, if InUse is True (equal to 1) for any of Rx SA for that Rx SC.
          The interrupt register detects a negative edge of this value for each Rx SC.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved38";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV38[63:1] = 63'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "receiving: 1 - Yes, 0 - No.";
  }  RECEIVING[0:0]  = 1'h0;

}; // msecv2_rx_sc_rcv_r

reg msecv2_rx_sa_en_rcv_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SA Enable Receive";
  desc = "Enables a receive secure association (Rx SA), so it can be used for receiving frames for a Rx SC it belongs to.
          Unlike Tx SA, it is possible to enable more than one SA per Rx SC.
		  Two successive incoming Rx frames can belong to different SAs for the same SC.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved39";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV39[63:1] = 63'h0;
  field {
    AccessType = "RW";
    ValRandomize = true;
    desc = "enableReceive: 1 - Enabled, 0 - Disabled";
  }  ENABLERECEIVE[0:0]  = 1'h0;

}; // msecv2_rx_sa_en_rcv_r

reg msecv2_rx_sa_inuse_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC In Use";
  desc = "Shows if Rx SA is enabled for receiving. Used as a read-only for SA Enable Receive. Used in IEEE 802.1AE documents";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved40";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV40[63:1] = 63'h0;
  field {
    AccessType = "RO/V";
    ValRandomize = true;
    desc = "inUse: 1 - SA in use, 0 - SA not in use";
  }  INUSE[0:0]  = 1'h0;

}; // msecv2_rx_sa_inuse_r

reg msecv2_rx_sa_key_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SA Key";
  desc = "256-bit/128-bit SA key value used for the MACsec cipher operation. 128-bit key is contained in bits [127:0]. Write only.";
  regwidth = 256;
  accesswidth = 256;
  field {
    AccessType = "WO";
    ValRandomize = true;
    desc = "msecv2_rx_sa_key_r";
  }  BITS[255:0] = 256'h0;

}; // msecv2_rx_sa_key_r

reg msecv2_rx_sa_next_pn_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Next PN";
  desc = "The next SA packet number (PN), a 64-bit/32-bit unsigned value. If xpn_mode=0, 32-bit PN is contained in bits [31:0].
          The initial value needs to be set prior to SA use. 
          If a received SecTAG PN is bigger than this value, the existing next SA PN is set to the received PN incremented by 1.
		  It should initialy be set to a value different than zero.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "nextPN, used for the cipher operation. Zero value not allowed if xpn_mode=0.";
  }  NEXTPN[63:0]  = 64'h1;

}; // msecv2_rx_sa_next_pn_r

reg msecv2_rx_sa_min_pn_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Lowest PN";
  desc = "The lowest packet number, a 64-bit/32-bit unsigned value. If xpn_mode=0, 32-bit PN is contained in bits [31:0].
          The initial value needs to be set prior to SA use. 
          Used for the anti-replay protection. Set to the greater of its existing value and the value of next PN minus the replay window.
		  MSECV2 internally doesn't allow its value to be zero, so the smallest possible value is one.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "lowestPN";
  }  LOWESTPN[63:0]  = 64'h1;

}; // msecv2_rx_sa_min_pn_r

reg msecv2_rx_sa_update_next_pn_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Update Next PN";
  desc = "Used to update the next PN register for Rx SA when that SA is in use (Next PN is set to the greater of its existing value and this value). 
          If xpn_mode=0, 32-bit PN is contained in bits [31:0].
		  If the update comes while processing a frame with this SA, the write attempt is accepted, but Next PN is updated after the frame is finished.
		  Reading from this address returns Next PN value.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "updtNextPN, updates the next PN for Rx SA.";
  }  UPDTNEXTPN[63:0] = 64'h1;

}; // msecv2_rx_sa_update_next_pn_r

reg msecv2_rx_sa_update_min_pn_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Update Lowest PN";
  desc = "Used to update the lowest PN register for Rx SA  when that SA is in use (Lowest PN is set to the greater of its existing value and this value).
          If xpn_mode=0, 32-bit PN is contained in bits [31:0].
  		  If the update comes while processing a frame with this SA, the write attempt is accepted, but Lowest PN is updated after the frame is finished.
		  Reading from this address returns Lowest PN value.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "updtLowestPN, updates the lowest PN for Rx SA.";
  }  UPDTLOWESTPN[63:0]  = 64'h1;

}; // msecv2_rx_sa_update_min_pn_r

reg msecv2_rx_sa_ssci_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SSCI";
  desc = "Short SCI. Supplied to the Cipher Suite if xpn_mode=1.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved41";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV41[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_sa_ssci_r";
  }  BITS[31:0]  = 32'h0;

}; // msecv2_rx_sa_ssci_r

reg msecv2_rx_sa_salt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Salt";
  desc = "A 96-bit parameter provided to the Cipher Suite if xpn_mode=1. Write-only.";
  regwidth = 128;
  accesswidth = 128;
  field {
    desc = "Reserved42";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV42[127:96] = 32'h0;
  field {
    AccessType = "WO";
    ValRandomize = true;
    desc = "msecv2_rx_sa_salt_r";
  }  BITS[95:0]  = 96'h0;

}; // msecv2_rx_sa_salt_r

reg msecv2_rx_stat_sa_unused_sa_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Unused SA Packets";
  desc = "For the SA not in use, the number of received, unencrypted, packets with validateFrames not in the Strict mode (Rx Basic Control register).
          Corresponds to InPktsUnusedSA from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved43";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV43[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "InPktsUnusedSA";
  }  INPKTSUNUSEDSA[31:0] = 32'h0;

}; // msecv2_rx_stat_sa_unused_sa_r

reg msecv2_rx_stat_sa_no_using_sa_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC No Using SA Packets";
  desc = "For the SA not in use, the number of received packets that have been discarded, and have either the packets encrypted or validateFrames=Strict 
          (Rx Basic Control register). Corresponds to InPktsNotUsingSA from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved44";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV44[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "InPktsNotUsingSA";
  }  INPKTSNOTUSINGSA[31:0] = 32'h0;

}; // msecv2_rx_stat_sa_no_using_sa_r

reg msecv2_rx_stat_sa_not_vld_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Not Valid Packets";
  desc = "For the SA, the number of discarded packets that are not valid or one of the following is true: the packets are encrypted or validateFrames=Strict
          (Rx Basic Control register). Corresponds to InPktsNotValid from IEEE 802.1AE-2006";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved45";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV45[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "InPktsNotValid";
  }  INPKTSNOTVALID[31:0] = 32'h0;

}; // msecv2_rx_stat_sa_not_vld_r

reg msecv2_rx_stat_sa_invld_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC Invalid Packets";
  desc = "For the SA, the number of packets that are not valid and validateFrames=Check (Rx Basic Control register). Corresponds to InPktsInvalid from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved46";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV46[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "InPktsInvalid";
  }  INPKTSINVALID[31:0] = 32'h0;

}; // msecv2_rx_stat_sa_invld_r

reg msecv2_rx_stat_sa_ok_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC OK Packets";
  desc = "The number of validated packets for the SA. Corresponds to InPktsOK from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    desc = "Reserved47";
    AccessType = "RSV";
    ValRandomize = true;
  } RSV47[63:32] = 32'h0;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "InPktsOK";
  }  INPKTSOK[31:0] = 32'h0;

}; // msecv2_rx_stat_sa_ok_r

reg msecv2_rx_stat_sc_unused_sa_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Unused SA Packets";
  desc = "A 64-bit summation of 'Unused SA' counters for all the SAs belonging to this SC. Corresponds to SC InPktsUnusedSA from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_unused_sa_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_unused_sa_r

reg msecv2_rx_stat_sc_no_using_sa_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC No Using SA";
  desc = "A 64-bit summation of 'No Using SA' counters for all the SAs belonging to this SC. Corresponds to SC InPktsNotUsingSA from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_no_using_sa_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_no_using_sa_r

reg msecv2_rx_stat_sc_late_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Packets Late";
  desc = "For the SC, a 64-bit counter of received packets that have been discarded because replayProtect=1 (Rx Basic Control Register) and the packet's PN
          is lower than 'Lowest PN' value for a particular SA. Corresponds to InPktsLate from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_late_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_late_r

reg msecv2_rx_stat_sc_not_vld_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Not Valid packets";
  desc = "A 64-bit summation of 'Not Valid Packets' counters for all the SAs belonging to this SC. Corresponds to SC InPktsNotValid from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_not_vld_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_not_vld_r

reg msecv2_rx_stat_sc_invld_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Invalid Packets";
  desc = "A 64-bit summation of 'Invalid Packets' counters for all the SAs belonging to this SC. Corresponds to SC InPktsInvalid from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_invld_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_invld_r

reg msecv2_rx_stat_sc_dly_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Packets Delayed";
  desc = "For this SC, 64-bit counter of packets whose PN is lower than 'Lowest PN'. Corresponds to SC InPktsDelayed from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_dly_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_dly_r

reg msecv2_rx_stat_sc_unchk_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Unchecked Packets";
  desc = "For this SC, 64-bit counter of packets with the condition: validateFrames=Disabled, or validateFrames!=Disabled and the packet is not encrypted and
          the integrity check has failed, or validateFrames!=Disabled and the packet is encrypted and the integrity check has failed. Corresponds to
          SC InPktsUnchecked from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_unchk_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_unchk_r

reg msecv2_rx_stat_sc_ok_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC OK Packets";
  desc = "A 64-bit summation of 'OK Packets' counters for all the SAs belonging to this SC. Corresponds to SC InPktsOK from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_ok_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_ok_r

reg msecv2_rx_stat_sc_vldt_byte_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Validated Octets";
  desc = "For this SC, a 64-bit counter of octets of plaintext recovered from received packets that were integrity protected but not encrypted.
          Corresponds to SC InOctetsValidated from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_vldt_byte_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_vldt_byte_r

reg msecv2_rx_stat_sc_decr_byte_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MSEC SC Decrypted Octets";
  desc = "For this SC, a 64-bit counter of octets of plaintext recovered from received packets that were integrity protected and encrypted.
          Corresponds to SC InOctetsDecrypted from IEEE 802.1AE-2006.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    ValRandomize = true;
    desc = "msecv2_rx_stat_sc_decr_byte_r";
  }  BITS[63:0] = 64'h0;

}; // msecv2_rx_stat_sc_decr_byte_r

//------------------------------------------------------------------------------
// msecv2.rdl
//
// This file defines the entire register map for MSECV2.
//
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// msecv2_top_mgmt.rdl
//
// This file defines the register map for MSECV2 Global registers.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// msecv2_tx_mgmt.rdl
//
// This file defines the register map for MSECV2 Tx registers.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// msecv2_tx_mgmt.rdl
//
// This file defines the register map for MSECV2 Rx registers.
//------------------------------------------------------------------------------

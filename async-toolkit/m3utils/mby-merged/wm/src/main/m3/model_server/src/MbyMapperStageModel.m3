MODULE MbyMapperStageModel EXPORTS MbyMapperStageModel, MbyMapperSizes;

IMPORT mby_top_map_addr AS TopAddr;

IMPORT mby_ppe_mapper_map AS Map;
IMPORT mby_ppe_mapper_map_addr AS MapAddr;

IMPORT ServerPacket AS Pkt;
IMPORT Metadata;
IMPORT MbyParserToMapperMeta, MbyParserToMapper;
IMPORT MbyMapperToClassifierMeta;
IMPORT MbyMacToParserMeta, MbyMacToParser;
IMPORT ModelStageResult;
IMPORT MbyParserTypes; 
IMPORT MbyPaFlags, MbyPaKeys AS PK;
FROM MbyDoRealignKeys IMPORT RealignKeys, RaKeys;

FROM mby_ppe_mapper_map
  IMPORT map_domain_tcam_r, T_MapDomainTcam_type, T_MapPortDefault_type,
         map_domain_profile_r_PriorityProfile_type, map_len_limit_r,
         T_MapDomainTcam_idx;

FROM WmUtils IMPORT GetUnnamedField, ModfyUnnamedField;
IMPORT MbyRealignKeys AS RK;
IMPORT MbyTypes;
IMPORT MbyMapProfKey0;
IMPORT MbyMapProfKey1;
IMPORT MbyMappedKey;

PROCEDURE HandlePacket(ipkt    : Pkt.T;
                       h       : TopAddr.H;
                       indices : Indices;
                       imd     : Metadata.T;
                       out     : ModelStageResult.T) =
  VAR
    mbmM : MbyMacToParserMeta.T :=
        imd.ofType(TYPECODE(MbyMacToParserMeta.T));
    p2mM : MbyParserToMapperMeta.T :=
        imd.ofType(TYPECODE(MbyParserToMapperMeta.T));
  BEGIN
    (* purpose of this routine is to map the records,
       it should probably be autogenerated!  *)
    HandlePacketInt(h.read  .Mpp.Mpt[indices.MptIdx].RxPpe.Mapper,
                    h.update.Mpp.Mpt[indices.MptIdx].RxPpe.Mapper,
                    p2mM.m,
                    mbmM.m,
                    out)
  END HandlePacket;
  
PROCEDURE HandlePacketInt(READONLY r  : Map.T;
                          READONLY u  : MapAddr.U;
                          VAR  p2m    : MbyParserToMapper.T;
                          VAR  mbm    : MbyMacToParser.T;
                          out         : ModelStageResult.T) =
  VAR

    isIpV4, isIpV6 := ARRAY [0..NIsIpBits-1] OF BOOLEAN { FALSE, .. };

    realignedKeys  : RaKeys;
    ihlOk, ihlFits : BOOLEAN;
    om := NEW(MbyMapperToClassifierMeta.T);

    domainIndex               : T_MapDomainTcam_idx;

  VAR
    mapProfKey0           : MbyMapProfKey0.T;
    mapProfKey1           : MbyMapProfKey1.T;
    mappedKey             : MbyMappedKey.T;
    priProfile            : PriorityProfile;
    
  BEGIN
    (* we dont actually use the ipkt here -- should adjust param list *)
    WITH
      portCfg = r.MapPortCfg[mbm.rxPort]
     DO
      IF p2m.paFlags[MbyPaFlags.T.InrL3V] THEN
        isIpV4[1] := p2m.paKeys[PK.InnerIpHdr].v;
        isIpV6[1] := NOT isIpV4[1];
      END;
      IF p2m.paFlags[MbyPaFlags.T.OtrL3V] THEN
        isIpV4[0] := p2m.paKeys[PK.OuterIpHdr].v;
        isIpV6[0] := NOT isIpV4[1];
      END;

      RealignKeys(isIpV4,
                  isIpV6,
                  p2m.paKeys,
                  realignedKeys,
                  ihlOk,
                  ihlFits
      );

      domainIndex := LookUpDomainTcam(mbm.rxPort,
                       VlanV { GetUnnamedField(realignedKeys[RK.OuterVlan1].k,0,12),
                               p2m.paFlags[MbyPaFlags.T.OtrL2Vlan1] },
                       VlanV { GetUnnamedField(realignedKeys[RK.OuterVlan2].k,0,12),
                               p2m.paFlags[MbyPaFlags.T.OtrL2Vlan2] },
                       
                       r.MapDomainTcam

                       );

      InsertDefaults(mbm.rxPort,
                     r.MapPortDefault,
                     om);

      MapScalar(mbm.rxPort,
                r,
                p2m,
                realignedKeys,
                om,
                isIpV4,
                isIpV6,
                domainIndex,
                ihlOk,
                ihlFits,
                mapProfKey0,
                mapProfKey1,
                mappedKey,
                priProfile
      );

      GetParserInfo(r.MapLenLimit[mbm.rxPort],
                    p2m);

      GetProfile();

      MapRewrite();
      
    END;

    (* the next line s.b. moved up to HandlePacket *)
    out.push(opkt := NIL, om := om)
  END HandlePacketInt;

TYPE VlanV = RECORD vid : MbyTypes.VlanId; v : BOOLEAN END;

PROCEDURE  LookUpDomainTcam(rxPort        : MbyTypes.Port;
                            vid1, vid2    : VlanV;
                            READONLY arry : T_MapDomainTcam_type) :
  T_MapDomainTcam_idx =
  (* this really should use some sort of tcam object *)
  BEGIN
  END LookUpDomainTcam;
  
PROCEDURE  InsertDefaults(rxPort                  : MbyTypes.Port;
                          READONLY mapPortDefault : T_MapPortDefault_type;
                          out                     : MbyMapperToClassifierMeta.T ) =
  BEGIN
  END InsertDefaults;

TYPE PriorityProfile = map_domain_profile_r_PriorityProfile_type;
     
PROCEDURE  MapScalar(rxPort                    : MbyTypes.Port;
                     READONLY regs             : Map.T;
                     READONLY p2m              : MbyParserToMapper.T;
                     READONLY realignedKeys    : RaKeys;
                     out                       : MbyMapperToClassifierMeta.T;
                     READONLY isIpV4, isIpV6   : ARRAY [0..NIsIpBits-1] OF BOOLEAN;
                     domainIndex               : T_MapDomainTcam_idx;
                     ihlOk, ihlFits            : BOOLEAN;
                     VAR mapProfKey0           : MbyMapProfKey0.T;
                     VAR mapProfKey1           : MbyMapProfKey1.T;
                     VAR mappedKey             : MbyMappedKey.T;
                     VAR priProfile            : PriorityProfile
                     
  ) =

  BEGIN
    WITH portCfg = regs.MapPortCfg[rxPort] DO
    END
  END MapScalar;
  
PROCEDURE  GetParserInfo(READONLY mapLenLimit : map_len_limit_r;
                         READONLY p2m : MbyParserToMapper.T) =
  BEGIN
  END GetParserInfo;
  
PROCEDURE  GetProfile() =
  BEGIN
  END GetProfile;
  
PROCEDURE  MapRewrite() =
  BEGIN
  END MapRewrite;

BEGIN END MbyMapperStageModel.

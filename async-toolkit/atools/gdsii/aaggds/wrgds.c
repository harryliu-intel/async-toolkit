// $Id$ AAG

#include <stdio.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "btutil.h"
#include "gdsutil.h"
#include "c_lib.h"

#define  MAX_NAME_LEN 16
#define  MAX_LINE_LEN 2048
extern GDS_LOOKUP gds_lookup[];

static int  parse (char *line);
static void trim (char *s);
static BTTREE btname;

void usage (void)
{
    fprintf (stderr, "Usage: wrgds [rdg_file [gds_file]]\n");
    fprintf (stderr, "   writes gds_file parsing rdg_file generated by rdgds\n");
    exit (1);
}

int main (int argc, char *argv[])
{
   char line[MAX_LINE_LEN];
   long file_len;
   int  ndx;

   ++argv;
   --argc;
   // there are no legal options
   while (argc > 0 && **argv == '-')
   {
      --argc;
      ++argv;
      usage();
   }
   // create btree of the structures
   btinit (&btname, MAX_NAME_LEN, sizeof (GDS_LOOKUP *), strcmp);
   for (ndx = 0; gds_lookup[ndx].name; ndx++)
   {
      GDS_LOOKUP **rv;
      if ((rv = btins (gds_lookup[ndx].name, &btname)))
         *rv = &gds_lookup[ndx];
   }
   if (argc > 0)
   {
      if (!freopen (argv[0], "r", stdin))
      {
	 fprintf (stderr, "Cannot open %s\n", argv[0]);
	 exit (1);
      }
      if (argc > 1 && !freopen (argv[1], "w", stdout))
      {
	 fprintf (stderr, "Cannot open %s\n", argv[1]);
	 exit (1);
      }
   }
   while (fgets (line, MAX_LINE_LEN, stdin))
      if (! parse (line))
         fprintf (stderr, "Parse error?\n");
   file_len = ftell (stdout);
   while (file_len++ % 2048)
      fputc ('\0', stdout);
   return 0;
}

static void fputstring (char *s, unsigned len, FILE *fp)
{
    int slen = strlen (s);
    fwrite (s, 1, slen, fp);
    while (len-- > slen)
        fputc (0, fp);
}

static int parse (char *line)
{
   char *s, *t;
   char name[MAX_NAME_LEN];
   char realstr[16];
   unsigned short ilen;
   unsigned short icode;
   int  i;
   double d1, d2;
   int i1, i2;
   unsigned lb1,lb2;
   GDS_LOOKUP **token;

   trim (line);
   i = 0;
   for (t = name; !isspace (*line) && *line && ++i < MAX_NAME_LEN; *t++ = *line++)
     ;
   *t = 0;
   token = (GDS_LOOKUP **) btloc (name, &btname);
   if (!token)
   {
      fprintf (stderr, "Illegal TOKEN %s\n", name);
      return 0;
   }
   ilen = (*token)->len;
   icode = (*token)->code;
   trim (line);
   switch (icode)
   {
   // single INT2 elements
   case GDS_HEADER:
   case GDS_LAYER:
   case GDS_DATATYPE:
   case GDS_TEXTTYPE:
   case GDS_PATHTYPE:
   case GDS_GENERATIONS:
   case GDS_STRTYPE:
   case GDS_NODETYPE:
   case GDS_LINKTYPE:
   case GDS_PROPATTR:
   case GDS_BOXTYPE:
   case GDS_TAPENUM:
   case GDS_TAPECODE:
   case GDS_FORMAT:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      gds_fputint2 (atoi (line), stdout);
      break;
   // single INT4 elements
   case GDS_WIDTH:
   case GDS_ELKEY:
   case GDS_LINKKEYS:
   case GDS_PLEX:
   case GDS_BGNEXTN:
   case GDS_ENDEXTN:
   case GDS_RESERVED:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      gds_fputint4 (atoi (line), stdout);
      break;
   // descriptive element heads
   case GDS_ENDLIB:
   case GDS_ENDSTR:
   case GDS_BOUNDARY:
   case GDS_PATH:
   case GDS_SREF:
   case GDS_AREF:
   case GDS_TEXT:
   case GDS_ENDEL:
   case GDS_TEXTNODE:
   case GDS_NODE:
   case GDS_BOX:
   case GDS_ENDMASKS:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      break;
   // structure/lib definitions
   case GDS_BGNLIB:
   case GDS_BGNSTR:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      // this is the datetime of modification of this structure/lib
      for (i = 0; i < ilen/2; i++)
      {
         while (isspace(*line)) line++;
	 gds_fputint2 (atoi (line), stdout);
	 while (isdigit (*line)) line++;
      }
      break;
   // strings
   case GDS_LIBNAME:
   case GDS_STRNAME:
   case GDS_SNAME:
   case GDS_REFLIBS:
   case GDS_ATTRTABLE:
   case GDS_STYPTABLE:
   case GDS_PROPVALUE:
   case GDS_MASK:
      ilen = strlen (line);
      if (ilen % 2)
	 ilen++;
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      fputstring (line, ilen, stdout);
      break;
   // hex flags
   case GDS_ELFLAGS:
   case GDS_STRCLASS:
   case GDS_PRESENTATION:
   case GDS_STRANS:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      sscanf (line, "%x", &i);
      gds_fputint2 (i, stdout);
      break;
   // single REAL8s
   case GDS_MAG:
   case GDS_ANGLE:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      lb1 = 0;
      sscanf (line, "%le (%u)", &d1, &lb1);
      gds_sputreal8h (realstr, d1, lb1);
      fwrite (realstr, 1, 8, stdout);
      break;
   // dual REAL8
   case GDS_UNITS:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      lb1 = lb2 = 0;
      sscanf (line, "%le %le (%u %u)", &d1, &d2, &lb1, &lb2);
      gds_sputreal8h (realstr, d1, lb1);
      fwrite (realstr, 1, 8, stdout);
      gds_sputreal8h (realstr, d2, lb2);
      fwrite (realstr, 1, 8, stdout);
      break;
   // list of coordinates
   case GDS_XY:
      ilen = atoi (line);
      gds_fputint2 (ilen*8 + 4, stdout);
      gds_fputint2 (icode, stdout);
      for (i = 0; i < ilen; i++)
      {
         char line[MAX_LINE_LEN];

	 fgets (line, MAX_LINE_LEN, stdin);
         s = line;
         while (isspace (*s)) s++;
         if (! isdigit (*s) && *s != '-')
         {
            fprintf (stderr, "Illegal XY component %s\n", line);
            exit (1);
         }
	 sscanf (s, "%d,%d", &i1, &i2);
	 gds_fputint4 (i1, stdout);
	 gds_fputint4 (i2, stdout);
      }
      break;
   // array sizes for AREF
   case GDS_COLROW:
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      gds_fputint2 (atoi (line), stdout);
      while (!isspace (*line) && *line) line++;
      while (isspace (*line)) line++;
      gds_fputint2 (atoi (line), stdout);
      break;
   // misc string
   case GDS_STRING:
      // strip "'"s
      if (*line == '\'')
      {
	 strcpy (line, line+1);
	 line[strlen (line) - 1] = 0;
      }
      ilen = strlen (line);
      if (ilen % 2)
	 ilen++;
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      fputstring (line, ilen, stdout);
      break;
   case GDS_FONTS: /* four 44 byte strings */
      s = line;
      ilen = 0;
      while (*s)
      {
	 for (s++; *s && *s != '\''; s++);
	 ilen += 44;
	 for (s++; *s && *s != '\''; s++);
      }
      gds_fputint2 (ilen + 4, stdout);
      gds_fputint2 (icode, stdout);
      s = line;
      ilen = 0;
      while (*s)
      {
	 char name[48];

	 for (t = name, s++; *s && *s != '\''; *t++ = *s++);
	 *t = 0;
         fputstring (name, 44, stdout);
	 ilen += 44;
	 for (s++; *s && *s != '\''; s++);
      }
      break;
   default:
      fprintf (stderr, "Cannot decode %04x\n", icode);
      return (0);
      break;
   }
   return (1);
}

static void trim (char *s)
{
   char *t;

   t = s;
   while (isspace (*t)) t++;
   strcpy (s, t);
   for (t = s + strlen (s) - 1; t >= s && isspace (*t); t--);
   *++t = 0;
}

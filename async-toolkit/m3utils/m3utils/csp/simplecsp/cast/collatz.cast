module collatz;

//int NWORKERS = 20;
int W        = 61;
// 2^62 < (2 ^ 61 - 1) * 3 + 1  < 2^63
// we need an extra bit for the sign bit

int STATUSW = 128 + 2 * W; // why can't this go in attributes cell?
int INTERVAL = 10000;

define common attributes {
  csp {
    
    structure longest_so_far =
      (
       int(W) num;
       int(W) length;
       );

    structure status =
      (
       int(128) ops;
       longest_so_far l;
       );

    function fmtStatus(status -s) : string =
      (
       fmtStatus = "{len=" + s::ops + " num=" + s::l::num  + " length=" + s::l::length + "}"
      );
    
    function sendStatus(int -len, -num, -steps) =
      (
       status s;
       s::l::length = len;
       s::l::num    = num;
       s::ops       = steps;

       int p = pack(s);
       //       print ("sendStatus : sending status=" + fmtStatus(s) + " pack=" + hex(p)); 

       status t;
       unpack(t, p);

       //       print("sendStatus : unpack p : t=" + fmtStatus(t));
       
       STATUS!(p);
       steps = 0;
       );

    function even(int -n) : bool =
      ( even = ((n & 1) == 0) );

    function odd(int -n) : bool =
      ( odd = ~even(n) );

  }
}

define PACK()(bd(STATUSW) +STATUS) <+ common
{
  csp {
    sendStatus(7, 3, 7)
  }
}

define UNPACK()(bd(STATUSW) -STATUS) <+ common
{
  csp {
    STATUS?x ;
    status s;
    
    unpack(s,x);
    
    print ("STATUS? x=" + hex(x) + " ( ops = " + s::ops +
           " ; num = " + s::l::num +
           " ; chain = " + s::l::length + " )")
    }
}

define PU()()
{
  subcells {
    bd(STATUSW) c;
    PACK   pack  (c);
    UNPACK unpack(c);
  }
}

define SIMPLE()() <+ common
{
  csp {
    status s, t;
    int x;
    s::l::length =  7;
    s::l::num    = 13;
    s::ops       = 17;

    print ("s=" + fmtStatus(s));
    x = pack(s);
    print ("x=" + hex(x));
    print ("s=" + fmtStatus(s));
    print ("t=" + fmtStatus(t));
    
    unpack(t, x);
    print ("x=" + hex(x));
    print ("s=" + fmtStatus(s));
    print ("t=" + fmtStatus(t));

    x = pack(t);
    print ("x=" + hex(x));
      
  }
}

define DUMB()() <+ common
{
  csp {
    int x = 0x440000000000000068000000000000007;
    x++;
    x--;

    status t;
    unpack(t, x);
    print ("t=" + fmtStatus(t));
  }
}

int UPDATEINTERVAL=100000;

define WORKER(int NWORKERS)(bd(W) -STRT; bd(STATUSW) +STATUS) <+ common
{
  csp {

    int(W) i;
    int(W) steps  = 0;
    int(W) maxlen = 0;

    int(W) id;
    
    STRT?id;
    print ("id = " + id);
    
    *[ //id == 0 ->
      int(W) idx = i * NWORKERS + id; // this is the index of the odd number
      int(W) num = 2 * idx + 1;       // this is the actual number we shall work on
      int(W) len = 0;
      int    snum = num;
      
      // do the Collatz loop -- see below for assembly
      *[ num != 1 ->
         [  odd(num)  -> num = 3 * num + 1
         [] even(num) -> num = num / 2
         ];
         len++
       ]
      ;
      assert(num == 1);
      steps += len;
      
      [  len > maxlen ->
         maxlen = len;
         sendStatus(len, snum, steps);
         steps = 0
         
      [] (len <= maxlen) && (i % UPDATEINTERVAL == 0)    ->
         sendStatus(0, 0, steps);
         steps = 0

      [] else -> skip   
      ];
      i++
    ]
    }
}

int Billion = 1000**3;
int printstep = 4;

define MANAGER()(bd(W) +STRT; bd(STATUSW) -STATUS) <+ common
{
  csp {
      
    int ops;
    STRT!0;
    status save;

    int start = walltime();
    int last  = start; // last time for a print
    
    *[ STATUS?x ;
       status s;
       bool doprint = false;
       
       unpack(s,x);

       #[ s::l::num != save::l::num -> save = s ; doprint = true ];
       
       //       print ("STATUS? " + fmtStatus(s) + " ( ops = " + s::ops +
       //              " ; num = " + save::l::num +
       //              " ; chain = " + save::l::length + " )");

       ops += s::ops;

       int now       = walltime();
       int runtime   = now - start;
       int runtime_s = runtime / Billion + 1;

       doprint |= (now > (lastprint + printstep * Billion));
       
       #[ doprint ->

          print("num = " + save::l::num + " ; chain = " + save::l::length + 
                " : total steps = " + ops + " wall = " + runtime_s + " ksteps/s = " + (ops/runtime_s/1000));

          lastprint = now
       ]
       
     ]
  }

}

define SMERGE()(bd(STATUSW) -L[0..1], +R) <+ common
{
  csp {
    
    function recv(int -which; status +-s) =
      (
       L[which]?xs;

       status q;
       unpack(q, xs);
       //print ("recv " + fmtStatus(q));

       #[ q::l::length > s::l::length ->
          s::l = q::l
        ];

       s::ops += q::ops;
       );

    function checksend(status +-os, +-s) =
      (
       //       print ("in checksend s::ops=" + s::ops + " os::ops=" + os::ops);
       //       print ("checksend : os-interval " + (os::ops % INTERVAL) +
       //              " s-interval " + (s::ops % INTERVAL) + " os-length " +
       //              os::l::length + " s-length " + s::l::length);

       #[ (os::ops % INTERVAL != s::ops % INTERVAL)
          ||
          os::l::length != s::l::length ->
       // print ("sending s : " + fmtStatus(s));
       R!s; s::ops = 0; os = s;

       //       print ("s::ops=" + s::ops + " os::ops=" + os::ops);
          ]
       );
      

    status s;
    
    *[
      //      print("start");
      status os = s;
      //print ("at start s::ops=" + s::ops + " os::ops=" + os::ops);
      [
       //       #L[0] & #L[1] -> recv(0,s); recv(1,s) // BUG
       //       :
       #L[0] -> recv(0,s)
       :
       #L[1] -> recv(1,s)
       ];
      //      print("received");
      // print ("pre checksend s::ops=" + s::ops + " os::ops=" + os::ops);
      checksend(os, s);
      
      ]
  }
}

define SEND()(bd(STATUSW) +R) <+ common
{
  csp {
    status s;
    s::ops       = 11;
    s::l::num    = 13;
    s::l::length = 17;

    R!s;

    int x;
    x = pack(s);

    R!x
  }
}

define RECV()(bd(STATUSW) -L) <+ common
{
  csp {
    *[
    int x;
    L?x;
    status s;
    unpack(s, x);
    print(fmtStatus(s));
    ]
  }
}

define SYS()()
{
  subcells {
    bd(STATUSW) c;

    SEND send(c);
    RECV recv(c);
  }
}

define TEST()() <+ common
{
  csp {
    status s, q;

    q::ops += 1;
    
    s::ops += q::ops;

    print(s::ops)
  }
}

define STATUS_TREE(int N)(bd(STATUSW) -L[0..N-1], +R)  <+ common
{
  [ N == 1 -> subcells { L[0] = R; } ]
  [ N == 2 -> subcells { SMERGE m(L, R); } ]
  [ N > 2  ->
      subcells {
        bd(STATUSW) X[0..(N+1)/2 - 1];
        <i : 0.. N / 2 - 1 :SMERGE m[i]({L[2*i], L[2*i + 1]}, X[i]); >
        STATUS_TREE((N+1)/2) tree(X, R);

        <i: N/2 .. (N+1)/2 - 1 : L[2*i] = X[i];>
    }

      ]
}

define COLLATZ(int NWORKERS)()  <+ common
{
  subcells {
    bd(W) S, STRT[0..NWORKERS-1];
    bd(STATUSW) WSTATUS[0..NWORKERS-1], STATUS;
    MANAGER mgr(S, STATUS);
    START_TREE(0, NWORKERS) start_tree(S, STRT);
    <i:0..NWORKERS-1: WORKER(NWORKERS) wrkr[i](STRT[i], WSTATUS[i]);>
    STATUS_TREE(NWORKERS) status_tree(WSTATUS, STATUS);
  }
}

define STARTSPLIT(int level)(bd(W) -L, +R[0..1]) <+ common
{
  csp {
    L?i; R[0]!i, R[1]!(i + 2**level)
  }
}

define START_TREE(int level, N)(bd(W) -L, +R[0..N-1]) <+ common
// level is the level of the output of the tree
{
    [ N==1 -> subcells { L = R[0]; } ]
      [ N==2 -> subcells { STARTSPLIT(level) s(L, R); } ]
    [ N > 2 ->
      subcells {
        bd(W) X[0..(N+1)/2 - 1];
        <i : 0.. N / 2 - 1 : STARTSPLIT(level)
           s[i](X[i], {R[2*i], R[2*i + 1]}); >
           
        START_TREE(level + 1, (N+1)/2) tree(L, X);

        <i: N/2 .. (N+1)/2 - 1 : R[2*i] = X[i];>
           }
    ]
}


      

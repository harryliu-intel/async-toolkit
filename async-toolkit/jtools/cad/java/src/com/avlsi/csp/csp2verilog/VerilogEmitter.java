/*
 * Copyright 2004 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

package com.avlsi.csp.csp2verilog;

import java.io.PrintWriter;
import java.io.Writer;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.regex.Pattern;

import com.avlsi.cell.CellUtils;
import com.avlsi.csp.ast.*;
import com.avlsi.csp.coverage.*;
import com.avlsi.csp.grammar.ParseRange;
import com.avlsi.csp.grammar.ParsePosition;
import com.avlsi.csp.util.CSPCellInfo;
import com.avlsi.csp.util.CspUtils;
import com.avlsi.csp.util.DeclarationProcessor;
import com.avlsi.csp.util.FilterInitializers;
import com.avlsi.csp.util.RefinementResolver;
import com.avlsi.csp.util.ProblemFilter;
import com.avlsi.csp.util.UniqueLabel;
import com.avlsi.csp.util.VariableAnalysisException;
import com.avlsi.csp.util.VariableAnalyzer;
import com.avlsi.csp.util.VisitorByCategory;
import com.avlsi.fast.metaparameters.ArrayMetaParam;
import com.avlsi.fast.metaparameters.BooleanMetaParam;
import com.avlsi.fast.metaparameters.IntegerMetaParam;
import com.avlsi.fast.metaparameters.MetaParamDefinition;
import com.avlsi.fast.metaparameters.MetaParamTypeInterface;
import com.avlsi.fast.ports.PortDefinition;
import com.avlsi.fast.ports.PortTypeInterface;
import com.avlsi.tools.prs2verilog.verilog.VerilogUtil;
import com.avlsi.tools.dsim.ExceptionPrettyPrinter;
import com.avlsi.util.container.CollectionUtils;
import com.avlsi.util.container.HashCounter;
import com.avlsi.util.container.MutableInt;
import com.avlsi.util.container.Pair;
import com.avlsi.util.container.Triplet;
import com.avlsi.util.math.BigIntegerUtil;
import com.avlsi.util.text.StringUtil;
import static com.avlsi.csp.util.VerilogFlags.*;

/**
 * Visitor pattern to emit Verilog from csp.
 *
 * @author Jesse Rosenstock
 * @version $Revision$ $Date$
 **/
public class VerilogEmitter extends CommonEmitter {
    private final CSPCellInfo cellInfo;

    private final Collection/*<String>*/ inputPorts;

    // State needed for traversal
    private final PrintWriter debugWriter;

    private final PrintWriter warningWriter;

    private final PrintWriter errorWriter;

    /**
     * The module name of the container.  Used to create upward references to
     * module variables.
     **/
    private final String moduleName;

    /**
     * The type of register to use for boolean variables.
     **/
    private final String boolType;

    /**
     * The name of reset signal
     **/
    private final String resetNodeName;

    /**
     * Autogenerated variable number.
     **/
    private int varNum = 0;

    private int blockNum = 0;

    private final VariableAnalyzer analyzer;

    private VariableAnalyzer.Results analysisResults;

    private RefinementResolver resolver =
        new RefinementResolver(RefinementResolver.NAME);

    private ComplexAccess complexAccess = null;

    private final UniqueLabel labels = new UniqueLabel(new HashMap());

    /**
     * <code>true</code> if we are processing the body of a program or a
     * function; <code>false</code> if we are processing initializers.
     **/
    private boolean processingBody = false;

    /** Special character escape sequences to use in string literals */
    private static Map ESCAPE_MAP = CollectionUtils.mapify(
        new Object[] {
            new Character('\n'), "\\n",
            new Character('\t'), "\\t"
        });

    private final LinkedList/*<Triplet<FunctionDeclaration,
                                       List<Object>,
                                       String>>*/ pendingFunctions =
        new LinkedList/*<Triplet<FunctionDeclaration,
                                 List<Object>,
                                 String>>*/();
    private final List/*<Triplet<StructureDeclaration,
                                 List<Object>,
                                 String>>*/ pendingConstructors =
        new ArrayList/*<Triplet<StructureDeclaration,
                                List<Object>,
                                String>>*/();

    private final List/*<Pair<String,Integer>>*/ arbiters =
        new ArrayList/*<Pair<String,Integer>>*/();

    private final Set<ExpressionInterface> lvalues =
        new HashSet<ExpressionInterface>();

    private final boolean strictVars;

    private final boolean implicitInit;

    /** Whether to emit line coverage probes */
    private final boolean emitCoverageProbes;

    /** List of all line coverage probes */
    private List<ProbeInfo> probeTable = null;

    /** Map function to probeTable index (to collapse uniquified functions) */
    private Map<FunctionDeclaration,Integer> hitTableOffsets = null;

    /** Index for the next probe */
    private int hitTableOffset = 0;

    private int scope = 0;

    private final ProblemFilter problems;

    private StatementInterface infiniteLoop = null;

    private static final String INFINITE_LOOP_ITERATION_EVENT =
        "c2v_infinite_loop_event";

    private static final String STATE_COVERGROUP_INST =
        "c2v_state_cg_inst";

    private static final String HIT_TABLE =
        "c2v_line_cov_hits";

    private static final String LINE_COV_COVERGROUP_INST =
        "c2v_line_cov_cg_inst";

    private interface Index {
        void write() throws VisitorException;
    }
    private class ComplexAccess {
        private class FixedIndex implements Index {
            private final String var;
            public FixedIndex(final String var) {
                this.var = var;
            }
            public void write() throws VisitorException {
                out.print(var);
            }
        }
        private class ExpressionIndex implements Index {
            private final ExpressionInterface expr;
            public ExpressionIndex(final ExpressionInterface expr) {
                this.expr = expr;
            }
            public void write() throws VisitorException {
                expr.accept(VerilogEmitter.this);
            }
        }

        private final LinkedList/*<Index>*/ array;
        private final LinkedList/*<String>*/ structure;
        private final Type ty;
        private Object base;
        public ComplexAccess() {
            this((Type) null);
        }
        public ComplexAccess(final ExpressionInterface expr) {
            this(lvalues.contains(expr) ? (Type) null
                                        : analysisResults.getType(expr));
        }
        public ComplexAccess(final Type ty) {
            this.array = new LinkedList/*<Index>*/();
            this.structure = new LinkedList/*<String>*/();
            this.ty = ty;
        }
        public ComplexAccess(final ComplexAccess other) {
            this.array = new LinkedList/*<Index>*/(other.array);
            this.structure = new LinkedList/*<String>*/(other.structure);
            this.base = other.base;
            this.ty = other.ty;
        }
        private void accessArray(final Index idx, final boolean forward) {
            if (forward) array.addLast(idx);
            else array.addFirst(idx);
        }
        public void accessArray(final String var) {
            accessArray(new FixedIndex(var), true);
        }
        public void accessArray(final ExpressionInterface expr) {
            accessArray(new ExpressionIndex(expr), false);
        }
        public void accessStructure(final String fieldName) {
            accessStructure(fieldName, true);
        }
        public void accessStructure(final String fieldName,
                                    final boolean forward) {
            if (forward) structure.addLast(fieldName);
            else structure.addFirst(fieldName);
        }
        public Object getBase() {
            return base;
        }
        public void setBase(final Object token) {
            base = token;
        }
        private void emit(final String hierarchy,
                          final String channelPart,
                          final Type ty) throws VisitorException {
            final StringBuffer buf = new StringBuffer();
            String concat = null;
            if (ty instanceof IntegerType) {
                final IntegerType it = (IntegerType) ty;
                if (it.getDeclaredWidth() != null) {
                    final int width = getIntegerConstant(it.getDeclaredWidth());
                    if (it.isSigned()) {
                        buf.append("(util.sign_extend(");
                        concat = "))";
                    } else {
                        buf.append("($signed({ ");
                        buf.append(Math.max(1, registerBitWidth - width));
                        buf.append("'b0, ");
                        concat = " }))";
                    }
                }
            } else if (ty instanceof NodeType) {
                final NodeType nt = (NodeType) ty;
                if (nt.isArrayed()) {
                    buf.append("($signed({ ");
                    buf.append(Math.max(1, registerBitWidth - nt.getWidth()));
                    buf.append("'b0, ");
                    concat = " }))";
                }
            }

            buf.append(hierarchy);
            buf.append("\\");
            buf.append((String) tokenVerilogNameMap.get(base));
            for (Iterator i = structure.iterator(); i.hasNext(); ) {
                buf.append('.');
                buf.append((String) i.next());
            }
            buf.append(channelPart);
            out.print(buf.toString());
            out.print(' ');
            for (Iterator i = array.iterator(); i.hasNext(); ) {
                out.print("[");
                ((Index) i.next()).write();
                out.print("]");
            }
            if (concat != null) {
                out.print(concat);
            }
        }
        public void write(final String channelPart) throws VisitorException {
            final ComplexAccess mapped = mapComplexArgument(this);
            String hierarchy = mapped.getHierarchy();
            if (hierarchy != null && getHierarchy() == hierarchy)
                hierarchy = null;
            mapped.emit(hierarchy == null ? "" : escape(hierarchy) + ".",
                        channelPart, ty);
        }
        public void write() throws VisitorException {
            write("");
        }
        public Collection getIndices() {
            return array;
        }
        public ComplexAccess map(final ComplexAccess previous) {
            if (previous == null) return this;

            final ComplexAccess result = new ComplexAccess(previous.ty);
            result.array.addAll(previous.array);
            result.array.addAll(array);
            result.structure.addAll(previous.structure);
            result.structure.addAll(structure);
            result.base = previous.base;
            return result;
        }
        public void copyStructure(final ComplexAccess other) {
            structure.clear();
            structure.addAll(other.structure);
        }
        public String getHierarchy() {
            return (String) hierarchyNameMap.get(base);
        }
    }

    private class ComplexDeclaration {
        private final List<Range> array;
        private final List<String> structure;
        private Type type;
        public ComplexDeclaration() {
            this.array = new ArrayList<>();
            this.structure = new ArrayList<>();
        }
        public ComplexDeclaration(final ComplexDeclaration c) {
            this.array = new ArrayList<>(c.array);
            this.structure = new ArrayList<>(c.structure);
            this.type = c.type;
        }
        public void declareArray(final Range expr) {
            array.add(expr);
        }
        public void declareStructure(final String fieldName) {
            structure.add(fieldName);
        }
        public void setType(final Type type) {
            this.type = type;
        }
        protected String getStructurePartUnescaped(final String base) {
            final StringBuffer buf = new StringBuffer();
            buf.append(base);
            for (String s : structure) {
                buf.append('.');
                buf.append(s);
            }
            return buf.toString();
        }
        protected String getStructurePart(final String base) {
            return escape(getStructurePartUnescaped(base));
        }
        protected List<Range> getArray() {
            return Collections.unmodifiableList(array);
        }
        public void declare(final String base) throws VisitorException {
            if (type instanceof StringType) {
                out.print("`CSP_STRING ");
            } else if (type instanceof BooleanType) {
                out.print(boolType); out.ws();
            } else {
                out.print(getRegisterType((IntegerType) type)); out.ws();
            }
            out.print(getStructurePart(base));
            for (Range r : array) {
                out.print('[');
                r.getMinExpression().accept(VerilogEmitter.this);
                out.print(':');
                r.getMaxExpression().accept(VerilogEmitter.this);
                out.print(']');
            }
        }
        private String getIndices() throws VisitorException {
            final StringBuffer buf = new StringBuffer();
            int idx = 0;
            for (Iterator i = array.iterator(); i.hasNext(); ++idx) {
                buf.append("[loop$[" + idx + "]]");
            }
            return buf.toString();
        }
    }

    private boolean coverage_off(boolean off) {
        if (off) out.disableCoverage();
        return off;
    }
    
    private boolean coverage_off(AbstractASTNodeInterface node) {
        return coverage_off(node.getFlag(DISABLE_COVERAGE));
    }

    private boolean coverage_off() {
        return coverage_off(true);
    }

    private void coverage_on(boolean off) {
        if (off) out.enableCoverage();
    }

    private void coverage_on() {
        coverage_on(true);
    }

    private boolean isFirstActualFalse(final FunctionCallExpression e) {
        final Iterator<ExpressionInterface> it = e.getActuals();
        return it.hasNext() && CspUtils.getBooleanConstant(it.next())
                                       .orElse(false);
    }

    private void emitOneProbe(StatementInterface node, String type) {
        if (emitCoverageProbes) {
            if (node.getFlag(DISABLE_COVERAGE)) {
                out.println("// no coverage probe for preprocessing code");
            } else if (CspUtils.hasFunctionCallTo(node, "cover")
                        .map(f -> isFirstActualFalse(f))
                        .orElse(false)) {
                out.println("// coverage probe elided for cover(false) (" +
                            node.getParseRange().fullString() + ")");
            } else if (CspUtils.hasFunctionCallTo(node, "assert")
                               .map(f -> isFirstActualFalse(f))
                               .orElse(false)) {
                out.println("// coverage probe elided for assert(false) (" +
                            node.getParseRange().fullString() + ")");
            } else {
                final ProbeInfo probe = new ProbeInfo(
                        node.getParseRange(), type, cellInfo.getAbbreviatedType());
                if (hitTableOffset < probeTable.size()) {
                    assert Objects.equals(
                            probeTable.get(hitTableOffset).toString(),
                            probe.toString());
                } else {
                    probeTable.add(probe);
                }
                out.println(HIT_TABLE + "[" + hitTableOffset + "] = 1'b1;" +
                        " // coverage probe (" + node.getParseRange().fullString() + ")");
                hitTableOffset++;
            }
        }
    }

    private String getLoopVarType(final Range r) {
        final ExpressionInterface minExpr = r.getMinExpression();
        final ExpressionInterface maxExpr = r.getMaxExpression();
        if (minExpr instanceof IntegerExpression &&
            maxExpr instanceof IntegerExpression) {
            BigInteger min = new BigInteger(
                    ((IntegerExpression) minExpr).getValue(),
                    ((IntegerExpression) minExpr).getRadix());
            BigInteger max = new BigInteger(
                    ((IntegerExpression) maxExpr).getValue(),
                    ((IntegerExpression) maxExpr).getRadix());
            max = max.add(BigInteger.ONE);
            if (min.signum() == -1) min = min.negate();
            if (max.signum() == -1) max = max.negate();
            int lindex = Math.max(min.bitLength(), max.bitLength());
            return "bit signed [" + lindex + ":0]";
        } else {
            return registerType;
        }
    }

    private void emitForLoop(final String var, final Range r)
        throws VisitorException {
        out.print("for (" + var + " = ");
        r.getMinExpression().accept(this);
        out.print(';'); out.ws(); out.print(var + " <= ");
        r.getMaxExpression().accept(this);
        out.print(';'); out.ws(); out.print(var + " = " + var + " + 1)");
    }

    private void emitChannelPart(final ExpressionInterface chanExpr,
                                 final String part) throws VisitorException {
        complexAccess = new ComplexAccess();
        chanExpr.accept(this);
        final ComplexAccess old = complexAccess;
        complexAccess = null;
        old.write(part);
    }

    private interface ChannelOperations {
        void visitProbeExpression(ExpressionInterface chanExpr)
            throws VisitorException;
        void visitPeekExpression(ExpressionInterface chanExpr)
            throws VisitorException;
        void visitSendStatement(SendStatement s) throws VisitorException;
        void visitReceiveStatement(ReceiveStatement s) throws VisitorException;
        void processChannel(ExpressionInterface chanExpr, boolean bool)
            throws VisitorException;
    }

    private ChannelOperations getChannelOperation(
            final ExpressionInterface chanExpr) {
        final ChannelType chanType =
            (ChannelType) analysisResults.getType(chanExpr);
        final String typeName = chanType.getTypeName();
        if (typeName.startsWith("standard.channel.bd")) {
            return new BDChannelOperations();
        } else if (typeName.startsWith("standard.channel.e1of")) {
            return new E1ofNChannelOperations();
        } else {
            throw new RuntimeException("No support for channel type: " +
                    typeName);
        }
    }

    private class E1ofNChannelOperations implements ChannelOperations {
        private void emitChannelEnable(final ExpressionInterface chanExpr)
            throws VisitorException {
            emitChannelPart(chanExpr, "$enable");
        }

        private void emitChannelData(final ExpressionInterface chanExpr)
            throws VisitorException {
            emitChannelPart(chanExpr, "$data");
        }

        public void visitProbeExpression(ExpressionInterface chanExpr)
            throws VisitorException {
            // #L == (L.d >= 0)
            // #R == R.e

            // The type checking pass should have ensured that this is indeed
            // a channel type.
            final ChannelType type = 
                (ChannelType) analysisResults.getType(chanExpr);
            // Add - to compensate for difference in verilog and csp
            // comparison semantics.
            if (type.getDirection() == PortDirection.IN) {
                out.print("(");
                emitChannelData(chanExpr);
                out.println(" >= 0)");
            } else {
                assert type.getDirection() == PortDirection.OUT;
                emitChannelEnable(chanExpr);
            }
        }

        public void visitPeekExpression(ExpressionInterface chanExpr)
            throws VisitorException {
            //  inside guard: #L? == L.d
            // outside guard: #L? == ( [ L.d >= 0 ] ; L.d )
            // FunctionPreprocessor converts peeks outside of guards
            // to assignment statements that are handled specially
            // in this file by visitAssignmentStatement
            // It converts peeks within guards by pre-pending AND of
            // probes to the expression.
            // Thus, here, we just need to spit L.d
            emitChannelData(chanExpr);
        }

        public void visitSendStatement(SendStatement s)
            throws VisitorException {
            // R!x == ( [  R.e ] ; R.d = POSMOD(x, numValues)
            //        ; [ !R.e ] ; R.d = -1 )
            // Good test cases include:
            // 1. R[getTime() % N]!x
            // This will ensure channel is evaluated only once
            
            final ExpressionInterface chanExpr = s.getChannelExpression();

            // The type checking pass should have ensured that this is indeed
            // a channel type and that the direction is appropriate
            final ChannelType type =
                (ChannelType) analysisResults.getType(chanExpr);
            assert type.getDirection() == PortDirection.OUT;
            final BigInteger numValues = type.getNumValues();
            assert numValues.signum() == 1;

            out.print("wait(");
            visitProbeExpression(chanExpr);
            out.println(");");

            lvalues.add(s.getRightHandSide());

            final boolean pow2 = BigIntegerUtil.isPowerOf2(numValues);

            if (!pow2) {
                out.print("if ((");
                // it's okay to evaluate the rhs multiple times because rhs is
                // guaranteed to be a simple variable
                s.getRightHandSide().accept(VerilogEmitter.this);
                out.print(" < 1'sb0) || (");
                s.getRightHandSide().accept(VerilogEmitter.this);
                out.print(" >= ");
                processBigInteger(numValues, 10);
                out.println("))");
                out.print("`CAST2VERILOG_CSP_WARNING(\"" +
                          s.getParseRange().fullString() + "\", " +
                          "util.posmod_warning(");
                s.getRightHandSide().accept(VerilogEmitter.this);
                out.print(", ");
                processBigInteger(numValues.subtract(BigInteger.ONE), 10);
                out.println("))");
            }

            emitChannelData(chanExpr);
            out.print(" = ");
            if (numValues.equals(BigInteger.ONE)) {
                out.print("0");
            } else {
                if (pow2) {
                    processBigInteger(numValues.subtract(BigInteger.ONE), 16);
                    out.print(" & (");
                } else {
                    out.print("util.posmod(");
                }
                s.getRightHandSide().accept(VerilogEmitter.this);
                if (!pow2) {
                    out.println(", ");
                    processBigInteger(numValues, 16);
                }
                out.print(")");
            }
            out.println(';');

            out.print("wait(!");
            emitChannelEnable(chanExpr);
            out.println(");");

            emitChannelData(chanExpr);
            out.println(" = -1;");
        }

        public void visitReceiveStatement(ReceiveStatement s)
            throws VisitorException {
            // This expansion requires slack of at least 1 to get probe
            // sends to behave properly.
            // L?x == ( [ L.d >= 0 ] ; x = L.d ; L.e = 0
            //        ; [ L.d <  0 ] ; L.e = 1 )
            // Good test cases include:
            // 1. L[getTime() % N]?x
            // 2. L[x]?x
            // These will ensure channel is evaluated only once
            
            final ExpressionInterface chanExpr = s.getChannelExpression();

            out.print("wait(");
            emitChannelData(chanExpr);
            out.println(" >= 0);");

            if (s.getRightHandSide() != null)
                processAssignmentStatement(s.getRightHandSide(),
                                           s.getRightHandSide(), chanExpr,
                                           null);

            emitChannelEnable(chanExpr);
            out.println(" = 0;");

            out.print("wait(");
            emitChannelData(chanExpr);
            out.println(" < 0);");

            emitChannelEnable(chanExpr);
            out.println(" = 1;");
        }

        public void processChannel(ExpressionInterface chanExpr, boolean bool)
            throws VisitorException {
            if (bool) out.print("(");
            emitChannelData(chanExpr);
            if (bool) out.print("!= 0)");
        }
    }

    private class BDChannelOperations implements ChannelOperations {
        private void emitChannelAck(final ExpressionInterface chanExpr)
            throws VisitorException {
            emitChannelPart(chanExpr, "$ack");
        }

        private void emitChannelReq(final ExpressionInterface chanExpr)
            throws VisitorException {
            emitChannelPart(chanExpr, "$req");
        }

        private void emitChannelData(final ExpressionInterface chanExpr)
            throws VisitorException {
            emitChannelPart(chanExpr, "$data");
        }

        private void emitChannelDataRhs(final ExpressionInterface chanExpr)
            throws VisitorException {
            out.print("$signed({1'b0, ");
            emitChannelData(chanExpr);
            out.print("})");
        }

        public void visitProbeExpression(ExpressionInterface chanExpr)
            throws VisitorException {
            // #L == (L.C.q != L.C.a)
            // #R == (R.C.q == R.c.a)

            final ChannelType type = 
                (ChannelType) analysisResults.getType(chanExpr);
            final String op =
                type.getDirection() == PortDirection.IN ? "!=" : "==";

            out.print("(");
            emitChannelReq(chanExpr);
            out.print(" " + op + " ");
            emitChannelAck(chanExpr);
            out.print(")");
        }

        public void visitPeekExpression(ExpressionInterface chanExpr)
            throws VisitorException {
            //  inside guard: #L? == L.d
            // outside guard: #L? == ( [ L.d >= 0 ] ; L.d )
            // FunctionPreprocessor converts peeks outside of guards
            // to assignment statements that are handled specially
            // in this file by visitAssignmentStatement
            // It converts peeks within guards by pre-pending AND of
            // probes to the expression.
            // Thus, here, we just need to spit L.d
            emitChannelDataRhs(chanExpr);
        }

        public void visitSendStatement(SendStatement s)
            throws VisitorException {
            // R!x == ( [ #R ]; R.d = POSMOD(x, numValues); R.q = ~R.q )
            // Good test cases include:
            // 1. R[getTime() % N]!x
            // This will ensure channel is evaluated only once
            
            final ExpressionInterface chanExpr = s.getChannelExpression();

            // The type checking pass should have ensured that this is indeed
            // a channel type and that the direction is appropriate
            final ChannelType type =
                (ChannelType) analysisResults.getType(chanExpr);
            assert type.getDirection() == PortDirection.OUT;
            final BigInteger numValues = type.getNumValues();
            assert numValues.signum() == 1;

            out.print("wait(");
            visitProbeExpression(chanExpr);
            out.println(");");

            lvalues.add(s.getRightHandSide());

            final boolean pow2 = BigIntegerUtil.isPowerOf2(numValues);

            if (!pow2) {
                out.print("if ((");
                // it's okay to evaluate the rhs multiple times because rhs is
                // guaranteed to be a simple variable
                s.getRightHandSide().accept(VerilogEmitter.this);
                out.print(" < 1'sb0) || (");
                s.getRightHandSide().accept(VerilogEmitter.this);
                out.print(" >= ");
                processBigInteger(numValues, 10);
                out.println("))");
                out.print("`CAST2VERILOG_CSP_WARNING(\"" +
                          s.getParseRange().fullString() + "\", " +
                          "util.posmod_warning(");
                s.getRightHandSide().accept(VerilogEmitter.this);
                out.print(", ");
                processBigInteger(numValues.subtract(BigInteger.ONE), 10);
                out.println("))");
            }

            emitChannelData(chanExpr);
            out.print(" = ");
            if (numValues.equals(BigInteger.ONE)) {
                out.print("0");
            } else {
                if (pow2) {
                    processBigInteger(numValues.subtract(BigInteger.ONE), 16);
                    out.print(" & (");
                } else {
                    out.print("util.posmod(");
                }
                s.getRightHandSide().accept(VerilogEmitter.this);
                if (!pow2) {
                    out.println(", ");
                    processBigInteger(numValues, 16);
                }
                out.print(")");
            }
            out.println(';');

            emitChannelReq(chanExpr);
            out.print(" = ~");
            emitChannelReq(chanExpr);
            out.println(";");
        }

        public void visitReceiveStatement(ReceiveStatement s)
            throws VisitorException {
            // L?x == ( [ #L ]; x = L.d; L.a = ~L.a )
            // Good test cases include:
            // 1. L[getTime() % N]?x
            // 2. L[x]?x
            // These will ensure channel is evaluated only once
            
            final ExpressionInterface chanExpr = s.getChannelExpression();

            out.print("wait(");
            visitProbeExpression(chanExpr);
            out.println(");");

            if (s.getRightHandSide() != null)
                processAssignmentStatement(s.getRightHandSide(),
                                           s.getRightHandSide(), chanExpr,
                                           null);

            emitChannelAck(chanExpr);
            out.print(" = ~");
            emitChannelAck(chanExpr);
            out.println(";");
        }

        public void processChannel(ExpressionInterface chanExpr, boolean bool)
            throws VisitorException {
            if (bool) out.print("(");
            emitChannelDataRhs(chanExpr);
            if (bool) out.print("!= 0)");
        }
    }

    private void println(String s, AbstractASTNodeInterface node) {
        out.print(s);
        if (node != null) {
            final ParseRange pr = node.getParseRange();
            if (pr != ParseRange.EMPTY) {
                out.print(" // " + pr.fullString());
            }
        }
        out.println();
    }

    public VerilogEmitter(final CSPCellInfo cellInfo,
                          final Collection/*<String>*/ inputPorts,
                          final PrintWriter out,
                          final PrintWriter warningWriter,
                          final PrintWriter errorWriter,
                          final PrintWriter debugWriter,
                          final String moduleName,
                          final String resetNodeName,
                          final int registerBitWidth,
                          final boolean strictVars,
                          final boolean implicitInit,
                          final boolean emitCoverageProbes,
                          final ProblemFilter problems) { 
        super(out, registerBitWidth, true);
        this.cellInfo = cellInfo;
        this.inputPorts = inputPorts;
        this.warningWriter = warningWriter;
        this.errorWriter = errorWriter;
        this.debugWriter = debugWriter;
        this.moduleName = moduleName;
        this.analyzer = new VariableAnalyzer(cellInfo);
        this.analysisResults = null;
        this.boolType = "bit";
        this.resetNodeName = resetNodeName;
        this.strictVars = strictVars;
        this.implicitInit = implicitInit;
        this.emitCoverageProbes = emitCoverageProbes;
        if (emitCoverageProbes) {
            this.probeTable = new ArrayList<>();
            this.hitTableOffsets = new HashMap<>();
        }
        this.problems = problems;
    }

    private void processUnary(final AbstractUnaryExpression expr,
            final String op) throws VisitorException {
        out.print('(' + op);
        expr.getExpression().accept(this);
        out.print(')');
    }

    private void processSpecialBinary(final AbstractBinaryExpression expr,
            final String func)
        throws VisitorException {
        // REVIEW: What is the overhead of functions?  Should we
        // do this inline with a temporary variable?
        out.print(func + '(');
        lvalues.add(expr.getLeft());
        expr.getLeft().accept(this);
        out.print(','); out.ws();
        lvalues.add(expr.getRight());
        expr.getRight().accept(this);
        out.print(')');
    }

    private void prettyMessage(String message, ParseRange pr) {
        ExceptionPrettyPrinter.prettyMessage(message, pr.start.filename,
                                             pr.start.line, pr.start.column+1,
                                             errorWriter);
    }

    /** 
     * Inspect the sets of uninitialized variables returned by variable
     * analysis.  
     **/
    private Set/*<String>*/ processResults(VariableAnalyzer.Results r) {
        final Set/*<String>*/ undeclaredVars = new HashSet/*<String>*/();
        Map m = r.getUndeclaredTypes();
        for (final Iterator i = m.keySet().iterator(); i.hasNext(); ) {
            String name = (String) i.next();
            Type type = (Type) m.get(name);

            if (type == null
             || type instanceof IntegerType
             || type instanceof BooleanType)
                undeclaredVars.add(name);
            else {  
                errorWriter.flush();
                warningWriter.flush();
                throw new Error ("Undeclared variable has unsupported type.");
            }
        }

        return undeclaredVars;
    }

    private void outputProgramBody(CSPProgram e) throws VisitorException {
        declareVariables();

        final boolean[] hasCovergroup = new boolean[] { false };
        if (e.getStatement() instanceof SequentialStatement) {
            for (Iterator<StatementInterface> i =
                    ((SequentialStatement) e.getStatement()).getStatements();
                i.hasNext(); ) {
                StatementInterface s = i.next();
                if (CspUtils.getInfiniteLoopBody(s) != null) {
                    infiniteLoop = s;
                    break;
                }
            }
        }

        if (infiniteLoop != null) {
            final String coverGroup = cellInfo.getAbbreviatedType() + "$state_cg";

            out.println("event " + INFINITE_LOOP_ITERATION_EVENT + ";");
            final Map<IdentifierExpression,Declarator> topVars =
                new LinkedHashMap<>();
            getTopLevelVariables(e.getStatement(), resolver, analysisResults,
                null, topVars, new HashSet<>());
            final int stateCGlimit = 1024;
            final String decl = "covergroup " + escape(coverGroup) +
                                " @(" + INFINITE_LOOP_ITERATION_EVENT + ");";
            for (Map.Entry<IdentifierExpression,Declarator> topVar :
                    topVars.entrySet()) {
                final Type t = topVar.getValue().getTypeFragment();
                if (!t.getFlag(DISABLE_COVERAGE)) {
                    final int packSize =
                        CspUtils.getPackSize(
                            st -> resolver.getResolvedStructures()
                                          .get(st)
                                          .getSecond(),
                            t);
                    if (packSize > 0 && packSize < stateCGlimit) {
                        declareCoverpoint(() -> decl,
                                          topVar.getKey().getIdentifier(),
                                          topVar.getValue().getTypeFragment(),
                                          hasCovergroup);
                    }
                }
            }
            if (hasCovergroup[0]) {
                out.println("endgroup");
                out.println(escape(coverGroup) + " " + STATE_COVERGROUP_INST +
                            " = new;");
            }
        }

        if (emitCoverageProbes) {
            // count the number of probes, and declare hit table
            final MutableInt count = new MutableInt(0);
            e.accept(new VisitorByCategory() {
                protected void processAbstractGuardedStatement(AbstractGuardedStatement s)
                throws VisitorException {
                    super.processAbstractGuardedStatement(s);
                    final StatementInterface els = s.getElseStatement();
                    if (els != null && !els.getFlag(DISABLE_COVERAGE)) {
                        count.inc();
                    }
                }
                protected void processGuardedCommandInterface(GuardedCommandInterface gci)
                throws VisitorException {
                    final StatementInterface gc = ((GuardedCommand) gci).getCommand();
                    if (!gc.getFlag(DISABLE_COVERAGE)) {
                        count.inc();
                    }
                    gc.accept(getVisitor());
                }
            });
            if (count.get() > 0) {
                coverage_off();
                out.println("bit [" + (count.get() - 1) + ":0] " + HIT_TABLE + ";");
                out.println("initial " + HIT_TABLE + " = '0;");
                coverage_on();
            }
        }

        // call resetNodes() if it is defined
        final Pair/*<CSPProgram,FunctionDeclaration>*/ resetDecl =
            (Pair) resolver.getResolvedFunctions()
                           .get(RefinementResolver.RESET_FUNCTION_CALL);
        if (resetDecl != null) {
            if (resetDecl.getSecond() instanceof FunctionDeclaration) {
                out.println("always @(" + resetNodeName + " )");
                out.println("if (" + resetNodeName + "  == 0) " +
                            "begin : reset_nodes");
                final String funcName =
                    getFullName((FunctionDeclaration) resetDecl.getSecond(),
                                Collections.EMPTY_LIST);
                out.println(funcName + " ;");
                out.println("end");
            } else {
                warningWriter.println(
                    "Invalid definition of special function resetNodes: " +
                    ((AbstractASTNode) e).getParseRange().fullString());

            }
        }

        // start main block on posedge of _RESET 
        out.println("always @(posedge " + resetNodeName + " )");
        out.println("begin : main ");

        final Set/*<String>*/ undeclaredVars = processResults(analysisResults);
        // assign to 0
        if (implicitInit) {
            for (Iterator i = undeclaredVars.iterator(); i.hasNext(); ) {
                final String var = escape((String) i.next());
                out.println(var + " = 0;");
            }
            out.println();
        }

        // handle initializer statement to deal with top-level constants
        // TODO: Share top-level constants, as this wastes memory
        if (e.getInitializerStatement() != null) {
            coverage_off();
            final FilterInitializers filter =
                new FilterInitializers(analysisResults, allUsedTokens);
            filter.filter(e.getInitializerStatement()).accept(this);
            coverage_on();
        }

        // csp body
        processingBody = true;
        e.getStatement().accept(this);
        processingBody = false;

        // end initial block
        out.println("end");
        out.println();
    }

    private void setupCoverageProbes(final FunctionDeclaration decl) {
        if (emitCoverageProbes) {
            hitTableOffset = hitTableOffsets.computeIfAbsent(decl, 
                    k -> Integer.valueOf(probeTable.size()));
        }
    }

    public void visitCSPProgram(CSPProgram e) throws VisitorException {

        resolver.resolve(e);
        e = resolver.getCSPProgram();

        // declare and initialize the undeclared variables
        try {
            analysisResults = analyzer.getResults(e, resolver);
            allUsedTokens.addAll(analysisResults.getUsedTokens());
        } catch (VariableAnalysisException x) {
            throw new VisitorException(x.getMessage());
        }
        problems.process(analysisResults.getErrors(strictVars));

        for (Iterator i = e.getFunctionDeclarations(); i.hasNext(); ) {
            final FunctionDeclaration decl = (FunctionDeclaration) i.next();
            try {
                getAnalyzerResults(decl, e.getInitializerStatement());
            } catch (VariableAnalysisException x) {
                throw new VisitorException(x.getMessage(), x);
            }
        }

        if (!problems.hasError()) {
            setupCoverageProbes(null);
            updateTokenVerilogMap(moduleName);
            outputProgramBody(e);
            outputFunctions(e.getInitializerStatement());
            outputConstructors();
            outputArbiters();

            if (emitCoverageProbes && !probeTable.isEmpty()) {
                final String coverGroup =
                    cellInfo.getAbbreviatedType() + "$cov_cg";
                out.println("covergroup " + escape(coverGroup) +
                    " @(" + HIT_TABLE + " or " + resetNodeName + ");");
                out.println("  option.per_instance = 1;");
                int i = 0;
                for (ProbeInfo p : probeTable) {
                    out.println("  coverpoint " + HIT_TABLE + "[" + i + "] {");
                    out.println("    bins hit = ( 0 => 1 );");
                    out.println("    option.comment = \"" + p.toString() + "\";");
                    out.println("  }");
                    i++;
                }
                out.println("endgroup");
                out.println(escape(coverGroup) + " " + LINE_COV_COVERGROUP_INST +
                            " = new;");
            }
        }

        out.flush();
    }

    /**
     * Return a new autogenerated variable number.
     **/
    private int genVarNum() {
        return varNum++;
    }

    private String genBlock() {
        return "\\$block" + blockNum++ + ' ';
    }

    public void visitAddExpression(AddExpression e)
        throws VisitorException {
        if (analysisResults.getType(e) instanceof StringType) {
            out.print("csp_string.concat(");
            final boolean lstr =
                analysisResults.getType(e.getLeft()) instanceof StringType;
            if (!lstr) out.print("util.csp_string(");
            e.getLeft().accept(this);
            if (!lstr) out.print(", 10)");

            out.print(", ");

            final boolean rstr =
                analysisResults.getType(e.getRight()) instanceof StringType;
            if (!rstr) out.print("util.csp_string(");
            e.getRight().accept(this);
            if (!rstr) out.print(", 10)");

            out.print(')');
        } else {
            processBinary(e, "+");
        }
    }

    public void visitAndExpression(AndExpression e)
        throws VisitorException {
        processBinary(e, "&");
    }

    public void visitArrayAccessExpression(ArrayAccessExpression e)
        throws VisitorException {
        boolean writeNow = false;
        if (complexAccess == null) {
            complexAccess = new ComplexAccess(e);
            writeNow = true;
        }
        complexAccess.accessArray(e.getIndexExpression());
        e.getArrayExpression().accept(this);
        if (writeNow) {
            final ComplexAccess old = complexAccess;
            complexAccess = null;
            old.write();
        }
    }

    public void visitBitRangeExpression(BitRangeExpression e)
        throws VisitorException {
        // The csp grammar only allows bit extraction from arrays,
        // structures and simple variables.
        assert e.getBitsExpression() instanceof IdentifierExpression ||
               e.getBitsExpression() instanceof ArrayAccessExpression ||
               e.getBitsExpression() instanceof MemberAccessExpression ||
               e.getBitsExpression() instanceof StructureAccessExpression:
               "Invalid bit range expression found at: " + e.getParseRange().fullString();

        lvalues.add(e.getBitsExpression());
        if (needBitRangeFunction(e)) {
            // can't use constant part-select, use special function
            out.print("util.bit_extract" +
                      (e.getMinExpression() == null ? "2" : "3") +
                      "(");
            e.getBitsExpression().accept(this);
            out.print(','); out.ws();
            lvalues.add(e.getMaxExpression());
            e.getMaxExpression().accept(this);
            if (e.getMinExpression() != null) {
                out.print(','); out.ws();
                lvalues.add(e.getMinExpression());
                e.getMinExpression().accept(this);
            }
            out.print(')');
        } else if (isBitRangeInvalid(e)) {
            out.print("'0");
        } else {
            processSimpleBitRange(e, false);
        }
    }

    private void printArg(final ExpressionInterface arg)
        throws VisitorException {
        lvalues.add(arg);
        if (analysisResults.getType(arg) instanceof StringType) {
            arg.accept(this); 
        } else {
            out.print("util.hex_string(");
            arg.accept(this); 
            out.print(")");
        }
    }

    /* Process built in functions - all others are turned into assignmented
       by processFunctionCalls */ 
    public void visitFunctionCallExpression(FunctionCallExpression e)
        throws VisitorException {
        final ExpressionInterface func = e.getFunctionExpression();
        final String funcName =
            func instanceof IdentifierExpression ?
                ((IdentifierExpression) func).getIdentifier() : null;

        if ("print".equals(funcName)) {
            final Iterator<ExpressionInterface> args = e.getActuals();
            final ExpressionInterface arg1 = args.next();
            final ExpressionInterface arg2 =
                args.hasNext() ? args.next() : null;

            if (arg2 == null) {
                out.print("`CAST2VERILOG_CSP_PRINT(");
                printArg(arg1);
            } else {
                out.print("`CAST2VERILOG_CSP_PRINT2(");
                printArg(arg1);
                out.print(", ");
                printArg(arg2);
            }
            out.println(")");
        } else if ("assert".equals(funcName)) {
            final Iterator args = e.getActuals();
            final ExpressionInterface guard = (ExpressionInterface) args.next();
            lvalues.add(guard);
            final ExpressionInterface message =
                args.hasNext() ? (ExpressionInterface) args.next()
                               : null;
            if (message != null) lvalues.add(message);

            out.print("`CAST2VERILOG_CSP_ASSERT" +
                      (message == null ? "" : "2") + "(\"" +
                      e.getParseRange().fullString() + "\", ");
            guard.accept(this);
            if (message != null) {
                out.print(','); out.ws();
                message.accept(this);
            }
            out.println(")");
        } else if ("choose".equals(funcName)) {
            Iterator i = e.getActuals(); 
            // XXX: Add null exception handling
            ExpressionInterface arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); 
            out.ws(); out.print('?'); out.ws();
            arg = (ExpressionInterface) i.next();
            lvalues.remove(arg);
            arg.accept(this); 
            out.ws(); out.print(':'); out.ws();
            arg = (ExpressionInterface) i.next();
            lvalues.remove(arg);
            arg.accept(this); 
        } else if ("random".equals(funcName) ||
                   "log2".equals(funcName) ||
                   "log4".equals(funcName)) {
            Iterator i = e.getActuals(); 
            out.print("util." + funcName + "(");
            final ExpressionInterface arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); 
            out.println(")");
        } else if ("wait".equals(funcName)) {
            final Iterator i = e.getActuals(); 
            out.print("`CAST2VERILOG_WAIT(");
            final ExpressionInterface arg = (ExpressionInterface) i.next();
            lvalues.add(arg);
            arg.accept(this); // in DSim units
            out.println(");");
        } else if ("string".equals(funcName)) {
            out.print("util.csp_string(");
            for (Iterator i = e.getActuals(); i.hasNext(); ) {
                final ExpressionInterface arg = (ExpressionInterface) i.next();
                lvalues.add(arg);
                arg.accept(this); 
                if (i.hasNext()) { out.ws(); out.print(','); out.ws(); }
            }
            out.println(")");
        } else if ("simtime".equals(funcName)) {
            out.println("`CAST2VERILOG_TIME");
        } else if ("walltime".equals(funcName)) {
            out.println("util.walltime()");
        } else if ("chr".equals(funcName) || "ord".equals(funcName)) {
            out.println("csp_string." + funcName + "(");
            final Iterator<ExpressionInterface> args = e.getActuals();
            final ExpressionInterface arg = args.next();
            lvalues.add(arg);
            arg.accept(this);
            out.println(")");
        } else if ("getArgValue".equals(funcName)) {
            out.print("csp_string.getArgValue(");
            final Iterator<ExpressionInterface> args = e.getActuals();
            final ExpressionInterface arg1 = args.next();
            final ExpressionInterface arg2 = args.next();
            lvalues.add(arg1);
            arg1.accept(this);
            out.print(", ");
            lvalues.add(arg2);
            arg2.accept(this);
            out.println(")");
        } else {
            throw new VisitorException("Unsupported function calls found: " + e.getParseRange().fullString());
        }
    }

    public void visitDivideExpression(DivideExpression e)
        throws VisitorException {
        // Handle divide by 0
        processSpecialBinary(e, "util.divide");
    }

    public void visitExponentialExpression(ExponentialExpression e)
        throws VisitorException {
        // XXX: handle 0**x, for x <= 0
        // According to the verilog spec exponentiation involving
        // signed values should give a real result.  Reals are 
        // rounded to nearest, except ties are rounded away from zero.
        // Thus, we should have 2**-1 == 1, but it seems that 2**-1 == 0.
        // Perhaps file a bug with cadence.
        processSpecialBinary(e, "util.pow");
    }

    public void visitLeftShiftExpression(LeftShiftExpression e)
        throws VisitorException {
        // handles negative shift amounts
        processSpecialBinary(e, "util.shift_left");
    }

    public void visitRightShiftExpression(RightShiftExpression e)
        throws VisitorException {
        // handles negative shift amounts
        processSpecialBinary(e, "util.shift_right");
    }

    private String escape(final String s) {
        return VerilogUtil.escapeIfNeeded(s);
    }

    public void visitIdentifierExpression(IdentifierExpression e)
        throws VisitorException {
        if (complexAccess == null) {
            complexAccess = new ComplexAccess(e);
            complexAccess.setBase(analysisResults.getIdentToken(e));
            complexAccess.write();
            complexAccess = null;
        } else complexAccess.setBase(analysisResults.getIdentToken(e));
    }

    public void visitLoopExpression(LoopExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitMultiplyExpression(MultiplyExpression e)
        throws VisitorException {
        processBinary(e, "*");
    }

    public void visitNegateExpression(NegateExpression e)
        throws VisitorException {
        processUnary(e, "-");
    }

    public void visitNotExpression(NotExpression e)
        throws VisitorException {
        processUnary(e, "~");
    }

    public void visitOrExpression(OrExpression e)
        throws VisitorException {
        processBinary(e, "|");
    }

    public void visitXorExpression(XorExpression e)
        throws VisitorException {
        processBinary(e, "^");
    }

    public void visitPeekExpression(PeekExpression e)
        throws VisitorException {
        getChannelOperation(e.getChannelExpression())
            .visitPeekExpression(e.getChannelExpression());
    }

    public void visitProbeExpression(ProbeExpression e)
        throws VisitorException {
        getChannelOperation(e.getChannelExpression())
            .visitProbeExpression(e.getChannelExpression());
    }

    public void visitReceiveExpression(ReceiveExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitRemainderExpression(RemainderExpression e)
        throws VisitorException {
        // handle x % 0
        processSpecialBinary(e, "util.remainder");
    }

    private void processString(String s) {
        final String esc =
            '"' + StringUtil.quoteASCIIString(s, ESCAPE_MAP) + '"';
        out.print("csp_string.init($bits(" + esc + "),"); out.ws();
        out.print(esc + ")");
    }

    public void visitStringExpression(StringExpression e)
        throws VisitorException {
        processString(e.getValue());
    }

    public void visitSubtractExpression(SubtractExpression e)
        throws VisitorException {
        processBinary(e, "-");
    }

    private void processStructureAccess(final String field,
                                        final ExpressionInterface structExpr,
                                        final ExpressionInterface accessExpr)
        throws VisitorException {
        boolean writeNow = false;
        if (complexAccess == null) {
            complexAccess = new ComplexAccess(accessExpr);
            writeNow = true;
        }
        complexAccess.accessStructure(field, false);
        structExpr.accept(this);
        if (writeNow) {
            final ComplexAccess old = complexAccess;
            complexAccess = null;
            old.write();
        }
    }

    public void visitStructureAccessExpression(StructureAccessExpression e)
        throws VisitorException {
        processStructureAccess(e.getFieldName(), e.getStructureExpression(), e);
    }

    public void visitMemberAccessExpression(MemberAccessExpression e)
        throws VisitorException {
        processStructureAccess(e.getMemberName(), e.getStructureExpression(),
                               e);
    }

    private void processBooleanChannel(ExpressionInterface chanExpr,
                                       ExpressionInterface rhs)
        throws VisitorException {
        if (chanExpr == null) rhs.accept(this);
        else {
            final boolean bool =
                analysisResults.getType(rhs) instanceof BooleanType;
            getChannelOperation(chanExpr).processChannel(chanExpr, bool);
        }
    }

    /**
     * Emit code to assign between two variables of the same type.
     *
     * @param lhs Left hand expression
     * @param rhs Right hand expression
     * @param t type of the expressions
     **/
    private void emitAssignment(final ComplexAccess lhs,
                                final ComplexAccess rhs, final Type t)
        throws VisitorException {
        emitAssignment(lhs, rhs, t, 0);
    }

    private void emitAssignment(final ComplexAccess lhs,
                                final ComplexAccess rhs, final Type t,
                                final int indices) throws VisitorException {
        if (t instanceof IntegerType || t instanceof BooleanType ||
            t instanceof StringType) {
            lhs.write();
            out.ws(); out.print('='); out.ws();
            rhs.write();
            out.println(";");
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            out.println("begin : " + genBlock());
            final String var = "loop$" + indices;
            out.println(getLoopVarType(at.getRange()) + " " + var + ";");
            emitForLoop(var, at.getRange());
            out.println(" begin");
            lhs.accessArray(var);
            rhs.accessArray(var);
            emitAssignment(lhs, rhs, at.getElementType(), indices + 1);
            out.println("end");
            out.println("end");
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nlhs = new ComplexAccess(lhs);
                    final ComplexAccess nrhs = new ComplexAccess(rhs);
                    final String id = d.getIdentifier().getIdentifier();
                    nlhs.accessStructure(id);
                    nrhs.accessStructure(id);
                    emitAssignment(nlhs, nrhs, d.getTypeFragment(), indices);
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot assign between: " + t);
        }
    }

    private void emitPack(final ComplexAccess expr, final Type t)
        throws VisitorException {
        if (t instanceof BooleanType) {
            expr.write();
        } else if (t instanceof IntegerType) {
            final IntegerType it = (IntegerType) t;
            final int width = getIntegerConstant(it.getDeclaredWidth()) - 1;
            expr.write();
            out.print("[" + width + ":0]");
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            final Range r = at.getRange();
            final int min = getIntegerConstant(r.getMinExpression());
            final int max = getIntegerConstant(r.getMaxExpression());
            boolean first = true;
            for (int i = max; i >= min; --i) {
                if (first) first = false;
                else { out.print(','); out.ws(); }
                final ComplexAccess nexpr = new ComplexAccess(expr);
                nexpr.accessArray(Integer.toString(i));
                emitPack(nexpr, at.getElementType());
            }
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final boolean[] first = new boolean[] { true };
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nexpr = new ComplexAccess(expr);
                    final String id = d.getIdentifier().getIdentifier();
                    nexpr.accessStructure(id);
                    if (first[0]) first[0] = false;
                    else { out.print(','); out.ws(); }
                    emitPack(nexpr, d.getTypeFragment());
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot pack: " + t);
        }
    }

    private ComplexAccess getComplexAccess(final ExpressionInterface expr)
        throws VisitorException {
        complexAccess = new ComplexAccess(expr);
        expr.accept(this);
        final ComplexAccess result = complexAccess;
        complexAccess = null;
        return result;
    }

    private void emitPack(final ExpressionInterface structure)
        throws VisitorException {
        emitPack(getComplexAccess(structure),
                 (Type) analysisResults.getType(structure));
    }

    // Fix up booleans, specifically, true is unpacked as 1, but needs to be
    // turned to -1
    private void emitUnpack(final ComplexAccess expr, final Type t)
        throws VisitorException {
        if (t instanceof BooleanType) {
        } else if (t instanceof IntegerType) {
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            final Range r = at.getRange();
            final int min = getIntegerConstant(r.getMinExpression());
            final int max = getIntegerConstant(r.getMaxExpression());
            for (int i = max; i >= min; --i) {
                final ComplexAccess nexpr = new ComplexAccess(expr);
                nexpr.accessArray(Integer.toString(i));
                emitUnpack(nexpr, at.getElementType());
            }
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nexpr = new ComplexAccess(expr);
                    final String id = d.getIdentifier().getIdentifier();
                    nexpr.accessStructure(id);
                    emitUnpack(nexpr, d.getTypeFragment());
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot unpack: " + t);
        }
    }

    private void emitUnpack(final ExpressionInterface structure)
        throws VisitorException {
        emitUnpack(getComplexAccess(structure),
                   (Type) analysisResults.getType(structure));
    }

    /**
     * Process an assignment statement.
     *
     * @param lhs left hand side of the assignment statement
     * @param rhs right hand side of the assignment statement;
     * <code>null</code> if the right hand side is the value from a channel
     * @param chanExpr <code>null</code> if the right hand side is not the
     * value from a channel; otherwise, it contains the channel expression to
     * read from.
     **/
    private void processAssignmentStatement(ExpressionInterface lhs,
                                            ExpressionInterface rhs,
                                            ExpressionInterface chanExpr,
                                            AssignmentStatement stmt)
        throws VisitorException {
        lvalues.add(lhs);
        final boolean op =
            stmt != null && stmt.getKind() != AssignmentStatement.EQUAL;
        if (lhs instanceof BitRangeExpression &&
            needBitRangeFunction((BitRangeExpression) lhs)) {
            final BitRangeExpression bitRangeExpression =
                (BitRangeExpression) lhs;
            out.print("util.bit_insert_" +
                      (op ? stmt.getKindString() : "") +
                      (bitRangeExpression.getMinExpression() == null ?
                          "3" : "4") +
                      "(");
            lvalues.add(bitRangeExpression.getBitsExpression());
            bitRangeExpression.getBitsExpression().accept(this);
            out.print(','); out.ws();
            lvalues.add(rhs);
            processBooleanChannel(chanExpr, rhs);
            out.print(','); out.ws();
            lvalues.add(bitRangeExpression.getMaxExpression());
            bitRangeExpression.getMaxExpression().accept(this);
            if (bitRangeExpression.getMinExpression() != null) {
                out.print(','); out.ws();
                lvalues.add(bitRangeExpression.getMinExpression());
                bitRangeExpression.getMinExpression().accept(this);
            }
            out.println(");");
        } else if (analysisResults.getType(lhs) instanceof StructureType ||
                   analysisResults.getType(lhs) instanceof ArrayType) {
            // This can only be an assignment between two structure or array
            // variables
            complexAccess = new ComplexAccess();
            lhs.accept(this);
            final ComplexAccess lca = complexAccess;

            complexAccess = new ComplexAccess();
            rhs.accept(this);
            final ComplexAccess rca = complexAccess;
            complexAccess = null;

            final Type t = (Type) analysisResults.getType(lhs);
            boolean cov = coverage_off(t);
            emitAssignment(lca, rca, t);
            coverage_on(cov);
        } else {
            final Type lty = (Type) analysisResults.getType(lhs);
            boolean cov = coverage_off(lty);
            final boolean lstr =
                stmt != null && stmt.getKind() == AssignmentStatement.ADD &&
                (lty instanceof StringType);
            final boolean rstr =
                lstr && !(analysisResults.getType(rhs) instanceof StringType);
            final boolean skip = lhs instanceof BitRangeExpression &&
                                 isBitRangeInvalid((BitRangeExpression) lhs);

            if (skip) out.print("/* ");
            if (op) out.print("util.assign_" +
                              (lstr ? "concat" : stmt.getKindString()) + "(");
            if (lhs instanceof BitRangeExpression) {
                final BitRangeExpression bre = (BitRangeExpression) lhs;
                lvalues.add(bre.getBitsExpression());
                processSimpleBitRange(bre, true);
            } else {
                lhs.accept(this);
            }
            if (op) { out.ws(); out.print(','); out.ws(); }
            else {
                out.print(" = ");
            }
            if (rstr) out.print("util.csp_string(");
            lvalues.add(rhs);
            processBooleanChannel(chanExpr, rhs);
            if (rstr) out.print(", 10)");
            if (op) out.print(" )");
            if (skip) out.println(" */");
            else out.println(';');
            coverage_on(cov);

            if (false) {
                // debugging display
                out.print("$display(\"");
                lhs.accept(this);
                out.print(": %d\\n\", ");
                lhs.accept(this);
                out.println(");");
            }
        }
    }

    private String getFullName(
            final FunctionDeclaration decl,
            final List/*<Object>*/ arrayArg) throws VisitorException {
        final Pair/*<FunctionDeclaration,List<Object>>*/ p =
            new Pair/*<FunctionDeclaration,List<Object>>*/(decl, arrayArg);
        final String result = decl.getName() + "$" + labels.getLabel(p);
        pendingFunctions.addFirst(new Triplet/*<FunctionDeclaration,
                                           List<Object>,
                                           String>*/(decl, arrayArg, result));

        return result;
    }

    private String getFullName(
            final StructureDeclaration decl,
            final List/*<Object>*/ arrayArg) throws VisitorException {
        final Pair/*<StructureDeclaration,List<Object>>*/ p =
            new Pair/*<StructureDeclaration,List<Object>>*/(decl, arrayArg);
        final String result = decl.getName() + "$" + labels.getLabel(p);
        pendingConstructors.add(new Triplet/*<StructureDeclaration,
                                             List<Object>,
                                             String>*/(decl, arrayArg, result));

        return result;
    }

    private final Map/*<FunctionDeclaration,VariableAnalyzer.Results>*/
        functionAnalyzerCache =
            new HashMap/*<FunctionDeclaration,VariableAnalyzer.Results>*/();

    private VariableAnalyzer.Results
    getAnalyzerResults(final FunctionDeclaration decl,
                       final SequentialStatement initStmt)
    throws VariableAnalysisException {
        VariableAnalyzer.Results results =
            (VariableAnalyzer.Results) functionAnalyzerCache.get(decl);
        if (results == null) {
            results = analyzer.getResults(decl, initStmt, resolver);
            allUsedTokens.addAll(results.getUsedTokens());
            problems.process(results.getErrors(strictVars));
            functionAnalyzerCache.put(decl, results);
        }
        return results;
    }

    private final Map/*<Object,Object>*/ arrayMapping =
        new HashMap/*<Object,Object>*/();

    private ComplexAccess mapComplexArgument(final ComplexAccess access) {
        final ComplexAccess mapped =
            (ComplexAccess) arrayMapping.get(access.getBase());
        return access.map(mapped);
    }

    private void outputFormalParameter(final IdentifierExpression ident,
                                       final Type t,
                                       final Iterator/*<ComplexAccess>*/ args,
                                       final UniqueLabel label,
                                       final String inout,
                                       final boolean[] comma)
        throws VisitorException {
        if (t instanceof ArrayType || t instanceof StructureType) {
            final ComplexAccess access = (ComplexAccess) args.next();
            final int num = label.getLabel(access);
            final ComplexAccess fixed = new ComplexAccess();
            fixed.copyStructure(access);
            fixed.setBase(access.getBase());
            final int indices = access.getIndices().size();
            if (indices > 0 && comma[0]) out.println(",");
            for (int i = 0; i < indices; ++i) {
                comma[0] = true;
                final String var = "i$" + num + "$" + i;
                final Type ity =
                    (Type) new IntegerType().setFlag(DISABLE_COVERAGE, true);
                declareVariable("input ", var, ity, ",");
                if (i < indices - 1) out.println(",");
                fixed.accessArray(var);
            }
            arrayMapping.put(t, fixed);
        } else {
            if (comma[0]) out.println(",");
            declareVariable(inout, ident.getIdentifier(), t, ",");
            comma[0] = true;
        }
    }

    private void outputConstructor(final StructureDeclaration decl,
                                   final List/*<Object>*/ arrayArg,
                                   final String name) throws VisitorException {
        final Iterator argIter = arrayArg.iterator();
        final UniqueLabel label = new UniqueLabel();
        final boolean[] comma = new boolean[] { false };
        out.println("task " + escape(name) + " (");
        (new DeclarationProcessor() {
            public void process(final Declarator d) throws VisitorException {
                final IdentifierExpression ident = d.getIdentifier();
                final Type t = d.getTypeFragment();
                tokenVerilogNameMap.put(t, ident.getIdentifier());
                hierarchyNameMap.put(t, name);
                outputFormalParameter(ident, t, argIter, label, "input ",
                                      comma);
            }
        }).process(decl.getDeclarations());
        final IdentifierExpression rident = new IdentifierExpression("ret$");
        final StructureType rtype = new StructureType(false, decl.getName());
        tokenVerilogNameMap.put(rtype, rident.getIdentifier());
        hierarchyNameMap.put(rtype, name);
        outputFormalParameter(rident, rtype, argIter, label, "output ", comma);
        out.println(");");
        out.println();

        out.println("begin : main");
        final ComplexAccess lhs = new ComplexAccess();
        lhs.setBase(rtype);
        (new DeclarationProcessor() {
            public void process(final Declarator d)
                throws VisitorException {
                final ComplexAccess nlhs = new ComplexAccess(lhs);
                final String id = d.getIdentifier().getIdentifier();
                nlhs.accessStructure(id);

                final ComplexAccess nrhs = new ComplexAccess();
                nrhs.setBase(d.getTypeFragment());
                emitAssignment(nlhs, nrhs, d.getTypeFragment(), 0);
            }
        }).process(decl.getDeclarations());
        out.println("end");
        out.println("endtask");
    }

    private void outputFunction(final FunctionDeclaration decl,
                                final SequentialStatement initStmt,
                                final List/*<Object>*/ arrayArg,
                                final String name) throws VisitorException {
        final VariableAnalyzer.Results old = analysisResults;
        try {
            analysisResults = getAnalyzerResults(decl, initStmt);
        } catch (VariableAnalysisException x) {
            throw new VisitorException(x.getMessage(), x);
        }

        updateTokenVerilogMap(name);

        arrayMapping.clear();
        out.println("task " + escape(name) + " (");
        final Iterator argIter = arrayArg.iterator();
        final UniqueLabel label = new UniqueLabel();
        final boolean[] comma = new boolean[] { false };
        for (Iterator i = decl.getFormals().getDeclarations(); i.hasNext(); ) {
            final DeclaratorList d =
                ((Declaration) i.next()).getDeclaratorList();
            for (Iterator j = d.getDeclarators(); j.hasNext(); ) {
                final Declarator dor = (Declarator) j.next();
                final IdentifierExpression ident = dor.getIdentifier();
                final Type t = (Type) analysisResults.getIdentToken(ident);
                lastVerilogTokenMap.remove(t);
                outputFormalParameter(ident, t, argIter, label,
                        dor.getDirection() == Declarator.IN ? "input "
                                                            : "inout ",
                        comma);
            }
        }
        // return value
        final Type rtype = decl.getReturnType();
        if (rtype != null) {
            outputFormalParameter(decl.getNameIdentifier(), rtype,
                                  argIter, label, "output ", comma);
        }
        out.println(");");
        out.println();
        if (rtype != null)
            lastVerilogTokenMap.remove(analysisResults.getIdentToken(decl.getNameIdentifier()));

        declareVariables();

        // start initial block
        out.println("begin : main");

        // declare and initialize the undeclared variables
        final Set/*<String>*/ undeclaredVars = processResults(analysisResults);

        // assign to 0 - undeclared variables
        for (Iterator i = undeclaredVars.iterator(); i.hasNext(); ) {
            final String var = escape((String) i.next());
            out.println(var + " = 0;");
        }
        // assign to 0 - return value
        if (decl.getReturnType() != null)
            initVar(decl.getReturnType(), decl.getNameIdentifier(), 0, null);
        // assign to 0 - output parameters
        for (Iterator i = decl.getFormals().getDeclarations(); i.hasNext(); ) {
            final DeclaratorList d =
                ((Declaration) i.next()).getDeclaratorList();
            for (Iterator j = d.getDeclarators(); j.hasNext(); ) {
                final Declarator dor = (Declarator) j.next();
                if (dor.getDirection() == Declarator.OUT) {
                    final IdentifierExpression ident = dor.getIdentifier();
                    final Type t = (Type) analysisResults.getIdentToken(ident);
                    initVar(t, ident, 0, null);
                }
            }
        }
        out.println();

        // csp body
        processingBody = true;
        decl.getBodyStatement().accept(this);
        processingBody = false;

        // end initial block
        out.println("end");
        out.println();

        // end module
        out.println("endtask");
        analysisResults = old;
    }

    private void outputFunctions(final SequentialStatement initStmt)
        throws VisitorException {
        final HashSet/*<Triplet<FunctionDeclaration,
                                List<Object>,
                                String>>*/ seen =
            new HashSet/*<FunctionDeclaration,List<Object>,String>>*/();
        while (!pendingFunctions.isEmpty()) {
            final Triplet/*<FunctionDeclaration,List<Object>,String>>*/ t =
                (Triplet) pendingFunctions.remove(0);
            if (!seen.add(t)) continue;
            final FunctionDeclaration decl = (FunctionDeclaration) t.getFirst();
            final List/*<Object>*/ arrayArg = (List) t.getSecond();
            final String name = (String) t.getThird();
            setupCoverageProbes(decl);
            outputFunction(decl, initStmt, arrayArg, name);
        }
    }

    private void outputConstructors() throws VisitorException {
        final HashSet/*<Triplet<StructureDeclaration,
                                List<Object>,
                                String>>*/ seen =
            new HashSet/*<StructureDeclaration,List<Object>,String>>*/();
        while (!pendingConstructors.isEmpty()) {
            final Triplet/*<StructureDeclaration,List<Object>,String>>*/ t =
                (Triplet) pendingConstructors.remove(0);
            if (!seen.add(t)) continue;
            final StructureDeclaration decl =
                (StructureDeclaration) t.getFirst();
            final List/*<Object>*/ arrayArg = (List) t.getSecond();
            final String name = (String) t.getThird();
            outputConstructor(decl, arrayArg, name);
        }
    }

    private void outputArbiters() {
        for (Iterator i = arbiters.iterator(); i.hasNext(); ) {
            final Pair p = (Pair) i.next();
            final String inst = (String) p.getFirst();
            final Integer guards = (Integer) p.getSecond();
            out.println("`CAST2VERILOG_ARBITER #(" + guards + ") " +
                        inst + "(" + resetNodeName + " );");
        }
    }

    private void processFunctionArgument(
            final ExpressionInterface arg,
            final Collection/*<Object>*/ realArgs,
            final Collection/*<ExpressionInterface>*/ arrayArgs)
        throws VisitorException {
        final Type type = analysisResults.getType(arg);
        if (type instanceof ArrayType || type instanceof StructureType) {
            complexAccess = new ComplexAccess();
            arg.accept(this);
            final ComplexAccess mapped = mapComplexArgument(complexAccess);
            complexAccess = null;
            arrayArgs.add(mapped);
            realArgs.addAll(mapped.getIndices());
        } else {
            realArgs.add(arg);
        }
    }

    private void readHexInts(ArrayType ty) throws VisitorException {
        out.print("ReadHexInts#(");
        ty.getRange().getMinExpression().accept(this);
        out.print(",");
        ty.getRange().getMaxExpression().accept(this);
        out.print(",");
        out.print(getRegisterWidth((IntegerType) ty.getElementType()));
        out.print(",");
        out.print(registerBitWidth);
        out.print(")");
    }
    
    private void commaSeperated(final ExpressionInterface... es)
        throws VisitorException {
        boolean first = true;
        for (ExpressionInterface e : es) {
            if (first) first = false;
            else out.print(",");
            e.accept(this);
        }
    }

    private void processFunctionCall(final FunctionCallExpression e,
                                     final ExpressionInterface lhs)
        throws VisitorException {
        for (Iterator arg = e.getActuals(); arg.hasNext(); ) {
            lvalues.add((ExpressionInterface) arg.next());
        }
        Type lty = null;
        if (lhs != null) {
            lvalues.add(lhs);
            lty = (Type) analysisResults.getType(lhs);
        }

        final Pair/*<CSPProgram,FunctionDeclaration>*/ p =
            (Pair) resolver.getResolvedFunctions().get(e);
        final Object decl = p == null ? null : p.getSecond();
        String name = null;
        if (p == null || RefinementResolver.isBuiltin(decl)) {
            final ExpressionInterface func = e.getFunctionExpression();
            if (func instanceof IdentifierExpression) {
                name = ((IdentifierExpression) func).getIdentifier();
                if (name.equals("print") || name.equals("wait") ||
                    name.equals("assert")) { 
                    visitFunctionCallExpression(e); // process builtin funcs 
                } else if (name.equals("srandom")) {
                    System.out.println("N.B. srandom() function being skipped");
                } else if (name.equals("choose") || name.equals("random") ||
                           name.equals("string") || name.equals("log2") ||
                           name.equals("log4") || name.equals("simtime") ||
                           name.equals("walltime") ||
                           name.equals("ord") || name.equals("chr") ||
                           name.equals("getArgValue")) {
                    boolean cov = coverage_off(lty);
                    lhs.accept(this);
                    out.print(" = ");
                    visitFunctionCallExpression(e); // process builtin funcs 
                    out.println(" ; ");
                    coverage_on(cov);
                } else if (name.equals("pack")) {
                    boolean cov = coverage_off(lty);
                    lhs.accept(this);
                    out.print(" = { ");
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    emitPack(i.next());
                    out.println(" }; ");
                    coverage_on(cov);
                } else if (name.equals("unpack")) {
                    out.print("{ ");
                    final Iterator i = e.getActuals();
                    final ExpressionInterface structure =
                        (ExpressionInterface) i.next();
                    emitPack(structure);
                    out.print(" } = ");
                    ((ExpressionInterface) i.next()).accept(this);
                    out.println(" ;");
                    emitUnpack(structure);
                } else if (name.equals("energy")) {
                    // do nothing
                } else if (name.equals("readHexInts")) {
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    final ExpressionInterface file = i.next();
                    final ExpressionInterface count = i.next();
                    final ExpressionInterface array = i.next();
                    final ArrayType ty =
                        (ArrayType) analysisResults.getType(array);

                    boolean cov = coverage_off(lty);
                    readHexInts(ty);
                    out.print("::readHexInts(");
                    out.print("__csp_to_sv_string(");
                    file.accept(this);
                    out.print("),");
                    commaSeperated(array, count, lhs);
                    out.println(");");
                    coverage_on(cov);
                } else if (name.equals("dumpOn")) {
                    out.println("`CAST2VERILOG_DUMP_ON");
                } else if (name.equals("dumpOff")) {
                    out.println("`CAST2VERILOG_DUMP_OFF");
                } else if (name.equals("cover")) {
                } else if (name.equals(RefinementResolver.BuiltIn.FOPEN)) {
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    final ExpressionInterface file = i.next();
                    final ExpressionInterface mode = i.next();
                    boolean cov = coverage_off(lty);
                    lhs.accept(this);
                    out.print(" = ReadHexInts#()::fopen(");
                    out.print("__csp_to_sv_string(");
                    file.accept(this);
                    out.print("), __csp_to_sv_string(");
                    mode.accept(this);
                    out.println("));");
                    coverage_on(cov);
                } else if (name.equals(RefinementResolver.BuiltIn.FCLOSE)) { 
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    final ExpressionInterface stream = i.next();
                    boolean cov = coverage_off(lty);
                    lhs.accept(this);
                    out.print(" = ReadHexInts#()::fclose(int'(");
                    stream.accept(this);
                    out.println("));");
                    coverage_on(cov);
                } else if (name.equals(RefinementResolver.BuiltIn.FREAD)) {
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    final ExpressionInterface ptr = i.next();
                    final ExpressionInterface size = i.next();
                    final ExpressionInterface nmemb = i.next();
                    final ExpressionInterface stream = i.next();
                    boolean cov = coverage_off(lty);
                    readHexInts((ArrayType) analysisResults.getType(ptr));
                    out.print("::fread(");
                    commaSeperated(ptr, size, nmemb, stream, lhs);
                    out.println(");");
                    coverage_on(cov);
                } else if (name.equals(RefinementResolver.BuiltIn.FWRITE)) {
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    final ExpressionInterface ptr = i.next();
                    final ExpressionInterface size = i.next();
                    final ExpressionInterface nmemb = i.next();
                    final ExpressionInterface stream = i.next();
                    boolean cov = coverage_off(lty);
                    readHexInts((ArrayType) analysisResults.getType(ptr));
                    out.print("::fwrite(");
                    commaSeperated(ptr, size, nmemb, stream, lhs);
                    out.println(");");
                    coverage_on(cov);
                } else if (name.equals(RefinementResolver.BuiltIn.FPOLL)) { 
                    final Iterator<ExpressionInterface> i = e.getActuals();
                    final ExpressionInterface stream = i.next();
                    boolean cov = coverage_off(lty);
                    lhs.accept(this);
                    out.print(" = ReadHexInts#()::fpoll(int'(");
                    stream.accept(this);
                    out.println("));");
                    coverage_on(cov);
                } else {
                    // not supported: eventQueueIsEmpty, stable, enableDSimErrors
                    throw new VisitorException(
                            "Unsupported builtin function at " +
                            e.getParseRange().fullString());
                }
            } else {
                throw new VisitorException("Call to unknown function at " +
                                           e.getParseRange().fullString());
            }
            return;
        }

        final Collection realArgs = new ArrayList/*<Object>*/();
        if (decl instanceof FunctionDeclaration ||
            decl instanceof StructureDeclaration) {
            final List/*<Object>*/ arrayArg = new ArrayList/*<Object>*/();
            for (Iterator i = e.getActuals(); i.hasNext(); ) {
                final ExpressionInterface arg = (ExpressionInterface) i.next();
                processFunctionArgument(arg, realArgs, arrayArg);
            }
            if (lhs != null) processFunctionArgument(lhs, realArgs, arrayArg);

            if (decl instanceof FunctionDeclaration) {
                name = getFullName((FunctionDeclaration) decl, arrayArg);
            } else {
                name = getFullName((StructureDeclaration) decl, arrayArg);
            }
        } else {
            throw new VisitorException("Call to unknown function at " +
                                       e.getParseRange().fullString());
        }

        out.print(name);
        if (!realArgs.isEmpty()) {
            out.print("(");
            for (Iterator i = realArgs.iterator(); i.hasNext(); ) {
                final Object o = i.next();
                if (o instanceof ExpressionInterface) {
                    ((ExpressionInterface) o).accept(this);
                } else {
                    ((Index) o).write();
                }
                if (i.hasNext()) { out.print(','); out.ws(); }
            }
            out.print(")");
        }
        out.println(";");
    }
    public void visitAssignmentStatement(AssignmentStatement s)
        throws VisitorException {
        final ExpressionInterface rhs = s.getRightHandSide();
        // Here we handle peeks outside of guards as a special case of the rhs
        // of assignments because the FunctionPreprocessor transforms peeks
        // outside of guards as x = #X? + 0 into temp = #X?; x = temp + 0
        // Peeks inside guards are handled in visitPeekExpressions
        if (rhs instanceof PeekExpression) {
            // outside guard: #L? == ( [ L.d >= 0 ] ; L.d )
            final ExpressionInterface chanExpr =
                ((PeekExpression) rhs).getChannelExpression();
            out.print("wait(");
            getChannelOperation(chanExpr).visitProbeExpression(chanExpr);
            out.println(");");
            processAssignmentStatement(s.getLeftHandSide(), rhs,
                                       chanExpr, null);
        } else if (rhs instanceof FunctionCallExpression) {
            processFunctionCall((FunctionCallExpression) rhs,
                                s.getLeftHandSide());
        } else {
            processAssignmentStatement(s.getLeftHandSide(), rhs, null, s);
        }
    }

    /**
     * Returns true if the guarded statement has one guard
     * and no else clause.
     **/
    private static boolean hasOneGuard(AbstractGuardedStatement s) {
        final Iterator i = s.getGuardedCommands();
        assert i.hasNext();
        i.next();
        return !i.hasNext() && s.getElseStatement() == null;
    }

    /**
     * Returns number of guards in guarded statement 
     **/
    private static int numGuards(AbstractGuardedStatement s) {
        final Iterator i = s.getGuardedCommands();
        int numGuards = 0;
        assert i.hasNext();
        while (i.hasNext()) {
                numGuards++; 
                i.next();
        }
        return(numGuards);
    }

    public void processSelectionOrRepetition(
            final AbstractGuardedStatement s,
            final boolean isRepetition,
            final boolean isDeterministic)
        throws VisitorException {
        if (isRepetition && hasOneGuard(s)) {
            // Special case the 1 guard case into a simple while loop
            final GuardedCommand gc =
                (GuardedCommand) s.getGuardedCommands().next();
            final StatementInterface guardStmt;
            if (gc instanceof GuardedCommandWithStatement) {
                guardStmt =
                    ((GuardedCommandWithStatement) gc).getGuardStatement();
            } else {
                guardStmt = null;
            }
            if (guardStmt != null) {
                guardStmt.accept(this);
            }
            out.print("while (");
            gc.getGuard().accept(this);
            println(") begin", gc);
            if (s == infiniteLoop) {
                out.println("-> " + INFINITE_LOOP_ITERATION_EVENT + ";");
            }
            emitOneProbe(gc.getCommand(), "repetition statement alternative");
            gc.getCommand().accept(this);
            if (guardStmt != null) {
                guardStmt.accept(this);
            }
            out.println("end");
        } else {
            out.println("begin : " + genBlock());
            final String chosenGuard = "chosen_guard$" + genVarNum();
            out.println("integer " + chosenGuard + ';');
            final String numTrueGuards = "num_true_guards$" + genVarNum();
            out.println("integer " + numTrueGuards + ';');

            // for non-determistic case declare an array of true guard nums
            final int numGuards = numGuards(s);
            final String arbiterInst, trueGuards;
            if (isDeterministic) {
                arbiterInst = null;
                trueGuards = "true_guards$" + genVarNum();
                out.println("integer " + trueGuards +
                            "[0:" + numGuards + " - 1];");
            } else {
                arbiterInst = "arbiter$" + genVarNum();
                trueGuards = arbiterInst + ".true_guards";
                arbiters.add(new Pair(arbiterInst, new Integer(numGuards)));
            }

            if (!isRepetition || s.getElseStatement() == null) {
                // hack around lack of do ... while loop by setting
                // chosenGuard to 0 initially
                out.println(chosenGuard + " = 0;");
                out.println("while (" + chosenGuard + " != -1) begin");
            } else
                out.println("while (1) begin");

            out.println(chosenGuard + " = -1;");
            out.println(numTrueGuards + " = 0;");


            // handle guards
            int guardNum = 0;
            for (Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
                final GuardedCommand gc = (GuardedCommand) i.next();

                if (gc instanceof GuardedCommandWithStatement) {
                    final GuardedCommandWithStatement gcws =
                        (GuardedCommandWithStatement) gc;
                    gcws.getGuardStatement().accept(this);
                }

                out.print("if (");
                gc.getGuard().accept(this);
                println(")", gc.getGuard());

                out.println("begin");
                if (isDeterministic) // remember true guard
                    out.println(chosenGuard + " = " + guardNum + ';');

                // trueGuards[numTrueGuards] = guardNum; 
                out.println(trueGuards + "[" + numTrueGuards + "] = " +
                    guardNum + ";"); 

                out.println(numTrueGuards + " = " + numTrueGuards + "+ 1;");
                out.println("end");

                ++guardNum;
            }

             // emit error checking code for more than 1 guard being true
             // in deterministic case
             if (isDeterministic) {
                 coverage_off();
                 out.println("// error checking code"); 
                 out.println("if (" + numTrueGuards + " > 1) begin");
                 out.println("`CAST2VERILOG_MULTIPLE_GUARDS_TRUE_ERROR2(\"" +
                             s.getParseRange().fullString() + "\", " +
                             numTrueGuards + ", " + trueGuards + ")");
                 out.println("end // error checking code"); 
                 coverage_on();
            }

            // pick guard randomly among true guards
            if (!isDeterministic) {
                out.println("if (" + numTrueGuards + "> 0)");
                out.println(chosenGuard + " = " + arbiterInst + ".select(" +
                            numTrueGuards + ");");
            }

            // handle bodies
            out.println("case (" + chosenGuard + ')');
            // handle else or do nothing case
            out.println("-1 : begin");
            if (s.getElseStatement() != null) {
                emitOneProbe(s.getElseStatement(),
                    "repetition or selection statement else clause");
                s.getElseStatement().accept(this);
            } else if (!isRepetition) {
                // handle case that no guards are true
                // REVIEW: This might not be the best way to handle waiting
                out.print("@(");
                boolean first = true;
                for (Iterator i = inputPorts.iterator(); i.hasNext(); ) {
                    final String inputPort = (String) i.next();
                    if (!first) {
                        out.ws(); out.print("or"); out.ws();
                    }
                    first = false;
                    out.print(inputPort + " ");
                }
                if (first) {
                    // if there are no inputs at all to the cell, deadlock by
                    // waiting for the chosenGuard variable to change, which
                    // cannot happen
                    out.print(chosenGuard + " ");
                }
                out.println(");");

                // HACK: stay in loop by setting chosenGuard to 0
                out.println(chosenGuard + " = 0;");
            }
            out.println("end");
            // handle other bodies
            guardNum = 0;
            for (Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
                final GuardedCommand gc = (GuardedCommand) i.next();
                println(guardNum + " : begin", gc.getCommand());
                emitOneProbe(gc.getCommand(),
                    "repetition or selection statement alternative");
                gc.getCommand().accept(this);
                if (!isRepetition) {
                    // HACK: end loop by setting chosenGuard to -1
                    out.println(chosenGuard + " = -1;");
                }
                out.println("end");

                ++guardNum;
            }
            out.println("endcase");

            out.println("end");
            out.println("end");
        }
    }


    public void visitDeterministicRepetitionStatement(
            DeterministicRepetitionStatement s)
        throws VisitorException {
        processSelectionOrRepetition(s, true, true);
    }


    public void visitDeterministicSelectionStatement(
            DeterministicSelectionStatement s)
        throws VisitorException {
        processSelectionOrRepetition(s, false, true);
    }

    public void visitExpressionStatement(ExpressionStatement s)
        throws VisitorException {
        final ExpressionInterface expr = s.getExpression();
        if (expr instanceof FunctionCallExpression) {
            processFunctionCall((FunctionCallExpression) expr, null);
            return;
        }
        unsupported(s);
    }

    public void visitLoopStatement(LoopStatement s) throws VisitorException {
        // Only sequential loops are translated directly; parallel loops is
        // only handled via loop unrolling
        if (s.getSeparator() == LoopStatement.SEQUENTIAL) {
            out.println("begin : " + genBlock());
            final String loopMax = "loopMax$" + genVarNum();
            out.println(registerType + " " + loopMax + ";");
            out.print(loopMax + " = ");
            s.getRange().getMaxExpression().accept(this); 
            out.println(" ;");

            out.print("for (");
            s.getIndexVarExpression().accept(this);
            out.print("=");
            s.getRange().getMinExpression().accept(this);
            out.print(" ; ");
            s.getIndexVarExpression().accept(this);
            out.print(" <= " + loopMax + " ; ");
            s.getIndexVarExpression().accept(this);
            out.print("=");
            s.getIndexVarExpression().accept(this);
            println(" + 1) begin ", s);
            s.getStatement().accept(this); 
            out.println("end");
            out.println("end");
        } else {
            throw new VisitorException("Range not compile time constants in loop at " + s.getParseRange().fullString());
        }
    }

    public void visitNonDeterministicRepetitionStatement(
            NonDeterministicRepetitionStatement s)
        throws VisitorException {
        unsupported(s);
    }


    public void visitNonDeterministicSelectionStatement(
            NonDeterministicSelectionStatement s)
        throws VisitorException {
        /* Through exception on else. Currently this also causes a grammer exception */
        if (s.getElseStatement() != null) {
            throw new AssertionError("Else in non-deterministic selection not supported");
        }
        processSelectionOrRepetition(s, false, false);
    }

    public void visitLinkageLoopTerm(final LinkageLoopTerm term)
        throws VisitorException {
        unsupported(term);
    }

    public void visitLinkageExpressionTerm(final LinkageExpressionTerm term)
        throws VisitorException {
        unsupported(term);
    }

    public void visitLinkageArrayAccessExpression(
            final LinkageArrayAccessExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitLinkageIdentifierExpression(
            final LinkageIdentifierExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitLinkageStructureAccessExpression(
            final LinkageStructureAccessExpression e)
        throws VisitorException {
        unsupported(e);
    }

    public void visitParallelStatement(ParallelStatement s)
        throws VisitorException {
        out.println("fork");

        for (Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();

            println("begin", stmt);

            // emit the parallel code
            stmt.accept(this);

            out.println("end");
        }

        out.println("join");
    }

    public void visitReceiveStatement(ReceiveStatement s)
        throws VisitorException {
        getChannelOperation(s.getChannelExpression())
            .visitReceiveStatement(s);
    }

    private void processConcat(final String var, final String literal) {
        out.print(var + " = csp_string.concat(" + var + ", ");
        processString(literal);
        out.println(");");
    }

    public void visitSendStatement(SendStatement s)
        throws VisitorException {
        getChannelOperation(s.getChannelExpression())
            .visitSendStatement(s);
    }

    public void visitSequentialStatement(SequentialStatement s)
        throws VisitorException {
        ++scope;
        for (final Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();
            stmt.accept(this);
        }   
        --scope;
    }

    public void visitErrorStatement(ErrorStatement s)
        throws VisitorException {
        out.println("`CAST2VERILOG_CSP_ERROR(\"" +
                    s.getParseRange().fullString() + "\")");
    }

    public void visitSkipStatement(SkipStatement s)
        throws VisitorException {
        // do nothing
    }

    private void declareType(final Type t,
                             final ComplexDeclaration decl,
                             final Collection/*<ComplexDeclaration>*/ results)
        throws VisitorException {
        if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            decl.declareArray(at.getRange());
            declareType(at.getElementType(), decl, results);
        } else if (t instanceof IntegerType || t instanceof BooleanType ||
                   t instanceof StringType) {
            decl.setType(t);
            results.add(decl);
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            // VariableAnalyzer should have made sure all structures are valid
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexDeclaration cdecl =
                        new ComplexDeclaration(decl);
                    cdecl.declareStructure(d.getIdentifier().getIdentifier());
                    declareType(d.getTypeFragment(), cdecl, results);
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Unsupported type: " + t);
        }
    }

    private void declareVariable(final String id, final Type t)
        throws VisitorException {
        boolean cov = coverage_off(t);
        declareVariable("", id, t, ";");
        out.println(";");
        coverage_on(cov);
    }

    private void declareVariable(final String inout, final String id,
                                 final Type t, final String delim)
        throws VisitorException {
        final Collection<ComplexDeclaration> results = new ArrayList<>();
        final ComplexDeclaration decl = new ComplexDeclaration();
        declareType(t, decl, results);

        // just emit declaration
        for (Iterator i = results.iterator(); i.hasNext(); ) {
            final ComplexDeclaration cdecl = (ComplexDeclaration) i.next();
            out.print(inout);
            cdecl.declare(id);
            if (i.hasNext()) out.println(delim);
        }
    }

    private void declareCoverpoint(final Supplier<String> preamble,
                                   final String id,
                                   final Type t,
                                   final boolean[] hasCG)
        throws VisitorException {
        final Collection<ComplexDeclaration> results = new ArrayList<>();
        final ComplexDeclaration decl = new ComplexDeclaration();
        declareType(t, decl, results);

        for (ComplexDeclaration cdecl : results) {
            if (!hasCG[0]) {
                out.println(preamble.get());
                hasCG[0] = true;
            }
            (new ComplexDeclaration(cdecl) {
                private void unroll(final List<Range> rs,
                                    final int dims,
                                    final String base,
                                    final String idx)
                throws VisitorException {
                    if (dims < rs.size()) {
                        final Range r = rs.get(dims);
                        final int min = getIntegerConstant(r.getMinExpression());
                        final int max = getIntegerConstant(r.getMaxExpression());
                        for (int i = min; i <= max; ++i) {
                            unroll(rs, dims + 1, base, idx + "[" + i + "]");
                        }
                    } else {
                        out.println("  coverpoint " + escape(base) + idx + ";");
                    }
                }
                public void declare(final String base) throws VisitorException {
                    unroll(getArray(), 0, getStructurePartUnescaped(base), "");
                }
            }).declare(id);
        }
    }

    private Map/*<Type,String>*/ tokenVerilogNameMap =
        new HashMap/*<Type,String>*/();
    private Map/*<Type,String>*/ lastVerilogTokenMap =
        new LinkedHashMap/*<Type,String>*/();
    private Map/*<Type,String>*/ hierarchyNameMap =
        new HashMap/*<Type,String>*/();
    private Set<Type> allUsedTokens = new HashSet<Type>();
    private void updateTokenVerilogMap(final String hierarchy) {
        lastVerilogTokenMap.clear();
        final Map/*<Type,String>*/ tokenIdentMap =
            analysisResults.getTokenIdentMap();
        final Set<Type> initializerTokens =
            analysisResults.getInitializerTokens();
        final HashCounter counter = new HashCounter();
        for (Iterator i = tokenIdentMap.entrySet().iterator(); i.hasNext(); ) {
            final Map.Entry/*<Type,String>*/ entry = (Map.Entry) i.next();
            final Type type = (Type) entry.getKey();
            final String id = (String) entry.getValue();
            final int count = counter.getCount(id);
            counter.add(id);
            final String realId = id + (count == 0 ? "" : "$$" + count);
            tokenVerilogNameMap.put(type, realId);
            // ChannelTypes and ChannelStructureTypes cannot be passed to
            // functions as arguments, and therefore can only be accessed if
            // they are in the cell's port list.  The cell ports translate to
            // module ports, which are visible to tasks defined in the module,
            // so we do not need to do anything to them.
            final Type baseType = CspUtils.getBaseType(type);
            if ((baseType instanceof IntegerType ||
                 baseType instanceof BooleanType ||
                 baseType instanceof StringType ||
                 baseType instanceof StructureType) &&
                !initializerTokens.contains(type) &&
                allUsedTokens.contains(type))
                lastVerilogTokenMap.put(type, realId);
            hierarchyNameMap.put(type, hierarchy);
        }
    }

    private void declareVariables() throws VisitorException {
        for (Iterator i = lastVerilogTokenMap.entrySet().iterator();
             i.hasNext(); ) {
            final Map.Entry/*<String,Token>*/ entry = (Map.Entry) i.next();
            declareVariable((String) entry.getValue(), (Type) entry.getKey());
        }
    }

    private void initVar(final Type t, final IdentifierExpression ident,
                         final int dims, final ExpressionInterface init)
        throws VisitorException {
        complexAccess = new ComplexAccess();
        ident.accept(this);
        final ComplexAccess access = complexAccess;
        complexAccess = null;
        boolean cov = dims == 0 && coverage_off(t);
        initVar(t, access, dims, init);
        coverage_on(cov);
    }

    private void initVar(final Type t, final ComplexAccess ident,
                         final int dims, final ExpressionInterface init) 
        throws VisitorException {
        if (t instanceof IntegerType || t instanceof BooleanType) {
            ident.write();
            out.print(" = ");
            if (init == null) out.print('0');
            else init.accept(this);
            out.println(";");
        } else if (t instanceof StringType) {
            ident.write();
            out.print(" = ");
            if (init == null) out.print("csp_string.init($bits(\"\"),\"\")");
            else init.accept(this);
            out.println(";");
        } else if (t instanceof ArrayType) {
            final ArrayType at = (ArrayType) t;
            out.println("begin : " + genBlock());
            final String var = "loop$" + dims;
            out.println(getLoopVarType(at.getRange()) + " " + var + ";");
            emitForLoop(var, at.getRange());
            out.println(" begin");
            ident.accessArray(var);
            initVar(at.getElementType(), ident, dims + 1, init);
            out.println("end");
            out.println("end");
        } else if (t instanceof StructureType) {
            final Pair p = (Pair) resolver.getResolvedStructures().get(t);
            final StructureDeclaration sdecl =
                (StructureDeclaration) p.getSecond();
            final DeclarationProcessor proc = new DeclarationProcessor() {
                public void process(final Declarator d)
                    throws VisitorException {
                    final ComplexAccess nident = new ComplexAccess(ident);
                    nident.accessStructure(d.getIdentifier().getIdentifier());
                    initVar(d.getTypeFragment(), nident, dims + 1,
                            d.getInitializer());
                }
            };
            proc.process(sdecl.getDeclarations());
        } else {
            throw new AssertionError("Cannot initialize type: " + t);
        }
    }

    public void visitVarStatement(VarStatement s)
        throws VisitorException {
        for (Iterator i = s.getDeclarationList().getDeclarations();
             i.hasNext(); ) {
            final Declaration declaration = (Declaration) i.next();

            for (Iterator j =
                     declaration.getDeclaratorList().getDeclarators();
                 j.hasNext(); ) {
                final Declarator declarator = (Declarator) j.next();
                final Type t = declarator.getTypeFragment();

                // declaration has been emitted at top of block by
                // declareVariables(), just assign here
                final ExpressionInterface init  = declarator.getInitializer();
                if (implicitInit || init != null || scope > 1) {
                    initVar(t, declarator.getIdentifier(), 0, init);
                }
            }
        }

        // only support new style declarations
        assert s.getStatement() == null;
    }

    public void visitArrayType(ArrayType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitChannelType(ChannelType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitChannelStructureType(ChannelStructureType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitIntegerType(IntegerType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitBooleanType(BooleanType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitNodeType(NodeType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitStringType(StringType t) throws VisitorException {
        unsupported(t);
    }

    public void visitStructureType(StructureType t)
        throws VisitorException {
        unsupported(t);
    }

    public void visitIdentifierList(IdentifierList il)
        throws VisitorException {
        unsupported(il);
    }

    public void visitLoopGuard(LoopGuard s) throws VisitorException {
        unsupported(s);
    }

    public void visitIncDecStatement(IncDecStatement s)
        throws VisitorException {
        unsupported(s);
    }

    private void unsupported(AbstractASTNode n) throws VisitorException {
        throw new VisitorException("CSP construct not yet supported at " +
                                   n.getParseRange().fullString());
    }
    
    public List<StructureDeclaration> getStructureDeclaration() {
        return resolver.getResolvedStructures()
                       .values()
                       .stream()
                       .map(p -> p.getSecond())
                       .collect(Collectors.toList());
    }
}

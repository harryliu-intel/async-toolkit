// DO NOT EDIT. Generated by reg2rdl hlp_fghash.reg.

<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>



// EM_HASH_LOOKUP[0..8191]

reg em_hash_lookup_r {
  shared;
  HandCoded = true;
  name = "FFU hashing buckets.";
  desc = "
  In single lookup mode, there is one table using 8K buckets.
  In split-4K lookup mode,
  * LOOKUP0 = EM_LOOKUP[0..4095]
  * LOOKUP1 = EM_LOOKUP[4096..8192]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RW";
    desc = "
    ptr*4 is the byte-location of the bucket's first entry in Hash Entry RAM.

           ";
    ValRandomize = true;
  } PTR[83:64] = 20'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } RSVD1_[63:52] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_4[51:48] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_3[47:44] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_2[43:40] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_1[39:36] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_0[35:32] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects which bucket_hash values have entries.

           ";
    ValRandomize = true;
  } MASK[31:0] = 32'h0;
};



// EM_HASH_CAM[0..31,0..7]

reg em_hash_cam_r {
  shared;
  HandCoded = true;
  name = "CAM entries for hash overflow.";
  desc = "
  The second index is the entry number, and the third index
  is the word number. The entry format is big-endian. Byte 0 is bits 63..56 of word 0.

  In 64B entry mode, the entry is 64 bytes wide.
  In 64B mode there is a single action resolution and the 1-2 actions from
  the highest-numbered matching entry are used.
  To form a 64B entry, a key 56B or less is padded with 0s to 56B and followed by two actions.
  In the case of a 60B key, there is only 1 action at EM_HASH_CAM[group][rule][7][31:0].

  In 32B entry mode, EM_HASH_CAM[group][rule][0..3] is the row0 entry,
  and EM_HASH_CAM[group][rule][4..7] is the row1 entry. The two rows are resolved
  independently: the 1-2 actions from the highest-numbered matching entry within each row
  are used. To form a 32B entry, a key 24B or less is padded with 0s to 24B and followed
  by two actions. In the case of a 28B key in 32B mode, there is only 1 action.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } DATA[63:0] = 64'h0;
};
regfile em_hash_cam_rf {
  em_hash_cam_r EM_HASH_CAM[8] += 8;
};



// EM_HASH_CAM_EN[0..1,0..31]

reg em_hash_cam_en_r {
  shared;
  HandCoded = true;
  name = "Select EM_HASH_CAM scenarios.";
  desc = "
  When EM_HASH_CAM_EN[group][row][rule].mask[s] is set, then
  EM_HASH_CAM[group][rule][row*4 +: 4] is used in scenario s.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Select scenarios for this rule. Uses little-endian bit numbering.

           ";
    ValRandomize = true;
  } MASK[63:0] = 64'h0;
};
regfile em_hash_cam_en_rf {
  em_hash_cam_en_r EM_HASH_CAM_EN[32] += 8;
};



// EM_KEY_MASK0[0..1,0..63]

reg em_key_mask0_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key8s to participate in hashing and matching. 
     Key8Mask[i] selects key8[i].

           ";
    ValRandomize = true;
  } KEY8_MASK[63:0] = 64'h0;
};
regfile em_key_mask0_rf {
  em_key_mask0_r EM_KEY_MASK0[64] += 8;
};



// EM_KEY_MASK1[0..1,0..63]

reg em_key_mask1_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Similar to KeySubmode0. Provides a second mask operation.

           ";
    ValRandomize = true;
  } KEY_SUBMODE1[51:50] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Controls EM_KEY_MASK2[].KeySubmask0.
   * if key_submode0=0, apply key_submask0 bitmask to keys 24..25 (MPLS 0)
   * if key_submode0=1, apply key_submask0 bitmask to keys 26..27 (MPLS 1)
   * if key_submode0=2, apply key_submask0 nybblemask to keys 24..31 (MPLS 0-3)
   * if key_submode0=3, apply key_submask0 nybblemask to keys 48..55 (outer IPv4, or outer SIPv6)

           ";
    ValRandomize = true;
  } KEY_SUBMODE0[49:48] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key32s to participate in hashing and matching. 
     Key32Mask[i] selects key32[i].

           ";
    ValRandomize = true;
  } KEY32_MASK[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key16s to participate in hashing and matching. 
     Key16Mask[i] selects key16[i].

           ";
    ValRandomize = true;
  } KEY16_MASK[31:0] = 32'h0;
};
regfile em_key_mask1_rf {
  em_key_mask1_r EM_KEY_MASK1[64] += 8;
};



// EM_KEY_MASK2[0..1,0..63]

reg em_key_mask2_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Similar to KeySubmask0. Provides a second mask operation.

           ";
    ValRandomize = true;
  } KEY_SUBMASK1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "
     Bit- or nybble-mask to apply to special keys.
     Setting a mask bit to 0 causes the bit or nybble to be zeroed
     out without shifting other bits/nybbles in the compacted key.

           ";
    ValRandomize = true;
  } KEY_SUBMASK0[31:0] = 32'h0;
};
regfile em_key_mask2_rf {
  em_key_mask2_r EM_KEY_MASK2[64] += 8;
};



// EM_KEY_MASK3[0..1,0..63]

reg em_key_mask3_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Similar to KEY_SUBMASK2 but applies to inner VLAN2.

           ";
    ValRandomize = true;
  } KEY_SUBMASK5[7:6] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Similar to KEY_SUBMASK2 but applies to inner VLAN1.

           ";
    ValRandomize = true;
  } KEY_SUBMASK4[5:4] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Similar to KEY_SUBMASK2 but applies to outer VLAN2.

           ";
    ValRandomize = true;
  } KEY_SUBMASK3[3:2] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Applies a mask to the outer VLAN1 key as follows:
       * 00b: 0x0FFF
       * 01b: 0xF000
       * 10b: 0x7000
       * 11b: Reserved (NOP)

           ";
    ValRandomize = true;
  } KEY_SUBMASK2[1:0] = 2'h0;
};
regfile em_key_mask3_rf {
  em_key_mask3_r EM_KEY_MASK3[64] += 8;
};



// EM_KEY_MASK4[0..1,0..63]

reg em_key_mask4_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     A 32-bit mask applied over KEY8[39:36].

           ";
    ValRandomize = true;
  } KEY_SUBMASK7[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "
     A 32-bit mask applied over KEY8[31:28].

           ";
    ValRandomize = true;
  } KEY_SUBMASK6[31:0] = 32'h0;
};
regfile em_key_mask4_rf {
  em_key_mask4_r EM_KEY_MASK4[64] += 8;
};



// EM_HASH_MISS[0..1,0..63]

reg em_hash_miss_r {
  shared;
  HandCoded = true;
  name = "Provides two hash-miss actions for each hashtable row.";
  desc = "
  EM_HASH_MISS[r][scenario] provides 2 actions for row r=0..1.

  If there is no key match in ENTRY_RAM or CAM, then both actions are taken.
  The format of the action is the same as EM_ACTION,
  HASH_ENTRY_RAM, and EM_HASH_CAM.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION0[31:0] = 32'h0;
};
regfile em_hash_miss_rf {
  em_hash_miss_r EM_HASH_MISS[64] += 8;
};



// EM_HASH_CFG[0..63]

reg em_hash_cfg_r {
  shared;
  HandCoded = true;
  name = "Configure FFU hashing";
  desc = "
  This register is indexed by the scenario.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Define lookup (or entry) modes : split 4K (0) or one 8K (1).
                                      32B      (0) or 64B    (1).

           ";
    ValRandomize = true;
  } MODE[46:46] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Start of hash table.
     Must be a multiple of 2^hash_size[ROW].

           ";
    ValRandomize = true;
  } BASE_PTR_0[45:33] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     Start of hash table.
     Must be a multiple of 2^hash_size[ROW].

           ";
    ValRandomize = true;
  } BASE_PTR_1[32:20] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of hash bits to use in lookup address calculation.

     * lookup_ptr = base_ptr[ROW] + hash % 2^hash_size[ROW]

     For example, hash_size=10 yields a table with 1024 buckets.

           ";
    ValRandomize = true;
  } HASH_SIZE_0[19:15] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of hash bits to use in lookup address calculation.

     * lookup_ptr = base_ptr[ROW] + hash % 2^hash_size[ROW]

     For example, hash_size=10 yields a table with 1024 buckets.

           ";
    ValRandomize = true;
  } HASH_SIZE_1[14:10] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Size of each entry, given as a multiple of 4B.
     The entry size must be a multiple of 4 in the range 8..64.
     The entry bytes following the padded key are actions.

     Set entry_size[r]==0 to disable row r lookups in this scenario.

           ";
    ValRandomize = true;
  } ENTRY_SIZE_0[9:5] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Size of each entry, given as a multiple of 4B.
     The entry size must be a multiple of 4 in the range 8..64.
     The entry bytes following the padded key are actions.

     Set entry_size[r]==0 to disable row r lookups in this scenario.

           ";
    ValRandomize = true;
  } ENTRY_SIZE_1[4:0] = 5'h0;
};



// Begin reg2rdl addrmap section

addrmap mby_ppe_em_map {
  name = "mby_em";
  desc = "Exact-match registers";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  em_hash_lookup_r          EM_HASH_LOOKUP[8192];
  em_hash_cam_rf            EM_HASH_CAM[32]     ;
  em_hash_cam_en_rf         EM_HASH_CAM_EN[2]   ;
  em_key_mask0_rf           EM_KEY_MASK0[2]     ;
  em_key_mask1_rf           EM_KEY_MASK1[2]     ;
  em_key_mask2_rf           EM_KEY_MASK2[2]     ;
  em_key_mask3_rf           EM_KEY_MASK3[2]     ;
  em_key_mask4_rf           EM_KEY_MASK4[2]     ;
  em_hash_miss_rf           EM_HASH_MISS[2]     ;
  em_hash_cfg_r             EM_HASH_CFG[64]     ;
}; // final size: 0x22600 <= 0x40000 = 8<<15

// INTEL TOP SECRET
// Copyright 2014 Intel Corporation. All Rights Reserved.
//

`include "hlp_udp.rdl"
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

reg shell_ctl_uerr_cnt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "12-bit uncorrectable error counter";
  desc = "uncorrectable error counter register";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD_[31:12] = 20'h0;
  field {
    AccessType = "RO/V";
    desc = "12-bit counter";
    ValRandomize = true;
  } COUNTER[11:0] = 12'h0;
};

reg shell_ctl_cerr_cnt_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "12-bit correctable error counter";
  desc = "correctable error counter register";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD_[31:12] = 20'h0;
  field {
    AccessType = "RO/V";
    desc = "12-bit counter";
    ValRandomize = true;
  } COUNTER[11:0] = 12'h0;
};

reg shell_ctl_status_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG2'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG2_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG2_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Status register in shell controller for a memory.";
  desc = "Status register in shell controller for a memory";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD1_[31:30] = 2'h0;
  field {
    AccessType = "RO/V";
    desc = "Last occured ECC Correctable/Uncorrectable error address.";
    ValRandomize = true;
  } ERROR_ADDRESS[29:12] = 18'h0;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD0_[11:4] = 8'h0;
  field {
    AccessType = "RO/V";
    desc = "Initialization of all the Memories in the cluster is done.";
    ValRandomize = true;
  } GLOBAL_INIT_DONE[3:3] = 1'h0;
  field {
    AccessType = "RO/V";
    desc = "Memory initialization is done.";
    ValRandomize = true;
  } INIT_DONE[2:2] = 1'h0;
  field {
    AccessType = "RO/C/V";
    desc = "Indication of correctable ECC error.";
    ValRandomize = true;
  } ECC_CORRECTABLE[1:1] = 1'h0;
  field {
    AccessType = "RO/C/V";
    desc = "Indication of uncorrectable ECC error.";
    ValRandomize = true;
  } ECC_UNCORRECTABLE[0:0] = 1'h0;
};

reg shell_ctl_cfg_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "Configuration register in shell controller";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      Indicates the index of the GEN_ECC_COMPUTE block, to which the invert_1/2 are addressed.
    ";
    ValRandomize = true;
  } GEN_ECC_INST_NUM[31:25] = 7'h0;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD3_[24:20] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
      Read Margin value to overide the default value of a Memory, Used
      only in SRAMs.
    ";
    ValRandomize = true;
  } READ_MARGIN[19:16] = 4'h2;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD2_[15:13] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
      Read Margin enable to overide the default value of a Memory, Used
      only in SRAMs.
    ";
    ValRandomize = true;
  } READ_MARGIN_ENABLE[12:12] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD1_[11:10] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      Enable counting uncorrectable ECC errors from this memory in a
      global counter.
    ";
    ValRandomize = true;
  } U_ECC_COUNT_ENABLE[9:9] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
      Enable counting correctable ECC errors from this memory in a
      global counter.
    ";
    ValRandomize = true;
  } C_ECC_COUNT_ENABLE[8:8] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD0_[7:6] = 2'h0;
  field {
    AccessType = "RW";
    desc = "Mask the interrupt from the memory on ECC Error.";
    ValRandomize = true;
  } MASK_INT[5:5] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Light Sleep Bypass. To bypass a dynamic Light-sleep mode access in
      the memory through the mem_ls_enter signal in the memory shell.
    ";
    ValRandomize = true;
  } LS_BYPASS[4:4] = 1'h1;
  field {
    AccessType = "RW";
    desc = "Light Sleep Force. To force a Light-Sleep mode in the Memory.";
    ValRandomize = true;
  } LS_FORCE[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      ECC debug: inverts the second bit of data to issue an error during
      read access.
    ";
    ValRandomize = true;
  } INVERT_2[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
       ECC debug: inverts the second bit of data to issue an error
       during read access.
    ";
    ValRandomize = true;
  } INVERT_1[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "Enable of the ECC checking correction mechanism.";
    ValRandomize = true;
  } ECC_ENABLE[0:0] = 1'h1;
};

reg shell_ctl_tcam_cfg_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG3'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG3_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG3_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "Configuration register in shell controller";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      Indicates the index of the GEN_ECC_COMPUTE block, to which the invert_1/2 are addressed.
    ";
    ValRandomize = true;
  } GEN_ECC_INST_NUM[31:25] = 7'h0;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD3_[24:20] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
      Read Margin value to overide the default value of a Memory, Used
      only in SRAMs.
    ";
    ValRandomize = true;
  } READ_MARGIN[19:16] = 4'h2;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD2_[15:13] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
      Read Margin enable to overide the default value of a Memory, Used
      only in SRAMs.
    ";
    ValRandomize = true;
  } READ_MARGIN_ENABLE[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "Hold unused MGM TCAM sweeper in IDLE state";
    ValRandomize = true;
  } TCAM_UPDATE_DIS[11:11] = 1'h0;
  field {
    AccessType = "RW";
    desc = "Disable TCAM error checking (in unused MGM sweeper)";
    ValRandomize = true;
  } TCAM_CHECK_ERR_DIS[10:10] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Enable counting uncorrectable ECC errors from this memory in a
      global counter.
    ";
    ValRandomize = true;
  } U_ECC_COUNT_ENABLE[9:9] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
      Enable counting correctable ECC errors from this memory in a
      global counter.
    ";
    ValRandomize = true;
  } C_ECC_COUNT_ENABLE[8:8] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "Reserved bits";
  } _RSVD0_[7:6] = 2'h0;
  field {
    AccessType = "RW";
    desc = "Mask the interrupt from the memory on ECC Error.";
    ValRandomize = true;
  } MASK_INT[5:5] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Light Sleep Bypass. To bypass a dynamic Light-sleep mode access in
      the memory through the mem_ls_enter signal in the memory shell.
    ";
    ValRandomize = true;
  } LS_BYPASS[4:4] = 1'h1;
  field {
    AccessType = "RW";
    desc = "Light Sleep Force. To force a Light-Sleep mode in the Memory.";
    ValRandomize = true;
  } LS_FORCE[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      ECC debug: inverts the second bit of data to issue an error during
      read access.
    ";
    ValRandomize = true;
  } INVERT_2[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
       ECC debug: inverts the second bit of data to issue an error
       during read access.
    ";
    ValRandomize = true;
  } INVERT_1[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "Enable of the ECC checking correction mechanism.";
    ValRandomize = true;
  } ECC_ENABLE[0:0] = 1'h1;
};

reg shell_ctl_dbg_ctl_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "Indirect read debug control register";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    desc = "Transaction done";
    ValRandomize = true;
  } DONE[31:31] = 1'h0;
  field {
    AccessType = "RW/V";
    desc = "Read enable";
    ValRandomize = true;
  } RD_EN[30:30] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "8-bit DWord select";
  } _RSVD_[29:26] = 4'h0;
  field {
    AccessType = "RW/V";
    desc = "8-bit DWord select";
    ValRandomize = true;
  } DW_SEL[25:18] = 8'h0;
  field {
    AccessType = "RW/V";
    desc = "18-bit indirect address";
    ValRandomize = true;
  } ADDRESS[17:0] = 18'h0;
};

reg shell_ctl_dbg_data_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "Indirect read debug data register";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    desc = "Read data";
    ValRandomize = true;
  } DW_RD[31:0] = 32'h0;
};


#################################################################################
# This file contains ad-hoc connectivity BETWEEN the IPs instantiated as part of
# this subsystem.
#
# It should NOT include connectivity specs to global units such as: clocks/reset,
# power management (pmc/punit), dfx units
#
# See $COLLAGE_ROOT/templates/ad_hoc_connections.txt for syntax
# 
#################################################################################
##################################################################
# Ad hoc connections
##################################################################
#
#
# Syntax for this File
# Any opton given in ?? is optional
#
# 1. Export Pin
# 
#    E <Pin Name> <Port Name>  ?propagate? ?Direction? ?Signal Name? ?Comment? ?Context?
#    Example: E i_m_stap/ftap_tck	   ftap_clk     1      in    ftap_tck   {To Master DfxUnit}
#    Note:    Default behaviour is to export the IP pin all the way to top level. Direction is used when inout 
#    	      IP pin needs to connect to in/out top level pin
#             propagete 0 will export only to next level of hierarchy
#             context will export till given context
#
# 2. Connect Pins
#
#    C <Driver Pin> {<One or more receivers>} ?Signal Name? ?Comment?
#    example: C i_socunit/psf_t0_func_disable_rtic      i_psf/t0_func_disable[0]
#
# 3. Open connection
#
#    O <Pin Name> ?Comment?
# 
# 4. Pattern based Constant connection
# 
#    T <value> <Pin Name Pattern>  ?Comment?  ?constant_format?
#    where <value> can be "zero" or "one" or some constant number (hex format by default) 
#    example: T one unitA/inp[1-0]
#    example: T 0x1 unitA/intB
#    example: T 8'b10000010 unitB/pinx {} {v}
#    
# 5. TCL command evaluation
#
#    V {any valid tcl command, must be fully specified on this line}
# 
# 6. Disconnect
# 
#    D <Pin Name>
#
# 7. Create Port on a hierarchy (default: top level)
# 
#    CP <Port Name> <Direction> ?Dimensions? ?Context?
#    example: CP portA	in {2 0} /parssa
#
# 8. Rename Port
# 
#    R <Hierarchy> <Old Port Name> <New Port Name>
#    example: R	   parsc     abc   xyz
#
# 9. Create connection and port (IP pin driving other internal IP pins and also exported)
#
#    CE <Driver Pin> {<One or more receivers>} <Port Name> ?Comment?
#
# 10. Connect Pins (No driver) Only supported for singleton or complete buses cannot do bit connections
#
#    CNS   {<One or more receivers>} ?Signal Name? ?Comment?
#    example: CNS   {i_socunit/psf_t0_func_disable_rtic      i_psf/t0_func_disable[0]}
#
# 11. Connect Pins (Multiple drivers) Only supported for singleton or complete buses cannot do bit connections
#
#    CMS   {<One or more pins>} 
#    example: CMS   {i_socunit/psf_t0_func_disable_rtic i_psf/t0_func_disable[0] i_cpu/xyz}
#
# 12. Pattern based Connect Pins (Pattern only for pin name not inst/ip name)
#
#    CRn <driver_pin_or_port_name_pattern> <receiver_pin_or_port_name_patter > ?exact_name_match?
#    example: CRn i_socunit/psf*      i_psf/psf*
#    Note: this line would not be supported: CRn i_soc*/psf*      i_ps*/psf*
#    Note: it allows pattern only in pin
#
# 13. Pattern based Connect Pins (Same as CRn but allows index in pin pattern)
#    
#    CRi <driver_pin_or_port_name_pattern with optional index> <driver_pin_or_port_name_pattern with optional index>
#    example: CRi i_socunit/abc[5-0]      i_psf/xyz[5-0]
#    Note: Pattern is only for pin name, no pattern is processed for instance/ip name. 
#    Pin pattern can be followed by index
#
# 14. Pattern based Connect Pins (Pattern only for inst_name and not ip names)
#
#    CRc <Driver InstNamePattern/Pin> <Receiver InstName Pattern/Pin>
#    example: CRc i_socunit/abc     i_psf*/xyz
#    Note: It does not support patterns for Pin name, patterns are only supported for instance names
#
# 15. Connect from Intermediate partition pin to list of receivers
#
#    Ci <Driver Pin> <List of Receivers>
#    example: Ci par_psf/abc     {i_psf0/xyz i_psf1/xyz} 
#
# Note: # at the beginning of the line is a comment line
# 
##################################################################


# Connect all pins with same name between EPC & MPP
#CRn mby_ec_top_{%inst_num}/grp_*     mby_mpp_{%inst_num}/grp_*   exact_name_match
V collage_connect_pins_same_name -iplist {mby_ec_top_{%inst_num} mby_mpp_{%inst_num}}

# used to strap csr start & end values according to:
# mpp0 (start - end) = 32'h2000_0000 - 32'h23FF_FFFF;  // for mgp0  and 1
#    ...
# mpp7 (start - end) = 32'h3C00_0000 - 32'h3FFF_FFFF;  // for mgp14 and 15
V eval {set i [format 0x%x [expr ({%inst_num}<<26)+0x20000000]]} ; {create_connection -constant $i mby_mpp_{%inst_num}/i_mpp_csr_start}
V eval {set i [format 0x%x [expr ({%inst_num}<<26)+0x23FFFFFF]]} ; {create_connection -constant $i mby_mpp_{%inst_num}/i_mpp_csr_end}

# Connect to GMM; connect 1 port to member of struct on another port
##C mby_gmn_0/tag_ring_out_0_0.parity                         mby_mpp_{%inst_num}/
##C mby_gmn_0/tag_ring_out_0_0.mirror
#C mby_gmn_0/tag_ring_out_0_0.dst_tc                         mby_mpp_0/egr0_tagring_if0_0_llt_tc
##C mby_gmn_0/tag_ring_out_0_0.dst_port_id                    mby_mpp_{%inst_num}/egr0_tagring_if0_0_llt_dst  # width mismatch...
#C mby_gmn_0/tag_ring_out_0_0.next_len                       mby_mpp_0/egr0_tagring_if0_0_dqtag_next_len
#C mby_gmn_0/tag_ring_out_0_0.sll                            mby_mpp_0/egr0_tagring_if0_0_dqtag_ssl
#C mby_gmn_0/tag_ring_out_0_0.src_tc                         mby_mpp_0/egr0_tagring_if0_0_dqtag_src_tc
#C mby_gmn_0/tag_ring_out_0_0.src_port_id                    mby_mpp_0/egr0_tagring_if0_0_dqtag_src_port
#C mby_gmn_0/tag_ring_out_0_0.at_egr_rate                    mby_mpp_0/egr0_tagring_if0_0_dqtag_at_egr_rate
#C mby_gmn_0/tag_ring_out_0_0.multi_copy                     mby_mpp_0/egr0_tagring_if0_0_dqtag_multi_copy
#C mby_gmn_0/tag_ring_out_0_0.err_xmd                        mby_mpp_0/egr0_tagring_if0_0_dqtag_err_xmd
#C mby_gmn_0/tag_ring_out_0_0.eop                            mby_mpp_0/egr0_tagring_if0_0_dqtag_eop
#C mby_gmn_0/tag_ring_out_0_0.length                         mby_mpp_0/egr0_tagring_if0_0_dqtag_length
#C mby_gmn_0/tag_ring_out_0_0.ptr_toggle                     mby_mpp_0/egr0_tagring_if0_0_dqtag_ptr_toggle
#C mby_gmn_0/tag_ring_out_0_0.ptr                            mby_mpp_0/egr0_tagring_if0_0_dqtag_ptr
#C mby_gmn_0/tag_ring_out_0_0.valid                          mby_mpp_0/egr0_tagring_if0_0_lltformat_valid 
### can also connect struct type to struct type, if that's how ports are defined
##C mby_gmn_0/tag_ring_out_0_0                                mby_mpp_{%inst_num}/egr0_tag_ring_fromgmn_0_0  

## mpp ports for tagring
#input  logic  [20-1:0]  egr0_tagring_if0_dqtag_ptr,              // Blasted Interface egr_tagring_if.egr egr0_tagring_if0
#input  logic   [4-1:0]  egr0_tagring_if0_dqtag_ptr_toggle,
#input  logic   [8-1:0]  egr0_tagring_if0_dqtag_length,  
#input  logic            egr0_tagring_if0_dqtag_eop,     
#input  logic            egr0_tagring_if0_dqtag_err_xmd, 
#input  logic            egr0_tagring_if0_dqtag_multi_copy,
#input  logic            egr0_tagring_if0_dqtag_at_egr_rate,
#input  logic   [4-1:0]  egr0_tagring_if0_dqtag_src_port,
#input  logic   [3-1:0]  egr0_tagring_if0_dqtag_src_tc,  
#input  logic   [3-1:0]  egr0_tagring_if0_dqtag_ssl,     
#input  logic   [2-1:0]  egr0_tagring_if0_dqtag_next_len,
#input  logic  [16-1:0]  egr0_tagring_if0_llt_dst,       
#input  logic   [4-1:0]  egr0_tagring_if0_llt_tc,        
#input  logic   [9-1:0]  egr0_tagring_if0_llt_mirror_dest1,
#input  logic   [2-1:0]  egr0_tagring_if0_llt_mirror_dest2,
#input  logic  [14-1:0]  egr0_tagring_if0_llt_policer_idx,
#input  logic            egr0_tagring_if0_lltformat_valid,

## GMM struct
#typedef struct packed {
#   logic [MBY_TAG_RING_PARITY_MSB:0]    parity;   
#   logic [MBY_TAG_RING_RSVRD_MSB:0]     rsvrd;
#   logic                                mirror;
#   logic [MBY_TAG_TX_TC_MSB:0]          dst_tc;
#   logic [MBY_TAG_TX_PORT_MSB:0]        dst_port_id;
#   logic [MBY_TAG_NEXT_LEN_MSB:0]       next_len;      
#   logic [MBY_TAG_SLL_MSB:0]            sll;
#   logic [MBY_TAG_RX_TC_MSB:0]          src_tc;                
#   logic [MBY_PORTID_IN_MGP_MSB:0]      src_port_id;
#   logic                                at_egr_rate; 
#   logic                                multi_copy;
#   logic                                err_xmd; 
#   logic                                eop;            // End-of_packet
#   logic [MBY_TAG_LENGTH_MSB:0]         length;         // length of packets data in this segment in bytes
#   logic [MBY_SEG_PTR_TOGGLE_MSB:0]     ptr_toggle;     // Semaphore for 4 64B words
#   logic [MBY_SEG_PTR_MSB:0]            ptr;            // Segment Pointer
#   logic                                valid;          // Valid
#} mby_tag_ring_t;   


### Write ports
## WB MPPs (4 MPPs)
# MPP0
# mim 0a
### WIP
#C mby_msh_0/o_igr_{%mpp_msh_side}_wreq_credits[{%mpp_msh_row_indx}][0]        mby_mpp_{%inst_num}/i_mim0_wreq_credits_w0   
#C mby_msh_0/o_igr_{%mpp_msh_side}_wreq_credits[{%mpp_msh_row_indx}][1]        mby_mpp_{%inst_num}/i_mim0_wreq_credits_w1   
#C mby_msh_0/o_igr_{%mpp_msh_side}_wb_wreq_credits[{%mpp_msh_row_indx}][2]     mby_mpp_{%inst_num}/i_mim0_wreq_credits_w2   


##############################################################################
# Local Variables:
# mode: tcl
# End:

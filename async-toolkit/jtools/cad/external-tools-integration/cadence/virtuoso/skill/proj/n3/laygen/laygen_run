#!/usr/intel/bin/perl -w

my $LAYGENWARD="$ENV{LAYGENWARD}";
my $COLLATERAL="$LAYGENWARD/collateral/arch/e08";
my $placements=1;
my $height=1;
my $width="min";
my $allow_opens=0;

while (@ARGV && $ARGV[0] =~ /^--(\S+)=(\S+)/) {
    if    ($1 eq "width") { $width=$2; }
    elsif ($1 eq "height") { $height=$2; }
    elsif ($1 eq "placements") { $placements=$2; }
    elsif ($1 eq "allow-opens") { $allow_opens=$2; }
    else { last; }
    shift;
}

(@ARGV>=1) or die "USAGE: laygen_run [--width=w] [--height=h] fqcn [e08name]\n";
my $cell=$ARGV[0];
my $e08=$cell;
if (@ARGV>1) {
    $e08=$ARGV[1];
    if ($e08 =~ /d(....)$/) { $height=2; } # E08 naming convention
}

my $lsf =
    "set_architecture_file $COLLATERAL/e08.arch\n" .
    "set_rpg_file $COLLATERAL/e08_rpg_all.txt\n" .
    "set_tcl_container_file $COLLATERAL/e08_container.tcl\n" .
    "set_option layer_file $COLLATERAL/e08.layer\n" .
    "set_option fabric e08\n" .
    "set_option use_assumptions yes\n" .
    "set_option max_num_cores 1\n" .
    "set_log_level status";

my $place="";
if (-e "${e08}.place") {
    $place="set_option option {Option name=manual_placement_file value=../${e08}.place}";
}

my $rundir="${cell}.run";
my $lgf="$e08.lgf";
system("mkdir -p $rundir");
chdir($rundir);
system("$ENV{FULCRUM} graph_netlist --format=eps " .
       "--cast-path=$ENV{CAST_PATH} --include-all $cell");
system("$ENV{FULCRUM} cast2cdl " .
       "--process-dependent-name --cdl-mos-parameters=m " .
       "--cast-path=$ENV{CAST_PATH} --cadence-name " .
       "--cell=$cell --output=hier.cdl");
system("$ENV{FULCRUM} inliner --flatten " .
       "--cdl=hier.cdl --library=hier.cdl > flat.cdl");
system("$ENV{FULCRUM} cdl2lgf " .
       "--length 20e-9 --gridW 34e-9 --maxNmosW 102e-9 --maxPmosW 102e-9 " .
       "$cell flat.cdl $lgf");

# place
print "PLACE: $lgf\n";
open OUT, ">place.lsh" or die;
print OUT <<EOF;
$lsf
$place
set_option placement_result_idx $placements
set_option generate_snp yes
set_option run_hazel_placement_engine 1
set_option placement_effort 1
set_option target_area $width
set_option target_height $height
set_option option {Option name=plan_device_y value=1 push_out=0 push_devices_to_default=1,0}
set_option option {Option name=max_y value=3,2}
set_option route no
set_netlist $lgf
run_main
exit
EOF
system("$LAYGENWARD/bin/laygen_shell -nogui -file place.lsh >& place.log");

# route all placements
my @files = split("\n",`ls out/*.lgf`);
foreach my $place_lgf (@files) {
    # detect internal nets and nets that are transitor gates
    my %internal;
    my %transistor_gate;
    open LGF, "<$place_lgf" or die;
    while (my $line=<LGF>) {
        if ($line =~ /^Nets type=Internal \[\s+(.*)\s+\]/) {
            foreach my $net (sort(split(" ",$1))) {
                $internal{$net}=1;
            }
        }
        elsif ($line =~ /^Device \S+ nets=\[ (\S+) (\S+) (\S+) (\S+) \] type=(\S+)/) {
            $transistor_gate{$2}=1;
        }
    }
    close LGF;

    # restrict m2 routing of internal nets
    my $internal_m2="";
    foreach my $net (sort keys %internal) {
        my $priority=1;
        $priority=2 if (defined($transistor_gate{$net}));
        $internal_m2 .= "set_option option {Option name=control_net_tracks " .
            "action=at_most target=0 net=\"$net\" priority=$priority layer=metal2}\n";
    }

    # route
    my $routedir=$place_lgf;
    $routedir =~ s/\.lgf//;
    print "ROUTE: $routedir\n";
    system("mkdir $routedir");
    open OUT, ">$routedir/route.lsh" or die;
    print OUT <<EOF;
$lsf
set_option option {Option name=undesired_pattern_report_filename value=undesired_patterns.txt}
set_option option {Option name=dump_final_rpg_file value=0}
set_option option {Option name=show_invisible_layout value=0}
set_option option {Option name=eliminate_undesired_subties value=0}
set_option option {Option name=allow_opens value=$allow_opens}
$internal_m2
set_option upperlayer m2
set_option route yes
set_netlist ../../$place_lgf
run_main
exit
EOF
    close OUT;
    system("cd $routedir; nbq -j route.log $LAYGENWARD/bin/laygen_shell " . 
               "-nogui -file route.lsh");
}


############################ MAPPER REGISTER SET ##########################
#

--addressBase           0x000000
--addressBits           19
--atomic                64
--addressing            fullalign 
--space                 MSG       
--opcode                MEM-SB    
--No_IOSF_Primary       true      
--resetDomains          SWITCH,MGMT    

-set hlp_MAPPER  Mapper Register Set



###############################################################################
# INGRESS STAGE

-register MAP_PORT_CFG[0..23] Mapper configuration per port

  >PG HLP_PG1
  +DEFAULT_SGLORT:16:RW:0
    default SGLORT value, used if default_sglort_en is set.
  +DEFAULT_SGLORT_EN:1:RW:0
    overwrite the SGLORT parser key (after the IP rearrange step creates space).
  +PORT_SCENARIO:4:RW:0
    Bits to feed into scenario CAM.


-register MAP_PORT_DEFAULT[0..23,0..5] Default parse keys per port
  For each packet, 6 entries are used:
  .  MAP_PORT_DEFAULT[port][0..5]

  Apply the defaults in the following order:

  * For target field less than 96, set key_valid for keys modified by the value field.
  * Copy dscp/vpri/vid to actions, overriding the default values inserted above for keys_valid
  * Insert the rest of default targets in 96..191.

  >PG HLP_PG1
  +USE_PARSE_PTR:1:RW:0
    If use_parse_ptr is set, then the value to use for
    MAP_PORT_DEFAULT[port][i] is parse_result.ptr[i*2 : i*2+1].
    ptr[i] is MSB and ptr[i+1] is LSB. The parser provides ptrs[7:1], set ptrs[0]=0.

    This field is only used when the second index is 0..3.

  +VALUE:16:RW:0
    The immediate value to use if !use_parse_ptr && (use_key == 255).

  +USE_KEY:8:RW:0
    If use_key[i] is <255, then replace value[i] with keys[use_key[i]].

    This is needed to enable the FFU to provide key bits directly into
    mod_meta or other actions. It also removes the need for a
    reverse-remap feature in FFU.

    This field is only used when the second index is 0..1.

  +TARGET:8:RW:ff
    target indicates where to put the value.

    * 0..79 = keys (if not already valid)
    * 80..95 = force into key 12..27 (ignore validity from parser)
    * 96..191 = initial FFU actions.
    * 96..111 = act24 lower 16
    * 112..127 = act24 upper 8   (act24[target-112][23:16] = value[7:0])
    * 128..159 = act4, 4 consecutive nybbles. Must be a multiple of 4.
    * 160..191 = act4, 2 consecutive nybbles. Must be a multiple of 2.
    * 192..223 = act4, 1 nybble
    * 224 = set flags[15:0]
    * 225..254 = reserved
    * 255 = NOP (discard the value)


-register MAP_DGLORT_TCAM[0..7] Default DGLORT Assignment
     
  The (MAP_DGLORT_*) registers describe how to convert the
  21-bit key:
  .  {lan_dest_port, dsi_dest_port, onpi_type}
  into a 16-bit default DGLORT.  The match semantics are identical to that of the FFU_TCAM.

  >PG HLP_PG1
   +KEY_INVERT:21:RW:1ffff
      select which bits to compare
   +KEY:21:RW:1ffff
      bits to be compared against the key from packet metadata


-register MAP_DGLORT_ACTION[0..7] Default DGLORT Assignment

  The (MAP_DGLORT_*) registers describe how to convert the
  21-bit key:
  .  {lan_dest_port, dsi_dest_port, onpi_type}
  into a 16-bit default DGLORT.

  MAP_DGLORT_ACTION[i] is used when MAP_DGLORT_KEY[i] is the highest-numbered hit.
  The DGLORT used is
   .    base | rotate(key, rot) & mask_gen(start, len)
  Wherein
   .    rotate(key, rot) == (key << rot) | (key >> (32-rot))
   .    mask_gen(start, len)[j] is set if j>=start and j < start+len

  >PG HLP_PG1
   +ENABLE:1:RW:0
      Enable default dglort.
      The default dglort will overwrite the DGLORT parser key
      (after the IP rearrange step creates space,
       and after PORT_DEFAULT has potentially assigned a default value).
   +ROT:5:RW:0
      the key is padded to 32 bits and then rotated left by rot, and then the 16 lsbs are used.
   +START:4:RW:0
      first bit to insert into dglort
   +LENGTH:5:RW:0
      number of bits to insert into dglort
   +BASE:16:RW:0
      constant to be ORed in with selected, rotated key bits


-register MAP_CPM_FN  Enable CPM Ingress ONPI function per port.
  >PG HLP_PG1
  +PORT_MASK:24:RW:0
    Bit i is set if the CPM Ingress ONPI function is enabled on port i.
    When this function is enabled, and the ESP_VALID parser flag is set,
    the IP and ESP header header offsets are written into ONPI metadata.

-register MAP_LEN_LIMIT[0..23] parser_info length limits
    Indexed by logical rx port. This register controls how many 4B tags (or labels)
    Modify can add versus how many can be removed.
  >PG HLP_PG1
    +OTR_L2_LEN_LIMIT:3:RW:0
      Outer L2 length limit. The datapath is unable to pop more than otr_l2_len_limit outer L2 tags,
      or to push more than (4-otr_l2_len_limit) outer L2 tags.
    +INR_L2_LEN_LIMIT:3:RW:0
      Inner L2 length limit. The datapath is unable to pop more than inr_l2_len_limit inner L2 tags,
      or to push more than (4-inr_l2_len_limit) inner L2 tags.
    +OTR_MPLS_LEN_LIMIT:3:RW:0
      Outer MPLS length limit. The datapath is unable to pop more than otr_mpls_len_limit outer
      MPLS labels, or to push more than (7-otr_mpls_len_limit) outer MPLS labels.
    +INR_MPLS_LEN_LIMIT:3:RW:0
      Inner MPLS length limit. The datapath is unable to pop more than inr_mpls_len_limit inner
      MPLS labels, or to push more than (7-inr_mpls_len_limit) inner MPLS labels.


-register MAP_DOMAIN_TCAM[0..4095] Domain mapper TCAM entries

   Configures an entry in the TCAM. 
    
    A match occurs when the data searched is equal to the content, as defined
    in the table below.

    A key is loaded by writing the key into 'Key' (KEY / KEY_TOP) and loading its 1s
    compliment in KeyInvert (KEY_INVERT / KEY_TOP_INVERT). Writing both 'Key' and 'KeyInvert' with 1
    on same bit in both fields will invalidate the entry while writing
    0 on same bit in both field is equivalent of ignoring this bit in
    the seach.
 
    The table below shows the encoded data value stored (Content)
    based on the Key and KeyInvert values.

          .+-----------------------------------------------------+
          .| KeyInvert    | Key          |        Content        |
          .=======================================================
          .|      0       |      0       |   X (always match)    |
          .+-----------------------------------------------------+
          .|      0       |      1       |           1           |
          .+-----------------------------------------------------+
          .|      1       |      0       |           0           |
          .+-----------------------------------------------------+
          .|      1       |      1       | Always mismatch state |
          .+-----------------------------------------------------+

    The highest index has precedence in case there is more than one match.
    
    Note, when performing the match function, in addition to the main fields and their corresponding 
    invert ones, _RSVD0_ and _RSVD1_ fields are partially used in hit generation. To make the hit independent of them,
    those RSVD bits should be programmed to zero (always match) so they do not affect the hit. Those bits are 
    bits 39..34 (6 bits in _RSVD0_) and bits 103..98 (6 bits in _RSVD1_) which should all be programmed to zero. 
    This assures the match is not dependent on _RSVD0_ and _RSVD1_ fields. 
    
    
  >PG HLP_PG1
    +_RSVD1_:30:RV:0
      Reserved
    +PORT_KEY_INVERT:8:RW:ff
      Inverted ingress port number
    +VID2_VALID_INVERT:1:RW:1
      Inverted validity for outer VLAN2
    +VID2_KEY_INVERT:12:RW:fff
      Inverted outer VLAN2
    +VID1_VALID_INVERT:1:RW:1
      Inverted validity for outer VLAN1
    +VID1_KEY_INVERT:12:RW:fff
      Inverted outer VLAN1
    +_RSVD0_:30:RV:0
      Reserved
    +PORT_KEY:8:RW:ff
      Ingress port number
    +VID2_VALID:1:RW:1
      Valid state for outer VLAN2
    +VID2_KEY:12:RW:fff
      Outer VLAN2
    +VID1_VALID:1:RW:1
      Valid state for outer VLAN1
    +VID1_KEY:12:RW:fff
      Outer VLAN1


###############################################################################
# MAP_SCALAR STAGE


-register MAP_DOMAIN_ACTION0[0..4095] Dommain mapper Action entries
  >PG HLP_PG1
  +L2_DOMAIN:9:RW:0
     An L2 domain value used downstream. Used when update_domains=1.
  +L3_DOMAIN:6:RW:0
     An L3 domain value used downstream. Used when update_domains=1.
  +OPERATOR_ID:4:RW:0
     A network addressing domain or operator ID. Used when update_domains=1.
  +UPDATE_DOMAINS:1:RW:0
    When set, use the domains, priority_profile, and operator_id from the action,
    and write the domain and operator_id fields into the packet's ONPI metadata.

    If update_domains=0, then use the l2_domain, l3_domain, and operator_id fields
    received in the packet's ONPI metadata. Do not overwrite those fields. And use
    the priority_profile retrieved from MAP_DOMAIN_PROFILE instead.
  +LEARN_EN:1:RW:0
     Learning enable/disable.
     This is used as the default value for the FFU 'LEARN' action.
  +LEARN_MODE:1:RW:0
     Select shared(0) or independent(1) VLAN learning.
  +PRIORITY_PROFILE:5:RW:0
     A profile index for remapping ingress priorities. Used when update_domains=1.
  +PRI_SOURCE:8:RW:0
     Defines TC precedence sources

     pri_source[7:6] = highest precedence TC source ID

     pri_source[1:0] = lowest precedence TC source  ID
  +FORCE_DEFAULT_PRI:1:RW:0
    Force 3b DEFAULT_PRI as the default TC value, overriding all
    precedence sources
  +DEFAULT_PRI:3:RW:0
    default TC value, used if none of the precedence sources are present
    and metadata does not provide TC

-register MAP_DOMAIN_ACTION1[0..4095] Dommain mapper Action entries
  >PG HLP_PG1
  +DOMAIN_SCENARIO:8:RW:0
     Bits to feed into scenario CAM.
  +L2_POLICER:12:RW:0
     A policer index associated with the L2 domain.
     If l2_policer is nonzero, then the default POLICER[0] action is (bank=0, index=l2_policer).
  +L3_POLICER:12:RW:0
     A policer index associated with the L3 domain.
     If l3_policer is nonzero, then the default POLICER[1] action is (bank=5, index=l3_policer).
  +VLAN_COUNTER:12:RW:0
     A VLAN counter index indicating the VLAN counter to be used for counting RX stats on this tuple.


-register MAP_DOMAIN_PROFILE[0..511] Priority Profile to use when DOMAIN_ACTION[].UpdateDomains=0.
  Indexed by l2_domain.
  >PG HLP_PG1
  +PRIORITY_PROFILE:5:RW:0
     A profile index for remapping ingress priorities.
     Used when DOMAIN_ACTION[].update_domains=0.


-register MAP_PORT[0..23] Configures source port to 4-bit mapping
  >PG HLP_PG1
    +MAP_PORT:4:RW:0
        Resulting MAP_PORT per source port


--atomic 128
-register MAP_MAC[0..95] Configures 48-bit to 4-bit MAC address mapping
  >PG HLP_PG1
    +MAC_ROUTABLE:1:RW:0
        Is this a virtual router destination MAC?
    +MAP_MAC:8:RW:0
        8-bit mapped MAC
    +VALID:4:RW:0
        * bit 0 = entry valid for outer DMAC
        * bit 1 = entry valid for outer SMAC
        * bit 2 = entry valid for inner DMAC
        * bit 3 = entry valid for inner SMAC
    +IGNORE_LENGTH:6:RW:0
        Ignore this many LSB bits when matching
    +MAC:48:RW:0
        Ethernet MAC Key. Ignored bits must be set to 0. 


--atomic 64
-register MAP_TYPE[0..15] Configures 16-bit to 4-bit EtherType mapping
  >PG HLP_PG1
    +VALID:2:RW:0
        bit 0 = valid for outer L2 header
        bit 1 = valid for inner L2 header
    +MAP_TYPE:4:RW:0
        4-bit mapped EtherType
    +TYPE_XXX:16:RW:0
        EtherType Key


-register MAP_IP_LO[0..15] Configures low 64-bit key of 128-bit to 4-bit IP address mapping
  >PG HLP_PG1
    +IP_LO:64:RW:0
        Low 64 bits of IP address prefix key.  Ignored bits must be set to 0.


-register MAP_IP_HI[0..15] Configures high 64-bit key of 128-bit to 4-bit IP address mapping
  >PG HLP_PG1
    +IP_HI:64:RW:0
        High 64 bits of IP address prefix key.  Ignored bits must be set to 0.


-register MAP_IP_CFG[0..15] Configures 128-bit to 4-bit IP address mapping
  >PG HLP_PG1
    +MATCH_LENGTH:8:RW:0
        Indicates the number of most-significant bits of the IP address to match on.  For
        IPv6 addresses, the the match for entry i is against { MAP_IP_HI[i], MAP_IP_LO[i] }.
        and MATCH_LENGTH is in the range 0..128.  For IPv4 addresses, the match for entry i
        is against MAP_IP_HI[i][63:32] and MATCH_LENGTH is in the range 0..32.
    +VALID:4:RW:0
        * bit 0 = entry valid for outer DIP
        * bit 1 = entry valid for outer SIP
        * bit 2 = entry valid for inner DIP
        * bit 3 = entry valid for inner SIP
    +MAP_IP:4:RW:0
        4-bit mapped IP address
    +IP_SCENARIO:2:RW:0
        2-bit value to feed into scenario CAM
    +IS_IPV6:1:RW:0
        * If set, header must be ipv6 to match.
        * If clear, header must be ipv4 to match.


-register MAP_PROT[0..7] Configures 8-bit to 3-bit L4 Protocol mapping
    The same mapping is used for both inner and outer PROT.
  >PG HLP_PG1
    +MAP_PROT:3:RW:0
        3-bit mapped IP protocol number
    +PROT:8:RW:0
        Input IP protocol number


-register MAP_L4_SRC[0..63] Configures 16-bit to 4-bit L4 source port mapping
  >PG HLP_PG1
    +MAP_L4_SRC:16:RW:0
        Mapped result
    +VALID:2:RW:0
        * bit 0 = this entry valid for outer L4_src
        * bit 1 = this entry valid for inner L4_src
    +MAP_PROT:3:RW:0
        3-bit MAP_PROT key that must match to enable this entry
    +L4_SRC:16:RW:0
        L4 source port key


-register MAP_L4_DST[0..63] Configures 16-bit to 4-bit L4 destination port mapping
  >PG HLP_PG1
    +MAP_L4_DST:16:RW:0
        Mapped result
    +VALID:2:RW:0
        * bit 0 = this entry valid for outer L4_dst
        * bit 1 = this entry valid for inner L4_dst
    +MAP_PROT:3:RW:0
        3-bit MAP_PROT key that must match to enable this entry
    +L4_DST:16:RW:0
        L4 destination port key


###############################################################################
# MAP_SCENARIO STAGE


-register MAP_EXP_TC[0..31]   Maps EXP to TC
    Indexed by 5-bit priority_profile.Refer to QoS Chapter Priority Management for programming guide.
    One field for each possible ingress EXP value.

  >PG HLP_PG1
    +TC[7..0]:3:RW:0
        TC to set for this EXP.


-register MAP_DSCP_TC[0..2047]  Maps ingress DSCP to TC and DSCP
    Indexed by {priority_profile[4:0], dscp[5:0]}. Refer to QoS Chapter Priority Management for programming guide.

  >PG HLP_PG1
    +TC:3:RW:0
        TC to set for this ingress DSCP
    +DSCP:6:RW:0
        internal DSCP to set for this ingress DSCP


-register MAP_VPRI_TC[0..31]   Maps ingress VPRI to TC
    Indexed by 5-bit priority_profile. Refer to QoS Chapter Priority Management for programming guide.
    One field for each possible ingress VPRI value.

  >PG HLP_PG1
    +TC[15..0]:3:RW:0
        Defines the TC associated with this ingress VPRI.


-register MAP_VPRI[0..31]  Maps ingress VPRI to internal VPRI
    Indexed by 5-bit priority_profile.
    One field for each possible ingress VPRI value.

  >PG HLP_PG1
    +VPRI[15..0]:4:RW:0
        Defines the internal VPRI associated with this ingress VPRI.


-register MAP_SCEN_KEY0[0..95] Scenario CAM key value 0 
  Scenario KEY0 is parser flags.
  This register provides the key values to compare against. The same format is used for key and key invert. 

  The semantic is identical to that used in the FFU_TCAM register.

  The MAP_SCEN_ACTION having the same index as the highest-numbered matching key is used. 

  >PG HLP_PG1
  +PTRS_ERR:1:RW:1
   An error occured in pointer calculation for parser_info, indicating a header length is too small. 
   ptrs_err=0 in windowed parsing mode.
  +EX:3:RW:7
        ex[2]=depth_exceed, ex[1]=trunc_header, ex[0]=parsing_done
  +CSUM:2:RW:3
  	For non-IPv4 packets, both of these bits are 1.  For IPv4 packets, these bits indicate
    the validity of the IP header checksum field:
       * csum[0] indicates if the outer IP header checksum is valid
       * csum[1] indicates if the inner IP header checksum is valid
  +IP_IS_V6:2:RW:3
	   * ip_is_v6[0] = is_v6(outer_ip)
       * ip_is_v6[1] = is_v6(inner_ip)
  +IP_FITS:2:RW:3
      These bits indicate whether modifications are possible beyond the outer or inner IP header.
      Also, if the L4 header is UDP or TCP, then ip_fits must be set to allow a NAT operation.
       * ip_fits[0] = otr_l4_v && otr_l3_v && (otr_l4_ptr - otr_l3_ptr <= 56)
       * ip_fits[1] = inr_l4_v && inr_l3_v && (inr_l4_ptr - inr_l3_ptr <= 56)
  +IHL_OK:1:RW:1
     Indicates that the IHL is at least 5 or the packet is not IPv4.
  +IHL_FITS:1:RW:1
     Indicates that the payload length is at least 4*IHL, or the packet is
     not IPv4.
  +FLAGS:47:RW:7fffffffffff
     parser flags 47..1
  +RSVD:1:RW:1
     Reserved. Set to 0. Parser flag 0 is not used.


-register MAP_SCEN_KEY_INVERT0[0..95] Scenario CAM key invert 0
  Scenario KEY0 is parser flags.
  This register selects which key bits to compare. The same format is used for key and key invert. 

  The semantic is identical to that used in the FFU_TCAM register.

  The MAP_SCEN_ACTION having the same index as the highest-numbered matching key is used. 

  >PG HLP_PG1
  +PTRS_ERR:1:RW:1
   An error occured in pointer calculation for parser_info, indicating a header length too small 
   or not having the expected residue mod 4. ptrs_err=0 in windowed parsing mode.
  +EX:3:RW:7
        ex[2]=depth_exceed, ex[1]=trunc_header, ex[0]=parsing_done
  +CSUM:2:RW:3
  	parser IPv4 checksum results
  +IP_IS_V6:2:RW:3
	* ip_is_v6[0] = is_v6(outer_ip)
        * ip_is_v6[1] = is_v6(inner_ip)
  +IP_FITS:2:RW:3
      These bits indicate whether modifications are possible beyond the outer or inner IP header.
      Also, if the L4 header is UDP or TCP, then ip_fits must be set to allow a NAT operation.
       * ip_fits[0] = otr_l3_v && (otr_l4_ptr - otr_l3_ptr <= 56)
       * ip_fits[1] = inr_l3_v && (inr_l4_ptr - inr_l3_ptr <= 56)
  +IHL_OK:1:RW:1
     Indicates that the IHL is at least 5 or the packet is not IPv4.
  +IHL_FITS:1:RW:1
     Indicates that the payload length is at least 4*IHL, or the packet is
     not IPv4.
  +FLAGS:47:RW:7fffffffffff
     parser flags 47..1
  +RSVD:1:RW:1
     Reserved. Set to 0. Parser flag 0 is not used.


-register MAP_SCEN_KEY1[0..95] Scenario CAM key value 1 
  Scenario KEY1 is metadata/mapping.
  This register provides the key values to compare against. The same format is used for key and key invert. 

  The semantic is identical to that used in the FFU_TCAM register.

  The MAP_SCEN_ACTION having the same index as the highest-numbered matching key is used. 

  >PG HLP_PG1
  +METADATA_TYPE:8:RW:ff
     . pkt_meta.c.typ
  +METADATA_FLAGS:11:RW:7ff
     * pkt_meta.dsi_rx_hlp_cpm.flags (if pkt_meta.c.typ == DSI_RX)
     * pkt_meta.dsi_tx_hlp_cpm.flags (if pkt_meta.c.typ == DSI_TX)
     * 0 (otherwise)
  +L2_DOMAIN:9:RW:1ff
     . pkt_meta.c.l2_domain
     May have been changed by MAP_DOMAIN_ACTION0.
  +L3_DOMAIN:6:RW:3f
     . pkt_meta.c.l3_domain
     May have been changed by MAP_DOMAIN_ACTION0.
  +IP_SCENARIO:8:RW:ff
     * ip[1:0] = MAP(outer SIP).scenario
     * ip[3:2] = MAP(outer DIP).scenario
     * ip[5:4] = MAP(inner SIP).scenario
     * ip[7:6] = MAP(inner DIP).scenario
  +PORT_SCENARIO:4:RW:f
     4 bits from MAP_PORT_CFG
  +DOMAIN_SCENARIO:8:RW:ff
     8 bits from MAP_DOMAIN_ACTION
  +MAC_ROUTABLE:4:RW:f
     * mac_routable[0] = outer DMAC routable
     * mac_routable[1] = outer SMAC routable
     * mac_routable[2] = inner DMAC routable
     * mac_routable[3] = inner SMAC routable
  +MAC_MBCAST:2:RW:3
     * mac_mbcast[0] = outer DMAC multicast bit set
     * mac_mbcast[1] = outer DMAC is broadcast address


-register MAP_SCEN_KEY_INVERT1[0..95] Scenario CAM key invert 1
  Scenario KEY1 is metadata/mapping.
  This register selects which key bits to compare. The same format is used for key and key invert. 

  The semantic is identical to that used in the FFU_TCAM register.

  The MAP_SCEN_ACTION having the same index as the highest-numbered matching key is used. 

  >PG HLP_PG1
  +METADATA_TYPE:8:RW:ff
     . pkt_meta.c.typ
  +METADATA_FLAGS:11:RW:7ff
     * pkt_meta.dsi_rx_hlp_cpm.flags (if pkt_meta.c.typ == DSI_RX)
     * pkt_meta.dsi_tx_hlp_cpm.flags (if pkt_meta.c.typ == DSI_TX)
     * 0 (otherwise)
  +L2_DOMAIN:9:RW:1ff
     . pkt_meta.c.l2_domain
     May have been changed by MAP_DOMAIN_ACTION0.
  +L3_DOMAIN:6:RW:3f
     . pkt_meta.c.l3_domain
     May have been changed by MAP_DOMAIN_ACTION0.
  +IP_SCENARIO:8:RW:ff
     * ip[1:0] = MAP(outer SIP).scenario
     * ip[3:2] = MAP(outer DIP).scenario
     * ip[5:4] = MAP(inner SIP).scenario
     * ip[7:6] = MAP(inner DIP).scenario
  +PORT_SCENARIO:4:RW:f
     4 bits from MAP_PORT_CFG
  +DOMAIN_SCENARIO:8:RW:ff
     8 bits from port configuration
  +MAC_ROUTABLE:4:RW:f
     * mac_routable[0] = outer DMAC routable
     * mac_routable[1] = outer SMAC routable
     * mac_routable[2] = inner DMAC routable
     * mac_routable[3] = inner SMAC routable
  +MAC_MBCAST:2:RW:3
     * mac_mbcast[0] = outer DMAC multicast bit set
     * mac_mbcast[1] = outer DMAC is broadcast address



-register MAP_SCEN_ACTION[0..95] Scenario action value
  The scenario mapper is used for three functions:

  * For scenario and key-rewrite generation the mapper produces a scenario value and key rewrite profile, based on the highest matching rule that has scenario_valid=1
  * For trigger ID generation, the mapper produces a downstream trigger ID value, based on the higest matching rule that has trig_valid=1
  * For priority profile selection, the mapper provides input as to how VPRI and DSCP are remapped, based on the highest matching rule that has prios_valid=1

  An entry may have multiple valid bits set, allowing the entry to participate in more than one resolution (and thus produce more then one set of outputs).  For example a rule may generate both scenario and a trigger ID.  

  >PG HLP_PG1
  +SCENARIO_VALID:1:RW:0
    When scenario_valid is set, this rule participates in MAP_SCEN_ACTION scenario resolution.
    The scenario and MAP_REWRITE values for the highest-numbered matching rule
    having scenario_valid are used.

  +SCENARIO:6:RW:0
    Initial scenario value for FFU

  +REWRITE_PROFILE:4:RW:0
    When scenario_valid is set, this field selects which profile in MAP_REWRITE to use.

  +TRIG_VALID:1:RW:0
    When trig_valid is set, this rule participates in MAP_SCEN_ACTION triggers resolution.
    The scen_trig value, parser_error, and ip_options_mask for the highest-numbered matching rule
    having trig_valid are used.

  +SCEN_TRIG:8:RW:0
    Default triggers value to use.
    (for handling DHCP/BOOTP/ARP/ICMP, tagging violation, parse error, etc.)

  +PARSER_ERROR:1:RW:0
    Generate a parser_error action in Fwd, which will drop the packet.
    parser_error is logged in RX_STATS bank 2, bin 3.

  +IP_OPTIONS_MASK:7:RW:0
    Mask to select which parser flags will generate TRAP_IP_OPTIONS.
    The formula is as follows, where :
      // otr_opt_flags[6] = IPv4 case
      // otr_opt_flags[5:0] from parser.
      // inr_opt_flags[6] = IPv4 case
      // inr_opt_flags[5:0] from parser.
      * otr_opt_flags = {otr_l3_v && !otr_v6 && otr_l3_len > 20, parser_flags[37:32]}                      
      * inr_opt_flags = {inr_l3_v && !inr_v6 && inr_l3_len > 20, parser_flags[43:38]}                    
      * ip_options[0] = |(ip_options_mask & otr_opt_flags)
      * ip_options[1] = |(ip_options_mask & inr_opt_flags)

    Finally trap_ip_options = ip_options[mod_idx.decap]

  +PRIOS_VALID:1:RW:0
    When prios_valid is set, this rule participates in MAP_SCEN_ACTION priority resolution.
    The vpri_tgt and dscp_tgt for the highest-numbered matching rule having prios_valid are used.

   +VPRI_TGT:3:RW:0
     Bit vector selecting which VPRIs to apply the p=priority_profile translation to.

     If bit 0 is set:
     *   key16[OUTER_VLAN1].vpri = MAP_VPRI[p, key16[OUTER_VLAN1].vpri] 

     If bit 1 is set:
     *   key16[INNER_VLAN1].vpri = MAP_VPRI[p, key16[INNER_VLAN1].vpri] 

     If bit 2 is set:
     *   act4[VPRI0] = act4[VPRI1] = MAP_VPRI[p, key16[OUTER_VLAN1].vpri] 

     vpri_tgt takes precedence over key rewrite in the case of conflict.  Multiple bits may be set.

   +DSCP_TGT:3:RW:0
     Bit vector selecting which DSCPs to apply the p=priority_profile translation to.

     If bit 0 is set:
     *    key8[OUTER_DS].vpri = MAP_DSCP_TC[p, key8 [OUTER_DS].dscp].dscp

     If bit 1 is set:
     *   key8 [INNER_DS].dscp = MAP_DSCP_TC[p, key8 [INNER_DS].dscp].dscp

     If bit 2 is set:
     *   act4[DSCP_HI:DSCP_LO] = MAP_DSCP_TC[p, key8 [OUTER_DS].dscp].dscp

     dscp_tgt takes precedence over key rewrite in the case of conflict.  Multiple bits may be set.


-register MAP_DOMAIN_POL_CFG  Provides the per-color linked-counter configuration for domain TCAM assigned policers.
  >PG HLP_PG1
  +L3_COLOR_CFG:3:RW:0
    Provides the G/Y/R linked-counter enables for the policer command associated with the L3 policer output of
    MAP_DOMAIN_ACTION1.
  +L2_COLOR_CFG:3:RW:0
    Provides the G/Y/R linked-counter enables for the policer command associated with the L2 policer output of
    MAP_DOMAIN_ACTION1.

-register MAP_REWRITE[0..15][0..31] Key rewrite selector
  This register is indexed by the output of the rewrite_profile output of the scenario CAM.rule number, 
  and by target nybble.
  >PG HLP_PG1
  +SRC_ID:6:RW:0
     Select which rewrite source nybble to use for this target nybble.
     If src_id=0, then do not rewrite the target nybble (leave as received from parser).

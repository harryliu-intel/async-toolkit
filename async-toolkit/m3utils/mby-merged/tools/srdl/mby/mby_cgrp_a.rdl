// DO NOT EDIT. Generated by reg2rdl hlp_fghash.reg.

<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

reg lpm_key_sel0_r {
  shared;
  HandCoded = true;
  name = "Key select for LPM";
  desc = "
        Selects the bytes of key for the LPM lookup.  Indexed by profile ID.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Selects which of the KEY16 fields to use for the metadata portion of the LPM key.
           ";
    ValRandomize = true;
  } MD_KEY16_MASK[63:0] = 64'h0;
};

reg lpm_key_sel1_r {
  shared;
  HandCoded = true;
  name = "Key select for LPM";
  desc = "
        Selects the bytes of key for the LPM lookup.  Indexed by profile ID.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Selects which of the KEY8 fields to use for the address portion of the LPM key.
           ";
    ValRandomize = true;
  } ADDR_KEY8_MASK[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "
    Selects which of the KEY8 fields to use for the metadata portion of the LPM key.
           ";
    ValRandomize = true;
  } MD_KEY8_MASK[31:0] = 32'h0;
};

reg lpm_key_sel2_r {
  shared;
  HandCoded = true;
  name = "Key select for LPM";
  desc = "
        Selects the bytes of key for the LPM lookup.  Indexed by profile ID.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Selects which of the KEY16 fields to use for the address portion of the LPM key.
           ";
    ValRandomize = true;
  } ADDR_KEY16_MASK[63:0] = 64'h0;
};

reg lpm_key_sel3_r {
  shared;
  HandCoded = true;
  name = "Key select for LPM";
  desc = "
        Selects the bytes of key for the LPM lookup.  Indexed by profile ID.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Selects which of the KEY32 fields to use for the address portion of the LPM key.
           ";
    ValRandomize = true;
  } ADDR_KEY32_MASK[15:0] = 16'h0;
};

reg lpm_key_mask_r {
  shared;
  HandCoded = true;
  name = "Key mask for LPM";
  desc = "
        Configures the 160b mask used against the LPM key for lookup.  This 
        register is indexed first by profile.  The second index j selects
        the j'th 64b chunk of the mask.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Selects which of the KEY16 fields to use for the metadata portion of the LPM key.
           ";
    ValRandomize = true;
  } MASK[63:0] = 64'h0;
};
regfile lpm_key_mask_rf {
  lpm_key_mask_r LPM_KEY_MASK[20] += 8;
};

reg lpm_match_tcam_r {
  shared;
  HandCoded = true;
  name = "Pre-lookup for LPM search";
  desc = "
            Matches the first 4B of the key, the 'metadata' portion.  This
            field can be up to 4B.  Each entry of LPM_MATCH_TCAM points into
            a root subtrie to search into.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    The inverted key value to match against.
           ";
    ValRandomize = true;
  } KEY_INVERT[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "
    The key value to match against.
           ";
    ValRandomize = true;
  } KEY[31:0] = 32'h0;
};

reg lpm_match_action_r {
  shared;
  HandCoded = true;
  name = "Pre-lookup for LPM search";
  desc = "
            Action results for the TCAM match in LPM_MATCH_TCAM.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        The number of child pointers at the list starting at CHILD_BASE_PTR.
           ";
    ValRandomize = true;
  } CHILD_PTR_LEN[39:32] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
    An index into LPM_SUBTRIE_CPTR selecting the child pointer list associated with the
    subtrie in ROOT_PTR.
           ";
    ValRandomize = true;
  } CHILD_BASE_PTR[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
    An index into LPM_SUBTRIE_{BITMAPS,APTR} selecting the root subtrie to search into.
           ";
    ValRandomize = true;
  } ROOT_PTR[15:0] = 16'h0;
};

reg lpm_subtrie_bitmaps_r {
  shared;
  HandCoded = true;
  name = "Sub-trie storage for LPM";
  desc = "
            Contains the prefix and child presence bitmaps for each subtrie.
            This register is indexed first by subtrie number, and then by 
            columns 0..7, representing the 255b of prefix bitmap (columns 0..3) and 256b of
            child presence bitmap (columns 4..7). 
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Bit map array as described.
           ";
    ValRandomize = true;
  } BITMAP[63:0] = 64'h0;
};
regfile lpm_subtrie_bitmaps_rf {
  lpm_subtrie_bitmaps_r LPM_SUBTRIE_BITMAPS[8] += 8;
};

reg lpm_subtrie_cptr_r {
  shared;
  HandCoded = true;
  name = "Sub-trie storage for LPM";
  desc = "
            Contains the list of child pointers associated with the given subtrie
            as well as the new CHILD_BASE_PTR for each of those child subtries.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Length of the child pointer list at CHILD_BASE_PTR.
           ";
    ValRandomize = true;
  } CHILD_PTR_LEN[39:32] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
    Pointer into LPM_SUBTRIE_CPTR for this child.
           ";
    ValRandomize = true;
  } CHILD_BASE_PTR[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
    Pointer into LPM_SUBTRIE_BITMAPS for this child.
           ";
    ValRandomize = true;
  } SUBTRIE_PTR[15:0] = 16'h0;
};

reg lpm_subtrie_aptr_r {
  shared;
  HandCoded = true;
  name = "Sub-trie storage for LPM";
  desc = "
            Contains the ACTION_BASE_PTR for each subtrie.  This references a 
            pointer into SHM_FWD_TABLE0.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Indicates the base pointer for the actions for this subtrie.  This value is
            in 16B units and indicates the address into SHM_FWD_TABLE0. 
           ";
    ValRandomize = true;
  } ACTION_BASE_PTR[18:0] = 19'h0;
};
// EM_A_HASH_LOOKUP[0..8191]

reg em_a_hash_lookup_r {
  shared;
  HandCoded = true;
  name = "FFU hashing buckets.";
  desc = "
  In single lookup mode, there is one table using 8K buckets.
  In split-4K lookup mode,
  * LOOKUP0 = EM_A_LOOKUP[0..4095]
  * LOOKUP1 = EM_A_LOOKUP[4096..8192]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RW";
    desc = "
    ptr*4 is the byte-location of the bucket's first entry in Hash Entry RAM.

           ";
    ValRandomize = true;
  } PTR[83:64] = 20'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } RSVD1_[63:52] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_4[51:48] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_3[47:44] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_2[43:40] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_1[39:36] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_0[35:32] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects which bucket_hash values have entries.

           ";
    ValRandomize = true;
  } MASK[31:0] = 32'h0;
};



// EM_A_HASH_CAM[0..31,0..7]

reg em_a_hash_cam_r {
  shared;
  HandCoded = true;
  name = "CAM entries for hash overflow.";
  desc = "
  The second index is the entry number, and the third index
  is the word number. The entry format is big-endian. Byte 0 is bits 63..56 of word 0.

  In 64B entry mode, the entry is 64 bytes wide.
  In 64B mode there is a single action resolution and the 1-2 actions from
  the highest-numbered matching entry are used.
  To form a 64B entry, a key 56B or less is padded with 0s to 56B and followed by two actions.
  In the case of a 60B key, there is only 1 action at EM_A_HASH_CAM[group][rule][7][31:0].

  In 32B entry mode, EM_A_HASH_CAM[group][rule][0..3] is the row0 entry,
  and EM_A_HASH_CAM[group][rule][4..7] is the row1 entry. The two rows are resolved
  independently: the 1-2 actions from the highest-numbered matching entry within each row
  are used. To form a 32B entry, a key 24B or less is padded with 0s to 24B and followed
  by two actions. In the case of a 28B key in 32B mode, there is only 1 action.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } DATA[63:0] = 64'h0;
};
regfile em_a_hash_cam_rf {
  em_a_hash_cam_r EM_A_HASH_CAM[8] += 8;
};



// EM_A_HASH_CAM_EN[0..1,0..31]

reg em_a_hash_cam_en_r {
  shared;
  HandCoded = true;
  name = "Select EM_A_HASH_CAM scenarios.";
  desc = "
  When EM_A_HASH_CAM_EN[group][row][rule].mask[s] is set, then
  EM_A_HASH_CAM[group][rule][row*4 +: 4] is used in scenario s.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Select scenarios for this rule. Uses little-endian bit numbering.

           ";
    ValRandomize = true;
  } MASK[63:0] = 64'h0;
};
regfile em_a_hash_cam_en_rf {
  em_a_hash_cam_en_r EM_A_HASH_CAM_EN[32] += 8;
};



// EM_A_KEY_SEL0[0..1,0..63]

reg em_a_key_sel0_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key8s to participate in hashing and matching. 
     Key8Mask[i] selects key8[i].

           ";
    ValRandomize = true;
  } KEY8_MASK[31:0] = 32'h0;
};
regfile em_a_key_sel0_rf {
  em_a_key_sel0_r EM_A_KEY_SEL0[64] += 8;
};



// EM_A_KEY_SEL1[0..1,0..63]

reg em_a_key_sel1_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.

  This register is indexed first by hash number 0..1, then by scenario.

  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Selects one of 16 128 bit masks stored in EM_A_KEY_MASK to 
     apply to the key during comparison.
           ";
    ValRandomize = true;
  } KEY_MASK_SEL[51:48] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key32s to participate in hashing and matching. 
     Key32Mask[i] selects key32[i].

           ";
    ValRandomize = true;
  } KEY32_MASK[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key16s to participate in hashing and matching. 
     Key16Mask[i] selects key16[i].

           ";
    ValRandomize = true;
  } KEY16_MASK[31:0] = 32'h0;
};
regfile em_a_key_sel1_rf {
  em_a_key_sel1_r EM_A_KEY_SEL1[64] += 8;
};



// EM_A_KEY_MASK[0..1,0..31]

reg em_a_key_mask_r {
  shared;
  HandCoded = true;
  name = "Hash key bit mask";
  desc = "
  Provides a 128 bit hash key mask for each of 16 hash key profiles.
  Indexed first by hash number, then by:
  [code]
  (KEY_MASK_SEL * 2) + DW
  where there are 2 DWs per profile (128 bits)
  [/code]
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     64 of the 128 bits in the mask.
     Indicates which bits are included in the hash calculation.

           ";
    ValRandomize = true;
  } MASK[63:0] = 64'h0;
};
regfile em_a_key_mask_rf {
  em_a_key_mask_r EM_A_KEY_MASK[32] += 8;
};




// EM_A_HASH_MISS[0..1,0..63]

reg em_a_hash_miss_r {
  shared;
  HandCoded = true;
  name = "Provides two hash-miss actions for each hashtable row.";
  desc = "
  EM_A_HASH_MISS[r][scenario] provides 2 actions for row r=0..1.

  If there is no key match in ENTRY_RAM or CAM, then both actions are taken.
  The format of the action is the same as EM_A_ACTION,
  HASH_ENTRY_RAM, and EM_A_HASH_CAM.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION0[31:0] = 32'h0;
};
regfile em_a_hash_miss_rf {
  em_a_hash_miss_r EM_A_HASH_MISS[64] += 8;
};



// EM_A_HASH_CFG[0..63]

reg em_a_hash_cfg_r {
  shared;
  HandCoded = true;
  name = "Configure FFU hashing";
  desc = "
  This register is indexed by the scenario.
  
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Define lookup (or entry) modes : split 4K (0) or one 8K (1).
                                      32B      (0) or 64B    (1).

           ";
    ValRandomize = true;
  } MODE[46:46] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Start of hash table.
     Must be a multiple of 2^hash_size[ROW].

           ";
    ValRandomize = true;
  } BASE_PTR_0[45:33] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     Start of hash table.
     Must be a multiple of 2^hash_size[ROW].

           ";
    ValRandomize = true;
  } BASE_PTR_1[32:20] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of hash bits to use in lookup address calculation.

     * lookup_ptr = base_ptr[ROW] + hash % 2^hash_size[ROW]

     For example, hash_size=10 yields a table with 1024 buckets.

           ";
    ValRandomize = true;
  } HASH_SIZE_0[19:15] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of hash bits to use in lookup address calculation.

     * lookup_ptr = base_ptr[ROW] + hash % 2^hash_size[ROW]

     For example, hash_size=10 yields a table with 1024 buckets.

           ";
    ValRandomize = true;
  } HASH_SIZE_1[14:10] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Size of each entry, given as a multiple of 4B.
     The entry size must be a multiple of 4 in the range 8..64.
     The entry bytes following the padded key are actions.

     Set entry_size[r]==0 to disable row r lookups in this scenario.

           ";
    ValRandomize = true;
  } ENTRY_SIZE_0[9:5] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Size of each entry, given as a multiple of 4B.
     The entry size must be a multiple of 4 in the range 8..64.
     The entry bytes following the padded key are actions.

     Set entry_size[r]==0 to disable row r lookups in this scenario.

           ";
    ValRandomize = true;
  } ENTRY_SIZE_1[4:0] = 5'h0;
};



addrmap mby_ppe_cgrp_a_map {
  name = "mby_em";
  desc = "Classifier group A registers";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  em_a_hash_lookup_r          EM_A_HASH_LOOKUP[32768];
  em_a_hash_cam_rf            EM_A_HASH_CAM[32]     ;
  em_a_hash_cam_en_rf         EM_A_HASH_CAM_EN[2]   ;
  em_a_key_sel0_rf            EM_A_KEY_SEL0[2]      ;
  em_a_key_sel1_rf            EM_A_KEY_SEL1[2]      ;
  em_a_key_mask_rf            EM_A_KEY_MASK[2]      ;
  em_a_hash_miss_rf           EM_A_HASH_MISS[2]     ;
  em_a_hash_cfg_r             EM_A_HASH_CFG[64]     ;

  lpm_subtrie_aptr_r          LPM_SUBTRIE_APTR[24576];
  lpm_subtrie_cptr_r          LPM_SUBTRIE_CPTR[24576];
  lpm_subtrie_bitmaps_rf      LPM_SUBTRIE_BITMAPS[24576];
  lpm_match_tcam_r            LPM_MATCH_TCAM[512];
  lpm_match_action_r          LPM_MATCH_ACTION[512];
  lpm_key_mask_rf             LPM_KEY_MASK[64];
  lpm_key_sel0_r              LPM_KEY_SEL0[64];
  lpm_key_sel1_r              LPM_KEY_SEL1[64];
  lpm_key_sel2_r              LPM_KEY_SEL2[64];
  lpm_key_sel3_r              LPM_KEY_SEL3[64];
}; // final size: 0x22600 <= 0x40000 = 8<<15

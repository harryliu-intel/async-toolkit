<%extends C>
<%import>
java.util.Collection;
com.fulcrummicro.util.misc.Utility;
com.fulcrummicro.hw.verification.chip.mgmt.registers.Register;
com.fulcrummicro.hw.verification.chip.mgmt.registers.RegisterType;
</%import>
<%doc>

/******************************************************************************
 * Main Template
 ******************************************************************************/

</%doc>
<%args>
Collection<Register> regs;
String prefix;
</%args>
<%java>
final String lcPrefix = Utility.underscoreToCamelCase(prefix, false);
final String ucPrefix = lcPrefix.toUpperCase();
</%java>
/**
 * INTEL CONFIDENTIAL
 * Copyright <& copyright_year; &> Intel Corporation. All Rights Reserved.
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material may
 * be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or
 * delivery of the Materials, either expressly, by implication, inducement,
 * estoppel or otherwise. Any license under such intellectual property rights
 * must be express and approved by Intel in writing.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.
 * Last Updated <& timestamp; &>
 */

#include "fm_sdk_<% lcPrefix %>_int.h"

/*****************************************************************************
 * Data Structures
 *****************************************************************************/

/**************************************************
 * Register default values
 **************************************************/

typedef struct _fm_<% lcPrefix %>RegisterDefault
{
    /* Mask to be applied to register address. */
    fm_uint32   addrMask;

    /* Expected result of applying addrMask to the register address. If
     * result matches, then this table entry applies to the register. */
    fm_uint32   addrResult;

    /* Default value for this word */
    fm_uint32   def;

} fm_<% lcPrefix %>RegisterDefault;


/**************************************************
 * Register field types
 **************************************************/

typedef struct _fm_<% lcPrefix %>RegisterAccess
{
    /* Mask to be applied to register address. */
    fm_uint32   addrMask;

    /* Expected result of applying addrMask to the register address. If
     * result matches, then this table entry applies to the register. */
    fm_uint32   addrResult;

    /* Mask of bits with RW access */
    fm_uint32   rwMask;

    /* Mask of bits with RO access */
    fm_uint32   roMask;

    /* Mask of bits with CW access */
    fm_uint32   cwMask;

    /* Mask of bits with CW1 access */
    fm_uint32   cw1Mask;

    /* Mask of bits with RV access */
    fm_uint32   rvMask;

} fm_<% lcPrefix %>RegisterAccess;


/**************************************************
 * Register reset domains
 **************************************************/

typedef struct _fm_<% lcPrefix %>RegisterResetDomain
{
    fm_uint32 addrMask;

    fm_uint32 addrResult;

    fm_uint32 domainMask;

} fm_<% lcPrefix %>RegisterResetDomain;

/*****************************************************************************
 * Register Tables
 *****************************************************************************/


/**************************************************
 * List of register words that have at least one
 * bit not of type RW.
 **************************************************/

const fm_<% lcPrefix %>RegisterAccess <% lcPrefix %>RegisterFieldTypeTable[] =
{
/*   addrMask    addrResult  rwMask      roMask      cwMask      cw1Mask     rvMask          name [word] */
<%for Register reg : regs %>\
<%doc>Do not emit any entries if (i) the register is an alias for a
multi-purpose register or (ii) the register does not contain any predefined
fields.</%doc>
<%if reg.getAlias() == null &&
     reg.getTypeMaskExpanded(null).cardinality() != 0 %>\
<%for int i = 0, j = 0; i < reg.getEntryWidth(); i++, j += 32 %>\
<%if reg.getTypeMaskExpanded(RegisterType.RW).getUnsignedInt(j) != 0xffffffff ||
     reg.getTypeMaskExpanded(RegisterType.RO).getUnsignedInt(j) != 0 ||
     reg.getTypeMaskExpanded(RegisterType.CW).getUnsignedInt(j) != 0 ||
     reg.getTypeMaskExpanded(RegisterType.CW1).getUnsignedInt(j) != 0 ||
     reg.getTypeMaskExpanded(RegisterType.RV).getUnsignedInt(j) != 0 %>\
    {<& xdisplay; i = reg.getAddressMatchMaskExcludingWordBits(); w = 32 &>, \
<& strfaddr; addr = reg.getAddress() + i &>, \
<& xdisplay; i = reg.getTypeMaskExpanded(RegisterType.RW).getUnsignedInt(j); w = 32 &>, \
<& xdisplay; i = reg.getTypeMaskExpanded(RegisterType.RO).getUnsignedInt(j); w = 32 &>, \
<& xdisplay; i = reg.getTypeMaskExpanded(RegisterType.CW).getUnsignedInt(j); w = 32 &>, \
<& xdisplay; i = reg.getTypeMaskExpanded(RegisterType.CW1).getUnsignedInt(j); w = 32 &>, \
<& xdisplay; i = reg.getTypeMaskExpanded(RegisterType.RV).getUnsignedInt(j); w = 32 &>}, \
/* <% reg.getName() %><%if reg.getEntryWidth()>1 %> [<% i %>]</%if> */
</%if>\
</%for>\
</%if>\
</%for>\
    /* Terminator */
    {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}
};


/**************************************************
 * List of register words that have a non-zero
 * default value.
 **************************************************/

const fm_<% lcPrefix %>RegisterDefault <% lcPrefix %>RegisterDefaultTable[] =
{
/*   addrMask    addrResult  default         name [word] */
<%for Register reg : regs %>\
<%for int j = 0; j < reg.getEntryWidth(); j++ %>\
<%if reg.getDefault(0, j) != 0 %>\
    {<& xdisplay; i = reg.getAddressMatchMaskExcludingWordBits(); w = 32 &>, \
<& strfaddr; addr = reg.getAddress() + j &>, \
<& xdisplay; i = reg.getDefault(0, j); w = 32 &>}, \
/* <% reg.getName() %><%if reg.getEntryWidth()>1 %> [<% j %>]</%if> */
</%if>\
</%for>\
</%for>\
    /* Terminator */
    {0x00000000, 0x00000000, 0x00000000}
};


/**************************************************
 * List of register words that are on a separate
 * reset domain
 **************************************************/

const fm_<% lcPrefix %>RegisterResetDomain <% lcPrefix %>ResetDomainTable[] =
{
/*   addrMask    addrResult  domainMask */
<%for Register reg : regs %>\
    {<& xdisplay; i = reg.getAddressMatchMask(); w = 32 &>, \
<& strfaddr; addr = reg.getAddress() &>, \
<& rstmask; r = reg &>}, /* <% reg.getName() %> */
</%for>\
    /* Terminator */
    {<& xdisplay; i = 0; w = 32 &>, \
<& strfaddr; addr = 0 &>, \
<& xdisplay; i = 0; w = 32 &>}
};


/*****************************************************************************
 * Public Functions
 *****************************************************************************/

/*****************************************************************************/
/** <% lcPrefix %>ModelFindRegisterResetDomain
 * \ingroup intModel
 *
 * \desc            Searches the set of reset domains for the given register for
 *                  the given reset domain.
 *
 * \param[in]       addr is the register's address in the <% ucPrefix %> register
 *                  space.
 *
 * \param[in]       domain is the reset domain to search for.
 *
 * \return          TRUE if the reset domain is found in the set of reset
 *                  domains for the given register.
 * \return          FALSE otherwise
 *
 *****************************************************************************/
<% lcPrefix %>_resetDomain <% lcPrefix %>ModelFindRegisterResetDomain(fm_uint32 addr, <% lcPrefix %>_resetDomain domain)
{
    const fm_<% lcPrefix %>RegisterResetDomain *rst;

    /* Search the register reset domain table to check if this register is part
     * of the given reset domain. */
    rst = <% lcPrefix %>ResetDomainTable;

    while (rst->addrMask)
    {
        if ( (addr & rst->addrMask) == rst->addrResult )
        {
            if ( ( rst->domainMask & (1 << domain) ) != 0 )
            {
                return TRUE;
            }
            break;
        }
        ++rst;
    }

    return FALSE;

}   /* end <% lcPrefix %>ModelFindRegisterResetDomain */




/*****************************************************************************/
/** <% lcPrefix %>ModelGetRegisterDefault
 * \ingroup intModel
 *
 * \desc            Returns the default value for the given register.
 *                                                                      \lb\lb
 *                  The defaults table is searched for a non-zero default value.
 *                  If none, zero is returned as the default, otherwise the
 *                  default from the table is returned.
 *
 * \param[in]       addr is the register's address in the <% ucPrefix %> register
 *                  space.
 *
 * \return          Default value
 *
 *****************************************************************************/
fm_uint32 <% lcPrefix %>ModelGetRegisterDefault(fm_uint32 addr)
{
    const fm_<% lcPrefix %>RegisterDefault *defaults;
    fm_uint32                       rtnValue = 0;

    /**************************************************
     * Search the defaults table to see if this reg
     * has a non-zero default value.
     **************************************************/

    defaults = <% lcPrefix %>RegisterDefaultTable;

    while (defaults->addrMask)
    {
        /* Does masked address give the expected result? */
        if ( (addr & defaults->addrMask) == defaults->addrResult )
        {
            rtnValue = defaults->def;
            break;
        }

        ++defaults;
    }

    return rtnValue;

}   /* end <% lcPrefix %>ModelGetRegisterDefault */



/*****************************************************************************/
/** <% lcPrefix %>ModelGetRegisterAccess
 * \ingroup intModel
 *
 * \desc            Returns various mask(Read-Write,Read-Only, etc.) values
 *                  for the given register.
 *
 * \param[in]       addr is the register's address in the <% ucPrefix %> register
 *                  space.
 *
 * \param[out]      rwMask points to caller-allocated storage where this
 *                  function should place the mask identifying read-write bits.
 *
 * \param[out]      roMask points to caller-allocated storage where this
 *                  function should place the mask identifying read-only bits.
 *
 * \param[out]      cwMask points to caller-allocated storage where this
 *                  function should place the mask identifying clear-on-write
 *                  bits.
 *
 * \param[out]      cw1Mask points to caller-allocated storage where this
 *                  function should place the mask identifying clear-on-write-1
 *                  bits.
 *
 * \param[out]      rvMask points to caller-allocated storage where this
 *                  function should place the mask identifying reserved bits.
 *
 * \return          None
 *
 *****************************************************************************/
void <% lcPrefix %>ModelGetRegisterAccess(fm_uint32  addr,
                                  fm_uint32 *rwMask,
                                  fm_uint32 *roMask,
                                  fm_uint32 *cwMask,
                                  fm_uint32 *cw1Mask,
                                  fm_uint32 *rvMask)
{
    const fm_<% lcPrefix %>RegisterAccess *access;

    /**************************************************
     * Defaults for most registers.
     **************************************************/

    *rwMask  = 0xffffffff;
    *roMask  = 0x00000000;
    *cwMask  = 0x00000000;
    *cw1Mask = 0x00000000;
    *rvMask  = 0x00000000;

    /**************************************************
     * Search the access table to see if this reg
     * has special access bit fields.
     **************************************************/

    access = <% lcPrefix %>RegisterFieldTypeTable;

    while (access->addrMask)
    {
        /* Does masked address give the expected result? */
        if ( (addr & access->addrMask) == access->addrResult )
        {
            *rwMask  = access->rwMask;
            *roMask  = access->roMask;
            *cwMask  = access->cwMask;
            *cw1Mask = access->cw1Mask;
            *rvMask  = access->rvMask;
            break;
        }

        ++access;
    }

    return;

}   /* end <% lcPrefix %>ModelGetRegisterAccess */


/**
 * INTEL CONFIDENTIAL
 * Copyright 2014 Intel Corporation. All Rights Reserved.
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material may
 * be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or
 * delivery of the Materials, either expressly, by implication, inducement,
 * estoppel or otherwise. Any license under such intellectual property rights
 * must be express and approved by Intel in writing.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.
 */

#include "fm_sdk_hlp_int.h"

/*****************************************************************************
 * Data Structures
 *****************************************************************************/

/**************************************************
 * Register default values
 **************************************************/

typedef struct _fm_hlpRegisterDefault
{
    /* Mask to be applied to register address. */
    fm_uint32   addrMask;

    /* Expected result of applying addrMask to the register address. If
     * result matches, then this table entry applies to the register. */
    fm_uint32   addrResult;

    /* Default value for this word */
    fm_uint32   def;

} fm_hlpRegisterDefault;


/**************************************************
 * Register field types
 **************************************************/

typedef struct _fm_hlpRegisterAccess
{
    /* Mask to be applied to register address. */
    fm_uint32   addrMask;

    /* Expected result of applying addrMask to the register address. If
     * result matches, then this table entry applies to the register. */
    fm_uint32   addrResult;

    /* Mask of bits with RW access */
    fm_uint32   rwMask;

    /* Mask of bits with RO access */
    fm_uint32   roMask;

    /* Mask of bits with CW access */
    fm_uint32   cwMask;

    /* Mask of bits with CW1 access */
    fm_uint32   cw1Mask;

    /* Mask of bits with RV access */
    fm_uint32   rvMask;

} fm_hlpRegisterAccess;


/**************************************************
 * Register reset domains
 **************************************************/

typedef struct _fm_hlpRegisterResetDomain
{
    fm_uint32 addrMask;

    fm_uint32 addrResult;

    fm_uint32 domainMask;

} fm_hlpRegisterResetDomain;

/*****************************************************************************
 * Register Tables
 *****************************************************************************/


/**************************************************
 * List of register words that have at least one
 * bit not of type RW.
 **************************************************/

const fm_hlpRegisterAccess hlpRegisterFieldTypeTable[] =
{
/*   addrMask    addrResult  rwMask      roMask      cwMask      cw1Mask     rvMask          name [word] */

// Auto generated reg attributes begin
// Auto generated reg attributes end

    /* Terminator */
    {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}
};


/**************************************************
 * List of register words that have a non-zero
 * default value.
 **************************************************/

const fm_hlpRegisterDefault hlpRegisterDefaultTable[] =
{
/*   addrMask    addrResult  default         name [word] */
// Auto generated reg defaults begin
// Auto generated reg defaults end
    /* Terminator */
    {0x00000000, 0x00000000, 0x00000000}
};


/**************************************************
 * List of register words that are on a separate
 * reset domain
 **************************************************/

const fm_hlpRegisterResetDomain hlpResetDomainTable[] =
{
/*   addrMask    addrResult  domainMask */
// Auto generated reg reset domains begin
// Auto generated reg reset domains end
    /* Terminator */
    {0x00000000, 0x000000, 0x00000000}
};


/*****************************************************************************/
/** isAddrMatched
 * \ingroup intModel
 *
 * \desc            Check if HLP address matches in range of mask and value.
 *
 * \param[in]       addr is the register's address in the HLP register
 *                  space.
 *
 * \param[in]       mask is the mask on address.
 *
 * \param[in]       result is the result to compare too.
 *
 * \return          TRUE if address matches the value.
 * \return          FALSE otherwise
 *
 *****************************************************************************/
static inline fm_bool isAddrMatched(fm_uint32 addr, fm_uint mask, fm_uint result)
{
	if ((addr & mask) == result)
	{
		/* Special case for overlapping addr/mask not capable of 
		 * matching the correct entry
		 */
		/* 0xFFF3F807, 0x3320000 FFU_HASH_CAM */
		if (((addr & 0xFFF3F800) == HLP_FFU_HASH_CAM(0,0,0,0)) &&
		    (mask != 0xFFF3F807))
		{
			/* matches FFU_HASH_CAM but it is not for
			 * FFU_HASH_CAM entry */
			return FALSE;
		}
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************
 * Public Functions
 *****************************************************************************/

/*****************************************************************************/
/** hlpModelFindRegisterResetDomain
 * \ingroup intModel
 *
 * \desc            Searches the set of reset domains for the given register for
 *                  the given reset domain.
 *
 * \param[in]       addr is the register's address in the HLP register
 *                  space.
 *
 * \param[in]       domain is the reset domain to search for.
 *
 * \return          TRUE if the reset domain is found in the set of reset
 *                  domains for the given register.
 * \return          FALSE otherwise
 *
 *****************************************************************************/
hlp_resetDomain hlpModelFindRegisterResetDomain(fm_uint32 addr, hlp_resetDomain domain)
{
    const fm_hlpRegisterResetDomain *rst;

    /* Search the register reset domain table to check if this register is part
     * of the given reset domain. */
    rst = hlpResetDomainTable;

    while (rst->addrMask)
    {
        if (isAddrMatched(addr, rst->addrMask, rst->addrResult))
        {
            if ( ( rst->domainMask & (1 << domain) ) != 0 )
            {
                return TRUE;
            }
            break;
        }
        ++rst;
    }

    return FALSE;

}   /* end hlpModelFindRegisterResetDomain */




/*****************************************************************************/
/** hlpModelGetRegisterDefault
 * \ingroup intModel
 *
 * \desc            Returns the default value for the given register.
 *                                                                      \lb\lb
 *                  The defaults table is searched for a non-zero default value.
 *                  If none, zero is returned as the default, otherwise the
 *                  default from the table is returned.
 *
 * \param[in]       addr is the register's address in the HLP register
 *                  space.
 *
 * \return          Default value
 *
 *****************************************************************************/
fm_uint32 hlpModelGetRegisterDefault(fm_uint32 addr)
{
    const fm_hlpRegisterDefault *defaults;
    fm_uint32                       rtnValue = 0;

    /**************************************************
     * Search the defaults table to see if this reg
     * has a non-zero default value.
     **************************************************/

    defaults = hlpRegisterDefaultTable;

    while (defaults->addrMask)
    {
        /* Does masked address give the expected result? */
        if (isAddrMatched(addr, defaults->addrMask, defaults->addrResult))
        {
            rtnValue = defaults->def;
            break;
        }

        ++defaults;
    }

    return rtnValue;

}   /* end hlpModelGetRegisterDefault */



/*****************************************************************************/
/** hlpModelGetRegisterAccess
 * \ingroup intModel
 *
 * \desc            Returns various mask(Read-Write,Read-Only, etc.) values
 *                  for the given register.
 *
 * \param[in]       addr is the register's address in the HLP register
 *                  space.
 *
 * \param[out]      rwMask points to caller-allocated storage where this
 *                  function should place the mask identifying read-write bits.
 *
 * \param[out]      roMask points to caller-allocated storage where this
 *                  function should place the mask identifying read-only bits.
 *
 * \param[out]      cwMask points to caller-allocated storage where this
 *                  function should place the mask identifying clear-on-write
 *                  bits.
 *
 * \param[out]      cw1Mask points to caller-allocated storage where this
 *                  function should place the mask identifying clear-on-write-1
 *                  bits.
 *
 * \param[out]      rvMask points to caller-allocated storage where this
 *                  function should place the mask identifying reserved bits.
 *
 * \return          None
 *
 *****************************************************************************/
void hlpModelGetRegisterAccess(fm_uint32  addr,
                                  fm_uint32 *rwMask,
                                  fm_uint32 *roMask,
                                  fm_uint32 *cwMask,
                                  fm_uint32 *cw1Mask,
                                  fm_uint32 *rvMask)
{
    const fm_hlpRegisterAccess *access;

    /**************************************************
     * Defaults for most registers.
     **************************************************/

    *rwMask  = 0xffffffff;
    *roMask  = 0x00000000;
    *cwMask  = 0x00000000;
    *cw1Mask = 0x00000000;
    *rvMask  = 0x00000000;

    /**************************************************
     * Search the access table to see if this reg
     * has special access bit fields.
     **************************************************/

    access = hlpRegisterFieldTypeTable;

    while (access->addrMask)
    {
        /* Does masked address give the expected result? */
        if (isAddrMatched(addr, access->addrMask, access->addrResult))
        {
            *rwMask  = access->rwMask;
            *roMask  = access->roMask;
            *cwMask  = access->cwMask;
            *cw1Mask = access->cw1Mask;
            *rvMask  = access->rvMask;
            break;
        }

        ++access;
    }

    return;

}   /* end hlpModelGetRegisterAccess */
  

//                                                                             
// File:            mby_ppe_cgrp_a_nested_map_regs.h                           
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_CGRP_A_NESTED_MAP_REGS_H_
#define _MBY_PPE_CGRP_A_NESTED_MAP_REGS_H_

#define A_MSGPORT     0x0
#define A_EM_HASH_LOOKUP_MSGREGADDR 0x0
#define A_LPM_SUBTRIE_APTR_MSGREGADDR 0x80000
#define A_LPM_SUBTRIE_CPTR_MSGREGADDR 0x0C0000
#define A_LPM_SUBTRIE_BITMAPS_MSGREGADDR 0x200000
#define A_LPM_MATCH_TCAM_MSGREGADDR 0x380000
#define A_LPM_MATCH_ACTION_MSGREGADDR 0x381000
#define A_LPM_KEY_MASK_MSGREGADDR 0x384000
#define A_LPM_KEY_SEL0_MSGREGADDR 0x388000
#define A_LPM_KEY_SEL1_MSGREGADDR 0x388200
#define A_LPM_KEY_SEL2_MSGREGADDR 0x388400
#define A_LPM_KEY_SEL3_MSGREGADDR 0x388600

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_FLAG
// EM_HASH_LOOKUP desc:  In single lookup mode, there is one table with [list] [*] 32K
// buckets in CGRP_A [*] 8K buckets in CGRP_B [/list] In split mode,
// the total number of buckets gets divided between the two halves of
// the split:[br] In CGRP_A: [list] [*] LOOKUP0 =
// EM_HASH_LOOKUP[0..16383] [*] LOOKUP1 = EM_HASH_LOOKUP[16384..32767]
// [/list] In CGRP_B: [list] [*] LOOKUP0 = EM_HASH_LOOKUP[0..4095]
// [*] LOOKUP1 = EM_HASH_LOOKUP[4096..8191] [/list]
typedef union {
    struct {
        uint128_t  MASK                 :  32;    //  selects which bucket_hash
                                                 // values have entries.
        uint128_t  SELECT_0             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_1             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_2             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_3             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_4             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  RSVD1_               :  12;    // 
        uint128_t  PTR                  :  20;    //  ptr*4 is the byte-location
                                                 // of the bucket's first entry in
                                                 // Hash Entry RAM.
        uint128_t  RSVD_0               :  44;    // Nebulon auto filled RSVD [127:84]

    }                                field;
    uint128_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SIZE 128
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_BITFIELD_COUNT 0x08
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_MSB 0x001f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_RANGE 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_MASK 0xffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_LSB 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_MSB 0x0023
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_RANGE 0x0004
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_MASK 0xf00000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_LSB 0x0024
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_MSB 0x0027
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_RANGE 0x0004
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_MASK 0xf000000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_LSB 0x0028
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_MSB 0x002b
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_RANGE 0x0004
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_MASK 0xf0000000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_LSB 0x002c
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_MSB 0x002f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_RANGE 0x0004
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_MASK 0xf00000000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_LSB 0x0030
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_MSB 0x0033
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_RANGE 0x0004
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_MASK 0xf000000000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__LSB 0x0034
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__RANGE 0x000c
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__MASK 0xfff0000000000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_LSB 0x0040
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_MSB 0x0053
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_RANGE 0x0014
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_MASK 0x000fffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_FLAG
// LPM_SUBTRIE_APTR desc:  Contains the ACTION_BASE_PTR for each subtrie. This references a
// pointer into SHM_FWD_TABLE0. [br][br] The first index is the bank
// number. Software should take care to allocate entries that could be
// accessed within a single cycle to different banks. The second index
// is sized to provide the total number of entries.
typedef union {
    struct {
        uint64_t  ACTION_BASE_PTR      :  19;    //  Indicates the base pointer
                                                 // for the actions for this
                                                 // subtrie. This value is in 16B
                                                 // units and indicates the
                                                 // address into SHM_FWD_TABLE0.
        uint64_t  RSVD_0               :  45;    // Nebulon auto filled RSVD [63:19]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_ACTION_BASE_PTR_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_ACTION_BASE_PTR_MSB 0x0012
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_ACTION_BASE_PTR_RANGE 0x0013
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_ACTION_BASE_PTR_MASK 0x0007ffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_ACTION_BASE_PTR_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_FLAG
// LPM_SUBTRIE_CPTR desc:  Contains the list of child pointers associated with the given
// subtrie as well as the new CHILD_BASE_PTR for each of those child
// subtries. [br][br] The first index is the bank number. Software
// should take care to allocate entries that could be accessed within a
// single cycle to different banks. The second index is sized to provide
// the total number of entries.
typedef union {
    struct {
        uint64_t  SUBTRIE_PTR          :  16;    //  Pointer into
                                                 // LPM_SUBTRIE_BITMAPS for this
                                                 // child.
        uint64_t  CHILD_BASE_PTR       :  16;    //  Pointer into
                                                 // LPM_SUBTRIE_CPTR for this
                                                 // child.
        uint64_t  CHILD_PTR_LEN        :   8;    //  Length of the child pointer
                                                 // list at CHILD_BASE_PTR.
        uint64_t  RSVD_0               :  24;    // Nebulon auto filled RSVD [63:40]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_BITFIELD_COUNT 0x03
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SUBTRIE_PTR_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SUBTRIE_PTR_MSB 0x000f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SUBTRIE_PTR_RANGE 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SUBTRIE_PTR_MASK 0x0000ffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_SUBTRIE_PTR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_BASE_PTR_LSB 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_BASE_PTR_MSB 0x001f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_BASE_PTR_RANGE 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_BASE_PTR_MASK 0xffff0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_BASE_PTR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_PTR_LEN_LSB 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_PTR_LEN_MSB 0x0027
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_PTR_LEN_RANGE 0x0008
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_PTR_LEN_MASK 0xff00000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_CHILD_PTR_LEN_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_FLAG
// LPM_SUBTRIE_BITMAPS desc:  Contains the prefix and child presence bitmaps for each subtrie.
// [br][br] The first index is the bank number. Software should take
// care to allocate entries that could be accessed within a single cycle
// to different banks. The second index breaks down as follows: [list]
// [*] Bits 2:0 of the index represent the column number, with column 0-3
// being the 256b of prefix bitmap and columns 4-7 being the 256b of
// child presence bitmap [*] Bits 11:3 of the index represent the
// subtrie number within the bank [/list]
typedef union {
    struct {
        uint64_t  BITMAP               :  64;    //  Bit map array as described.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_BITMAP_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_BITMAP_MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_BITMAP_RANGE 0x0040
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_BITMAP_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_BITMAP_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_FLAG
// LPM_MATCH_TCAM desc:  Matches the first 4B of the key, the 'metadata' portion. This field
// can be up to 4B. Each entry of LPM_MATCH_TCAM points into a root
// subtrie to search into.
typedef union {
    struct {
        uint64_t  KEY                  :  32;    //  The key value to match
                                                 // against.
        uint64_t  KEY_INVERT           :  32;    //  The inverted key value to
                                                 // match against.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_BITFIELD_COUNT 0x02
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_MSB 0x001f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_RANGE 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_MASK 0xffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_INVERT_LSB 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_INVERT_MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_INVERT_RANGE 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_INVERT_MASK 0xffffffff00000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_KEY_INVERT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_FLAG
// LPM_MATCH_ACTION desc:  Action results for the TCAM match in LPM_MATCH_TCAM.
typedef union {
    struct {
        uint64_t  ROOT_PTR             :  16;    //  An index into
                                                 // LPM_SUBTRIE_{BITMAPS,APTR}
                                                 // selecting the root subtrie to
                                                 // search into.
        uint64_t  CHILD_BASE_PTR       :  16;    //  An index into
                                                 // LPM_SUBTRIE_CPTR selecting the
                                                 // child pointer list associated
                                                 // with the subtrie in ROOT_PTR.
        uint64_t  CHILD_PTR_LEN        :   8;    //  The number of child pointers
                                                 // at the list starting at
                                                 // CHILD_BASE_PTR.
        uint64_t  RSVD_0               :  24;    // Nebulon auto filled RSVD [63:40]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_BITFIELD_COUNT 0x03
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_ROOT_PTR_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_ROOT_PTR_MSB 0x000f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_ROOT_PTR_RANGE 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_ROOT_PTR_MASK 0x0000ffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_ROOT_PTR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_BASE_PTR_LSB 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_BASE_PTR_MSB 0x001f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_BASE_PTR_RANGE 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_BASE_PTR_MASK 0xffff0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_BASE_PTR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_PTR_LEN_LSB 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_PTR_LEN_MSB 0x0027
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_PTR_LEN_RANGE 0x0008
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_PTR_LEN_MASK 0xff00000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_CHILD_PTR_LEN_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_FLAG
// LPM_KEY_MASK desc:  Configures the 160b mask used against the LPM key for lookup. This
// register is indexed first by profile. The second index j selects the
// j'th 64b chunk of the mask.
typedef union {
    struct {
        uint64_t  MASK                 :  64;    //  Selects which of the KEY16
                                                 // fields to use for the metadata
                                                 // portion of the LPM key.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_MASK_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_MASK_MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_MASK_RANGE 0x0040
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_FLAG
// LPM_KEY_SEL0 desc:  Selects the bytes of key for the LPM lookup. Indexed by profile ID.
typedef union {
    struct {
        uint64_t  MD_KEY16_SEL         :  64;    //  Selects which of the KEY16
                                                 // fields to use for the metadata
                                                 // portion of the LPM key.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_MD_KEY16_SEL_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_MD_KEY16_SEL_MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_MD_KEY16_SEL_RANGE 0x0040
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_MD_KEY16_SEL_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_MD_KEY16_SEL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_FLAG
// LPM_KEY_SEL1 desc:  Selects the bytes of key for the LPM lookup. Indexed by profile ID.
typedef union {
    struct {
        uint64_t  MD_KEY8_SEL          :  32;    //  Selects which of the KEY8
                                                 // fields to use for the metadata
                                                 // portion of the LPM key.
        uint64_t  ADDR_KEY8_SEL        :  32;    //  Selects which of the KEY8
                                                 // fields to use for the address
                                                 // portion of the LPM key.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_BITFIELD_COUNT 0x02
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_MD_KEY8_SEL_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_MD_KEY8_SEL_MSB 0x001f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_MD_KEY8_SEL_RANGE 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_MD_KEY8_SEL_MASK 0xffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_MD_KEY8_SEL_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_ADDR_KEY8_SEL_LSB 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_ADDR_KEY8_SEL_MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_ADDR_KEY8_SEL_RANGE 0x0020
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_ADDR_KEY8_SEL_MASK 0xffffffff00000000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_ADDR_KEY8_SEL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_FLAG
// LPM_KEY_SEL2 desc:  Selects the bytes of key for the LPM lookup. Indexed by profile ID.
typedef union {
    struct {
        uint64_t  ADDR_KEY16_SEL       :  64;    //  Selects which of the KEY16
                                                 // fields to use for the address
                                                 // portion of the LPM key.

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_ADDR_KEY16_SEL_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_ADDR_KEY16_SEL_MSB 0x003f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_ADDR_KEY16_SEL_RANGE 0x0040
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_ADDR_KEY16_SEL_MASK 0xffffffffffffffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_ADDR_KEY16_SEL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_FLAG
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_FLAG
// LPM_KEY_SEL3 desc:  Selects the bytes of key for the LPM lookup. Indexed by profile ID.
typedef union {
    struct {
        uint64_t  ADDR_KEY32_SEL       :  16;    //  Selects which of the KEY32
                                                 // fields to use for the address
                                                 // portion of the LPM key.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_t;
#endif
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_OFFSET 0x00
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_SCOPE 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_SIZE 64
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_RESET 0x00000000

#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_ADDR_KEY32_SEL_LSB 0x0000
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_ADDR_KEY32_SEL_MSB 0x000f
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_ADDR_KEY32_SEL_RANGE 0x0010
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_ADDR_KEY32_SEL_MASK 0x0000ffff
#define MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_ADDR_KEY32_SEL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_EM_HASH_LOOKUP_t EM_HASH_LOOKUP[32768]; // offset 4'h0, width 128
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_APTR_t LPM_SUBTRIE_APTR[512]; // offset 4'h0, width 64
    } LPM_SUBTRIE_APTR[48];                      // offset 20'h80000, size: 4096
    uint8_t                    rsvd0[65536];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_CPTR_t LPM_SUBTRIE_CPTR[512]; // offset 4'h0, width 64
    } LPM_SUBTRIE_CPTR[48];                      // offset 24'h0C0000, size: 4096
    uint8_t                    rsvd1[1114112];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_SUBTRIE_BITMAPS_t LPM_SUBTRIE_BITMAPS[4096]; // offset 4'h0, width 64
    } LPM_SUBTRIE_BITMAPS[48];                   // offset 24'h200000, size: 32768
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_TCAM_t LPM_MATCH_TCAM[512]; // offset 24'h380000, width 64
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_MATCH_ACTION_t LPM_MATCH_ACTION[512]; // offset 24'h381000, width 64
    uint8_t                    rsvd2[8192];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_MASK_t LPM_KEY_MASK[20]; // offset 4'h0, width 64
    } LPM_KEY_MASK[64];                          // offset 24'h384000, size: 160
    uint8_t                    rsvd3[6144];
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL0_t LPM_KEY_SEL0[64]; // offset 24'h388000, width 64
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL1_t LPM_KEY_SEL1[64]; // offset 24'h388200, width 64
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL2_t LPM_KEY_SEL2[64]; // offset 24'h388400, width 64
    MBY_PPE_CGRP_A_NESTED_MAP_MSG_LPM_KEY_SEL3_t LPM_KEY_SEL3[64]; // offset 24'h388600, width 64
} mby_ppe_cgrp_a_nested_map_t;                   // size:  24'h388800


#endif // _MBY_PPE_CGRP_A_NESTED_MAP_REGS_H_


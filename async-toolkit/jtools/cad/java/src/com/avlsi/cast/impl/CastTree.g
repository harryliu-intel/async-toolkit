//
// Copyright 2000 Asynchronous Digital Design.  All rights reserved.
//
// $Id$
//

//
// CAST Tree Parser Grammar (for use with antlr http://www.antlr.org/)
//
// author: Jesse Rosenstock
//

header {
    ///////////////////////////////////////////////////////////////////////
    //
    // Copyright 2000 Asynchronous Digital Design.  All rights reserved.
    //
    // Warning:  This file was AUTOMATICALLY GENERATED!!!
    //
    // DO NOT check in.
    // DO NOT modify.
    //
    // You want to modify CastTree.g instead.
    //
    ///////////////////////////////////////////////////////////////////////

    package com.avlsi.cast.impl;

    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.util.*;
    import com.avlsi.cell.CellImpl;
    import com.avlsi.cell.CellInterface;
    import com.avlsi.cell.ExclusiveNodeSet;
    import com.avlsi.cell.NoSuchSubcellException;
    import com.avlsi.cell.SubcellCreationException;
    import com.avlsi.file.common.HierName;
    import com.avlsi.file.common.InvalidHierNameException;
    import com.avlsi.prs.ProductionRule;
    import com.avlsi.prs.ProductionRuleSet;
    import com.avlsi.util.bool.AndBooleanExpression;
    import com.avlsi.util.bool.BooleanExpressionInterface;
    import com.avlsi.util.bool.HierNameAtomicBooleanExpression;
    import com.avlsi.util.bool.OrBooleanExpression;
    import com.avlsi.util.debug.Debug;
    import com.avlsi.util.exception.AssertionFailure;
    import com.avlsi.util.text.StringUtil;
}

// bring this into sync with cast.g
// rationalize the names

// import
// handle _ for name

// spiff up using ideas from TinyBasicTreeWalker.g

// _ explanation:
// _ allowed? Places where identifiers appear
//      Y       variableDeclarationStatement    T _
//      Y       metaParam                       def T(X _)()
//      Y       portParam                       def T()(X _)
//      Y       loopStatement                   < _ : N : ... >
//      Y/N     expression:ident                _
//      N       expression:field
//      N       baseType
//      N       typeDeclaration
//
// The only time a _ is allowed as part of an expression
// is as part of the port real parameter list.  Ie X x(a, _)
// 
// For var decl / meta param / port param / loop statement, a variable
// is created with an autogenerated name that can never be specifed by
// a user.
//
// For the port real parameter list, a variable of the appropriate
// type and autogenerated name is created. Ie
// define X()(T t) { }
// X x(_)
// is equivalent to
// T autogen_name;
// X x(autogen_name)

// misc todo:
// ensure only algebraic types in meta params, and non-alg in port
// catch illegal array access

class CastTreeParser extends TreeParser;

options {
    classHeaderSuffix = CastTreeParserInterface;
    importVocab = Cast;
    ASTLabelType = "ASTWithInfo";
    defaultErrorHandler = false;
}

{
    private CastParserEnvironment cpe = null;

    public void setCastParserEnvironment(final CastParserEnvironment cpe) {
        this.cpe = cpe;
    }

    private SemanticWrapperException semanticWrapperException(
            final String message,
            final Exception e,
            final ASTWithInfo ast) {
        return semanticWrapperException(message, e, ast.getFilename(),
            ast.getLine(), ast.getColumn());
    }

    private SemanticWrapperException semanticWrapperException(
            final Exception e,
            final ASTWithInfo ast) {
        return semanticWrapperException(e, ast.getFilename(),
            ast.getLine(), ast.getColumn());
    }

    private SemanticWrapperException semanticWrapperException(
            final Exception e,
            final String file,
            final int line,
            final int column) {
        return new SemanticWrapperException(e, file, line, column);
    }

    private SemanticWrapperException semanticWrapperException(
            final String message,
            final Exception e,
            final String file,
            final int line,
            final int column) {
        return new SemanticWrapperException(message, e, file, line, column);
    }

    private String getLocation(ASTWithInfo ast) {
        return ast.getFilename() + ":"
            + ast.getLine() + ","
            + ast.getColumn();
    }

    /**
     * Used to issue warnings.
     **/
    private void warn(final String s, final ASTWithInfo astForLoc) {
        System.err.println(s + " at " + getLocation(astForLoc));
    }

    //
    // commonly used operations to catch and map exceptions
    //

    /**
     * Lookup sym in env.  Turn all exception into
     * SemanticWrapperExceptions.
     **/
    private Value lookup(final Environment env,
                         final Symbol sym,
                         final ASTWithInfo symAST) 
        throws SemanticWrapperException {
        try {
            final Value v = env.lookup(sym);
            if (v == null)
                throw semanticWrapperException("symbol " + symAST.getText()
                    + " undefined.", new Exception(), symAST);
            return v;
        } catch (AmbiguousLookupException e) {
            throw semanticWrapperException("Symbol " + symAST.getText()
                + " exists in multiple imported files.  "
                + "Use (currently non-existent) import ... as.",
                e, symAST);
        }
    }

    /**
     * @param cell  the cell that will be affected by any connections
     **/
    private void assign(final Value dest,
                        final Value source,
                        final CellImpl cell,
                        final ASTWithInfo astLoc,
                        final String message)
        throws SemanticWrapperException {
        try {
            dest.assign(source, cell);
        } catch (InvalidOperationException e) {
            throw semanticWrapperException(message, e, astLoc);
        }
    }

    private int getInt(final Value v, final ASTWithInfo ast)
        throws SemanticWrapperException {
        try {
            return IntValue.valueOf(v).getValue().intValue();
        } catch (InvalidOperationException e) {
            throw semanticWrapperException(e, ast);
        }
        
    }

    /**
     * Turns the string into a Symbol.
     * If the string is "_", return a symbol of an auto-generated name,
     * otherwise, return a symbol of the name.
     **/
    private Symbol generateSymbol(final String s) {
        return Symbol.create(generateName(s));
    }

    /**
     * If the string is "_", return an auto-generated name,
     * otherwise, return the string.
     **/
    private String generateName(final String s) {
        if (s.equals("_"))
            return cpe.nextAnonymousName();
        else
            return s;
    }

    /**
     * Returns a collection of BooleanExpressionInterfaces for 
     * use by LOOP_OR / LOOP_AND (ie the &lt;| ... &gt; /
     * &lt;&amp; ... &gt; syntax.
     **/
    private Collection loopedExpression(
        final ASTWithInfo id,
        final Range r,
        final Environment env,
        final ASTWithInfo prsExpr)
    throws RecognitionException {
        final List l = new ArrayList();
        final Symbol sym = generateSymbol(id.getText());
        final Range.Iterator ri = r.iterator();
        while (ri.hasNext()) {
            final int i = ri.next();
            final Environment loopEnv
                = new LoopEnvironment(env, sym, IntValue.valueOf(i));

            l.add(prsExpression(prsExpr, loopEnv));
        }

        return l;
    }

    /**
     * Converts Value to BoolValue for use in an if guard.
     **/
    private BoolValue ifGuard(final Value v, final ASTWithInfo expr)
        throws SemanticWrapperException {
        try {
            return BoolValue.valueOf(v);
        } catch (InvalidOperationException e) {
            throw semanticWrapperException("if guard " + v + " not bool",
                e, expr);
        }
    }

    /**
     * Attempts to convert a value to a PRSExpressionValue, throwing
     * a SemanticWrapperException if the conversion is not possible.
     **/
    private PRSExpressionValue toPRSExpressionValue(
        final Value v,
        final ASTWithInfo expr)
    throws SemanticWrapperException {
        try {
            return PRSExpressionValue.valueOf(v);
        } catch (InvalidOperationException e) {
            throw semanticWrapperException("type not valid for lhs"
                + " of a production rule", e, expr);
        }
    }

    private HierName oppositePowerSupply(
        final Environment env,
        final HierName powerSupply,
        final ASTWithInfo errorAST) throws SemanticWrapperException {

        final String newPowerSupply;

        if (powerSupply.getAsString('.').equals("Vdd!"))
            newPowerSupply = "GND";
        else if (powerSupply.getAsString('.').equals("GND!"))
            newPowerSupply = "Vdd";
        else
            throw new AssertionFailure("bad power supply");

        try {
            return NodeValue.valueOf(
                    lookup(env, Symbol.create(newPowerSupply), errorAST))
                .getInstanceName();
        } catch (InvalidOperationException exn) {
            throw semanticWrapperException("Non-node type for " +
                newPowerSupply + ", implied by complex production rule",
                exn, errorAST);
        }
    }

    public void doInstantiation(
            final AST t,
            final String moduleName,
            final Environment env,
            final CellImpl parent,
            final CellInterface envContainer)
        throws RecognitionException {
        variableDeclarationStatement(t, new BlockEnvironment(env),
                false, parent);
    }
}

goal[CellImpl cell, String moduleName, LinkedList fileList]
returns [Environment exportedEnv]
    {
        exportedEnv = null;
        Debug.assertTrue(cpe != null);
        Debug.assertTrue(moduleName == null, "Cast v1 can't handle modules");
    }
    : exportedEnv=compilationUnit[cell, fileList]
    ;

compilationUnit[CellImpl cell, LinkedList fileList]
returns [Environment exportedEnv]
    {
        exportedEnv = null;
        final ImportEnvironment importEnv = cpe.newImportEnvironment();
        final TopLevelEnvironment env = new TopLevelEnvironment(importEnv);
    }
    : ( importDeclaration[cell, importEnv, fileList] )*
      ( bodyStatement[env, true, cell] | typeDeclaration[env] )*
    { exportedEnv = env.getExportedEnvironment(); }
    ;

importDeclaration[CellImpl cell, ImportEnvironment importEnv,
                  LinkedList fileList]
    : #( IMPORT id:IDENT )
    {
        String filename = id.getText();

        // check for import names of the form foo/foo.cast,
        // change them to foo/*.cast
        // this will be a temporary hack until we convert the old source
        // code

        final String[] splitSlash = StringUtil.split(filename, '/');

        // if there is one slash
        if (splitSlash.length == 2) {
            final String[] splitDot = StringUtil.split(splitSlash[1], '.');

            // if there is one dot after the slash
            // and the part before it is the same as before the slash,
            // and after the dot is .cast, then change to *
            if (splitDot.length == 2
                && splitDot[0].equals(splitSlash[0])
                && splitDot[1].equals("cast")) {
                filename = splitSlash[0] + "/*." + splitDot[1];
            }
        }

        try {
            final String dir = StringUtil.chompEnd(filename, "/*.cast");

            if (dir != null) {
                final Environment[] envs
                    = cpe.parseDirectory(dir, fileList, cell);

                for (int i = 0; i < envs.length; ++i)
                    importEnv.addEnvironment(envs[i]);
            } else
                importEnv.addEnvironment(
                    cpe.parseFile( filename, fileList, cell));
        } catch (CircularImportException e) {
            throw semanticWrapperException(e, id);
        } catch (SelfImportException e) {
            warn("Warning: self-import of " + filename, id);
        } catch (FileNotFoundException e) {
            throw semanticWrapperException( "Imported file not found: "
                + filename, e, id);
        } catch (IOException e) {
            throw semanticWrapperException("Error in import", e, id);
        } catch (antlr.RecognitionException e) {
            throw semanticWrapperException("Error in import", e, id);
        } catch (antlr.TokenStreamException e) {
            throw semanticWrapperException("Error in import", e, id);
        }
    }
    ;

// bodyStatementLists don't appear at the top level, so we can
// pass globalP == false to bodyStatement
bodyStatementList[Environment env, CellImpl cell]
    : #( BODY_STATEMENT_LIST ( bodyStatement[env, false, cell] )* )
    ;

// globalP: whether the body statement is at a global level
bodyStatement[Environment env, boolean globalP, CellImpl cell]
    : prsBlock[env, cell]
    | specBlock[env, cell]
    | javaBlock[env, cell]
    | dumbBlock
    | levelBlock[env, cell]
    | block[env, cell, false]
    | variableDeclarationStatement[env, globalP, cell]
    | loopStatement[env, cell]
    | ifStatement[env, cell]
    | assignmentStatement[env, cell]
    ;

// bodyP indicates if the block is the body of a function,
// and thus a new environment should NOT be started (because
// the args and body are in the same environment to support 
// stupidity such as this: define Y()(T x[0..1]) { T x[2] = z; }
// this should only be temporary.  Later, when cflat 
// compatability is not an issue, we can do:
// T y[0..2] = x @ { z };
block[Environment env, CellImpl cell, boolean bodyP]
    { final Environment blockEnv = bodyP ? env : new BlockEnvironment(env); }
    : #( BLOCK bodyStatementList[blockEnv, cell] )
    ;

dumbBlock
    : DUMB_BLOCK
    ;

levelBlock[Environment env, CellImpl cell]
    : #( LEVEL_BLOCK IDENT block[env, cell, false] )
    ;

// globalP: true if the variableDeclarationStatement occurs at the
// top-level (globally).  If so, then a ! will be appended to the 
// node name in primitiveType.
variableDeclarationStatement[Environment env, boolean globalP, CellImpl cell]
    { final Value v; Value vInit = null; String varName = null; 
      boolean inlineP = false, flattenP = false; }
    : #( VAR_DECL id:IDENT { varName = generateName(id.getText()); }
         ( INLINE { flattenP = true; } )?
         ( INLINE1 { inlineP = true; } )?
         ( FLATTEN { flattenP = true; } )?
         v=type[env, cell, HierName.makeHierName(varName), globalP,
                inlineP, flattenP, false]
         ( vInit=variableInitializer[env] )? )
    {
        final Symbol sym = Symbol.create(varName);
        
        // NOTE that the environment is augmented after the initializer
        // is walked

        try {
            env.bind(sym, v);
        } catch (SymbolRedeclaredException e) {
            // it could be a sparse array, check

            // 1: get the old value
            final Value vOld = lookup(env, sym, id);

            // 2: The old and new values must both be arrays.
            if (!(v instanceof ArrayValue && vOld instanceof ArrayValue))
                throw semanticWrapperException("variable " + id.getText()
                    + " redeclared", e, id);

            final ArrayValue av = (ArrayValue) v;
            final ArrayValue avOld = (ArrayValue) vOld;

            // 3: attempt to augment the array with the new indices
            //    this may fail if:
            //      the element types are not the same
            //      the dimensions don't agree
            //      the indices are not disjoint
            try {
                avOld.augment(av);
            } catch (InvalidOperationException ee) {
                throw semanticWrapperException("Unable to augment sparse"
                    + " array " + id.getText(), e, id);
            }
        }

        // foobarbaz

        // assignment of value = tuple takes care of connections.
        if (vInit != null)
            assign(v, vInit, cell, id, "Incompatible types for initializer"
                + " or port list.");
    }
    ;

// ASSIGN:    returns a non-tuple expression
// PORT_LIST: returns a     tuple expression
variableInitializer[Environment env] returns [Value v]
    { v = null; }
    : #( ASSIGN v=expression[env, false] )
    | #( PORT_LIST v=expressionList[env, true] )
    ;

// returns an uninitialized value of the appropriate type
// cell: the cell to which nodes and connections should be added
//   if processing a port-param list, or body variable declaration,
//   null if processing a meta-param list
type[Environment env, CellImpl cell, HierName varName, boolean globalP,
     boolean inlineP, boolean flattenP, boolean portP]
returns [Value v]
    { final Value vb; SubscriptSpecInterface s = null; v = null; }
    : #( TYPE vb=bt:baseType[env, cell, varName, globalP]
         ( s=arraySelector[env] )? )
    {
        try {
            if (s == null)
                v = vb;
            else
                v = ArrayValue.makeArray(vb, s);

            // XXX: keep track of which subcells are port subcells

            // if we have a subcell or node, then add to the list of subcells
            if (vb instanceof InstanceValue || vb instanceof NodeValue) {
                final HierName name;
                final CellInterface subcell;
                // TODO: refactor this shit, maybe getting rid of NodeValue
                if (vb instanceof InstanceValue) {
                    final InstanceValue iv = (InstanceValue) vb;
                    name = iv.getInstanceName();
                    subcell = iv.getCell();
                } else {
                    final NodeValue nv = (NodeValue) vb;
                    name = nv.getInstanceName();
                    subcell = nv.getCell();
                }

                if (s == null) {
                    cell.addSubcellPair(name, subcell, portP);

                    Debug.assertTrue(!(inlineP && flattenP));
                    
                    if (inlineP)
                        cell.inlineSubcell(name);
                    if (flattenP)
                        cell.flattenSubcell(name);
                } else {
                    // we have an array!
                    final int nElems = s.getNumElements();

                    for (int i = 0; i < nElems; ++i) {
                        // this duplicates code in ArrayValue.accessArray()
                        final HierName subcellName;
                        if (name.isGlobal()) {
                            final int bangIdx =
                                name.getSuffixString().indexOf('!');
                            Debug.assertTrue(bangIdx ==
                                name.getSuffixString().length() - 1);
                            subcellName = HierName.makeSiblingName(name,
                                name.getSuffixString().substring(0, bangIdx) +
                                DenseSubscriptSpec.idxToString(s.indexOf(i)) +
                                '!');
                        } else {
                            subcellName = HierName.makeSiblingName(name,
                                name.getSuffixString() +
                                DenseSubscriptSpec.idxToString(s.indexOf(i)));
                        }
                        cell.addSubcellPair(subcellName, subcell, portP);

                        if (inlineP)
                            cell.inlineSubcell(subcellName);
                        if (flattenP)
                            cell.flattenSubcell(subcellName);
                    }
                }
            }

        } catch (NoSuchSubcellException e) {
            throw (AssertionFailure)
                new AssertionFailure("subcell not found to be " +
                                     "flattened or inlined.").initCause(e);
        } catch (SubcellCreationException e) {
            Debug.assertTrue(false, "original cast cells don't have prs blocks, shouldn't get inlining exceptions: "+e);
        }
    }
    ;

// returns an instance value of the given type.
// cell: the cell to which nodes and connections should be added
//   if processing a port-param list, or body variable declaration,
//   null if processing a meta-param list
baseType[Environment env, CellImpl cell,
         HierName varName, boolean globalP] returns [Value v]
    { v = null; }
    : { TupleValue tupleVal; }
      #( USER_TYPE id:IDENT tupleVal=expressionList[env, false] )
      {
          // 1: check that there is a symbol of the given name
          // 2: check that the symbol has a type value
          // 3: Restore the environment under which the
          //    body should be evaluated (the definitin could
          //    have come from another file)
          //    Restore the AST for the parameters and bod4y
          // 4: make a local environment that will be used for 
          //    the parameters
          // 5: bind the meta parameters w/  values
          // 6: bind the port parameters w/o values
          // 6.5: have we already generated the CellInterface
          //     for this type + meta params? If so, use it.
          //     If not, generate it.
          // 7: evaluate the body, 

          // the port params are bound in variableDeclarationStatement
          //   by assigning a tuple to the value

          // 1
          final Symbol sym = Symbol.create(id.getText());
          final Value val = lookup(env, sym, id);

          // 2
          if (!(val instanceof UserDefinedValue))
              throw new RuntimeException(val + " not a user defined type");
          final UserDefinedValue typeVal = (UserDefinedValue) val;

          // 3
          final Environment bodyEnv = typeVal.getEnvironment();
          final AST metaParamList = typeVal.getMetaParamList();
          final AST portParamList = typeVal.getPortParamList();
          final AST body = typeVal.getBody();

          // 4
          final BlockEnvironment paramEnv = new BlockEnvironment(bodyEnv);
          
          // 5
          metaParamList(metaParamList, paramEnv, tupleVal);

          // 6
          final String typeName
              = UserDefinedValue.getTypeName(id.getText(), tupleVal);
          // make a temporary subcell to add the nodes / subcells
          // in the port list to.  It will be thrown away if 
          // a cached cell is found.
          final CellImpl tempSubCell = new CellImpl(typeName);
          final ArrayList portList = new ArrayList();
          portParamList(portParamList, paramEnv, tempSubCell, portList);

          // 6.5
          CellImpl subCell = (CellImpl) typeVal.getCell(tupleVal);
          if (subCell == null) {
              subCell = tempSubCell;

              // 7
              // protect the types of paramter arrays from being
              // changed by the body.  This is for the same nonsenst
              // as the boolean param to block
              block(body, paramEnv.protectedArrayEnvironment(), subCell, true);
              
              typeVal.putCell(tupleVal, subCell);
          }

          v = new InstanceValue(varName, subCell, sym, tupleVal, paramEnv,
                  null, null,
                  (Symbol []) portList.toArray(new Symbol[0]), new Symbol[0],
                  new String[0], new int[] { InstanceValue.INLINE_NONE });
      }
    | v=primitiveType[env, cell, varName, globalP]
    ;

// return the default value of the appropriate type
// (default is un-initialized, for algebraic types).
// cell: the cell to which nodes and connections should be added
//   if processing a port-param list, or body variable declaration,
//   null if processing a meta-param list
primitiveType[Environment env, CellImpl cell, HierName varName,
              boolean globalP]
returns [Value v]
    { v = null; }
    : BOOL   { v = new BoolValue();  }
    | INT    { v = new IntValue();   }
    | FLOAT  { v = new FloatValue(); }
    | NODE   
      {
          Debug.assertTrue(varName.getNumComponents() == 1);

          // if the node was declared globally, append '!' to the name
          // to flag that it is a global node.  this will be used by
          // flatten() so that the cell name in not prepended.
          if (globalP) {
              varName = HierName.makeHierName(
                  varName.getSuffixString() + '!');
          }

          cell.addNode(varName);
          v = new NodeValue(varName);  
      }
    ;

// all declarations occur in the same environment
typeDeclaration[Environment env]
    : #( TYPE_DEFINITION id:IDENT m:FORMALS p:FORMALS b:BLOCK )
    {
        try {
                final Symbol cellTypeSymbol = Symbol.create( id.getText() );
            env.bind(
                cellTypeSymbol,
                new UserDefinedValue(env, cellTypeSymbol, m, p, null, b));
        } catch (SymbolRedeclaredException e) {
            throw semanticWrapperException("type " + id.getText()
                + " redeclared", e, id);
        }
    }
    ;

metaParamList[Environment env, TupleValue tupleVal]
    { int i = 0; }
    : #( f:FORMALS ( metaParam[env, tupleVal, i++] )* )
    {
        if (i != tupleVal.getSize())
            throw semanticWrapperException(
                new Exception("wrong # of meta params"), f);
    }
    ;

// XXX: enforce that only int,bool,float can be meta-params
metaParam[Environment env, TupleValue tupleVal, int i]
    { Value v; }
    : #( VAR_DECL id:IDENT
         v=type[env, null, HierName.makeHierName(id.getText()), false, false,
                false, false] )
    {
        try {
            final Symbol sym = generateSymbol(id.getText());
            env.bind(sym, v);
            // cell is null because it shouldn't be used by assign
            v.assign(tupleVal.accessTuple(i), null);
        } catch (SymbolRedeclaredException e) {
            throw semanticWrapperException("meta param " + id.getText()
                + " redeclared ", e, id);
        } catch (InvalidOperationException e) {
            throw semanticWrapperException(e, id);
            // XXX: assignment of meta params didn't work!
            // probably want to catch this elsewhere!
        }
    }
    ;

// modifies portList to contain a list of the variable names
// declared in the port parameter list,
// also modifies env by binding an uninitialized value to
// all the variables declared in the port list.
// env: the environment for the subcell
portParamList[Environment env, CellImpl cell, ArrayList portList]
    : #( FORMALS ( portParam[env, cell, portList] )* )
    ;

portParam[Environment env, CellImpl cell, ArrayList portList]
    { Value v; }
    : #( VAR_DECL id:IDENT
         v=type[env, cell, HierName.makeHierName(id.getText()), false, false,
                false, true] )
    {
        try {
            final Symbol sym = generateSymbol(id.getText());
            env.bind(sym, v);
            portList.add(sym);
        } catch (SymbolRedeclaredException e) {
            throw semanticWrapperException("port param " + id.getText()
                + " redeclared", e, id);
        }
    }
    ;

// refactor: remove duplication with prsLoopStatement
loopStatement[Environment env, CellImpl cell]
    { Range r; }
    : #( LOOP id:IDENT r=range[env, true] slist:BODY_STATEMENT_LIST )
    {
        final Symbol sym = generateSymbol(id.getText());
        final Range.Iterator ri = r.iterator();
        while (ri.hasNext()) {
            final int i = ri.next();
            final Environment loopEnv
                = new LoopEnvironment(env, sym, IntValue.valueOf(i));
            bodyStatementList(slist, loopEnv, cell);
        }
    }
    ;

// refactor: remove duplication with prsIfStatement
ifStatement[Environment env, CellImpl cell]
    { Value v; }
    : #( IF v=expr:expression[env, false] slist:BODY_STATEMENT_LIST )
    {
        final BoolValue bv = ifGuard(v, expr);

        try {
            if (bv.getValue())
                bodyStatementList(slist, env, cell);
        } catch (InvalidOperationException e) {
            throw semanticWrapperException("If guard uninitialized.",
                e, expr);
        }
    }
    ;

// fix me up later?
// ( = expr+ expr )
assignmentStatement[Environment env, CellImpl cell]
    { final ArrayList l = new ArrayList(), eList = new ArrayList();
      Value v0, vv; }
    : #( ASSIGN v0=e0:expr[env, false]
         ( vv=ee:expression[env, false] { l.add(vv); eList.add(ee);} )* )
    { 
        // xxx use the cell

        // change the * to a +, and this goes away!
        Debug.assertTrue(l.size() > 0);

        for (int i = l.size() - 1; i > 0; --i)
            assign((Value) l.get(i - 1), (Value) l.get(i), cell,
                   (ASTWithInfo) eList.get(i - 1),
                   "assignment failed");

        assign(v0, (Value) l.get(0), cell, e0, "assignment failed");
    }
    ;

// returns a tuple, this will be converted to an array if needed
// anonymousAllowedP: true if anonymous variables (_) are allowed
//   as expressions in the expressionList
expressionList[Environment env,
               boolean anonymousAllowedP] returns [TupleValue v]
    { final List l = new ArrayList(); Value ve; v = null; }
    : #( EXPRESSION_LIST
         ( ve=expression[env, anonymousAllowedP] { l.add(ve); } )* )
    { v = new TupleValue((Value []) l.toArray(new Value[0])); }
    ;

// anonymousAllowedP: true if anonymous variables (_) are allowed
//   as expressions
expression[Environment env, boolean anonymousAllowedP] returns [Value v]
    { v = null; }
    : #( EXPRESSION v=expr[env, anonymousAllowedP] )
    ;

// anonymousAllowedP: true if anonymous variables (_) are allowed
//   as expressions
expr[Environment env, boolean anonymousAllowedP] returns [Value v]
    // logical
    { Value v1, v2; v = null; ASTWithInfo t = null; 
      Range r; }
    : #( o01:OR v1=expr[env, false] v2=expr[env, false] )
      { t = o01; v = v1.or(v2); }
    | #( o02:AND v1=expr[env, false] v2=expr[env, false] )
      { t = o02; v = v1.and(v2); }
    | #( o03:NOT v1=expr[env, false] )
      { t = o03; v = v1.not(); }
    // arithmetic
    | #( o04:PLUS v1=expr[env, false] v2=expr[env, false] )
      { t = o04; v = v1.add(v2); }
    | #( o05:MINUS v1=expr[env, false] v2=expr[env, false] )
      { t = o05; v = v1.subtract(v2); }
    | #( o06:TIMES v1=expr[env, false] v2=expr[env, false] )
      { t = o06; v = v1.multiply(v2); }
    | #( o07:DIV v1=expr[env, false] v2=expr[env, false] )
      { t = o07; v = v1.divide(v2); }
    | #( o08:MOD v1=expr[env, false] v2=expr[env, false] )
      { t = o08; v = v1.mod(v2); }
    | #( o09:UNARY_PLUS v1=expr[env, false] )
      { t = o09; v = v1.unaryPlus(); }
    | #( o10:UNARY_MINUS v1=expr[env, false] )
      { t = o10; v = v1.negate(); }
    // relational
    | #( o11:LT v1=expr[env, false] v2=expr[env, false] )
      { t = o11; v = v1.lt(v2);        }
    | #( o12:LE v1=expr[env, false] v2=expr[env, false] )
      { t = o12; v = v1.le(v2);        }
    | #( o13:EQ v1=expr[env, false] v2=expr[env, false] )
      { t = o13; v = v1.eq(v2);        }
    | #( o14:NE v1=expr[env, false] v2=expr[env, false] )
      { t = o14; v = v1.ne(v2);        }
    | #( o15:GE v1=expr[env, false] v2=expr[env, false] )
      { t = o15; v = v1.ge(v2);        }
    | #( o16:GT v1=expr[env, false] v2=expr[env, false] )
      { t = o16; v = v1.gt(v2);        }
    // selection
    | #( o17:FIELD_ACCESS v1=expr[env, false] fi:FIELD_IDENT )
      { t = o17; v = InstanceValue.valueOf(v1).accessField(
          Symbol.create(fi.getText()),
          FieldedValueInterface.INSTANCE_PERMISSION); }
    | { SubscriptSpecInterface s; }
      #( o18:ARRAY_ACCESS v1=expr[env, false] s=arraySelector[env] )
      { t = o18; v = ArrayValue.valueOf(v1).accessArray(s); }
    // primary
    | id:IDENT
      {
          t = id;

          final String s = id.getText();

          if (s.equals("_")) {
              if (anonymousAllowedP)
                  v = new AnonymousValue();
              else {
                  final SemanticException se
                      = new SemanticException("_ not allowed here",
                          id.getFilename(), id.getLine(), id.getColumn());
                  se.column = id.getColumn();
                  throw se;
              }
          } else
              v = lookup(env, Symbol.create(s), id);
      }
    | n:NUM_INT   { t = n; v = IntValue.valueOf(n.getText()); }
    | f:NUM_REAL  { t = f; v = FloatValue.valueOf(f.getText()); }
    | o19:TRUE        { t = o19; v = BoolValue.valueOf(true); }
    | o20:FALSE       { t = o20; v = BoolValue.valueOf(false); }
    | #( o21:ARRAY v1=expressionList[env, false] )
      { t = o21; v = ArrayValue.fromTuple(v1); }
    // prs stuff
    /// XXX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // uhm!!! should be looking symbols up in symbol table!!!!!!!
    | #( o22:PRS_AND v1=expr[env, false] v2=expr[env, false] )
      { t = o22; v = PRSExpressionValue.valueOf(v1).and(v2); }
    | #( o23:PRS_OR v1=expr[env, false] v2=expr[env, false] )
      { t = o23; v = PRSExpressionValue.valueOf(v1).or(v2); }
    | #( o24:PRS_NOT v1=expr[env, false] )
      { t = o24; v = PRSExpressionValue.valueOf(v1).not(); }
    // merge these two into something like:
    // LOOPED_OP ( AND | OR ) IDENT range EXPRESSION
    | #( o25:LOOP_OR id2:IDENT r=range[env, true] e2:PRS_EXPRESSION )
      { v = new PRSExpressionValue(
          new OrBooleanExpression(true,
              loopedExpression(id2, r, env, e2))); }
    | #( o26:LOOP_AND id3:IDENT r=range[env, true] e3:PRS_EXPRESSION )
      { v = new PRSExpressionValue(
          new AndBooleanExpression(true,
              loopedExpression(id3, r, env, e3))); }
    ;
    exception
    catch [InvalidOperationException e] {
        throw semanticWrapperException(e, t);
    }

// loopP indicates how a singleton range should be interpreted
// true: it will be interpreted as 0..n-1
// false: it will be interpreted as n..n
range[Environment env, boolean loopP] returns [Range r]
    { Value v1, v2 = null; r = null; }
    : #( RANGE v1=e1:expression[env, false]
             ( v2=e2:expression[env, false] )? )
    {
        final int i1 = getInt(v1, e1);

        if (v2 == null) {
            if (loopP)
                r = new Range(0, i1 - 1);
            else
                r = new Range(i1, i1);
        } else {
            final int i2 = getInt(v2, e2);

            r = new Range(i1, i2);
        }
    }
    ;

arraySelector[Environment env] returns [SubscriptSpecInterface s]
    { ArrayList l = new ArrayList(); Range r; s = null; }
    : #( ARRAY_SUB ( r=range[env, false] { l.add(r); } )* )
    { s = new DenseSubscriptSpec((Range []) l.toArray(new Range[0])); }
    //: #( RANGE_LIST ( range )* )
    ;

//
// PRS stuff
//

prsBlock[Environment env, CellImpl cell]
    : #( PRS prsStatements[env, cell, false] )
    ;

/// xxx: do the env shit!
prsEnvBlock[Environment env, CellImpl cell]
    : #( ENV prsStatements[env, cell, true] )
    ;

// envP: flag saying if the pr was declared in an env block
prsStatements[Environment env, CellImpl cell, boolean envP]
    : #( BODY_STATEMENT_LIST ( prsStatement[env, cell, envP] )* )
    ;

// envP: flag saying if the pr was declared in an env block
prsStatement[Environment env, CellImpl cell, boolean envP]
    : prsIfStatement[env, cell, envP]
    | prsLoopStatement[env, cell, envP]
    | prsAction[env, cell, envP]
    | prsEnvBlock[env, cell]
    ;

// envP: flag saying if the pr was declared in an env block
// todo: refactor: remove duplication with ifStatement
prsIfStatement[Environment env, CellImpl cell, boolean envP]
    { Value v; }
    : #( IF v=expr:expression[env, false] prslist:BODY_STATEMENT_LIST )
    {
        final BoolValue bv = ifGuard(v, expr);

        try {
            if (bv.getValue())
                prsStatements(prslist, env, cell, envP);
        } catch (InvalidOperationException e) {
            throw semanticWrapperException("If guard uninitialized.",
                e, expr);
        }
    }
    ;

// envP: flag saying if the pr was declared in an env block
// todo: refactor, remove duplication with loopStatement
prsLoopStatement[Environment env, CellImpl cell, boolean envP]
    { Range r; }
    : #( LOOP id:IDENT r=range[env, true] prslist:BODY_STATEMENT_LIST )
    {
        final Symbol sym = generateSymbol(id.getText());
        final Range.Iterator ri = r.iterator();
        while (ri.hasNext()) {
            final int i = ri.next();
            final Environment loopEnv
                = new LoopEnvironment(env, sym, IntValue.valueOf(i));
            prsStatements(prslist, loopEnv, cell, envP);
        }
    }
    ;

// envP: flag saying if the pr was declared in an env block
prsAction[Environment env, CellImpl cell, boolean envP]
    { ProductionRule pr1, pr2 = null;
      ProductionRuleSet prs;
      if (envP)
          prs = cell.getAssertedProductionRuleSet();
      else
          prs = cell.getProductionRuleSet();
    }
    // merge these
    : ( #( ARROW pr1=prsActionBody[env, cell] )
      | #( celem:CELEM_ARROW pr1=pab:prsActionBody[env, cell] )
        { pr2 =
            pr1.cElementComplement(
                oppositePowerSupply(env, pr1.getPowerSupply(), celem)); }
      | #( comb:COMB_ARROW pr1=prsActionBody[env, cell] )
        { pr2 =
            pr1.combinationalComplement(
                oppositePowerSupply(env, pr1.getPowerSupply(), comb)); }
      ) { prs.addProductionRule(pr1);
          if (pr2 != null)
              prs.addProductionRule(pr2);
        }
    ;

prsActionBody[Environment env, CellImpl cell]
returns [ProductionRule pr]
    {
        Value av, rhsv;
        BooleanExpressionInterface be;
        boolean unstabP = false, timedP = false;
        int afterTimeSteps = -1; // negative means unspecified -- AML
        int dir;
        ASTWithInfo exp;
    }
    : ( UNSTAB {unstabP = true;} )?
      ( AFTER av=e:expression[env, false]
        { afterTimeSteps = getInt(av, e); } )?
       be=prsExpression[env] rhsv=expr[env, false]
       ( p:PLUS  { dir=ProductionRule.UP;   exp=p; } 
       | m:MINUS { dir=ProductionRule.DOWN; exp=m; } )
    {
        final NodeValue nv = (NodeValue) rhsv;
        final HierName rhsNode = nv.getInstanceName();

        final String rail = dir == ProductionRule.UP ? "Vdd" : "GND";
        final HierName railName;
        try {
            final Symbol s = Symbol.create(rail);
            final Value v = lookup(env, s, exp);
            railName = NodeValue.valueOf(v).getInstanceName();
            final NodeValue railNode = new NodeValue(railName);
  
            cell.addNode(railName);
        } catch (InvalidOperationException exn) {
            throw semanticWrapperException("Non-node type for " + rail +
                ", implied by production rule",
                exn, exp);
        }

        pr = new ProductionRule(be, rhsNode, railName, dir, false, unstabP,
                                false, timedP, afterTimeSteps, false);
    }
    ;

// this returns a BooleanExpressionInterface, suitable for use as the
// lhs of a production rule, and nowhere else
prsExpression[Environment env] returns [BooleanExpressionInterface be]
    { Value prsv; }
    : #( PRS_EXPRESSION prsv=exp:expr[env, false] )
    { be = toPRSExpressionValue(prsv, exp).getBooleanExpression(); }
    ;

// Java Block
javaBlock[Environment env, CellImpl cell]
    : #( JAVA javaStatements[env, cell] )
    ;

javaStatements[Environment env, CellImpl cell]
    : #( BODY_STATEMENT_LIST ( javaStatement[env, cell] )* )
    ;

javaStatement[Environment env, CellImpl cell]
    : javaClassStatement[env, cell]
    | inputChannelStatement[env, cell]
    | outputChannelStatement[env, cell]
    | internalChannelStatement[env, cell]
    ;

javaClassStatement[Environment env, CellImpl cell]
    : #( JAVACLASS cls:QuotedString ) { cell.setJavaClass(cls.getText()); } 
    ;

inputChannelStatement[Environment env, CellImpl cell]
    : #( INPUTCHAN cls:QuotedString ) { cell.setInputChannel(cls.getText()); }
    ;

outputChannelStatement[Environment env, CellImpl cell]
    : #( OUTPUTCHAN cls:QuotedString ) { cell.setOutputChannel(cls.getText()); }
    ;

internalChannelStatement[Environment env, CellImpl cell]
    : #( INTERNALCHAN cls:QuotedString ) { cell.setInternalChannel(cls.getText()); }
    ;



//
// SPEC stuff
//

specBlock[Environment env, CellImpl cell]
    : #( SPEC specStatements[env, cell] )
    ;

specStatements[Environment env, CellImpl cell]
    : ( specStatement[env, cell] )*
    ;

specStatement[Environment env, CellImpl cell]
    : specExclStatement[env, cell]
    | specAttribStatement[env, cell]
    ;

specExclStatement[Environment env, CellImpl cell]
    { int hiLo; List l; }
    : ( #( EXCLHI l=specNodeList[env] {hiLo = ExclusiveNodeSet.HI;} )
      | #( EXCLLO l=specNodeList[env] {hiLo = ExclusiveNodeSet.LO;} )
      )
      { cell.getLocalExclusiveNodeSets().addExclusiveNodeSet(new ExclusiveNodeSet(hiLo, l)); }
    ;

specAttribStatement[Environment env, CellImpl cell]
    : ATTRIB
    ;

// returns a List of HierNames
specNodeList[Environment env] returns [ArrayList l]
    { Value v; l = new ArrayList(); }
    : ( v=exp:expr[env, false]
        {
            try {
                l.add(NodeValue.valueOf(v).getInstanceName());
            } catch (InvalidOperationException e) {
                throw semanticWrapperException("Non-node type where "
                    + "node type expected.", e, exp);
            }
        }
      )+
    ;

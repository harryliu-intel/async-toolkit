// INTEL TOP SECRET
// Copyright 2014 Intel Corporation. All Rights Reserved.
//
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

  // Enum: RX_STATS_BANK_1
enum rx_stats_bank_1_enum {
  NonIP_L2Ucast      =  4'd0 { desc = "Non-IP frame with unicast DMAC"; };
  NonIP_L2Mcast      =  4'd1 { desc = "Non-IP frame with multicast DMAC"; };
  NonIP_L2Bcast      =  4'd2 { desc = "Non-IP frame with broadcast DMAC"; };
  IPv4_L2Ucast       =  4'd3 { desc = "IPv4 frame with unicast DMAC"; };
  IPv4_L2Mcast       =  4'd4 { desc = "IPv4 frame with multicast DMAC"; };
  IPv4_L2Bcast       =  4'd5 { desc = "IPv4 frame with broadcast DMAC"; };
  IPv6_L2Ucast       =  4'd6 { desc = "IPv6 frame with unicast DMAC"; };
  IPv6_L2Mcast       =  4'd7 { desc = "IPv6 frame with multicast DMAC"; };
  IPv6_L2Bcast       =  4'd8 { desc = "IPv6 frame with broadcast DMAC"; };
  IEEE802_3_pause    =  4'd9 { desc = "IEEE 802.3 pause frame"; };
  Class_based_pause  = 4'd10 { desc = "Class based pause frame"; };
  Framing_Err        = 4'd11 { desc = "Frame received with framing or internal error"; };
  FCS_Err            = 4'd12 { desc = "Frame received with FCS error"; };
};


  // Enum: RX_STATS_BANK_4
enum rx_stats_bank_4_enum {
  FIDForwarded       =  4'd0 { desc = "Forwarded normally with hit in 
                                       MA_TABLE"; };
  FloodForwarded     =  4'd1 { desc = "Flooded due to miss in MA_TABLE"; };
  SpeciallyHandled   =  4'd2 { desc = "FTYPE=0x2 (special delivery)"; };
  ParserErrorDrop    =  4'd3 { desc = "Dropped due to parser errors"; };
  EccErrorDrop       =  4'd4 { desc = "Dropped due to uncorrectable ECC 
                                       errors"; };
  Trapped            =  4'd5 { desc = "Trapped to CPU"; };
  PauseDrops         =  4'd6 { desc = "Dropped due to SYS_CFG_1.dropPause or 
                                       .dropMacCtrlEthertype."; };
  STPDrops           =  4'd7 { desc = "Fully dropped due to STP violations, 
                                       partial drops not counted"; };
  SecurityViolations =  4'd8 { desc = "See GEN_MASK"; };
  VlanTagDrops       =  4'd9 { desc = "Dropped due to VLAN tag"; };
  VlanIngressDrops   = 4'd10 { desc = "Ingress VLAN boundary violation"; };
  VlanEgressDrops    = 4'd11 { desc = "Egress VLAN boundary violation"; };
  GlortMissDrops     = 4'd12 { desc = "Dropped due to miss in GLORT_TABLE"; };
  FFUDrops           = 4'd13 { desc = "Dropped due to FFU action"; };
  TriggerDrops       = 4'd14 { desc = "Dropped due to Trigger action"; };
};

  // Enum: RX_STATS_BANK_5
enum rx_stats_bank_5_enum {
  PolicerDrops      =  4'd0 { desc = "Dropped due to Policer action"; };
  TTLDrops          =  4'd1 { desc = "Routed frame dropped due to TTL â‰¤ 1"; };
  CMPrivDrops       =  4'd2 { desc = "Dropped due to CM_GLOBAL_WM"; };
  CMSMP0Drops       =  4'd3 { desc = "Dropped due to insufficient memory in 
                                      SMP 0"; };
  CMSMP1Drops       =  4'd4 { desc = "Dropped due to insufficient memory in 
                                      SMP 1"; };
  CMRxHog0Drops     =  4'd5 { desc = "Dropped due to hog watermark in SMP 0"; };
  CMRxHog1Drops     =  4'd6 { desc = "Dropped due to hog watermark in SMP 1"; };
  CMTxHog0Drops     =  4'd7 { desc = "Dropped due to hog/softdrop watermark in 
                                      SMP 0"; };
  CMTxHog1Drops     =  4'd8 { desc = "Dropped due to hog/softdrop watermark in 
                                      SMP 1"; };
  Reserved          =  4'd9 { desc = "Unused and reserved."; };
  TriggerRedirects  = 4'd10 { desc = "Redirected by triggers"; };
  FloodControlDrops = 4'd11 { desc = "Dropped due to DLF flood control"; };
  GlortForwarded    = 4'd12 { desc = "Forwarded due to FFU/ARP DGLORT rules"; };
  LoopbackSuppDrops = 4'd13 { desc = "Dropped due to loopback suppress"; };
  OtherDrops        = 4'd14 { desc = "Dropped frame due to one of the following:
                              (a) Reserved multicast DMAC (01-80-C2-00-00-XX), 
                              (b) Invalid SMAC, (c) Null GLORT destmask."; };
};


reg rx_stats_bank_frame_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Ingress statistics frame counter";
  desc = "
    Each entry corresponds to a port x statistics class. There are 4 
    banks in total. See specification chapter for more details.
    [br][br]
    The first index identifies the group, while the second index is the counter for that group.
    [list]
    [*] Group 0: RX_STATS_BANK_FRAME[0,port*18+type], type defined in RX_STATS_BANK_0
    [*] Group 1: RX_STATS_BANK_FRAME[1,port*18+type], type defined in RX_STATS_BANK_1
    [*] Group 2: RX_STATS_BANK_FRAME[2,port*18+type], type defined in RX_STATS_BANK_2
    [*] Group 3: RX_STATS_BANK_FRAME[3,port*18+type], type defined in RX_STATS_BANK_3
    [/list]
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
            Number of frames received.
           ";
    ValRandomize = true;
  } FRAME_COUNTER[47:0] = 48'h00;
};
regfile rx_stats_bank_frame_rf {
  rx_stats_bank_frame_r RX_STATS_BANK_FRAME[144] += 8;
};



reg rx_stats_bank_byte_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Ingress statistics byte counter";
  desc = "
    Each entry corresponds to a port x statistics class. There are 4 
    banks in total. See specification chapter for more details.
    [br][br]
    The first index identifies the group, while the second index is the counter for that group.
    [br][br]
    [*] Group 0: RX_STATS_BANK_BYTE[0,port*18+type], type defined in RX_STATS_BANK_0
    [*] Group 1: RX_STATS_BANK_BYTE[1,port*18+type], type defined in RX_STATS_BANK_1
    [*] Group 2: RX_STATS_BANK_BYTE[2,port*18+type], type defined in RX_STATS_BANK_2
    [*] Group 3: RX_STATS_BANK_BYTE[3,port*18+type], type defined in RX_STATS_BANK_3
    [/list]
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
            Number of bytes received.
           ";
    ValRandomize = true;
  } BYTE_COUNTER[55:0] = 56'h00;
};
regfile rx_stats_bank_byte_rf {
  rx_stats_bank_byte_r RX_STATS_BANK_BYTE[144] += 8;
};

//VLAN
reg rx_stats_vlan_frame_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Ingress statistics vlan frame counter";
  desc = "
    Each entry corresponds to a bin counter within a counter set. There are 4K 
    counter sets total, 4 bins in each counter set. 

    RX_STATS_VLAN_FRAME[vlan_couter,ftype], ftype is Unicast(0), Multicast(1), Broadcast(2), or Drop (3).
    The first index identifies the counter set, while the second index (ftype) identifies the bin of that counter set.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
            Number of vlan frames received.
           ";
    ValRandomize = true;
  } FRAME_COUNTER[35:0] = 36'h00;
};

reg rx_stats_vlan_byte_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Ingress statistics vlan byte counter";
  desc = "
    Each entry corresponds to a bin counter within a counter set. There are 4K 
    counter sets total, 4 bins in each counter set. 

    RX_STATS_VLAN_BYTE[vlan_couter,ftype], ftype is Unicast(0), Multicast(1), Broadcast(2), or Drop (3).
    The first index identifies the counter set, while the second index (ftype) identifies the bin of that counter set.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
            Number of vlan bytes received.
           ";
    ValRandomize = true;
  } BYTE_COUNTER[43:0] = 44'h00;
};




addrmap mby_ppe_rx_stats_map {
  name = "mby_rx_stats";
  desc = "Ingress Statistics Counters";
  addressing = fullalign;
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary=true;

  rx_stats_bank_frame_rf    RX_STATS_BANK_FRAME[4]        @0x00000 += 4096; // [128]
  rx_stats_bank_byte_rf     RX_STATS_BANK_BYTE[4]         @0x04000 += 4096; // [128]
  rx_stats_vlan_frame_r     RX_STATS_VLAN_FRAME[16128]    @0x08000 += 8; 
  rx_stats_vlan_byte_r      RX_STATS_VLAN_BYTE[16128]     @0x28000 += 8;
};


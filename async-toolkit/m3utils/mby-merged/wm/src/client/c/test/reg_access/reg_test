#!/usr/bin/env perl

use strict;
use warnings;

use File::Spec::Functions qw(catdir);
use File::Basename qw(dirname);
use Cwd qw(abs_path);
use Term::ANSIColor;
use FileHandle;
use Expect;
use Carp;


my @params = ("-m", "../../../../main/m3/model_server/AMD64_LINUX/models.packetServer");
@params = @ARGV if @ARGV;
my $path = catdir($ENV{'MODEL_ROOT'}, 'wm/src/client/c/examples/client_regwrite');
$path = catdir(dirname(dirname(dirname(abs_path($0)))), 'examples/client_regwrite') if not -e $path;
my $reg_file = catdir(dirname($path), 'fpps_reg_table.c');
my $client = do {
	local $ENV{'LD_LIBRARY_PATH'} = '../..';
	Expect->spawn($path, @params) or die colored("Could not start application $path\n", 'bold red')
};
my $timeout = 2;

# Wait for application prompt: <0>%
sub expect_prompt {
	$client->expect($timeout, '<0>% ') or carp colored("Prompt didn't occure\n",'yellow');
	return;
}

# Write the value to the register
sub write_value {
	my ($reg, $val) = @_;
	print $client "write $reg $val\n";
	expect_prompt;
	return;
}

# Read the value from register and compare with the expected one
sub read_value {
	my ($reg, $val) = @_;

	print $client "read $reg\n";
	$client->expect($timeout, '-re', '\-\> (0x[a-f0-9]+)\s') or croak colored("Could not read from register $reg\n",'bold red');
	expect_prompt;

	my $output = hex(($client->matchlist())[0]);
	($output == $val) or croak colored("Expected $val, but got $output\n", 'bold red');

	print colored 'Read value correct', 'green';
	print $client "\n";
	expect_prompt;

	return;
}

sub get_reg_list {
	my ($reg_table) = @_;
	my @registers;

	open my $fh, "<", $reg_table or croak colored("Could not open register table: $reg_table",'bold red');

	while (<$fh>) {
		if ($_ =~ /\s\{\"(\w+)\".*\}/x) {
			push @registers, $1;
		}
	}

	close $fh;
	return @registers;
}

my @registers = get_reg_list($reg_file);
my $value = 0xBEEF;

$client->expect($timeout, 'Started/connected') or warn colored("No response from white model, trying to perform test anyway...\n",'yellow');

# Write and read from each register
foreach my $reg (@registers) {
	write_value($reg, $value);
	read_value($reg, $value);
	++$value;

	print $client "\n";
	expect_prompt;
}

# Disconnect
print $client "quit\n";
$client->expect($timeout, 'Disconnected') or warn colored("Disconnection failed\n",'yellow');


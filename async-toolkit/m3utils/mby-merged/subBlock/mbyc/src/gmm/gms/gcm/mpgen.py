'''
# Tool mpgen: Memory Partition Generator
# Description: This tool creates the wrapper of the physical and
#              functional memories using generic interface. This
#              tool makes use of NGEN and MGM.
#              already run.
#Instructions:
#   1) Setup your nhdk enviroment tool, the script uses the
#      enviroment variable $MODEL_ROOT
#   2) Place the script under the folder of your partition.
#   3) Create your logical files in a folder called mem/
#   4) Run mgm for creating memories of your block.
#   5) The script will create a folder called ngen/ . If you have
#      a folder with this name, rename it or make a backup.
#   6) The script calls the make function inside ngen/ directory
#   7) You can copy the generated RTL via "make rtl copy" command.
#
#Author: Abisai Ramirez Perez abisai.ramirez.perez@intel.com
'''
#TODO: review if reset is used in rf ff and sram and shells wrapper.
#TODO: receive a list of clients and a list of list with logicals related to a client.
#TODO: review num, it is a str and a int is required
import time
import os
import stat
import io
import sys
import re
import getopt
import argparse

class mpgen():
    def __init__(self):
        self.module_name = "test"
        self.lnames      = []
        self.num         = 0
        self.ram_type    =[]
        self.ram_deep    =[]
        self.ram_wdata   =[]
        self.ram_wrres   =[]
        self.clr_onrst   =[]
        self.ram_winst   =[]
        self.name_if     =[]
        self.file_if     =[]
#        self.MapWrapper  =[]
        self.sigfile_txt =[]
    def ConfigDirs(self):
        self.path        =os.getcwd()
        self.ngen_path   =os.path.join(self.path,"ngen")
        self.make_path   =os.path.join(self.ngen_path,"Makefile")
        self.inclPath    =os.path.join(self.ngen_path,"../rtl/mby_"+self.module_name+"_if_inst.sv")
        self.m_ifPath    =os.path.join(self.ngen_path,"../rtl/mby_"+self.module_name+"_memory_if.sv")
        self.basePath    =os.path.join(self.ngen_path,"mby_"+self.module_name+"_gen_mem.base")
        self.hier_path   =os.path.join(self.ngen_path,"mby_"+self.module_name+"_gen_mem.hier")
        self.sig_path    =os.path.join(self.ngen_path,"mby_"+self.module_name+"_gen_mem.sig")
        self.prep_path   =os.path.join(self.ngen_path,"pre_process.pl")
        self.wrap_path   =os.path.join(self.ngen_path,self.module_name+"_shells_wrapper.map")
        self.ff_path     =os.path.join(self.ngen_path,self.module_name+"_ff_mems.map")
        self.sr_path     =os.path.join(self.ngen_path,self.module_name+"_sram_mems.map")
        self.rf_path     =os.path.join(self.ngen_path,self.module_name+"_rf_mems.map")
        self.mem_dir     =os.path.join(self.path,"mem")
        self.rpt_path    = os.path.join(os.environ['MODEL_ROOT'],"target/mby/mgm_run/"+self.module_name+"/reports/"+self.module_name+"_mem_imp.report")
        
    
    def create_if_include(self):
        print (self.num)
        # Generic memory interface instances to be included
        if (self.num==0):
            print("## Creating interface instances file:"+self.inclPath+" that could be included for memory interface instances\n")
            with io.open(self.inclPath,"w") as if_inst:
                L= len(self.lnames)
                for ii in range(L):
                    self.file_if.append("mby_mem_"+self.ram_type[ii]+"_if    #(.W_DATA("+self.ram_wdata[ii]+"),    .W_DEEP("+self.ram_deep[ii]+"),   .W_INST("+self.ram_winst[ii]+") )    "+self.lnames[ii]+"_if();\n")
                if_inst.writelines(self.file_if)
        # Creating a ad-hoc interface for module
        else:
            print("## Generating interface mby_"+self.module_name+"_memory_if\n\n")
            with io.open(self.m_ifPath,"w") as block_mem_if:
                L=len(self.lnames) # Logical names
                block_mem_if.write("// Code autogenerated via MPGEN. Please, Do not handwrite.\n")
                block_mem_if.write("interface mby_"+self.module_name+"_memory_if (); \n\n")
#TODO: review bwe signals
#TODO: add init_done signals
                # Creating the logic signal
                for ii in range(L):
                    if (self.clr_onrst[ii]==0):
                        logics_clr_on_rst_txt = ""
                    else:
                        logics_clr_on_rst_txt = "logic              "+self.lnames[ii]+"_init_done   "+"["+self.ram_winst[ii]+"];   \n"

                    logics_Text1r1w= [
                    "logic      [$clog2("+self.ram_deep[ii]+")-1:0]     "+self.lnames[ii]+"_rd_adr       ["+self.ram_winst[ii]+"]; \n",
                    "logic      [$clog2("+self.ram_deep[ii]+")-1:0]     "+self.lnames[ii]+"_wr_adr       ["+self.ram_winst[ii]+"]; \n",
                    "logic                                              "+self.lnames[ii]+"_rd_en        ["+self.ram_winst[ii]+"]; \n",
                    "logic      ["+self.ram_wdata[ii]+"-1:0]            "+self.lnames[ii]+"_wr_data      ["+self.ram_winst[ii]+"]; \n",
                    "logic                                              "+self.lnames[ii]+"_wr_en        ["+self.ram_winst[ii]+"]; \n",
                    "logic      ["+self.ram_wdata[ii]+"-1:0]            "+self.lnames[ii]+"_rd_data      ["+self.ram_winst[ii]+"]; \n",
                    "logic                                              "+self.lnames[ii]+"_rd_valid     ["+self.ram_winst[ii]+"]; \n",
                    logics_clr_on_rst_txt,
                    "\n"]
    
                    logics_Text1rw= [
                    "logic      [$clog2("+self.ram_deep[ii]+")-1:0]     "+self.lnames[ii]+"_adr          ["+self.ram_winst[ii]+"]; \n",
                    "logic                                              "+self.lnames[ii]+"_rd_en        ["+self.ram_winst[ii]+"]; \n",
                    "logic      ["+self.ram_wdata[ii]+"-1:0]            "+self.lnames[ii]+"_wr_data      ["+self.ram_winst[ii]+"]; \n",
                    "logic                                              "+self.lnames[ii]+"_wr_en        ["+self.ram_winst[ii]+"]; \n",
                    "logic      ["+self.ram_wdata[ii]+"-1:0]            "+self.lnames[ii]+"_rd_data      ["+self.ram_winst[ii]+"]; \n",
                    "logic                                              "+self.lnames[ii]+"_rd_valid     ["+self.ram_winst[ii]+"]; \n",
                    logics_clr_on_rst_txt,
                    "\n"]
    
                    if (self.ram_type[ii]=="1r1w"):
                        tempText = logics_Text1r1w
                    elif(self.ram_type[ii]=="1rw"):
                        tempText = logics_Text1rw
                    else:
                        tempText =""
                    block_mem_if.writelines(tempText)
                tempText=""
                logics_clr_on_rst_txt = ""

                #Writing modport client
                block_mem_if.write("modport cln( \n")
                for ii in range(L):

                    if (self.clr_onrst[ii]==0):
                        logics_clr_on_rst_txt = ""
                    else:
                        logics_clr_on_rst_txt = "input "+self.lnames[ii]+"_init_done,  \n"
                    
                    if (ii == L-1):
                        temptxt= ""
                    else:
                        temptxt= ","
    
                    Cln_ModportText1r1w= [
                    logics_clr_on_rst_txt,
                    "output "+self.lnames[ii]+"_rd_adr   , \n",
                    "output "+self.lnames[ii]+"_wr_adr   , \n",
                    "output "+self.lnames[ii]+"_rd_en    , \n",
                    "output "+self.lnames[ii]+"_wr_data  , \n",
                    "output "+self.lnames[ii]+"_wr_en    , \n",
                    "input  "+self.lnames[ii]+"_rd_data  , \n",
                    "input  "+self.lnames[ii]+"_rd_valid "+temptxt+" \n",
                    "\n"]
                    
                    Cln_ModportText1rw= [
                    logics_clr_on_rst_txt,
                    "output "+self.lnames[ii]+"_adr      , \n",
                    "output "+self.lnames[ii]+"_rd_en    , \n",
                    "output "+self.lnames[ii]+"_wr_data  , \n",
                    "output "+self.lnames[ii]+"_wr_en    , \n",
                    "input  "+self.lnames[ii]+"_rd_data  , \n",
                    "input  "+self.lnames[ii]+"_rd_valid "+temptxt+" \n",
                    "\n"]
    
                    if (self.ram_type[ii]=="1r1w"):
                        tempText = Cln_ModportText1r1w
                    elif(self.ram_type[ii]=="1rw"):
                        tempText = Cln_ModportText1rw
                    else:
                        tempText =""
                        print("Supported: 1rw, 1r1w. Review logical file on RAM port")
                    block_mem_if.writelines(tempText)
                block_mem_if.write(");\n\n")
                tempText=""
                temptxt=""
                logics_clr_on_rst_txt = ""
    
                block_mem_if.write("modport mem(\n")
                for ii in range(L):
                    if (ii == L-1):
                        temptxt= ""
                    else:
                        temptxt= ","
    
                    if (self.clr_onrst[ii]==0):
                        logics_clr_on_rst_txt = ""
                    else:
                        logics_clr_on_rst_txt = "output  "+self.lnames[ii]+"_init_done,  \n"
                    
                    Mem_ModportText1r1w= [
                    logics_clr_on_rst_txt,
                    "input  "+self.lnames[ii]+"_rd_adr   , \n",
                    "input  "+self.lnames[ii]+"_wr_adr   , \n",
                    "input  "+self.lnames[ii]+"_rd_en    , \n",
                    "input  "+self.lnames[ii]+"_wr_data  , \n",
                    "input  "+self.lnames[ii]+"_wr_en    , \n",
                    "output "+self.lnames[ii]+"_rd_data  , \n",
                    "output "+self.lnames[ii]+"_rd_valid "+temptxt+" \n",
                    "\n"]
                    
                    Mem_ModportText1rw= [
                    logics_clr_on_rst_txt,
                    "input  "+self.lnames[ii]+"_adr      , \n",
                    "input  "+self.lnames[ii]+"_rd_en    , \n",
                    "input  "+self.lnames[ii]+"_wr_data  , \n",
                    "input  "+self.lnames[ii]+"_wr_en    , \n",
                    "output "+self.lnames[ii]+"_rd_data  , \n",
                    "output "+self.lnames[ii]+"_rd_valid "+temptxt+" \n",
                    "\n"]
    
                    if (self.ram_type[ii]=="1r1w"):
                        tempText = Mem_ModportText1r1w
                    elif(self.ram_type[ii]=="1rw"):
                        tempText = Mem_ModportText1rw
                    else:
                        tempText =""
                        print("Review logical file on RAM port")
                    block_mem_if.writelines(tempText)
                    tempText=""
                block_mem_if.write(");\n\n")
                block_mem_if.write("endinterface \n")
             
    def createSigFile(self):
        if (self.num==0):
            L= len(self.lnames)
            with io.open(self.sig_path, "w") as sigFile:
                for it in range(L):
                    self.sigfile_txt.append(self.lnames[it]+"_if      interface\n;\n")
                sigFile.write("i_reset logic\n;\nreset_n logic\n\tno_pins\n;\n")
                sigFile.writelines(self.sigfile_txt)
        else:
            with io.open(self.sig_path, "w") as sigFile:
                self.sigfile_txt.append(self.module_name+"_mem_if      interface\n;\n")
                sigFile.write("i_reset logic\n;\nreset_n logic\n\tno_pins\n;\n")
                sigFile.writelines(self.sigfile_txt) 
    
    def parsingImplemReport(self):
        makeText = []
        with io.open(self.rpt_path, "r") as report, io.open(self.hier_path,"w") as hier, io.open(self.prep_path,"w") as preP:
            rdata=report.read(1000) # Reduce the amount of line read
            P_flops = r".+(FLOPS)"
            P_sram  = r".+(SRAM)"
            P_rf    = r".+(RF)"
            FF_Matched   = re.findall(P_flops,rdata) # Search for number of lines
            RF_Matched   = re.findall(P_rf,rdata) # Search for number of lines
            SR_Matched   = re.findall(P_sram,rdata) # Search for number of lines
            prePText =[ "#!/usr/bin/env perl \n",
                        "open(SF, \"$ENV{'MODEL_ROOT'}/target/mby/mgm_run/"+self.module_name+"/src/"+self.module_name+"_shells_wrapper.v\") || die \"can't open input file\n\";\n",
                        "open(TF, \">./"+self.module_name+"_shells_wrapper_inc.v\") || die \"can't open output file\n\";\n",
                        "\n",
                        "print TF \"`include        \\\""+self.module_name+"_mem.def\\\"\n\";\n",
                        "while (<SF>) {\n",
                        "   printf TF (\"%s\",$_);\n",
                        "}\n",
                        "close (TF);\n",
                        "close (SF);\n"
            ]
            HierText = ["//"+self.module_name+" block\n",
                        "\n",
                        "mby_"+self.module_name+"_gen_mem[\n",
                        self.module_name+"_shells_wrapper of "+self.module_name+"_shells_wrapper with "+self.module_name+"_shells_wrapper.map\n"
                            ]
            print("## Found memories in "+self.rpt_path+";")                        
            print(" - Number of FF mems:", len(FF_Matched))
            print(" - Number of RF mems:", len(RF_Matched))
            print(" - Number of SRAM mems:", len(SR_Matched), "\n")
            if (len(FF_Matched)>0):
                with io.open(self.ff_path, "w") as ffMap:
                    ffMap.write("1'b1 >>  car_raw_lan_power_good_with_byprst\n")
                    HierText.append(self.module_name+"_ff_mems of "+self.module_name+"_ff_mems with "+self.module_name+"_ff_mems.map\n")
                    makeText.append("	$(V2BBOX) -v $(MGM_RUN)/$(PAR)/src/mem_wrap/$(PAR)_ff_mems.v -p $(MGM_RUN)/$(PAR)/src,$(MGM_RUN)/rtl -o $(PAR)_ff_mems.v\n")
            if (len(RF_Matched)>0):
                with io.open(self.rf_path, "w") as rfMap:
                    rfMap.write("1'b1 >>  car_raw_lan_power_good_with_byprst\n")
                    HierText.append(self.module_name+"_rf_mems of "+self.module_name+"_rf_mems with "+self.module_name+"_rf_mems.map\n")
                    makeText.append("	$(V2BBOX) -v $(MGM_RUN)/$(PAR)/src/mem_wrap/$(PAR)_rf_mems.v -p $(MGM_RUN)/$(PAR)/src,$(MGM_RUN)/rtl -o $(PAR)_rf_mems.v\n")
            if (len(SR_Matched)>0):
                with io.open(self.sr_path, "w") as srMap:
                    srMap.write("1'b1 >>  car_raw_lan_power_good_with_byprst\n")
                    HierText.append(self.module_name+"_sram_mems of "+self.module_name+"_sram_mems with "+self.module_name+"_sram_mems.map\n")
                    makeText.append("	$(V2BBOX) -v $(MGM_RUN)/$(PAR)/src/mem_wrap/$(PAR)_sram_mems.v -p $(MGM_RUN)/$(PAR)/src,$(MGM_RUN)/rtl -o $(PAR)_sram_mems.v\n")
            HierText.append("]\n")
            hier.writelines(HierText)
            preP.writelines(prePText) 
        return makeText       
    
    def create_MapFileForShellsWrapper(self):
        # Using generic memory interface
        if (self.num==0):
            with io.open(self.wrap_path,"w") as wrapperfile:
                L=len(self.lnames)
                for ii in range(L):
                    for tt in range(int(self.ram_winst[ii])):

                        if (int(self.ram_winst[ii]) > 1):
                            tempvar= "_"+str(tt)
                        else:
                            tempvar= ""
                        
                        if (self.ram_wrres[ii]==0):
                            bweText = ""
                        else:
                            bweText = "                                             >> "+self.lnames[ii]+tempvar+"_wr_bwe\n"
                        
                        WrapperText1r1w= [
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_CFG_reg_sel\n",
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_STATUS_reg_sel\n",
                        self.lnames[ii]+"_if.rd_adr   "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_adr\n",
                        self.lnames[ii]+"_if.wr_adr   "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_wr_adr\n",
                        self.lnames[ii]+"_if.rd_en    "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_en\n",
                        self.lnames[ii]+"_if.wr_data  "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_wr_data\n",
                        self.lnames[ii]+"_if.wr_en    "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_wr_en\n",
                        bweText, 
                        self.lnames[ii]+"_if.rd_data  "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_data\n",
                        self.lnames[ii]+"_if.rd_valid "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_valid\n",
                        "                                             >> "+self.lnames[ii]+tempvar+"_ecc_uncor_err\n",
                        "                                             >> "+self.lnames[ii]+tempvar+"_init_done\n",
                        "1'b0                                         >> "+self.lnames[ii]+tempvar+"_mem_ls_enter\n",
                        "\n"
                        ]
                        
                        WrapperText1rw= [
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_CFG_reg_sel\n",
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_STATUS_reg_sel\n",
                        self.lnames[ii]+"_if.adr      "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_adr\n",
                        self.lnames[ii]+"_if.rd_en    "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_en\n",
                        self.lnames[ii]+"_if.wr_data  "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_wr_data\n",
                        self.lnames[ii]+"_if.wr_en    "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_wr_en\n",
                        bweText, 
                        self.lnames[ii]+"_if.rd_data  "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_data\n",
                        self.lnames[ii]+"_if.rd_valid "+"["+str(tt)+"]      >> "+self.lnames[ii]+tempvar+"_rd_valid\n",
                        "                                             >> "+self.lnames[ii]+tempvar+"_ecc_uncor_err\n",
                        "                                             >> "+self.lnames[ii]+tempvar+"_init_done\n",
                        "1'b0                                         >> "+self.lnames[ii]+tempvar+"_mem_ls_enter\n",
                        "\n"
                        ]
        
                        if (self.ram_type[ii]=="1r1w"):
                            tempText = WrapperText1r1w
                        elif(self.ram_type[ii]=="1rw"):
                            tempText = WrapperText1rw
                        else:
                            tempText =""
                            print("Review logical file on RAM port")
                        wrapperfile.writelines(tempText)
                        tempText=""
                EndingText =[  
                "1'b0 >> "+self.module_name.upper()+"_ECC_COR_ERR_reg_sel\n",
                "1'b0 >> "+self.module_name.upper()+"_ECC_UNCOR_ERR_reg_sel\n",
                "\n",
                "1'b1 >> unified_regs_rd\n",
                "'h0  >> unified_regs_wr_data\n",
                "     >> "+self.module_name+"_ecc_int\n",
                "     >> "+self.module_name+"_init_done\n",
                "     >> unified_regs_ack\n",
                "     >> unified_regs_rd_data\n",
                "\n",
                "cclk    >> clk\n",
                "reset_n >> reset_n\n"
                ]
                wrapperfile.writelines(EndingText)
        # Using ad-hoc interface for client
        else:
            with io.open(self.wrap_path,"w") as wrapperfile:
                L=len(self.lnames)
                for ii in range(L):
                    for tt in range(int(self.ram_winst[ii])):
                        
                        if (int(self.ram_winst[ii]) > 1):
                            tempvar= "_"+str(tt)
                        else:
                            tempvar= ""

                        if (self.ram_wrres[ii]==0):
                            bweText = ""
                        else:
                            bweText = "                                             >> "+self.lnames[ii]+tempvar+"_wr_bwe\n"
                       
              #          #print(self.lnames[ii]+"Value reset"+str(self.clr_onrst[ii])) 
                        
                        if (self.clr_onrst[ii]==0):
                            clr_on_rst_txt = "                                             >> "+self.lnames[ii]+tempvar+"_init_done\n"
                        else:
                            clr_on_rst_txt = self.module_name+"_mem_if."+self.lnames[ii]+"_init_done  "+"["+str(tt)+"]    >> "+self.lnames[ii]+tempvar+"_init_done\n"
        
                        WrapperText1r1w= [
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_CFG_reg_sel\n",
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_STATUS_reg_sel\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_adr   "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_adr\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_wr_adr   "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_wr_adr\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_en    "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_en\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_wr_data  "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_wr_data\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_wr_en    "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_wr_en\n",
                        bweText,
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_data  "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_data\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_valid "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_valid\n",
                        clr_on_rst_txt,
                        "                                             >> "+self.lnames[ii]+tempvar+"_ecc_uncor_err\n",
                        "1'b0                                         >> "+self.lnames[ii]+tempvar+"_mem_ls_enter\n",
                        "\n"
                        ]
                        
                        WrapperText1rw= [
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_CFG_reg_sel\n",
                        "1'b0                                         >> "+self.lnames[ii].upper()+tempvar+"_STATUS_reg_sel\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_adr      "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_adr\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_en    "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_en\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_wr_data  "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_wr_data\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_wr_en    "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_wr_en\n",
                        bweText, 
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_data  "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_data\n",
                        self.module_name+"_mem_if."+self.lnames[ii]+"_rd_valid "+"["+str(tt)+"]         >> "+self.lnames[ii]+tempvar+"_rd_valid\n",
                        clr_on_rst_txt,
                        "                                             >> "+self.lnames[ii]+tempvar+"_ecc_uncor_err\n",
                        "1'b0                                         >> "+self.lnames[ii]+tempvar+"_mem_ls_enter\n",
                        "\n"
                        ]
    
                        if (self.ram_type[ii]=="1r1w"):
                            tempText = WrapperText1r1w
                        elif(self.ram_type[ii]=="1rw"):
                            tempText = WrapperText1rw
                        else:
                            tempText =""
                            print("Review logical file on RAM port")
                        wrapperfile.writelines(tempText)
                        tempText=""
                EndingText =[  
                "1'b0 >> "+self.module_name.upper()+"_ECC_COR_ERR_reg_sel\n",
                "1'b0 >> "+self.module_name.upper()+"_ECC_UNCOR_ERR_reg_sel\n",
                "\n",
                "1'b1 >> unified_regs_rd\n",
                "'h0  >> unified_regs_wr_data\n",
                "     >> "+self.module_name+"_ecc_int\n",
                "     >> "+self.module_name+"_init_done\n",
                "     >> unified_regs_ack\n",
                "     >> unified_regs_rd_data\n",
                "\n",
                "cclk    >> clk\n",
                "reset_n >> reset_n\n"
                ]
                wrapperfile.writelines(EndingText)
    
    def createIFBase_f(self):
        if (self.num==0):
            L= len(self.lnames)
            for ii in range(L):
                self.name_if.append("mby_mem_"+self.ram_type[ii]+"_if.mem       "+self.lnames[ii]+"_if,\n")
        else:
            self.name_if.append("mby_"+self.module_name+"_memory_if.mem      "+self.module_name+"_mem_if,\n")
    
    def createBasefile(self):
        with io.open(self.basePath,"w") as basefile:
            textfile0 = [
            "// -- Author       : Autogenerated via MPGEN    \n",
            "// -- Project Name : MBY\n",
            "// -- Description  : "+self.module_name+" memory wrapper netlist.\n"
            "// -------------------------------------------------------------------\n",
            "ngen_mod_name \n",
            "input reset_n, \n",
            "\n"
            ]
            textfile1 = [
            "\n",
            "ngen_IO_list\n",
            "ngen_IO_end\n",
            "\n",
            "ngen_wires\n",
            "\n",
            "ngen_submodules\n",
            "\n",
            "ngen_endmodule\n"] # First part of script
            basefile.writelines(textfile0)
            basefile.writelines(self.name_if)
            basefile.writelines(textfile1)
    
    def createMakefile(self,makeText):
        with io.open(self.make_path,"w") as makefile:
            textfile=[ "BLOCK       = mby_$(PAR)_gen_mem\n",
            "DIFF        = $(if $(DISPLAY),tkdiff,diff -w)\n",
            "NGEN        = /p/hdk/rtl/proj_tools/sl2_tools/latest/scripts/ngen_i/ngen_i.pl\n",
            "NGEN_FLAGS  = -fi=INTCNOPWR\n",
            "V2BBOX      = /p/hdk/rtl/proj_tools/sl2_tools/latest/scripts/v2bbox.pl\n",
            "\n",
            "V_DIRS      = -d=../rtl\n",
            "V_LIBS      =\n",
            "MGM_RUN     = $(MODEL_ROOT)/target/mby/mgm_run\n",
            "\n",
            ".PHONY: ngen pre top rtl copy clean diff\n",
            "\n",
            "ngen: clean pre top\n",
            "\n",
            "pre:\n",
            "	./pre_process.pl\n",
            "	$(V2BBOX) -v $(PAR)_shells_wrapper_inc.v -n $(PAR)_shells_wrapper -p $(MGM_RUN)/$(PAR)/src,$(MGM_RUN)/rtl -o $(PAR)_shells_wrapper.v\n"]
            textfile1=[
            "\n",
            "top: pre\n",
            "	@$(NGEN) $(NGEN_FLAGS) $(V_DIRS) $(V_LIBS) $(BLOCK)\n",
            "	rm -f *.v\n",
            "\n",
            "rtl copy:\n",
            "	cp ngen/$(BLOCK).sv ../rtl/$(BLOCK).sv\n",
            "\n",
            "clean:\n",
            "	@echo \"Cleaning $(BLOCK)\"\n",
            "	@rm -rf $(wildcard ngen *.v *.sv *.tmp)\n",
            "\n",
            "diff:\n",
            "	@echo \"Making a difference...\" # one byte at a time\n",
            "	$(DIFF) ../rtl/$(BLOCK).sv ngen/$(BLOCK).sv\n"
            ]
            makefile.write("PAR         = "+self.module_name+"\n")
            makefile.writelines(textfile)
            makefile.writelines(makeText)
            makefile.writelines(textfile1)

    def main (self,argv):
        #cli= argparse.ArgumentParser()
        #cli.add_argument (
        #"--par_name",
        #nargs=1,
        #type = str,
        #default ="par0",
        #)
        #cli.parse_args(["--par_name", 'FOO'])
        #print ("parname:"+par_name)
        #cli.add_argument (
        #"--list3",
        #nargs="*",
        #type = str,
        #default =[],
        #)
        
        try:
            opts, argv =getopt.getopt(argv, "h:if", ["help","if"])
        except getopt.GetoptError as err:
            print (str(err))
            print("Memory partition generator\n")
            print("Syntaxis: \n")
            print("python3.5.1 mpgen.py <partition name> <list of clients/logicals> [opts]\n")
            print("-h   help\n")
            print("-if  Creation of client interfaces \n")
            sys.exit(2)
        for opt, a in opts:
            if opt == "-h":
                print("python3.5.1 mpgen.py <partition name><list of clients/logicals>[opts]\n")
                sys.exit()
            elif opt in ("-if"):
                self.num            = 1 
        
        self.module_name    = argv[0] # Partition name
        #self.client_list    = argv[1] # client list
        #self.logical_list   = argv[2] # Logicals related to clients
        self.ConfigDirs()
        print("## Current directory:%s"% self.path,"\n")
        print ("Memory Wrapper Generator of partition"+str(argv[0])+"\n")
        print("## MGM PAR reports dir:",self.rpt_path,"\n")
        try:      
            os.makedirs(self.ngen_path)
        except OSError:  
            print ("## Creation of the directory %s failed" % self.ngen_path)
        else:  
            print ("## Successfully created the directory %s" % self.ngen_path)
    
        for filename in os.listdir(self.mem_dir):
            if (filename.endswith(".logical")):
                filename_c=os.path.join(self.mem_dir,filename)
                P_logicalname = r"(.+).logical"
                LnameMatched   = re.search(P_logicalname,filename) # Search for logical name
                self.lnames.append(LnameMatched.group(1))
                with io.open(filename_c, "r") as logical:
                    data=logical.read(1000) # Reduce the amount of read lines
                    P_RamPorts      = r"Ram Ports.+=[\s\t]*(1r1w|1rw|2r2w)"
                    P_Lines         = r"Ram Lines Number.+=[\s\t]*(\d{1,9})"
                    P_DataW         = r"Ram Data Width.+=[\s\t]*(\d{1,9})"
                    P_WrRes         = r"Ram Write Resolution.+=[\t\s]*(\d{1,9})"
                    P_Insta         = r"Memory Instances.+=[\s\t]*(\d{1,9})"
                    P_reset         = re.compile(r"Ram Clear-On-Reset.+=[\s\t]*(Yes|No|Number|LL)", re.I)
                    PortsMatched   = re.search(P_RamPorts,data) # Search for ports types
                    LinesMatched   = re.search(P_Lines,data) # Search for number of lines
                    DataWMatched   = re.search(P_DataW,data) # Search for number of lines
                    WrResMatched   = re.search(P_WrRes,data) # Search for number of lines
                    InstaMatched   = re.search(P_Insta,data) # Search for number of lines
                    resetMatched   = re.search(P_reset,data) # Search for number of lines
                    #print ("ResetData:"+ resetMatched.group(1)+"  "+filename)
                    if ( (resetMatched.group(1).lower() == "yes") ):
                        self.clr_onrst.append(1)
                        #print ("Enter append 1 clear on reset")
                    else:
                        self.clr_onrst.append(0)
                        #print ("Enter append 0 clear on reset")

                    if (WrResMatched is not None):
                        if (WrResMatched.group(1)==DataWMatched.group(1)):
                            self.ram_wrres.append(0)
                        else:
                            self.ram_wrres.append(1)
                    else:
                            self.ram_wrres.append(0)
                    self.ram_type.append(PortsMatched.group(1))
                    self.ram_deep.append(LinesMatched.group(1))
                    self.ram_wdata.append(DataWMatched.group(1))
                    self.ram_winst.append(InstaMatched.group(1))
            else:
                print ("WARNING: file "+filename+" is not a logical file\n")
            #TextList = parsingImplemReport(module_name, self.rpt_path, self.hier_path, self.prep_path, self.ff_path, self.rf_path, self.sr_path)
        #print("Clear on reset values"+self.clr_onrst)
        TextList = self.parsingImplemReport()
        st = os.stat(self.prep_path)
        os.chmod(self.prep_path, st.st_mode | stat.S_IEXEC)
        self.createIFBase_f()
        self.createSigFile()
        self.create_MapFileForShellsWrapper()
        self.createMakefile(TextList)
        time.sleep(0.2)
        self.createBasefile() 
        self.create_if_include()
        os.chdir(self.ngen_path)
        print("## Running Make in ngen directory ##\n")
        os.system("make")
    def __del__(self):
        print ("End of Script")


if __name__== "__main__":
    obj = mpgen()
    obj.main(sys.argv[1:])


<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>



// EM_B_HASH_LOOKUP[0..8191]

reg em_b_hash_lookup_r {
  shared;
  HandCoded = true;
  name = "FFU hashing buckets.";
  desc = "
  In single lookup mode, there is one table using 8K buckets.
  In split-4K lookup mode,
  [list]
  [*] LOOKUP0 = EM_B_LOOKUP[0..4095]
  [*] LOOKUP1 = EM_B_LOOKUP[4096..8192]
  [/list]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RW";
    desc = "
    ptr*4 is the byte-location of the bucket's first entry in Hash Entry RAM.

           ";
    ValRandomize = true;
  } PTR[83:64] = 20'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } RSVD1_[63:52] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_4[51:48] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_3[47:44] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_2[43:40] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_1[39:36] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects 'more' hash bits.
    * bucket_hash[i] = more_hash[select[i]]

           ";
    ValRandomize = true;
  } SELECT_0[35:32] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    selects which bucket_hash values have entries.

           ";
    ValRandomize = true;
  } MASK[31:0] = 32'h0;
};



// EM_B_HASH_CAM[0..31,0..7]

reg em_b_hash_cam_r {
  shared;
  HandCoded = true;
  name = "CAM entries for hash overflow.";
  desc = "
  The second index is the entry number, and the third index
  is the word number. The entry format is big-endian. Byte 0 is bits 63..56 of word 0.
  [br][br]
  In 64B entry mode, the entry is 64 bytes wide.
  In 64B mode there is a single action resolution and the 1-2 actions from
  the highest-numbered matching entry are used.
  To form a 64B entry, a key 56B or less is padded with 0s to 56B and followed by two actions.
  In the case of a 60B key, there is only 1 action at EM_B_HASH_CAM[group][rule][7][31:0].
  [br][br]
  In 32B entry mode, EM_B_HASH_CAM[group][rule][0..3] is the row0 entry,
  and EM_B_HASH_CAM[group][rule][4..7] is the row1 entry. The two rows are resolved
  independently: the 1-2 actions from the highest-numbered matching entry within each row
  are used. To form a 32B entry, a key 24B or less is padded with 0s to 24B and followed
  by two actions. In the case of a 28B key in 32B mode, there is only 1 action.
  [br][br]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } DATA[63:0] = 64'h0;
};
regfile em_b_hash_cam_rf {
  em_b_hash_cam_r EM_B_HASH_CAM[8] += 8;
};



// EM_B_HASH_CAM_EN[0..1,0..31]

reg em_b_hash_cam_en_r {
  shared;
  HandCoded = true;
  name = "Select EM_B_HASH_CAM scenarios.";
  desc = "
  When EM_B_HASH_CAM_EN[group][row][rule].mask[s] is set, then
  EM_B_HASH_CAM[group][rule][row*4 +: 4] is used in scenario s.
  [br][br]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Select scenarios for this rule. Uses little-endian bit numbering.

           ";
    ValRandomize = true;
  } MASK[63:0] = 64'h0;
};
regfile em_b_hash_cam_en_rf {
  em_b_hash_cam_en_r EM_B_HASH_CAM_EN[32] += 8;
};



// EM_B_KEY_SEL0[0..1,0..63]

reg em_b_key_sel0_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.
  [br][br]
  This register is indexed first by hash number 0..1, then by scenario.
  [br][br]
  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  [br][br]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key8s to participate in hashing and matching. 
     Key8Mask[i] selects key8[i].

           ";
    ValRandomize = true;
  } KEY8_MASK[31:0] = 32'h0;
};
regfile em_b_key_sel0_rf {
  em_b_key_sel0_r EM_B_KEY_SEL0[64] += 8;
};



// EM_B_KEY_SEL1[0..1,0..63]

reg em_b_key_sel1_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how the FFU Group Hash hashes (hash0,hash1) should be calculated.
  [br][br]
  This register is indexed first by hash number 0..1, then by scenario.
  [br][br]
  Before matching, the selected (Key32, Key16, Key8) are compacted
  in big endian form. If the result is an odd number of bytes,
  a padding 0 byte is added.
  [br][br]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Selects one of 16 128 bit masks stored in EM_B_KEY_MASK to 
     apply to the key during comparison.
           ";
    ValRandomize = true;
  } KEY_MASK_SEL[51:48] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key32s to participate in hashing and matching. 
     Key32Mask[i] selects key32[i].

           ";
    ValRandomize = true;
  } KEY32_MASK[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects FFU key16s to participate in hashing and matching. 
     Key16Mask[i] selects key16[i].

           ";
    ValRandomize = true;
  } KEY16_MASK[31:0] = 32'h0;
};
regfile em_b_key_sel1_rf {
  em_b_key_sel1_r EM_B_KEY_SEL1[64] += 8;
};



// EM_B_KEY_MASK[0..1,0..31]

reg em_b_key_mask_r {
  shared;
  HandCoded = true;
  name = "Hash key bit mask";
  desc = "
  Provides a 128 bit hash key mask for each of 16 hash key profiles.
  Indexed first by hash number, then by:
  [code]
  (KEY_MASK_SEL * 2) + DW
  where there are 2 DWs per profile (128 bits)
  [/code]
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     64 of the 128 bits in the mask.
     Indicates which bits are included in the hash calculation.

           ";
    ValRandomize = true;
  } MASK[63:0] = 64'h0;
};
regfile em_b_key_mask_rf {
  em_b_key_mask_r EM_B_KEY_MASK[32] += 8;
};




// EM_B_HASH_MISS[0..1,0..63]

reg em_b_hash_miss_r {
  shared;
  HandCoded = true;
  name = "Provides two hash-miss actions for each hashtable row.";
  desc = "
  EM_B_HASH_MISS[r][scenario] provides 2 actions for row r=0..1.
  [br][br]
  If there is no key match in ENTRY_RAM or CAM, then both actions are taken.
  The format of the action is the same as EM_B_ACTION,
  HASH_ENTRY_RAM, and EM_B_HASH_CAM.
  [br][br]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION0[31:0] = 32'h0;
};
regfile em_b_hash_miss_rf {
  em_b_hash_miss_r EM_B_HASH_MISS[64] += 8;
};



// EM_B_HASH_CFG[0..63]

reg em_b_hash_cfg_r {
  shared;
  HandCoded = true;
  name = "Configure FFU hashing";
  desc = "
  This register is indexed by the scenario.
  [br][br]
  Noted that per-group above explicitly implies only FFU groups 0..1.  
  While these registers exist for FFU group 2, none of them should be 
  written by software and should be considered reserved
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Define lookup (or entry) modes : split 4K (0) or one 8K (1).
                                      32B      (0) or 64B    (1).

           ";
    ValRandomize = true;
  } MODE[46:46] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Start of hash table.
     Must be a multiple of 2^hash_size[ROW].

           ";
    ValRandomize = true;
  } BASE_PTR_0[45:33] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     Start of hash table.
     Must be a multiple of 2^hash_size[ROW].

           ";
    ValRandomize = true;
  } BASE_PTR_1[32:20] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of hash bits to use in lookup address calculation.

     * lookup_ptr = base_ptr[ROW] + hash % 2^hash_size[ROW]

     For example, hash_size=10 yields a table with 1024 buckets.

           ";
    ValRandomize = true;
  } HASH_SIZE_0[19:15] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of hash bits to use in lookup address calculation.

     * lookup_ptr = base_ptr[ROW] + hash % 2^hash_size[ROW]

     For example, hash_size=10 yields a table with 1024 buckets.

           ";
    ValRandomize = true;
  } HASH_SIZE_1[14:10] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Size of each entry, given as a multiple of 4B.
     The entry size must be a multiple of 4 in the range 8..64.
     The entry bytes following the padded key are actions.

     Set entry_size[r]==0 to disable row r lookups in this scenario.

           ";
    ValRandomize = true;
  } ENTRY_SIZE_0[9:5] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
     Size of each entry, given as a multiple of 4B.
     The entry size must be a multiple of 4 in the range 8..64.
     The entry bytes following the padded key are actions.

     Set entry_size[r]==0 to disable row r lookups in this scenario.

           ";
    ValRandomize = true;
  } ENTRY_SIZE_1[4:0] = 5'h0;
};

// WCM_TCAM[0..19,0..1023]

reg wcm_tcam_r {
  shared;
  HandCoded = true;
  name = "Configures an entry in a slice's key TCAM";
  desc = "
    Configures an entry in the TCAM. 
    [br][br] 
    A match occurs when the data searched is equal to the content, as defined
    in the table below.
    [br][br] 
    A key is loaded by writing the key into 'Key' (KEY / KEY_TOP) and loading its 1s
    compliment in KeyInvert (KEY_INVERT / KEY_TOP_INVERT). Writing both 'Key' and 'KeyInvert' with 1
    on same bit in both fields will invalidate the entry while writing
    0 on same bit in both field is equivalent of ignoring this bit in
    the seach.
    [br][br] 
    The table below shows the encoded data value stored (Content)
    based on the Key and KeyInvert values.

    [code]
          +-----------------------------------------------------+
          | KeyInvert    | Key          |        Content        |
          =======================================================
          |      0       |      0       |   X (always match)    |
          +-----------------------------------------------------+
          |      0       |      1       |           1           |
          +-----------------------------------------------------+
          |      1       |      0       |           0           |
          +-----------------------------------------------------+
          |      1       |      1       | Always mismatch state |
          +-----------------------------------------------------+
    [/code]

    The highest index has precedence in case there is more than one match in
    the same slice.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } _RSVD1_[127:104] = 24'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY_TOP_INVERT[103:96] = 8'hff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY_INVERT[95:64] = 32'hffffffff;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } _RSVD0_[63:40] = 24'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY_TOP[39:32] = 8'hff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY[31:0] = 32'hffffffff;
};
regfile wcm_tcam_rf {
  wcm_tcam_r WCM_TCAM[1024] += 16;
};



// WCM_ACTION[0..19,0..1023]

reg wcm_action_r {
  shared;
  HandCoded = true;
  name = "Configures an entry in action RAM";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION0[31:0] = 32'h0;
};
regfile wcm_action_rf {
  wcm_action_r WCM_ACTION[1024] += 8;
};



// WCM_TCAM_CFG[0..15,0..63]

reg wcm_tcam_cfg_r {
  shared;
  HandCoded = true;
  name = "Configures TCAM slice";
  desc = "
    Configure each slice behavior for each scenario.
    This register is indexed first by slice, then by scenario.
    It provides configuration for the cascading and mux selection. 
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Specifies the validity of 64-rule chunks.  ChunkMask[0] enables rules 0..63,
        ChunkMask[1] enables rules 64..127, etc.  Used to create smaller per-scenario tables.       

           ";
    ValRandomize = true;
  } CHUNK_MASK[51:36] = 16'hffff;
  field {
    AccessType = "RW";
    desc = "
        Starts a compare cascade

           ";
    ValRandomize = true;
  } START_COMPARE[35:35] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Starts an exclusion set

           ";
    ValRandomize = true;
  } START_SET[34:34] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Selects KEY8[SelectTop] as the top 8 bits of the lookup key. Only KEY8s can be selected
        for this field.

           ";
    ValRandomize = true;
  } SELECT_TOP[33:28] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
         Selects byte 0 of the lookup key. 
         [list]
         [*] If Select0 is in the range of 0-31, then the value is KEY16[Select0][7:0]. 
         [*] If Select0 is in the range of 32-95, then the value is KEY8[Select0 - 32]. 
         [*] If Select0 is in the range of 96-111, then the value is KEY32[Select0 - 96][7:0].
         [/list]

           ";
    ValRandomize = true;
  } SELECT0[27:21] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Selects byte 1 of the lookup key.
        [list]
        [*] If Select1 is in the range of 0-31, then the value is KEY16[Select1][15:8]. 
        [*] If Select1 is in the range of 32-95, then the value is KEY8[Select1 - 32]. 
        [*] If Select1 is in the range of 96-111, then the value is KEY32[Select1 - 96][15:8].
        [/list]

           ";
    ValRandomize = true;
  } SELECT1[20:14] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Selects byte 2 of the lookup key.
        [list]
        [*] If Select2 is in the range of 0-31, then the value is KEY16[Select2][7:0]. 
        [*] If Select2 is in the range of 32-95, then the value is KEY8[Select2 - 32]. 
        [*] If Select2 is in the range of 96-111, then the value is KEY32[Select2 - 96][23:16].
        [/list]

           ";
    ValRandomize = true;
  } SELECT2[13:7] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Selects byte 3 of the lookup key.
        [list]
        [*] If Select3 is in the range of 0-31, then the value is KEY16[Select3][15:8]. 
        [*] If Select3 is in the range of 32-95, then the value is KEY8[Select3 - 32]. 
        [*] If Select3 is in the range of 96-111, then the value is KEY32[Select3 - 96][31:24].
        [/list]

           ";
    ValRandomize = true;
  } SELECT3[6:0] = 7'h0;
};
regfile wcm_tcam_cfg_rf {
  wcm_tcam_cfg_r WCM_TCAM_CFG[64] += 8;
};



// WCM_ACTION_CFG[0..63]

reg wcm_action_cfg_r {
  shared;
  HandCoded = true;
  name = "Configures action RAM source.";
  desc = "
  This register is indexed by scenario.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_19[99:99] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_18[98:98] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_17[97:97] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_16[96:96] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_15[95:95] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_14[94:94] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_13[93:93] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_12[92:92] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_11[91:91] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_10[90:90] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_9[89:89] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_8[88:88] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_7[87:87] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_6[86:86] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_5[85:85] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_4[84:84] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_3[83:83] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_2[82:82] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_1[81:81] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE_0[80:80] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_19[79:76] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_18[75:72] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_17[71:68] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_16[67:64] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_15[63:60] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_14[59:56] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_13[55:52] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_12[51:48] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_11[47:44] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_10[43:40] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_9[39:36] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_8[35:32] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_7[31:28] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_6[27:24] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_5[23:20] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_4[19:16] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_3[15:12] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_2[11:8] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_1[7:4] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.

           ";
    ValRandomize = true;
  } INDEX_0[3:0] = 4'h0;
};

reg wcm_ip_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  name = "WCM IP register";
  desc = "WCM Interrupt Pending Register";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for correctable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_C_ERR[15:12] = 4'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for uncorrectable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_U_ERR[11:8] = 4'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for errors set in FGHASH_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGHASH_ERR[7:5] = 3'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for errors set in FGRP_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGRP_ERR[4:2] = 3'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bit, for error set in WCM_SWEEPER/WCM_SWEEP_ERR register.
           ";
    ValRandomize = true;
  } TCAM_SWEEP_ERR[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bit, for error set in FCMN_SHELL_CTL register.
           ";
    ValRandomize = true;
  } FCMN_SHELL_CTRL_ERR[0:0] = 1'h0;
};

reg wcm_im_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  name = "WCM IM register";
  desc = "Selects WCM Interrupt Mask Bits";
  regwidth = 64;
  accesswidth = 64;

  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for correctable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_C_ERR[15:12] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for uncorrectable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_U_ERR[11:8] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for errors set in FGHASH_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGHASH_ERR[7:5] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for errors set in FGRP_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGRP_ERR[4:2] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bit, for error set in WCM_SWEEPER/WCM_SWEEP_ERR register.
           ";
    ValRandomize = true;
  } TCAM_SWEEP_ERR[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bit, for error set in FCMN_SHELL_CTL register.
           ";
    ValRandomize = true;
  } FCMN_SHELL_CTRL_ERR[0:0] = 1'h0;
};

addrmap mby_ppe_cgrp_b_nested_map {
  name = "mby_nested_b";
  desc = "Classifier group B registers";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  em_b_hash_lookup_r          EM_HASH_LOOKUP[8192];
  wcm_tcam_rf                 WCM_TCAM[20]          ;
  wcm_action_rf               WCM_ACTION[24]        ;
  wcm_tcam_cfg_rf             WCM_TCAM_CFG[20]      ;
  wcm_action_cfg_r            WCM_ACTION_CFG[64]    ;
  wcm_ip_r                    WCM_IP                ;
  wcm_im_r                    WCM_IM                ;
};


addrmap mby_ppe_cgrp_b_map {
  name = "mby_em";
  desc = "Classifier group B registers";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  mby_ppe_cgrp_em_map         EM;
  mby_ppe_cgrp_b_nested_map   B;
}; // final size: 0x22600 <= 0x40000 = 8<<15

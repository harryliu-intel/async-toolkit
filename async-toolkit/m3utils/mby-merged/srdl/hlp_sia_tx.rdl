//------------------------------------------------------------------------------
//
//  INTEL CONFIDENTIAL
//
//  Copyright 2006 - 2015 Intel Corporation All Rights Reserved.
//
//  The source code contained or described herein and all documents related 
//  to the source code ("Material") are owned by Intel Corporation or its
//  suppliers or licensors. Title to the Material remains with Intel
//  Corporation or its suppliers and licensors. The Material contains trade
//  secrets and proprietary and confidential information of Intel or its
//  suppliers and licensors. The Material is protected by worldwide copyright
//  and trade secret laws and treaty provisions. No part of the Material may
//  be used, copied, reproduced, modified, published, uploaded, posted, 
//  transmitted, distributed, or disclosed in any way without Intel's prior
//  express written permission.
//
//  No license under any patent, copyright, trade secret or other intellectual
//  property right is granted to or conferred upon you by disclosure or
//  delivery of the Materials, either expressly, by implication, inducement,
//  estoppel or otherwise. Any license under such intellectual property rights
//  must be express and approved by Intel in writing.
//
//------------------------------------------------------------------------------
// -- Authors      : George Guo, Mike Mangione
// -- Project Name : Highland Park IP for Snow Ridge
// -- Description  : This is RDL for the Segment Interface Adapter (SIA) block.
//------------------------------------------------------------------------------

`include "hlp_udp.rdl"
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

//  $SIA_NUM_QUEUES = 8;
//  $SIA_NUM_PORTS  = 4;
//  $SIA_SCRATCH_DFT = 0xaaaa5555;

reg sia_tx_ctl_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;

  name = "SIA Tx Control Register.";
  desc = "This is Tx control register."; 

  regwidth    = 64;
  accesswidth = 64;

  field {
    AccessType = "RO/V";
    desc = "When high, this bit indicates the switch clock domain logic in SIA Tx has come out of reset. 
            When low, the switch clock domain is in reset.";
    ValRandomize = false;
  } TX_SWITCH_READY[8:8] = 1'h1;

  field {
    AccessType = "RW";
    desc = "This controls the minimum level width of signals crossing from port clock domain to switch clock domain. 
            The value is in number of cycles of port clock and should be an integer greater than (Fport_clk/Fswitch_clk) x 1.5. 
            The default value is suitable for Fport_clk = 800MHz, and Fswitch_clk = 850-300MHz.";
    ValRandomize = true;
  } TX_MIN_SYNC_CYCLES[6:4] = 3'h4;

  field {
    AccessType = "RW";
    desc = "This controls the arbitration mode for requrests of TxPktRAM memory reads 
            from the four ports in an SIA. 2'b00: Strict Priority, 2'b01: Rotating Priority, 
            2'b10: Round Robin.";
    ValRandomize = true;
  } TX_MEM_RD_ARB_MODE[1:0] = 2'h2;
}; // sia_tx_ctl_r

reg sia_tx_port_ctl_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;

  name = "SIA Tx Per-port Control Register.";
  desc = "This is Tx per-port control register."; 

  regwidth    = 64;
  accesswidth = 64;

  field {
    AccessType = "RW";
    desc = "This is a scratch register which can be written or read for diagnostic purpose.";
    ValRandomize = true;
  } DIAGNOSE_RSVD[31:24] = 8'ha5;

  field {
    AccessType = "RW";
    desc = "This bit enables SIA Tx operation for this port. Before enabled, the port must have been
            allocated space in the Tx Packet RAM by configuring the boundary register. If the boundary 
            register needs to be changed on the fly, it's required to ensure no traffic on the datapath
            and this bit must be set to 0 first.";
    ValRandomize = true;
  } SIA_TX_EN[16:16] = 1'h0;

  field {
    AccessType = "RW";
    desc = "The rising edge of this bit enables SIA Tx clear credit process, 
            which sends clear command for at least 16 continuous cycles to ESCHED for this port.
            This bit has higher priority than init_credit bit.";
    ValRandomize = true;
  } CLEAR_CREDIT[12:12] = 1'h0;

  field {
    AccessType = "RO/V";
    desc = "When set, this bit indicates the credit initialization process has completed. 
            The rising edge of init_credit resets this bit to 0.";
    ValRandomize = false;
  } INIT_CREDIT_DONE[9:9] = 1'h0;

  field {
    AccessType = "RW";
    desc = "The rising edge of this bit enables SIA Tx credit initialization process, 
            which sends the number of credits specified in init_credit_value field to ESCHED for this port.";
    ValRandomize = true;
  } INIT_CREDIT[8:8] = 1'h0;

  field {
    AccessType = "RW";
    desc = "This is the number of credits being sent to ESCHED during the credit initialization process. 
            This value should not be more than the equivalent value of TxRAM space allocated to this port
            by the upper/lower boundary register. Otherwise, the less value of credits will be sent to ESCHED.";
    ValRandomize = true;
  } INIT_CREDIT_VALUE[5:0] = 6'h00;
}; // sia_tx_port_ctl_r

reg sia_tx_port_mem_bound_ptr_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;

  name = "SIA Tx Per-port Memory Boundary and Pointer Register.";
  desc = "This is Tx per-port Tx Packet RAM memory upper/low boundary and Read/Write pointer register. 
          The port_en bit in Port Control register is required to toggle whenever a boundary is changed."; 

  regwidth    = 64;
  accesswidth = 64;

  field {
    AccessType = "RO/V";
    desc = "Pointer for this port to read Tx Packet RAM.";
    ValRandomize = false;
  } READ_POINTER[53:48] = 6'h00;

  field {
    AccessType = "RO/V";
    desc = "Pointer for this port to write Tx Packet RAM.";
    ValRandomize = false;
  } WRITE_POINTER[37:32] = 6'h00;

  field {
    AccessType = "RW";
    desc = "Upper bound of a space in the Tx Packet RAM this port would use. This port should be disabled
            by port_en = 0 whenever this boundary needs to be changed.";
    ValRandomize = true;
  } UPPER_BOUND[21:16] = 6'h00;

  field {
    AccessType = "RW";
    desc = "Lower bound of a space in the Tx Packet RAM this port would use. This port should be disabled
            by port_en = 0 whenever this boundary needs to be changed.";
    ValRandomize = true;
  } LOWER_BOUND[5:0] = 6'h00;
}; // sia_tx_port_bound_ptr_r

reg sia_tx_port_jitter_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;

  name = "SIA Tx Per-port Jitter Timer Control Register.";
  desc = "This is Tx per-port jitter timer control register. It configures 
          the number of switch_clk cycles that must elapse after SOP received 
          before the packet can be sent to MAC. The number of elapsed cycles is calculated by 
          jitter_base - {sop_seg_len[8:4] * jitter_multiplier, 4'b0} >> jitter_r_shift. 
          If EOP is received before the timer time-out, the pacekt will be sent to MAC immediately."; 

  regwidth    = 64;
  accesswidth = 64;

  field {
    AccessType = "RW";
    desc = "This configures the value of the right-shift.";
    ValRandomize = true;
  } JITTER_R_SHIFT[26:24] = 3'h0; 

  field {
    AccessType = "RW";
    desc = "This configures the value of the mulitplier.";
    ValRandomize = true;
  } JITTER_MULTIPLIER[20:16] = 5'h0; 

  field {
    AccessType = "RW";
    desc = "This configures the base jitter value for calculation of jitter timer value. The value is in 
            the number of switch_clk cycles.";
    ValRandomize = true;
  } JITTER_BASE[13:0] = 14'h0; 
}; // sia_tx_port_jitter_r

reg sia_ip_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Interrupt pending.";
  desc = "Interrupt pending register for SIA.";

  regwidth    = 64; 
  accesswidth = 64; 

  field {
    AccessType = "RW/1C/V";
    desc = "SIA RX runt.  Indicates when an rx port recieves a packet that is <= 16 bytes.  A status field, RX_RUNT_RCVD, is included in the IARB_TOKEN_RATE register to indicte which port received the runt packet. ";
    ValRandomize = true;
  } SIA_RX_RUNT[22:22] = 1'h0;

  field {
    AccessType = "RW/1C/V";
    desc = "This bit is the status for ECC interrupt from memory shell controller. ";
    ValRandomize = true;
  } MEM_ECC_ERR[21:21] = 1'h0;

  field {
    AccessType = "RW/1C/V";
    desc = "Each bit corresonds to rx queues 7:0.  For each queue that is configured as lossless (SIA_RX_Q_CFG.lossless_en is set), this interrupt occurs if an incoming packet is dropped or truncated.  In such a case, the corresponding SIA_RX_Q_OVERRUN register keeps counts of the number of packets dropped/truncated.  For the even numbered queues, this interrupt also occurs if a buffer is dropped from the tail of the queue because the corresponding port's buffer allocation limit (SIA_RX_PORT_CFG) is reached.  In such a case, the corresponding SIA_RX_PORT_TD register keeps counts of the number of buffers/packets dropped.";
    ValRandomize = true;
  } SIA_RX_INT[20:13] = 8'h00;

  field {
    AccessType = "RW/1C/V";
    desc = "Each bit is the status for overflow of allocated TxRAM space for each port in SIA Tx. If the overflow happened in a port, it would not be recoverable automatically and a reset or reconfiguring the related port should be done to bring the logic back to normal mode.";
    ValRandomize = true;
  } SIA_TX_INT[12:9] = 4'h0;

  field {
    AccessType = "RW/1C/V";
    desc = "This bit is asserted if SIA Tx receives more than one ripple segment within 2 switch clock cycles. ";
    ValRandomize = true;
  } RIPPLE_TOO_FAST[8:8] = 1'h0;

  field {
    AccessType = "RW/1C/V";
    desc = "Bits [7:4] are for status of each port's missing EOP on ripple, and bits [3:0] are for status of each port's missing SOP on ripple. If any of these events happened in a port, it would not be recoverable automatically and a reset or reconfiguring the related port should be done to bring the logic back to normal mode.";
    ValRandomize = true;
  } SIA_TX_TAP_INT[7:0] = 8'h00;
};

reg sia_im_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Interrupt mask.";
  desc = "The interrupt mask register controls if the corresponding interrupt
          source is presented to the interrupt hierarchy (bit is set to 0) or
          masked out (bit is set to 1).";

  regwidth    = 64; 
  accesswidth = 64; 

  field {
    AccessType = "RW";
    desc = "This bit is the mask for the SIA RX runt interrupt in SIA IP register. ";
    ValRandomize = true;
  } SIA_RX_RUNT[22:22] = 1'h1;

  field {
    AccessType = "RW";
    desc = "This bit is the mask for the ECC interrupt in SIA IP register. ";
    ValRandomize = true;
  } MEM_ECC_ERR[21:21] = 1'h1;

  field {
    AccessType = "RW";
    desc = "These bits are the masks for the SIA Rx queue interrupts in SIA IP register. ";
    ValRandomize = true;
  } SIA_RX_INT[20:13] = 8'hff;

  field {
    AccessType = "RW";
    desc = "These bits are the masks for the SIA Tx interrupts in SIA IP register. ";
    ValRandomize = true;
  } SIA_TX_INT[12:9] = 4'hf;

  field {
    AccessType = "RW";
    desc = "This bit is the mask for the ripple_too_fast interrupt in SIA IP register. ";
    ValRandomize = true;
  } RIPPLE_TOO_FAST[8:8] = 1'h1;

  field {
    AccessType = "RW";
    desc = "These bits are the masks for the SIA Tx Tap interrupts in SIA IP register. ";
    ValRandomize = true;
  } SIA_TX_TAP_INT[7:0] = 8'hff;
};

regfile sia_tx_port_ctl_rf {
  sia_tx_port_ctl_r SIA_TX_PORT_CTL[4] += 8;
};

regfile sia_tx_port_mem_bound_ptr_rf {
  sia_tx_port_mem_bound_ptr_r SIA_TX_PORT_MEM_BOUND_PTR[4] += 8;
};

regfile sia_tx_port_jitter_rf {
  sia_tx_port_jitter_r SIA_TX_PORT_JITTER[4] += 8;
};


addrmap hlp_SIA_TX_map {
  name = "hlp_SIA_TX";
  desc = "SIA TX Registers";
  addressing = fullalign;
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary=true;
  ArrayedMaps = 8;
  AddressBits = 9;
  ResetDomains = "PORTS,MGMT";

  sia_tx_port_ctl_rf            SIA_TX_PORT_CTL         ;
  sia_tx_port_mem_bound_ptr_rf  SIA_TX_PORT_BOUND_PTR   @0x0000040;
  sia_tx_port_jitter_rf         SIA_TX_PORT_TIMER       @0x0000080;
  sia_tx_ctl_r                  SIA_TX_CONTROL          @0x00000C0; 
  sia_ip_r                      SIA_IP                  @0x00000D0; 
  sia_im_r                      SIA_IM                  @0x00000D8; 
}; // SIA_TX_map



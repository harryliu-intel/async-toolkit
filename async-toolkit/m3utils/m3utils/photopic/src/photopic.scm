(require-modules "display" "m3")

;;
;; code to compute energy content of a few types of visible light
;;
;; Mika Nystrom <mika@alum.mit.edu> January 2023
;;
;; This code is meant to interface with Modula-3 implementations
;; in the m3utils or cm3 repos.
;;

;;
;; some constants of nature
;; all units are SI base units unless otherwise noted
;;
(define c 299792458.0)       ;; speed of light in vacuum
(define h 6.62607015e-34)    ;; Planck's constant
(define k 1.380649e-23)      ;; Boltzmann's constant
(define pi (* 4 (atan 1)))   ;; the ratio of circumference to diameter of a circle  

(define l0 380e-9)           ;; blue limit of human vision 380nm
(define l1 770e-9)           ;; red limit of human vision  770nm
(define nu0 (/ c l0))        ;; frequency of blue
(define nu1 (/ c l1))        ;; frequency of red

(define (reload) (load "photopic.scm"))

;; the following from tfc-yield.scm
;; glue function to make it possible to pass Scheme functions into
;; Modula-3 code
(define (make-lrfunc-obj f)
  (let* ((func (lambda(*unused* x)(f x)))
         (min-obj (new-modula-object 'LRFunction.T `(eval . ,func) `(evalHint . ,func))))
    min-obj))

(define (make-lrvectorfield-obj f)
  (let* ((func (lambda(*unused* x)(f x)))
         (min-obj (new-modula-object 'LRVectorField.T `(eval . ,func) `(evalHint . ,func))))
    min-obj))

(define (unwrap-lrfunc lrf)
  (let ((w (obj-method-wrap lrf 'LRFunction.T)))
    (lambda(x) (w 'eval x))))
   
;; helper function to integrate a function
(define (integrate f a b)
  ;; integrate f from a to be in 2^lsteps
  (NR4p4.QromoMidpoint (make-lrfunc-obj f)
                       a
                       b))

(define (make-Bnu T)
  ;; B_nu(T) 
  ;; blackbody radiance per frequency
  (lambda(nu)(Blackbody.PlanckRadiance T nu)))

(define (make-Bl T)
  ;; blackbody radiance per wavelength
  (lambda(l)
    (let ((nu (/ c l)))
      (/ (Blackbody.PlanckRadiance T nu) (/  c (* nu nu))))))

(define (plot f a b fn . steps)
  ;; produce a file in gnuplot data format 
  ;; plot function f from a to b into file called fn
  (let* ((n (if (null? steps) 100 (car steps)))
         (step (/ (- b a) n))
         (wr (FileWr.Open fn))
         )
    (let loop ((p a))
      (if (< p b)
          (begin
            (Wr.PutText wr (string-append (stringify p)
                                          " "
                                          (stringify (f p))
                                          dnl))
            (loop (+ p step)))
          (Wr.Close wr)))))
    

(define (total-power-at-temp T)
  ;; integrate the power of a blackbody at temp T (per square meter?)
  (integrate (make-Bl T) (/ l0 10) (* l1 100)))

(define (visible-power-at-temp T)
  ;; integrate the power of a blackbody at temp T in the visible spectrum
  ;; per square meter?
  (integrate (make-Bl T)  l0 l1))

;; note that it doesn't really matter what the area is that we integrate over
;; since all we care about is the fraction of the light that is in a particular
;; wavelength range

(define (visible-fraction-at-temp T)
  (/ (visible-power-at-temp T) (total-power-at-temp T)))

(define (make-normal mu sigma)
  ;; a Gaussian that we can use for various test purposes
  (lambda (x)
    (let* ((factor (/ 1 (* sigma (sqrt (* 2 pi)))))
           (s     (/ (- x mu) sigma))
           (y      (exp (* -0.5 s s))))
      (* factor y))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; lumens per watt calcs
;;

(define (calc-lumens f)
  (define (integrand x)
    (* (f x) (CieSpectrum.PhotoConv x)))

  (integrate integrand l0 l1))

(define (visible-power f)
  (integrate f l0 l1))

(define (total-power f)
  (+ (integrate f (/ l0 10) l0)
     (visible-power f)
     (integrate f l1 (* l1 100))))

(define (visible-lumens-per-watt f)
  (/ (calc-lumens f)
     (visible-power f)))

(define (total-lumens-per-watt f)
  (/ (calc-lumens f)
     (total-power f)))

(define (total-blackbody-lpW T)
  (total-lumens-per-watt (make-Bl T)))

(define (visible-blackbody-lpW T)
  (visible-lumens-per-watt (make-Bl T)))

(define (R9 l)
  ;; R9 color test spectrum
  (cdr (assoc 9 (Tcs.R l))))

(define (R n)
  ;; R(n) color test spectrum
  (lambda (l)
    (cdr (assoc n (Tcs.R l)))))

(define (FL n)
  (lambda (l)
    (cdr (assoc n (FlIlluminant.F l)))))

(define (make-plots)
  ;; run this to make some graphs
  (plot total-blackbody-lpW 1000 10000 "total_blackbody_lpw.dat")

  (plot visible-blackbody-lpW 1000 10000 "visible_blackbody_lpw.dat")
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CIE XYZ
;;

;; a "spectrum" is a procedure of one argument that returns
;; an energy density in W/nm (units?)

(define (get-channel channel)
  (lambda(l) (cdr (assoc channel (CieXyz.Interpolate l) ))))

(define (get-channel-integral spectrum channel)
  (let* ((c         (lambda(l) (cdr (assoc channel (CieXyz.Interpolate l) ))))
         (integrand (lambda(l) (* (c l) (spectrum l)))))
    (integrate integrand l0 l1)))

;; all the various coordinate systems used...

(define (xyz->Yxy xyz)
  ;; (x,y,z) and (Y, x, y)
  (let* ((xint (car xyz))
         (yint (cadr xyz))
         (zint (caddr xyz))
         (sum (+ xint yint zint)))
    (list sum (/ xint sum) (/ yint sum))))

(define (calc-Yxy spectrum)
  ;; compute Yxy on a given spectrum function
  (let* ((xint (get-channel-integral spectrum 'x))
         (yint (get-channel-integral spectrum 'y))
         (zint (get-channel-integral spectrum 'z)))
    (xyz->Yxy (list xint yint zint))))

(define (Yxy->uv Yxy)
  ;; convert to 1960 CIE MacAdam uv 
  (let* ((x         (cadr  Yxy))
         (y         (caddr Yxy))
         (uv-denom  (+ (* -2 x) (* 12 y) 3))
         (u         (/ (* 4 x) uv-denom))
         (v         (/ (* 6 y) uv-denom)))
    (list u v)))

(define (Yxy->Yuv Yxy)
  ;; same as above with Y also in the result
  (let* ((Y         (car Yxy))
         (x         (cadr  Yxy))
         (y         (caddr Yxy))
         (uv-denom  (+ (* -2 x) (* 12 y) 3))
         (u         (/ (* 4 x) uv-denom))
         (v         (/ (* 6 y) uv-denom)))
    (list Y u v)))

(define (calc-uv spectrum)
  ;; MacAdam 1960 UCS coordinates
  ;; note, NOT the same as 1976 CIE Luv
  ;; used for CCT calcs
  (let* ((Yxy       (calc-Yxy spectrum)))
    (Yxy->uv Yxy)))
         
(define (make-T-uv-tbl step wr)
  ;; print the UV values for different temperatures
  ;; in Modula-3 syntax, ready to be made into an Interface
  (let ((lo 0)
        (hi 20000)
        (fmt (lambda(x) (Fmt.LongReal x 'Auto 6))))
    
    (let loop ((T lo))
      (if (> T hi)
          'ok
          (begin
            (let ((uv (calc-uv (make-Bl T))))
              (dis " T { " (fmt T) ", UV { " (fmt (car uv)) ", " (fmt (cadr uv)) " } }, " dnl wr))
            (loop (+ step T)))))))

(define (make-T-uv-interface)
  ;; build the M3 interface
  (let ((wr (FileWr.Open "temp_uv.m3")))
    (make-T-uv-tbl 50 wr)
    (Wr.Close wr)))

(define (temp-uv T)
  ;; extract the uv coordinates for a T K blackbody from the table
  ;; prepared above
  (let* ((tuv (TempUv.Interpolate T))
         (u   (cdr (assoc 'u (assoc 'uv tuv))))
         (v   (cdr (assoc 'v (assoc 'uv tuv)))))
    (list u v)))

(define (uv-norm uv T)
  ;; compute the Duv given that T is the CCT of the spectrum whose
  ;; uv is given in uv
  (let* ((tuv (temp-uv T))
         (du  (- (car  uv) (car  tuv)))
         (dv  (- (cadr uv) (cadr tuv)))
         (dsq (+ (* du du) (* dv dv))))
    (sqrt dsq)))
        
(define (search-T uv)
  ;; compute the CCT for a source given its MacAdam uv coordinates
  (let* ((f  (lambda(T)(uv-norm uv T)))
         (mf (make-lrfunc-obj f))
         (T (Bracket.SchemeBrent '((a . 10) (b . 1000) (c . 20000))
                                 mf
                                 1e-6)))
    (list (cdr (assoc 'x T)) (cdr (assoc 'y T)))
    )
  )

(define (Yuv->UVW Yuv uv0)
  ;; convert to UVW coordinates under a given white point
  ;; uv0 is the white point
  (let* ((Y (car Yuv))
         (u (cadr Yuv))
         (v (caddr Yuv))

         (u0 (car uv0))
         (v0 (cadr uv0))

         (W* (- (* 25 (Math.pow Y (/ 1 3))) 17))
         (U* (* 13 W* (- u u0)))
         (V* (* 13 W* (- v v0))))
    (list U* V* W*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; simple operations on spectra
;;

(define (scale-spectrum a fact)
  (lambda(l)(* fact (a l))))

(define (combine-spectra a b op)
  (lambda(l)(op (a l)(b l))))

(define (multiply-spectra a b)
  (combine-spectra a b *))

(define (divide-spectra a b)
  (combine-spectra a b /))

(define (add-spectra a b)
  (combine-spectra a b +))

(define (weight-spectra a aw b bw)
  (add-spectra
   (scale-spectrum a aw)
   (scale-spectrum b bw)))

;; reflection rule for spectrum, it's the inner product
(define (reflected-tcs-spectrum i illuminant-spectrum)
  
  (multiply-spectra illuminant-spectrum (R i)))

;; normalize a spectrum so it has Y = 100 (needed for CRI calc)
(define (normalize-spectrum spectrum)
  (let* ((Yxy0 (calc-Yxy spectrum))
         (Y    (car Yxy0)))
    (lambda(l)(* (/ 100 Y)(spectrum l)))))

(define (calc-reflected-UVW sample normalized-spectrum uv0)
  (Yuv->UVW
   (Yxy->Yuv (calc-Yxy (multiply-spectra sample normalized-spectrum)))
   uv0))

;; convert to cd coordinates for color adaptation
(define (uv->cd uv)
  (let* ((u (car  uv))
         (v (cadr uv))
         (c (/ (+ 4 (- u) (* -10 v)) v))
         (d (/ (+ (* 1.708 v)(* -1.481 u) 0.404) v)))
    (list c d)))

;; perform von Kries color adaptation calculation
(define (adapted-uv ref-uv test-uv reflected-uv)
  (let* ((cd-r (uv->cd ref-uv))
         (cr   (car cd-r))
         (dr   (cadr cd-r))
         
         (cd-t (uv->cd test-uv))
         (ct   (car cd-t))
         (dt   (cadr cd-t))

         (cd-ti (uv->cd reflected-uv))
         (cti   (car cd-ti))
         (dti   (cadr cd-ti))

         (denom (+ 16.518 (* 1.481 (/ cr ct) cti) (* -1 (/ dr dt) dti)))
         
         (uci   (/ (+ 10.872 (* 0.404 (/ cr ct) cti) (* -4 (/ dr dt) dti))
                   denom))
                 

         (vci   (/ 5.520
                   denom)))

    (list uci vci)))

;; euclidean distance between two 3-vectors
(define (euclidean-3 a b)
  (let* ((dx (- (car a) (car b)))
         (dy (- (cadr a) (cadr b)))
         (dz (- (caddr a) (caddr b))))
    (Math.sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))

(define debug #f)

(define (calc-cri spectrum)
  ;; put it all together. compute the CRI of a given
  ;; continuous spectrum
  
  (let* ((norm-spectrum     (normalize-spectrum spectrum))
         (test-Yxy          (calc-Yxy norm-spectrum))
         (test-uv           (Yxy->uv test-Yxy))
         (ref-temp-res      (search-T test-uv))
         (ref-temp          (car ref-temp-res))
         (ref-uv            (temp-uv ref-temp))
         (norm-ref-spectrum (normalize-spectrum (make-Bl ref-temp)))
         )

    (define (calc-one tcsi)
      (let* ((sample (R tcsi))

             (ref-reflected     (multiply-spectra sample norm-ref-spectrum))
             (ref-reflected-Yxy (calc-Yxy ref-reflected))
             (ref-UVW           (Yuv->UVW (Yxy->Yuv ref-reflected-Yxy) ref-uv))
             
             (reflected-spectrum (multiply-spectra sample norm-spectrum))
             (reflected-Yxy      (calc-Yxy reflected-spectrum))
             (reflected-Yuv      (Yxy->Yuv reflected-Yxy))
             (Y                  (car reflected-Yuv))
             
             (reflected-uv       (cdr reflected-Yuv))
             (reflected-UVW      (Yuv->UVW (cons Y reflected-uv) ref-uv))
             
             (cat-uv             (adapted-uv ref-uv test-uv reflected-uv))
             (cat-UVW            (Yuv->UVW (cons Y cat-uv) ref-uv))
             (delta-EUVW         (euclidean-3 cat-UVW ref-UVW))
             (Ri                 (+ 100 (* -4.6 delta-EUVW)))
             )
        (if debug
            (dis "TCS " tcsi " reflected-Yxy " reflected-Yxy dnl
                 "TCS " tcsi " reflected-Yuv " reflected-Yuv dnl
                 "TCS " tcsi " cat-uv        " cat-uv dnl
                 "TCS " tcsi " reference-UVW " ref-UVW dnl
                 "TCS " tcsi " reflected-UVW " reflected-UVW dnl
                 "TCS " tcsi " cat-UVW       " cat-UVW dnl
                 "TCS " tcsi " delta-EUVW    " delta-EUVW dnl
                 "R" tcsi " = " Ri dnl
                 
                 ))
        Ri)
      )
      
    (if debug
        (dis "test-Yxy     " test-Yxy dnl
             "test-uv      " test-uv dnl
             "ref-temp-res " ref-temp-res dnl
             "ref-uv       " ref-uv dnl))
    (list ref-temp-res (map calc-one '(1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
    )
  )

(define (calc-Yri spectrum)
  ;; put it all together. compute the Y-ratio-i of a given
  ;; continuous spectrum
  
  (let* ((norm-spectrum     (normalize-spectrum spectrum))
         (test-Yxy          (calc-Yxy norm-spectrum))
         (test-uv           (Yxy->uv test-Yxy))
         (ref-temp-res      (search-T test-uv))
         (ref-temp          (car ref-temp-res))
         (ref-uv            (temp-uv ref-temp))
         (norm-ref-spectrum (normalize-spectrum (make-Bl ref-temp)))
         )

    (define (calc-one tcsi)
      (let* ((sample (R tcsi))

             (ref-reflected      (multiply-spectra sample norm-ref-spectrum))
             (ref-reflected-Yxy  (calc-Yxy ref-reflected))
             
             (reflected-spectrum (multiply-spectra sample norm-spectrum))
             (reflected-Yxy      (calc-Yxy reflected-spectrum))
             (Yri (/ (car reflected-Yxy) (car ref-reflected-Yxy)))               
             )
        Yri)
      )
      
    (if debug
        (dis "test-Yxy     " test-Yxy dnl
             "test-uv      " test-uv dnl
             "ref-temp-res " ref-temp-res dnl
             "ref-uv       " ref-uv dnl))
    (list ref-temp-res (map calc-one '(1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
    )
  )

(define (calc-reflected-Yxy spectrum sample)
  (let* ((norm-spectrum      (normalize-spectrum spectrum))
         (reflected-spectrum (multiply-spectra sample norm-spectrum)))
    (calc-Yxy reflected-spectrum)))

(define *start-selection*  '(1 2 3 4 5 6 7 8 9 10 11 12 13 14))
(define *the-selection*  *start-selection*)
;; careful of off-by one errors

(define (filter-out elem selection)
  (map (lambda(x)(if (equal? x elem) #f x)) selection))


(define (compute-on-selection full-cri)
  (let loop ((p    *the-selection*)
             (q    full-cri)
             (sum         0)
             (n           0)
             (worst     100)
             (the-worst  -1))
    (cond ((null? p)
           (list (/ sum n) worst the-worst))
          ((not (car p))
           (loop (cdr p) (cdr q) sum n worst the-worst))
          (else
           (let ((elem (car q)))
             (loop (cdr p)
                   (cdr q)
                   (+ elem sum)
                   (+ n 1) 
                   (min elem worst)
                   (if (< elem worst) (car p) the-worst)))))))

(define (calc-specs spectrum)
  ;; produce the specs of a spectrum:
  ;; CRI(Ra)
  ;; worst Ri (i \in 1..8)
  ;; theoretical efficacy in lm/W
  ;; vector of CRi for i \in 1 .. 14
  (let* ((full-cri (calc-cri spectrum))
         (ref-temp (caar full-cri))
         (Duv      (cadar full-cri))
         (ri-8     (head 8 (cadr full-cri)))
         (worst-ri (apply min ri-8))
         (efficacy (total-lumens-per-watt spectrum))
         (cri-ra   (/ (apply + ri-8) 8))

         (cri-14   (/ (apply + (cadr full-cri)) 14))
         (worst-14 (apply min (cadr full-cri)))

         (sel-data (compute-on-selection (cadr full-cri)))
          
         )
    (append (list cri-ra worst-ri efficacy)
            full-cri
            (append (list cri-14 worst-14) sel-data))))

(define (trunc-spectrum spectrum lo hi)
  ;; truncate a given spectrum to the wavelengths given
  (lambda(l)
    (cond ((< l lo) 0)
          ((> l hi) 0)
          (else (spectrum l)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Optimization code for use with COBYLA
;;

(define pspec '())
(define cur-dims '())
(define cur-base-spectrum '())

(define  (setup-pspec! dims base-spectrum)
  (set! cur-dims dims)
  (set! cur-base-spectrum base-spectrum)
  (set! pspec (ParametricSpectrum.New
               l0 l1 ;; optimization range
               dims   ;; how many dimensions
               base-spectrum ;; start func
               )
        )
  )

(define *p* '())

(define (set-zero!)
  (set! *p* (ParametricSpectrum.ZeroP pspec)))

;;;;;;;;;;;;;;;;;;;;

(define *test-spectrum* (trunc-spectrum (make-Bl 2700) l0 l1))

;;(setup-pspec! 20 test-spectrum)
;;(set-zero!)

;;;;;;;;;;;;;;;;;;;;

(define w '())

(define (setup-w!)
  (set! w (unwrap-lrfunc (ParametricSpectrum.GetFunc pspec *p*))))

(setup-w!)

(define (setup-problem! spectrum dims)
  (setup-pspec! dims spectrum)
  (set-zero!)
  (setup-w!)
  'ok
  )

(define (subdivide-problem!)
  (let ((new-dims (- (* cur-dims 2) 1))
        (new-p    (ParametricSpectrum.Subdivide *p*)))
    (setup-pspec! new-dims cur-base-spectrum)
    (set! *p* (ParametricSpectrum.Subdivide *p*))
    (setup-w!) 
    'ok
    ))
                  
(define (specs-func new-p)
  (ParametricSpectrum.SetVec *p* new-p)
  (calc-specs w)
  )

(define *target-cct*      2700)
(define *min-cri-ra*        82)
(define *min-r9*          -100)
(define *num-constraints*    6)

(define (specs->target specs)
  (let ((lpm    (caddr specs))
        (r9     (nth (car (cddddr specs)) 8))
        (cri    (car specs))
        (crmin  (cadr specs))
        (cct    (caar (cdddr specs)))
        (Duv    (cadar (cdddr specs)))
        )
    (dis specs dnl)
    (list (- (caddr specs))            ;; target var : efficacy
          (- cri   *min-cri-ra*)       ;; cri constraint
          (- r9    *min-r9*)           ;; cri constraint
          (- crmin (- *min-cri-ra* 10));; worst-component constraint
          (- cct (- *target-cct* 50))  ;; cct >= 2650
          (- (+ *target-cct* 50) cct)  ;; cct <= 2750
          (* 1000 (- 0.012 Duv))       ;; Duv <= 0.012 (weight 1000)
          )
        )
  )
      
(define (run rhobeg spec-evaluator)
  (let ((opt-func (lambda(p) (ParametricSpectrum.Scheme2Vec
                              (spec-evaluator (specs-func p))))))

                                   
    (COBYLA_M3.Minimize *p*                ;; state vector
                        *num-constraints*  
                        (make-lrvectorfield-obj opt-func)
                        rhobeg
                        0.0002 ;; rhoend
                        1000   ;; max steps
                        2      ;; iprint
                        )
    )
  )


(define (specs->target-r9 specs)
  (let ((lpm    (caddr specs))
        (r9     (nth (car (cddddr specs)) 8))
        (cri    (car specs))
        (crmin  (cadr specs))
        (cct    (caar (cdddr specs)))
        (Duv    (cadar (cdddr specs)))
        )
    (dis specs dnl)
    (list r9                          ;; target var : low R9
          (- cri   82)                ;; cri constraint
          (- crmin 72)                ;; worst-component constraint
          (- cct (- *target-cct* 50)) ;; cct >= 2650
          (- (+ *target-cct* 50) cct) ;; cct <= 2750
          (* 1000 (- 0.012 Duv))      ;; Duv <= 0.012 (weight 1000)
          (- lpm 90)                  ;; lpm >= 45 * 2
          )
        )
  )

(define (m3-opt-r9 p)
  (ParametricSpectrum.Scheme2Vec
   (specs->target-r9 (specs-func p))))

(define (run-r9)
  (COBYLA_M3.Minimize *p* 6 (make-lrvectorfield-obj m3-opt-r9) 1 0.00001 10000 2)
  )

(define (plot-current-state pfx)
  (let* ((nm (string-append 
             (stringify *target-cct*)
             "_CRI"
             (stringify *min-cri-ra*)
             pfx
             "_"
             (stringify cur-dims)
             ))
         (wr (FileWr.Open (string-append nm ".res"))))

    (dis (stringify (calc-specs w)) dnl dnl wr)

    (dis (stringify (ParametricSpectrum.Vec2Scheme *p*)) dnl wr)
    
    (plot (normalize-spectrum w)
          l0 l1
          (string-append "w_" nm ".dat")
          200)))



(define (run-example-iters! cct min-cri min-r9 repcnt spec-eval pfx)
  (dis "*****  START RUN cct=" cct " CRI(ra)>=" min-cri " " pfx "  *****" dnl)
  (define *start-dims*   2)
  (define *start-rhobeg* 4)
  (define rhobeg *start-rhobeg*)

  ;;(set! *test-spectrum* (make-lrfunc-obj (trunc-spectrum (make-Bl cct) l0 l1)))
  (set! *test-spectrum* (ParametricSpectrum.MakeBlackbodyInWavelength cct l0 l1))
  (set! *target-cct* cct)
  (set! *min-cri-ra* min-cri)
  (set! *min-r9* min-r9)
  
  (define (repeat)

    (set! rhobeg (/ rhobeg 2))
    
    (subdivide-problem!)
    (dis "subdividing cur-dims = " cur-dims dnl)
    (run rhobeg spec-eval)
    (plot-current-state pfx)
    
    (dis "done at dims " cur-dims dnl)

    )
  
  (plot (normalize-spectrum (unwrap-lrfunc *test-spectrum*))
        l0 l1
        (string-append "base_" (stringify cct) ".dat")
        200)
    
  (dis "setting up dims = " *start-dims* dnl)
  (setup-problem! *test-spectrum* *start-dims*)
  (run rhobeg spec-eval) ;; big step
  (plot-current-state pfx)
  (dis "done at dims " cur-dims dnl)

  (let loop ((k repcnt))
    (if (<= k 0) 'ok
        (begin (repeat) (loop (- k 1)))))
  )

(define (plot-the-samples)
  (define *min-sample*  1)
  (define *max-sample* 14)
  (let loop ((i *min-sample*))
    (if (> i *max-sample*)
        'ok
        (begin
          (plot (R i) l0 l1 (string-append "R" (stringify i) ".dat") 200)
          (loop (+ i 1))
          )
        )
    )
  )

(define (run-example! cct min-cri min-r9)
  (dis "run-example " min-cri " " min-r9 dnl)
  (run-example-iters! cct min-cri min-r9 7 specs->target
                      (string-append              "_R9="
                                                  (stringify min-r9))))

(define pp
  (obj-method-wrap (LibertyUtils.DoParseParams) 'ParseParams.T))

(if (pp 'keywordPresent "-run")
    (begin
      (define run-cct (pp 'getNextLongReal      0 1e6))
      (define run-cri (pp 'getNextLongReal -10000 100))
      (define run-r9  (pp 'getNextLongReal -10000 100))
      (run-example! run-cct run-cri run-r9)
      (exit)
      )
    )
      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(define (specs->cri-sel-target specs)
  (let ((lpm    (caddr specs))
        (r9     (nth (car (cddddr specs)) 8))
        (cri    (car specs))
        (crmin  (cadr specs))
        (cct    (caar (cdddr specs)))
        (Duv    (cadar (cdddr specs)))
        (sel-cri      (nth specs 7)) ;; cri over selected TCS
        (sel-wrst-cri (nth specs 8)) ;; worst cri over selected TCS
        )
    (dis specs dnl)
    (list (- (caddr specs))                    ;; target var : efficacy
          (- sel-cri   *min-cri-ra*)           ;; cri constraint
          (- sel-wrst-cri (- *min-cri-ra* 10)) ;; worst cri
          1
          (- cct (- *target-cct* 50))          ;; cct >= *target-cct* - 50
          (- (+ *target-cct* 50) cct)          ;; cct <= *target-cct* + 50
          (* 1000 (- 0.012 Duv))               ;; Duv <= 0.012 (weight 1000)
          )
        )
  )

(define (run-multi! cct cri)
  (set! *the-selection* *start-selection*)
  (let loop ((pfx "DROP"))
    (run-example-iters! cct cri -100 6 specs->cri-sel-target (string-append pfx "_X"))

    (if (not (= 0 (length (filter (lambda(x)x) *the-selection*))))
        (let ((worst-axis (nth (calc-specs w) 9)))
          (set! *the-selection* (filter-out worst-axis *the-selection*))
          (loop (string-append pfx "_" (stringify worst-axis)))
          )
        'ok
        )
    )
  )

(if (pp 'keywordPresent "-run-drop")
    (begin
      (define run-cct (pp 'getNextLongReal    0 1e6))
      (define run-cri (pp 'getNextLongReal -100 100))
      (run-multi! run-cct run-cri)
      (exit)
      )
    )
  

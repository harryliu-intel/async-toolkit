/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_nexthop_map_regs.h                                 
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_NEXTHOP_MAP_REGS_H_
#define _MBY_PPE_NEXTHOP_MAP_REGS_H_

#define NEXTHOP_MSGPORT     0x0
#define NEXTHOP_NH_CONFIG_MSGREGADDR 0x0
#define NEXTHOP_NH_STATUS_MSGREGADDR 0x8
#define NEXTHOP_NH_NEIGHBORS_0_MSGREGADDR 0x20000
#define NEXTHOP_NH_NEIGHBORS_1_MSGREGADDR 0x40000
#define NEXTHOP_NH_GROUPS_0_MSGREGADDR 0x60000
#define NEXTHOP_NH_GROUPS_1_MSGREGADDR 0x68000
#define NEXTHOP_NH_ROUTES_MSGREGADDR 0x80000
#define NEXTHOP_NH_WEIGHTS_MSGREGADDR 0x0A0000
#define NEXTHOP_INGRESS_VID_TABLE_MSGREGADDR 0x0C0000
#define NEXTHOP_FLOOD_GLORT_TABLE_MSGREGADDR 0x0C8000
#define NEXTHOP_NH_USED_MSGREGADDR 0x0C8800
#define NEXTHOP_NH_PATH_CTRS_MSGREGADDR 0x0E0000
#define NEXTHOP_NH_GROUP_MIN_MSGREGADDR 0x100000
#define NEXTHOP_MTU_TABLE_MSGREGADDR 0x101000

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLAG
// NH_CONFIG desc:  Global configuration for next-hop operation.
typedef union {
    struct {
        uint64_t  FLOWLET_ENABLE       :   1;    //  Enable flowlet-based load
                                                 // balancing.
        uint64_t  FLOWLET_INT_EN       :   1;    //  Enable interrupts for
                                                 // software based flowlet load
                                                 // balancing.
        uint64_t  SWEEPER_RATE         :   8;    //  Sets the rate at which the
                                                 // next-hop sweeper task ages out
                                                 // NH_ROUTE table entries for
                                                 // identifying flowlet gaps.
                                                 // [br][br] Units are TBD.
        uint64_t  RSVD_0               :  54;    // Nebulon auto filled RSVD [63:10]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_BITFIELD_COUNT 0x03
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_ENABLE_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_ENABLE_MSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_ENABLE_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_ENABLE_MASK 0x00000001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_ENABLE_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_INT_EN_LSB 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_INT_EN_MSB 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_INT_EN_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_INT_EN_MASK 0x00000002
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_FLOWLET_INT_EN_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SWEEPER_RATE_LSB 0x0002
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SWEEPER_RATE_MSB 0x0009
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SWEEPER_RATE_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SWEEPER_RATE_MASK 0x000003fc
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_SWEEPER_RATE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLAG
// NH_STATUS desc:  Reports to software the status of the next-hop.
typedef union {
    struct {
        uint64_t  FLOWLET              :  14;    //  Indicates the route table
                                                 // entry for which a flowlet
                                                 // boundary was detected and an
                                                 // interrupt generated
        uint64_t  RSVD_0               :  50;    // Nebulon auto filled RSVD [63:14]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_OFFSET 0x08
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_BITFIELD_COUNT 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLOWLET_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLOWLET_MSB 0x000d
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLOWLET_RANGE 0x000e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLOWLET_MASK 0x00003fff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_FLOWLET_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_FLAG
// NH_NEIGHBORS_0 desc:  Stores the low order half of the next-hop entry and related fields
// for IP routing and GLORT forwarding.
typedef union {
    struct {
        uint64_t  DST_MAC              :  48;    //  Destination MAC address for
                                                 // IP routing.[br] Ignored if
                                                 // ENTRY_TYPE=0.
        uint64_t  DGLORT               :  16;    //  Indicates the destination
                                                 // GLORT for both GLORT
                                                 // forrwarding and IP routing.

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_BITFIELD_COUNT 0x02
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DST_MAC_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DST_MAC_MSB 0x002f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DST_MAC_RANGE 0x0030
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DST_MAC_MASK 0xffffffffffff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DST_MAC_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DGLORT_LSB 0x0030
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DGLORT_MSB 0x003f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DGLORT_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DGLORT_MASK 0xffff000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_DGLORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_FLAG
// NH_NEIGHBORS_1 desc:  Stores the high order half of the next-hop entry and related fields
// for IP routing and GLORT forwarding.
typedef union {
    struct {
        uint64_t  EVID                 :  12;    //  Egress VLAN ID used for IP
                                                 // routing. [br] Ignored if
                                                 // ENTRY_TYPE=0.
        uint64_t  MTU_INDEX            :   3;    //  Index into the MTU size
                                                 // check table.
        uint64_t  MOD_IDX              :  24;    //  Modify index MOD_IDX.
        uint64_t  L2_DOMAIN            :   8;    //  New L2 domain value to use
                                                 // if UPDATE_L2_DOMAIN=1
        uint64_t  L3_DOMAIN            :   6;    //  New L3 domain value to use
                                                 // if UPDATE_L3_DOMAIN=1
        uint64_t  UPDATE_L2_DOMAIN     :   1;    //  Indicates whether to update
                                                 // the L2 domain value.
        uint64_t  UPDATE_L3_DOMAIN     :   1;    //  Indicates whether to update
                                                 // the L3 domain value.
        uint64_t  MARK_ROUTED          :   1;    //  Marks the packet as routed
                                                 // when doing GLORT forwarding so
                                                 // that Modify will update the
                                                 // appropriate header fields.[br]
                                                 // Ignored if ENTRY_TYPE=1.
        uint64_t  IPV6_ENTRY           :   1;    //  Indicates whether to derive
                                                 // the DMAC from the IPv6 DIP
                                                 // when doing IP routing and
                                                 // stateless autoconfig is
                                                 // enabled on the network.[br]
                                                 // Ignored if ENTRY_TYPE=0.
        uint64_t  ENTRY_TYPE           :   1;    //  0: Entry is used for GLORT
                                                 // forwarding. DST_MAC, EVID and
                                                 // IPV6_ENTRY are ignored.
                                                 // [br][br] 1: Entry is used for
                                                 // IP routing. DST_MAC provides
                                                 // the next hop router's DMAC
                                                 // and DGLORT indicates the
                                                 // egress port to which the next
                                                 // hop router is connected.
        uint64_t  RSVD_0               :   6;    // Nebulon auto filled RSVD [63:58]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_BITFIELD_COUNT 0x0a
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_EVID_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_EVID_MSB 0x000b
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_EVID_RANGE 0x000c
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_EVID_MASK 0x00000fff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_EVID_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MTU_INDEX_LSB 0x000c
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MTU_INDEX_MSB 0x000e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MTU_INDEX_RANGE 0x0003
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MTU_INDEX_MASK 0x00007000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MTU_INDEX_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MOD_IDX_LSB 0x000f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MOD_IDX_MSB 0x0026
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MOD_IDX_RANGE 0x0018
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MOD_IDX_MASK 0x7fffff8000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MOD_IDX_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L2_DOMAIN_LSB 0x0027
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L2_DOMAIN_MSB 0x002e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L2_DOMAIN_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L2_DOMAIN_MASK 0x7f8000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L2_DOMAIN_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L3_DOMAIN_LSB 0x002f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L3_DOMAIN_MSB 0x0034
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L3_DOMAIN_RANGE 0x0006
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L3_DOMAIN_MASK 0x1f800000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_L3_DOMAIN_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L2_DOMAIN_LSB 0x0035
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L2_DOMAIN_MSB 0x0035
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L2_DOMAIN_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L2_DOMAIN_MASK 0x20000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L2_DOMAIN_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L3_DOMAIN_LSB 0x0036
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L3_DOMAIN_MSB 0x0036
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L3_DOMAIN_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L3_DOMAIN_MASK 0x40000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_UPDATE_L3_DOMAIN_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MARK_ROUTED_LSB 0x0037
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MARK_ROUTED_MSB 0x0037
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MARK_ROUTED_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MARK_ROUTED_MASK 0x80000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_MARK_ROUTED_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_IPV6_ENTRY_LSB 0x0038
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_IPV6_ENTRY_MSB 0x0038
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_IPV6_ENTRY_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_IPV6_ENTRY_MASK 0x100000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_IPV6_ENTRY_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_ENTRY_TYPE_LSB 0x0039
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_ENTRY_TYPE_MSB 0x0039
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_ENTRY_TYPE_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_ENTRY_TYPE_MASK 0x200000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_ENTRY_TYPE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_FLAG
// NH_GROUPS_0 desc:  Stores the low order half of the next-hop group entry.
typedef union {
    struct {
        uint64_t  GROUP_TYPE           :   2;    //  Indicates the type of group:
                                                 // [list] [*] 0: ECMP group
                                                 // [*] 1: WCMP group [*] 2: ECMP
                                                 // group with flowlet support
                                                 // [*] 3: Reserved [/list]
        uint64_t  BASE_INDEX           :  14;    //  The index to the first
                                                 // NH_NEIGHBORS entry associated
                                                 // with this group. For ECMP
                                                 // groups, also indicates the
                                                 // first corresponding NH_ROUTES
                                                 // entry.
        uint64_t  N_GROUP_SZ_TYPE      :   1;    //  Indicates whether
                                                 // N_GROUP_SIZE is literal or a
                                                 // power of 2.
        uint64_t  N_GROUP_SIZE         :   6;    //  Indicates the size of the
                                                 // group in NH_NEIGHBORS. If
                                                 // N_GROUP_SZ_TYPE is 0, this
                                                 // field is the literal size of
                                                 // the group (0 indicates 64
                                                 // members). If N_GROUP_SZ_TYPE
                                                 // is 1, this field must be
                                                 // between 0 and 12 and the
                                                 // group size is 2^N_GROUP_SIZE.
        uint64_t  WEIGHT_ROW           :  11;    //  Used for GROUP_TYPE=1,
                                                 // indicates the weight table row
                                                 // in NH_WEIGHTS.
        uint64_t  WEIGHT_ROW_OFFSET    :   6;    //  Used for GROUP_TYPE=1,
                                                 // indicates the offset into the
                                                 // weight table row in
                                                 // NH_WEIGHTS.
        uint64_t  RSVD_0               :  24;    // Nebulon auto filled RSVD [63:40]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_BITFIELD_COUNT 0x06
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_GROUP_TYPE_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_GROUP_TYPE_MSB 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_GROUP_TYPE_RANGE 0x0002
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_GROUP_TYPE_MASK 0x00000003
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_GROUP_TYPE_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_BASE_INDEX_LSB 0x0002
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_BASE_INDEX_MSB 0x000f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_BASE_INDEX_RANGE 0x000e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_BASE_INDEX_MASK 0x0000fffc
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_BASE_INDEX_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SZ_TYPE_LSB 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SZ_TYPE_MSB 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SZ_TYPE_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SZ_TYPE_MASK 0x00010000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SZ_TYPE_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SIZE_LSB 0x0011
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SIZE_MSB 0x0016
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SIZE_RANGE 0x0006
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SIZE_MASK 0x007e0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_N_GROUP_SIZE_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_LSB 0x0017
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_MSB 0x0021
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_RANGE 0x000b
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_MASK 0x3ff800000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_OFFSET_LSB 0x0022
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_OFFSET_MSB 0x0027
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_OFFSET_RANGE 0x0006
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_OFFSET_MASK 0xfc00000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_WEIGHT_ROW_OFFSET_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLAG
// NH_GROUPS_1 desc:  Stores the high order half of the next-hop group entry.
typedef union {
    struct {
        uint64_t  R_GROUP_SZ_TYPE      :   1;    //  Indicates whether
                                                 // R_GROUP_SIZE is literal or a
                                                 // power of 2.
        uint64_t  R_GROUP_SIZE         :   6;    //  Indicates the size of the
                                                 // group in NH_ROUTES. If
                                                 // R_GROUP_SZ_TYPE is 0, this
                                                 // field is the literal size of
                                                 // the group (0 indicates 64
                                                 // members). If R_GROUP_SZ_TYPE
                                                 // is 1, this field must be
                                                 // between 0 and 12 and the
                                                 // group size is 2^R_GROUP_SIZE.
        uint64_t  FLOWLET_POLICY       :   3;    //  Indicates the flowlet
                                                 // re-balancing policy: [list]
                                                 // [*] 0: Software [*] 1:
                                                 // LetFlow [*] 2: Path Loading
                                                 // [*] 3: SDN Managed [*] 4:
                                                 // Local Congestion [*] 5:
                                                 // Congestion Notification [*]
                                                 // 6: Power Aware [*] 7:
                                                 // Reserved [/list] See the
                                                 // functional specification for
                                                 // details.
        uint64_t  FLOWLET_AGE_RESET    :   8;    //  Flowlet age reset value
        uint64_t  GROUP_MIN_INDEX      :  11;    //  Index to the minimal path
                                                 // counter for the group in
                                                 // NH_GROUP_MIN.
        uint64_t  RSVD_0               :  35;    // Nebulon auto filled RSVD [63:29]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_BITFIELD_COUNT 0x05
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SZ_TYPE_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SZ_TYPE_MSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SZ_TYPE_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SZ_TYPE_MASK 0x00000001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SZ_TYPE_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SIZE_LSB 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SIZE_MSB 0x0006
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SIZE_RANGE 0x0006
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SIZE_MASK 0x0000007e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_R_GROUP_SIZE_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_POLICY_LSB 0x0007
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_POLICY_MSB 0x0009
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_POLICY_RANGE 0x0003
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_POLICY_MASK 0x00000380
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_POLICY_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_AGE_RESET_LSB 0x000a
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_AGE_RESET_MSB 0x0011
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_AGE_RESET_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_AGE_RESET_MASK 0x0003fc00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_FLOWLET_AGE_RESET_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_GROUP_MIN_INDEX_LSB 0x0012
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_GROUP_MIN_INDEX_MSB 0x001c
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_GROUP_MIN_INDEX_RANGE 0x000b
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_GROUP_MIN_INDEX_MASK 0x1ffc0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_GROUP_MIN_INDEX_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_FLAG
// NH_ROUTES desc:  ECMP hash bin.
typedef union {
    struct {
        uint64_t  NEIGHBOR_IDX         :  14;    //  Index to NH_NEIGHBORS entry
                                                 // associated with this bin.
        uint64_t  GROUP_IDX            :  12;    //  Index to NH_GROUPS entry
                                                 // associated with this bin.
        uint64_t  AGE_COUNTER          :   8;    //  Flowlet gap timer counter
        uint64_t  RSVD_0               :  30;    // Nebulon auto filled RSVD [63:34]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_BITFIELD_COUNT 0x03
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_NEIGHBOR_IDX_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_NEIGHBOR_IDX_MSB 0x000d
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_NEIGHBOR_IDX_RANGE 0x000e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_NEIGHBOR_IDX_MASK 0x00003fff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_NEIGHBOR_IDX_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_GROUP_IDX_LSB 0x000e
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_GROUP_IDX_MSB 0x0019
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_GROUP_IDX_RANGE 0x000c
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_GROUP_IDX_MASK 0x03ffc000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_GROUP_IDX_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_AGE_COUNTER_LSB 0x001a
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_AGE_COUNTER_MSB 0x0021
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_AGE_COUNTER_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_AGE_COUNTER_MASK 0x3fc000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_AGE_COUNTER_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_FLAG
// NH_WEIGHTS desc:  Provides weights for each of the paths in a WCMP group.
typedef union {
    struct {
        uint64_t  WEIGHT_0             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_1             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_2             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_3             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_4             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_5             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_6             :   8;    //  Cumulative weight value for
                                                 // one path.
        uint64_t  WEIGHT_7             :   8;    //  Cumulative weight value for
                                                 // one path.

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_BITFIELD_COUNT 0x08
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_0_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_0_MSB 0x0007
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_0_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_0_MASK 0x000000ff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_0_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_1_LSB 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_1_MSB 0x000f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_1_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_1_MASK 0x0000ff00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_1_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_2_LSB 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_2_MSB 0x0017
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_2_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_2_MASK 0x00ff0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_2_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_3_LSB 0x0018
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_3_MSB 0x001f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_3_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_3_MASK 0xff000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_3_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_4_LSB 0x0020
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_4_MSB 0x0027
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_4_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_4_MASK 0xff00000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_4_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_5_LSB 0x0028
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_5_MSB 0x002f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_5_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_5_MASK 0xff0000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_5_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_6_LSB 0x0030
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_6_MSB 0x0037
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_6_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_6_MASK 0xff000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_6_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_7_LSB 0x0038
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_7_MSB 0x003f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_7_RANGE 0x0008
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_7_MASK 0xff00000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_WEIGHT_7_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_FLAG
// INGRESS_VID_TABLE desc:  Contains VLAN membership states, IGMP trap enable and reflection
// state for the ingress VLAN lookup.
typedef union {
    struct {
        uint64_t  MEMBERSHIP           :  17;    //  Defines port membership for
                                                 // this VLAN. A '1' in each bit
                                                 // position includes that port
                                                 // in the VLAN membership.
        uint64_t  REFLECT              :   1;    //  If this bit is set and
                                                 // PORT_CFG_2 destination mask
                                                 // include itself, then layer 2
                                                 // packets associated with this
                                                 // VLAN are allowed to go back
                                                 // on the port they come from
                                                 // (subject to LOOPBACK_SUPPRESS
                                                 // registers). If this bit is
                                                 // not set, then layer 2 packets
                                                 // associated with this VLAN are
                                                 // not allowed to go back on the
                                                 // port they come from. Routed
                                                 // packets are always allowed to
                                                 // go back where they come from
                                                 // and this bit is not used in
                                                 // this case.
        uint64_t  TRAP_IGMP            :   1;    //  Indicates if the IGMP frames
                                                 // on this VLAN shall be trapped
                                                 // or switched normally. The
                                                 // IGMP frames are trapped to the
                                                 // CPU glort.
        uint64_t  RSVD_0               :  45;    // Nebulon auto filled RSVD [63:19]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_BITFIELD_COUNT 0x03
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_MEMBERSHIP_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_MEMBERSHIP_MSB 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_MEMBERSHIP_RANGE 0x0011
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_MEMBERSHIP_MASK 0x0001ffff
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_MEMBERSHIP_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_REFLECT_LSB 0x0011
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_REFLECT_MSB 0x0011
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_REFLECT_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_REFLECT_MASK 0x00020000
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_REFLECT_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_TRAP_IGMP_LSB 0x0012
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_TRAP_IGMP_MSB 0x0012
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_TRAP_IGMP_RANGE 0x0001
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_TRAP_IGMP_MASK 0x00040000
#define MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_TRAP_IGMP_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLAG
// FLOOD_GLORT_TABLE desc:  Glorts for flooding, broadcast and multicast indexed by egress L2
// domain.
typedef union {
    struct {
        uint64_t  FLOOD_UNICAST_GLORT  :  16;    //  Defines the glort to use
                                                 // when flooding unicast frames
                                                 // if the Classifier and NextHop
                                                 // don't already provide a flood
                                                 // glort. For DLF flood control,
                                                 // set to a glort with a zero
                                                 // destination mask.
        uint64_t  FLOOD_MULTICAST_GLORT :  16;    //  Defines the glort to use
                                                 // when flooding multicast frames
                                                 // if the Classifier and NextHop
                                                 // don't already provide a flood
                                                 // glort. For DLF flood control,
                                                 // set to a glort with a zero
                                                 // destination mask.
        uint64_t  BROADCAST_GLORT      :  16;    //  Defines the glort used for
                                                 // broadcast.
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_BITFIELD_COUNT 0x03
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_UNICAST_GLORT_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_UNICAST_GLORT_MSB 0x000f
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_UNICAST_GLORT_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_UNICAST_GLORT_MASK 0x0000ffff
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_UNICAST_GLORT_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_MULTICAST_GLORT_LSB 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_MULTICAST_GLORT_MSB 0x001f
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_MULTICAST_GLORT_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_MULTICAST_GLORT_MASK 0xffff0000
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_FLOOD_MULTICAST_GLORT_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_BROADCAST_GLORT_LSB 0x0020
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_BROADCAST_GLORT_MSB 0x002f
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_BROADCAST_GLORT_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_BROADCAST_GLORT_MASK 0xffff00000000
#define MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_BROADCAST_GLORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_FLAG
// NH_USED desc:  Each time NEXTHOP_TABLE[index] entry is used to forward a frame, the
// chip sets the NH_USED[index{13:6}]{index{5:0}} bit to 1. When
// software writes a word to this table, any bits that are 1 in the word
// will clear the corresponding bit in NH_USED to 0. The software should
// read a word into x, record which entries have been used since the
// last sample, and then write x back to NH_USED to clear the bits. This
// avoids any race between the hardware and software. The concept is
// similar to an interrupt register.
typedef union {
    struct {
        uint64_t  USED                 :  64;    //  64 consecutive bits marking
                                                 // usage of corresponding
                                                 // NEXTHOP_TABLE entries.

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_BITFIELD_COUNT 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_USED_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_USED_MSB 0x003f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_USED_RANGE 0x0040
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_USED_MASK 0xffffffffffffffff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_USED_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_FLAG
// NH_PATH_CTRS desc:  A counter of bytes sent for transmission on each path in an ECMP
// group. Used for identifying the least used path for rebalancing
// flowlets. Each entry holds the byte count for the path in the
// corresponding index into NH_NEIGHBORS.
typedef union {
    struct {
        uint64_t  BYTES                :  64;    //  Byte count.

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_BITFIELD_COUNT 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_BYTES_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_BYTES_MSB 0x003f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_BYTES_RANGE 0x0040
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_BYTES_MASK 0xffffffffffffffff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_BYTES_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_FLAG
// NH_GROUP_MIN desc:  Each ECMP group keeps track of the path within the group to which
// the least number of bytes has been sent. This path will be the target
// path for flowlet rebalancing. [br][br] For the ECMP group whose
// NH_GROUPS entry is at index N, the corresponding entry will be:[br]
// NH_GROUP_MIN[N/4].MIN_X[br] where X = N % 4.
typedef union {
    struct {
        uint64_t  MIN_0                :  16;    //  NH_NEIGHBORS index
                                                 // corersponding to the path in
                                                 // an ECMP with the previously
                                                 // known least number of bytes
                                                 // sent to it.
        uint64_t  MIN_1                :  16;    //  NH_NEIGHBORS index
                                                 // corersponding to the path in
                                                 // an ECMP with the previously
                                                 // known least number of bytes
                                                 // sent to it.
        uint64_t  MIN_2                :  16;    //  NH_NEIGHBORS index
                                                 // corersponding to the path in
                                                 // an ECMP with the previously
                                                 // known least number of bytes
                                                 // sent to it.
        uint64_t  MIN_3                :  16;    //  NH_NEIGHBORS index
                                                 // corersponding to the path in
                                                 // an ECMP with the previously
                                                 // known least number of bytes
                                                 // sent to it.

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_BITFIELD_COUNT 0x04
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_0_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_0_MSB 0x000f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_0_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_0_MASK 0x0000ffff
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_0_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_1_LSB 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_1_MSB 0x001f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_1_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_1_MASK 0xffff0000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_1_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_2_LSB 0x0020
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_2_MSB 0x002f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_2_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_2_MASK 0xffff00000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_2_RESET_VALUE 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_3_LSB 0x0030
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_3_MSB 0x003f
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_3_RANGE 0x0010
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_3_MASK 0xffff000000000000
#define MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_MIN_3_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_FLAG
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_FLAG
// MTU_TABLE desc:  Defines the list of MTUs supported by the switch.
typedef union {
    struct {
        uint64_t  MTU                  :  14;    //  MTU size in bytes.
        uint64_t  RSVD_0               :  50;    // Nebulon auto filled RSVD [63:14]

    }                                field;
    uint64_t                         val;
} MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_t;
#endif
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_OFFSET 0x00
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_SCOPE 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_SIZE 64
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_BITFIELD_COUNT 0x01
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_RESET 0x00000000

#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_MTU_LSB 0x0000
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_MTU_MSB 0x000d
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_MTU_RANGE 0x000e
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_MTU_MASK 0x00003fff
#define MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_MTU_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_NEXTHOP_MAP_MSG_NH_CONFIG_t NH_CONFIG;        // offset 4'h0, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_NH_STATUS_t NH_STATUS;        // offset 4'h8, width 64
    uint8_t                    rsvd0[131056];
    MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_0_t NH_NEIGHBORS_0[16384]; // offset 20'h20000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_NH_NEIGHBORS_1_t NH_NEIGHBORS_1[16384]; // offset 20'h40000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_0_t NH_GROUPS_0[4096]; // offset 20'h60000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUPS_1_t NH_GROUPS_1[4096]; // offset 20'h68000, width 64
    uint8_t                    rsvd1[65536];
    MBY_PPE_NEXTHOP_MAP_MSG_NH_ROUTES_t NH_ROUTES[16384]; // offset 20'h80000, width 64
    // starting the regfile section
    struct {
        MBY_PPE_NEXTHOP_MAP_MSG_NH_WEIGHTS_t NH_WEIGHTS[8];    // offset 4'h0, width 64
    } NH_WEIGHTS[2048];                          // offset 24'h0A0000, size: 64
    MBY_PPE_NEXTHOP_MAP_MSG_INGRESS_VID_TABLE_t INGRESS_VID_TABLE[4096]; // offset 24'h0C0000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_FLOOD_GLORT_TABLE_t FLOOD_GLORT_TABLE[256]; // offset 24'h0C8000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_NH_USED_t NH_USED[256];     // offset 24'h0C8800, width 64
    uint8_t                    rsvd2[94208];
    MBY_PPE_NEXTHOP_MAP_MSG_NH_PATH_CTRS_t NH_PATH_CTRS[16384]; // offset 24'h0E0000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_NH_GROUP_MIN_t NH_GROUP_MIN[512]; // offset 24'h100000, width 64
    MBY_PPE_NEXTHOP_MAP_MSG_MTU_TABLE_t MTU_TABLE[8];     // offset 24'h101000, width 64
} mby_ppe_nexthop_map_t;                         // size:  24'h101040


#endif // _MBY_PPE_NEXTHOP_MAP_REGS_H_


#
# 
if {0} {
  _collage_temp_set_tag_on_pins "PWRGOOD_VNN_PMC" SOURCE pmc/pmc_vnn_pwrgood
  _collage_temp_set_tag_on_pins "PWRGOOD_VNN_PMC" SINK sbr0/fdfx_powergood
  _collage_get_design_sources POWERGOOD_VNN_PMC
  _collage_get_design_sinks POWERGOOD_VNN_PMC

  _collage_gen_tag_based_adhoc_file adhoc_tag_PWRGOOD_VNN_PMC.txt PWRGOOD_VNN_PMC
}

proc collage_gen_tag_based_adhoc_file {args} {
  parse_proc_arguments -args $args opts

  set fn $opts(-file)
  set descriptor_tag $opts(-tag)


  set src [_collage_get_design_sources ${descriptor_tag}]
  set sinks [_collage_get_design_sinks ${descriptor_tag}]
  
  set fh [open $fn w]

  if {$src == ""} {
    print_warning "No source found for: $descriptor_tag"
  }

  if {$sinks == ""} {
    print_warning "No sinks found for: $descriptor_tag "
  }

  foreach sink [lsort -uniq $sinks] {
    puts $fh "C $src $sink"
  }

  close $fh
  
}

define_proc_attributes collage_gen_tag_based_adhoc_file \
    -info "Generate adhoc connection file based on specified tag" \
    -define_args {
      {"-file"     "File name to write tags into"   "" string required}
      {"-tag"      "Name of tag to use, for example PWRGOOD_VNN_PMC"   "" string required}
    }


proc _collage_get_design_pins {descriptor_tag_id} {
  if { ![::collage_descriptor_tag::_is_descriptor_tag_registered $descriptor_tag_id] } {
    set err_msg "Descriptor TAG $descriptor_tag_id is not registered"
    print_error $err_msg
    error $err_msg
  }

  set design [current_design -quiet]
  set value [get_attribute $design -attr GenericAttr -subscript $descriptor_tag_id]

  return $value
}

proc _collage_get_design_sources {tag_name} { 
  return [_collage_get_design_pins ${tag_name}::SOURCE]
}

proc _collage_get_design_sinks {tag_name} { 
  return [_collage_get_design_pins ${tag_name}::SINK]
}

proc _collage_temp_set_tag_on_pins {tag kind pins} {
  set tag_name ${tag}::${kind}
  if {![::collage_descriptor_tag::_is_descriptor_tag_registered $tag_name]} {
    collage_register_descriptor_tag -descriptor_tag_name $tag_name -descriptor_tag_description "Generic User Tag"
  }

echo "DBG: tagging $pins with $tag_name"
  set cur_pins [_collage_get_design_pins $tag_name]
  collage_set_descriptor_tag -descriptor_tag_name $tag_name -descriptor_tag_value "$cur_pins $pins"
}



#########################################################################
# Collage process connectivity tags file
#########################################################################
# SYNTAX
# <keyword> <type> <tag name> <data>
# PGD SOURCE PGD_PMC_VNN {pmc/pmc_vnn_pwrgood}
# PGD SINK   PGD_PMC_VNN {sbr0/fdfx_pwrdgood}
proc collage_process_conn_tags_file {args} {
  parse_proc_arguments -args $args opts
  
  collage_process_clocks_file -file_name $opts(-file_name)
}

define_proc_attributes collage_process_conn_tags_file \
    -info "Collage - process connectivity tags files" \
    -define_args {
      {"-file_name"           "Connectivity tags file name"   "" string required}
    }


proc collage_tb_generate_sbr_collaterals {design_inst sbr_post_ti sbr_tb_override sbr_ti_inst sbr_names {use_force 0} {gen_always 0}} {
    set out_fh3 [open $sbr_post_ti w]
    set out_fh2 [open $sbr_tb_override w]
    set assign_force "assign"
    if {$use_force} {
      set assign_force "force"
    }

    if {$sbr_tb_override != ""} {
      puts $out_fh2 "#This file was automatically generated by SBOX TB assembly Flow"
      puts $out_fh2 "#source/soc/collage/assemble/soc_tb_utils.tcl collage_tb_generate_sbr_collaterals\n"
    }

    puts $out_fh3 "// This file was automatically generated by SBOX TB assembly Flow"
    puts $out_fh3 "// source/soc/collage/assemble/soc_tb_utils.tcl collage_tb_generate_sbr_collaterals\n"

    foreach s $sbr_names {
      echo "Doing SBR $s"
      set su [string toupper $s]
      #set s_hier "[::col::get_ip_hier_par $s]/$s"
      set s_hier [collage_get_hier_name -ip_name $s]
      echo "SBR NEW = $s and partition = $s_hier"
      eval_in_component $s_hier {
          set enports [_collage_sbr_param_val "NUMPORT_F"]
          echo "total ports = $enports"
          for {set port 0} {$port < $enports} {incr port} {
              set r2r [_collage_get_sbr_attr_val $s $port P${port}_R2R]
              if {$r2r ne ""} {
                continue
              }
              if {[_collage_sbr_is_router2router_link $port]} {
                  continue
              }

              set port_unused [_collage_get_sbr_attr_val $s $port P${port}_PORT_UNUSED]
              if {$port_unused ne ""} {
                continue
              }

              set mi_port_un [find_item -quiet -type param [collage_get_folded_name -name ${s}]/P${port}MI_PORT_UNUSED]
              if {$mi_port_un ne ""} {
                set mi_port_unused2 [_collage_sbr_param_val "P${port}MI_PORT_UNUSED"]
                set unused_attr_val [_collage_get_sbr_attr_val $s $port P${port}MI_PORT_UNUSED]
                if {$unused_attr_val ne ""} {
                  set mi_port_unused2 $unused_attr_val
                }
                if {$mi_port_unused2} {
                  echo "MI PORT UNUSED - TB : $s for port $port"
                  continue
                }
              }
              set f_port_name [_collage_sbr_param_val P${port}_NAME]
              set pname_attr_val [_collage_get_sbr_attr_val $s $port P${port}_NAME]
              if {$pname_attr_val ne ""} {
                set f_port_name $pname_attr_val
              }
              set orig_port_name [string toupper ${f_port_name}]
              set f_port_name "${f_port_name}_if"
              if {[info exists ::collage_tb::enable_suffix]} {
                set orig_port_name_en ${orig_port_name}$::collage_tb::enable_suffix
              } else {
                set orig_port_name_en ${orig_port_name}_ENABLE
              }
              set uspec_name [::collage_tb::_get_user_ip_enable_name_by_ifc_inst ${sbr_ti_inst}_${f_port_name}]
              if {$uspec_name ne ""} {
                set orig_port_name_en $uspec_name
              } 
              if {[info exists ::collage_tb::fabric_uspec_map($orig_port_name_en)]} {
                set orig_port_name_en $::collage_tb::fabric_uspec_map($orig_port_name_en)
              }
              set user_clkack "[lindex [collage_tb_get_sv_intf_conn_all ${sbr_ti_inst}_${f_port_name} "" "side_clkack" M] 0]"
              set user_clkreq "[lindex [collage_tb_get_sv_intf_conn_all ${sbr_ti_inst}_${f_port_name} "" "side_clkreq" M] 0]"
              set side_clkack "${assign_force} ${sbr_ti_inst}_${f_port_name}.side_clkack = '1;"
              set side_clkreq "${assign_force} ${sbr_ti_inst}_${f_port_name}.side_clkreq = '1;"
              if {$user_clkack ne "" && $user_clkack ne "<open>"} {
                set side_clkack "${assign_force} ${sbr_ti_inst}_${f_port_name}.side_clkack = ${user_clkack};"
              }
              if {$user_clkreq ne "" && $user_clkreq ne "<open>"} {
                set side_clkreq "${assign_force} ${sbr_ti_inst}_${f_port_name}.side_clkreq = ${user_clkreq};"
              }  

              if {$::collage_tb::use_generate} {
                puts $out_fh3 "generate"
                puts $out_fh3 "  if\ ($orig_port_name_en == 1) begin"
                
                echo "On port $port -  $f_port_name"
                set clkreqack_monitor_lines [sbr_get_agent_reqack $design_inst $s $port $f_port_name "M"]
                if {$clkreqack_monitor_lines != ""} {
                  if {$user_clkack ne "" && $user_clkack ne "<open>"} { 
                    puts $out_fh3 "     $side_clkack"
                    puts $out_fh3 "     $side_clkreq"
                  } else {
                    puts $out_fh3 "$clkreqack_monitor_lines"
                  }
                } else {
                  puts $out_fh3 "     $side_clkack"
                  puts $out_fh3 "     $side_clkreq"
                }
                puts $out_fh3 "  end"
                puts $out_fh3 "  else begin"
                set clkreqack_driver_lines [sbr_get_agent_reqack "soc" $s $port $f_port_name "D"]
                if {$clkreqack_driver_lines != "" && !$gen_always} {
                  puts $out_fh3 "$clkreqack_driver_lines"
                } else {
                  puts $out_fh3 "   always \@\(posedge ${sbr_ti_inst}_${f_port_name}.side_clk \) begin"
                  puts $out_fh3 "     ${sbr_ti_inst}_${f_port_name}.side_clkack <= ${sbr_ti_inst}_${f_port_name}.side_clkreq;"
                  puts $out_fh3 "   end"
                }
                puts $out_fh3 "   end"
                puts $out_fh3 "endgenerate"
                puts $out_fh3 ""
              } else {
                if {[info exists ::collage_tb::ifdef_var]} {
                  puts $out_fh3 "${::collage_tb::ifdef_var} $orig_port_name_en"
                } else {
                  puts $out_fh3 "\`ifdef $orig_port_name_en"
                }
                set clkreqack_monitor_lines [sbr_get_agent_reqack $design_inst $s $port $f_port_name "M"]
                if {$clkreqack_monitor_lines != ""} {
                  if {$user_clkack ne "" && $user_clkack ne "<open>"} {
                    puts $out_fh3 "     $side_clkack"
                    puts $out_fh3 "     $side_clkreq"
                  } else {
                    puts $out_fh3 "$clkreqack_monitor_lines"
                  }
                } else {
                  puts $out_fh3 "     $side_clkack"
                  puts $out_fh3 "     $side_clkreq"
                }
                puts $out_fh3 "\`else"
                set clkreqack_driver_lines [sbr_get_agent_reqack "soc" $s $port $f_port_name "D"]
                if {$clkreqack_driver_lines != "" && !$gen_always} {
                  puts $out_fh3 "$clkreqack_driver_lines"
                } else {
                  puts $out_fh3 "   always \@\(posedge ${sbr_ti_inst}_${f_port_name}.side_clk \) begin"
                  puts $out_fh3 "     ${sbr_ti_inst}_${f_port_name}.side_clkack <= ${sbr_ti_inst}_${f_port_name}.side_clkreq;"
                  puts $out_fh3 "   end"
                }
                puts $out_fh3 "\`endif"
                puts $out_fh3 ""

              }

              if {$sbr_tb_override != ""} {
                puts $out_fh2 "Fii ${sbr_ti_inst} ${f_port_name}"
              }
         }
     }
 }
 close $out_fh2
 close $out_fh3
}


# --------------------------------------
# Generate assign lines (monitor) to CLKREQ/ACK RTL ports of 
# the agent connected to a SBR router 
# 
# Assumptions: if there is > 1 SB interface, but only 1 SB::Power, the
# same SB::Power will be returned for both
# 
# Usage example: sbr_get_agent_reqack smca sbrscc 4 scc
# --------------------------------------
proc sbr_get_agent_reqack {dut_prefix sbr_name port_number f_port_name dir} {
  
  set ret_val ""

  # get the SBR RTL interface instance
  set i [find_interface_instances -component [collage_get_folded_name -name $sbr_name] -name port_${port_number}]


  if {[sizeof_collection $i] == 0} { return } ; # did not find rtl ifc

  # get connected agent ifc
  set agent_i [get_attribute  $i  -attr TargetConnection -subscript AllConsumers ]
  if {[sizeof_collection $agent_i] == 0} { return } ;    # nothing connected

  # get connected agent comp
  set top [lindex [split [get_attribute $agent_i -attr ComponentUserName] /] 1] 
#  if {[collage_is_mi_inst -name $top]} {
#    set agent $top
#  } else {
#    set agent [get_attribute $agent_i -attr ComponentOfItem]
#  }

  #set agent "/[regsub -all "%" [get_attribute $agent_i -attr InterfaceComponent] "/"]"
  set agent [::col::col_get_component_name $agent_i]
  
  echo "Evaluating $agent"

  set d_name [set d_unelab_name ""]
  eval_in_component $agent {
    set cur_d [current_design -quiet]
    sv_lassign [get_attribute -attrs "Name UnelabName"  $cur_d] d_name d_unelab_name
  }
  set cur_comp_is_rpt 0
  if {$d_unelab_name == "sbr_rpt"} {set cur_comp_is_rpt 1}
  while {$cur_comp_is_rpt} {
    set direction AllConsumers
    set ifc_name rpt_agt_side

    set ifc [find_interface_instances -component $agent -name $ifc_name -quiet]
    set agent_i [get_attribute $ifc -attr TargetConnection -subscript ${direction}]

    if {$agent_i == ""} {return}

    #set component [get_attribute -attrs ComponentOfItem $connection]
    #set agent "/[regsub -all "%" [get_attribute $agent_i -attr InterfaceComponent] "/"]"
    set agent [::col::col_get_component_name $agent_i]
    
    echo "Found $agent on agent side of repeater"
    eval_in_component $agent {
      set cur_d [current_design -quiet]
      sv_lassign [get_attribute -attrs "Name UnelabName"  $cur_d] d_name d_unelab_name
    }

    if {$d_unelab_name != "sbr_rpt"} {set cur_comp_is_rpt 0}
  }


  # find SB::Power ifc on agent comp
  set agent_cra_i [find_interface_instances -component $agent -filter {InterfaceDefinitionName==IOSF::SB::Power}]
  # if found only 1
  if {[sizeof_collection $agent_cra_i] != 1} { 
    # did not find or found more than 1 SB::Power
    return 
  }

  # find SB::Reset ifc on agent comp
  set found_rst_ifc 1 
  set agent_rst_i [find_interface_instances -component $agent -filter {InterfaceDefinitionName==IOSF::SB::Reset}]
  if {[sizeof_collection $agent_rst_i] != 1} { 
    # did not find or found more than 1 SB::Power
    set found_srt_ifc 0 
  }

  set subsys $::collage_tb::sbr_subsystems_map($sbr_name)
  set subsys_prefix $::collage_tb::sbr_subsystems_prefix($subsys)
  set ti_name ${subsys_prefix}

  set agent_hier_with_dot [regsub -all {/} $agent {.}]

  if {$found_rst_ifc} {
   set sig SIDE_RST_B
   set rst_port [get_interface_port_attribute -instance $agent_rst_i $sig InterfaceLink]
   set sv_sig [string tolower $sig]
  }
  if {$rst_port == "" || $rst_port == "<open>"} {
    set found_rst_ifc 0
  }
  if {$found_rst_ifc} {
   set rst_port_full_hier ${dut_prefix}${agent_hier_with_dot}.$rst_port
   if {$dir == "M"} {
         append ret_val "     initial force ${ti_name}_sideband_ti_${f_port_name}.${sv_sig} = $rst_port_full_hier ;\n"
   }
  }
  # get interface link of req/ack pins
  foreach sig "SIDE_CLKREQ SIDE_CLKACK" {
    set rtl_port [get_interface_port_attribute -instance $agent_cra_i $sig InterfaceLink]
    if {$rtl_port == "" || $rtl_port == "<open>"} {
      continue
    }
    set rtl_port_full_hier ${dut_prefix}${agent_hier_with_dot}.$rtl_port
    echo "RTL port is: $rtl_port_full_hier"
    # assign chs_sideband_ti_${f_port_name}.side_clkack
    set sv_sig [string tolower $sig]
    if {$dir == "M"} {
       if {[info exists ::collage_tb::sv_interface_map(${ti_name}_sideband_ti_${f_port_name},USER_SBR_POST_TI_FORCE)]} {
         append ret_val "     initial force ${ti_name}_sideband_ti_${f_port_name}.${sv_sig} = $rtl_port_full_hier ;\n"
       } else {
         append ret_val "     assign ${ti_name}_sideband_ti_${f_port_name}.${sv_sig} = $rtl_port_full_hier ;\n"
       }
    }
    if {$dir == "D"} {
       if {$sig == "SIDE_CLKREQ"} {
         if {[info exists ::collage_tb::sv_interface_map(${ti_name}_sideband_ti_${f_port_name},USER_SBR_POST_TI_FORCE)]} {
           append ret_val "     initial force $rtl_port_full_hier = ${ti_name}_sideband_ti_${f_port_name}.${sv_sig}; \n"
         } else {
           append ret_val "     assign $rtl_port_full_hier = ${ti_name}_sideband_ti_${f_port_name}.${sv_sig}; \n"
         }
       } else {
           if {[info exists ::collage_tb::sv_interface_map(${ti_name}_sideband_ti_${f_port_name},USER_SBR_POST_TI_FORCE)]} {
             append ret_val "     initial force ${ti_name}_sideband_ti_${f_port_name}.${sv_sig} = $rtl_port_full_hier ;\n"
           } else {
             append ret_val "     assign ${ti_name}_sideband_ti_${f_port_name}.${sv_sig} = $rtl_port_full_hier ;\n"
           }
       }
    }

  }

  return $ret_val
}

proc collage_set_sbr_attr_val {fname} {
  if {![file isfile $fname] || ![file readable $fname]} {
    print_info "$fname is not a file or readable. Please fix it and rerun."
  }
  array unset Sbr_Attrs 
  array set Sbr_Attrs {}
  sv_for_file l $fname {
    set l [string trim $l]
    if {$l == ""} {continue}
    if {[regexp {^\#} $l]} {continue}
    if {[llength $l] != 4} {error "Input format is incorrect. Should be <instance_name> <port_number> <attr> <value>"}
    sv_lassign $l inst_name port_num attr val
    lappend Sbr_Attrs($inst_name) [list $port_num $attr $val]
  }
  foreach i [array names Sbr_Attrs] {
    collage_eval_in_component -use_hier_par $i {
      set_attribute  [find_item -type cell [collage_get_folded_name -name $i]] -attr GenericAttr -subscript ${i} -value $Sbr_Attrs($i)
    }
  }
}

proc _collage_get_sbr_attr_val {inst_name port_num attr} {
  set res ""
  collage_eval_in_component .. {
    set ll [get_attribute [find_item -type cell [collage_get_folded_name -name $inst_name]] -attrs GenericAttr -subscript ${inst_name}]
    foreach l $ll {
      sv_lassign $l p_num atr val
      if {$p_num == $port_num && $atr == $attr} {set res $val; break;}
    }
  }
  return $res
}

proc collage_tb_add_sv_inst_rtlport_name {sv_inst_name sv_intf_name dut_inst_hier dut_inst dut_intf} {
  if {[info exists ::collage_tb::sv_interface_map($sv_inst_name,rtlportname)]} {
    return
  }
  if {[lsearch $::collage_tb::fabric_iosf_sb_hier [collage_get_hier_to_flat_name -hier_name $dut_inst_hier]] != -1 && [::collage_tb::_isa_iosf_sb_sv_ifc $sv_intf_name]} {
    set rtl_port_number [lindex [split $dut_intf "_"] end]
    if {![string is integer $rtl_port_number]} {
      return
    }
    eval_in_component $dut_inst_hier {
      if {! [catch {set is_route [get_configuration_parameter P${rtl_port_number}ROUTER2ROUTER]}] } {
        if {!$is_route} {
          if {! [catch {set rtlportname [get_configuration_parameter P${rtl_port_number}_NAME]}] } {
            set attr_val [_collage_get_sbr_attr_val $dut_inst $rtl_port_number P${rtl_port_number}_NAME]
            if {$attr_val ne ""} {
              set rtlportname $attr_val
            }
            if {$::collage_tb::enable_mi_corekit} {
              puts $::collage_tb::fmi_corekit "set ::collage_tb::sv_interface_map($sv_inst_name,rtlportname) $rtlportname"
            }
            set ::collage_tb::sv_interface_map($sv_inst_name,rtlportname) $rtlportname
          }
        }
      }
    }
  }
}

# dmcheria - Patch of _collage_tb_verif_write_dut so we can generate module instance with and without wires
# Emulation needs a dut module instance without testbench wire connections.
#################################################################################
# Write DUT
# _collage_tb_verif_write_dut
#################################################################################
proc _collage_tb_verif_write_dut {dut_inst_name} {
  global collage_tb_addons

  if {$::collage_tb::enable_split_tb_sv} {
    #puts $collage_tb_addons "  `ifndef EMULATION\n"
    puts $collage_tb_addons "    `include \"${::collage_tb::collage_design}_module.sv\"\n"
    #puts $collage_tb_addons "  `else\n"
    #puts $collage_tb_addons "    `include \"${::collage_tb::collage_design}_emu_module.sv\"\n"
    set dut_module "$::env(COLLAGE_WORK)/$::collage_tb::collage_design/src/${::collage_tb::collage_design}_module.sv"
    set ::collage_tb::collage_tb_misc_arr(reconfig_tb_files,MODULE) $dut_module
    puts $collage_tb_addons "   `include \"${::collage_tb::pre_post_include_prefix}_pre_ti_include.sv\"\n"
    set module_inst_file [open "$dut_module" "w"]
  } else {
    set module_inst_file $collage_tb_addons
  }

  if {$::collage_tb::enable_auto_wdu && $::collage_tb::enable_auto_wdu_include} {  
    puts $module_inst_file "`include ${::collage_tb::dut_inst_name}_autowdu.sv"
  }
  
  # Collect DUT data
  set dut_inst_ref [find_item -quiet -type cell $dut_inst_name]
  if {[sizeof_collection $dut_inst_ref] == 0} { 
    set emsg "COLLAGE_TB: write DUT - unable to find dut instance: $dut_inst_name"
    collage_message_print "TB-043" $emsg
    collage_message_print "TB-081" $emsg
  }
  set dut_design_ref [get_attribute -attrs ReferenceDesign $dut_inst_ref]
  set dut_module_name [get_attribute -attrs UnelabName $dut_design_ref]
  
  # DUT Parameters
  array set dut_params {}
  foreach_in_collection p [find_item -quiet -type param ${dut_inst_name}/* -filter "FromArchitecture==0"] {
    sv_lassign [split [get_attribute -attrs Name $p]  "/"] comp pname
    set pval [get_configuration_parameter -component $comp $pname]
    if {[regexp {^0x} $pval]} {
      set pval [_collage_tb_get_hdl_value $comp $pname]
    }
    set dut_params($pname) $pval
  }


  # DUT Ports : Get the pins by direction and in sorted order
  set dut_pins [_collage_tb_get_dut_pins ${dut_inst_name}]
  set longest_pin_name 0
  foreach p $dut_pins {
    set this_pin_len [string length [lindex $p 0]]
    if {$this_pin_len > $longest_pin_name} {
      set longest_pin_name $this_pin_len
    }
  }
  
  incr longest_pin_name 2
  set num_ports [llength $dut_pins]

  # Write the DUT instantiation
  set dut_sv_string ""
  if {[array size dut_params] != 0} {
    append dut_sv_string "   ${dut_module_name}\n"
    append dut_sv_string "      #("
    set dut_params_list [lsort [array names dut_params]]
    set num_params [llength $dut_params_list]
    set idx 0
    foreach pname $dut_params_list {
      set pval $dut_params($pname)
      incr idx
      if {$idx == 1} {
        # this is the first param
        append dut_sv_string ".${pname}($pval)"
      } else {
        append dut_sv_string "        .${pname}($pval)"
      }

      if {$idx == $num_params} {
        # this is the last param
        append dut_sv_string ") ${dut_inst_name}\n"
      } else {
        append dut_sv_string ",\n"
      }
    }
  } else {
    append dut_sv_string "   ${dut_module_name} ${dut_inst_name}\n"
  }
  
  if {$num_ports > 0} {
    #Normal testbench dut instance with wires
    append dut_sv_string "   \`ifndef EMULATION\n" 
    set idx 0
    foreach p $dut_pins {
      set pname [lindex $p 0]
      set pname_wire [::collage_tb::_get_wdu ${dut_inst_name}/$pname]
      incr idx
      if {$idx == 1} {
        # this is the first port
        append dut_sv_string [format "      (.%-${longest_pin_name}s(%s)" ${pname} $pname_wire]
      } else {
        append dut_sv_string [format "       .%-${longest_pin_name}s(%s)" ${pname} $pname_wire]
      }

      if {$idx == $num_ports} {
        # this is the last port
        append dut_sv_string ");\n"
      } else {
        append dut_sv_string ",\n"
      }
    }
    # Emulation dut instance, no testbench wires
    append dut_sv_string "   \`else\n" 
    set idx 0
    foreach p $dut_pins {
      set pname [lindex $p 0]
      # no wire names
      set pname_wire ""
      incr idx
      if {$idx == 1} {
        # this is the first port
        append dut_sv_string [format "      (.%-${longest_pin_name}s(%s)" ${pname} $pname_wire]
      } else {
        append dut_sv_string [format "       .%-${longest_pin_name}s(%s)" ${pname} $pname_wire]
      }

      if {$idx == $num_ports} {
        # this is the last port
        append dut_sv_string ");\n"
      } else {
        append dut_sv_string ",\n"
      }
    }
    append dut_sv_string "   \`endif\n" 
  } else {
    append dut_sv_string "      ();\n"
  }

  puts $module_inst_file $dut_sv_string

  if {$::collage_tb::enable_split_tb_sv} {
    close $module_inst_file
  }
}

proc _collage_find_design_insts {unelab_name} {
  eval_in_component / {
    set insts {}; 
    set top_design_name [get_attribute -attrs Name [current_design -quiet]]
    foreach_in_collection d [find_item -quiet -type design -filter "Name=~$unelab_name || UnelabName=~$unelab_name"] {
      # Skip hierarchies
      if {[get_attribute -attr IsHierarchicalComponent $d]} {
        continue
      }
      foreach_in_collection cr [get_attribute -attrs CellReferences $d] {
        set mi_insts [collage_get_mi_hier_insts [get_attr $cr -attr Name]]
        if {[llength $mi_insts] != 0} {
          lappend insts $mi_insts
        } else {
          set inst_name [get_attribute -attrs ComponentOfItem $cr]
          lappend insts $inst_name
        }
      }
    }

    if {$unelab_name == $::collage_tb::sbr_config_mod_name} {
      foreach_in_collection d [find_item -quiet -type design] {
        if {[get_attribute -attrs GenericBooleanAttr -subscript Sbr_IsLocked $d]} {
          foreach_in_collection cr [get_attribute -attrs CellReferences $d] {
            set mi_insts [collage_get_mi_hier_insts [get_attr $cr -attr Name]]
            if {[llength $mi_insts] != 0} {
              lappend insts $mi_insts
            } else {
              set inst_name [get_attribute -attrs ComponentOfItem $cr]
              lappend insts $inst_name
            }
          }
        }
      }
    }

    if {$unelab_name == "psf_wrapper" || $unelab_name == "_psf2"} {
      foreach_in_collection d [find_item -quiet -type design] {
        if {[get_attribute -attrs GenericBooleanAttr -subscript Psf_IsLocked $d]} {
          foreach_in_collection cr [get_attribute -attrs CellReferences $d] {
            set mi_insts [collage_get_mi_hier_insts [get_attr $cr -attr Name]]
            if {[llength $mi_insts] != 0} {
              lappend insts $mi_insts
            } else {
              set inst_name [get_attribute -attrs ComponentOfItem $cr]
              lappend insts $inst_name
            }
          }
        }
      }
    }

  }

  set instances [join $insts]
  set instances [lsort -unique $instances]
  return $instances
}

proc _collage_tb_find_sbr_networks {} {
  #find all subsystems with sbrs, multiple sbr network support
  set tail_sbrList "" ; # Leaf names of sbrs
  foreach sbr_list [_collage_find_design_insts $::collage_tb::sbr_config_mod_name] {
    foreach s $sbr_list {
      set sbr_name " [collage_get_hier_to_flat_name -hier_name $s] "
      append tail_sbrlist $sbr_name
      set sbr_name [string trim $sbr_name]
      set ::collage_tb::sbr_design_inst($sbr_name) $s
    }
  }

  #print_info "sbr_design_inst: "
  #parray ::collage_tb::sbr_design_inst

  foreach subsys [::collage_subsystem::_get_registered_subsystems] {
    set subsystems_sbr_list ""
    foreach ips [collage_get_subsystem_ips -subsystem_id $subsys] {
      if {[lsearch $tail_sbrlist $ips] != -1} {
        set ::collage_tb::sbr_subsystems_map($ips) $subsys
        if {[lsearch $::collage_tb::sbr_subsystems $subsys] == -1} {
          lappend ::collage_tb::sbr_subsystems $subsys
        }
        #lappend subsystems_sbr_list $ips
        set result $::collage_tb::sbr_design_inst($ips)
        lappend subsystems_sbr_list $result
      }
    }
    if {$subsystems_sbr_list != ""} {
      print_info "HERE !!! subsys $subsys list $subsystems_sbr_list"
      set ::collage_tb::sbr_subsystems_map($subsys) $subsystems_sbr_list
    }
  }
  print_info "sbr_subsystems_map: subsystems map to sbr and visa versa"
  parray ::collage_tb::sbr_subsystems_map
  print_info "subsystems_sbr_list: instance to ip "
  parray ::collage_tb::sbr_design_inst
  print_info "subsystems containing sbrs"
  foreach sub $::collage_tb::sbr_subsystems {
    print_info "subsystems: $sub"
  }
}

proc collage_tb_generate_sbr_collaterals_wrapper {design_inst final_post_ti final_tb_override {use_force 0} {gen_always 0}} {
  _collage_tb_find_sbr_networks

  set post_ti_fh [open $final_post_ti w]
  set tb_override_fh [open $final_tb_override w]

  foreach sub $::collage_tb::sbr_subsystems {
    if { [info exists ::collage_tb::sbr_subsystems_prefix($sub)] } {
      set subsys_prefix $::collage_tb::sbr_subsystems_prefix($sub)
    } else {
      #If no prefix is found, set it to chs
      set subsys_prefix "chs"
    }
    set sbr_post_ti "${::_chs_gen_tb_specs_dir}/${subsys_prefix}_sbr_post_ti_include.sv"
    set sbr_tb_override "${::_chs_gen_tb_specs_dir}/${subsys_prefix}_sbr_tb_overrides.txt"
    set sbr_ti_inst "${subsys_prefix}_sideband_ti"
    set sbrList $::collage_tb::sbr_subsystems_map($sub) ; # Leaf names of sbrs
    print_info "sbr_post_ti $sbr_post_ti sbr_tb_override $sbr_tb_override sbr_ti_inst $sbr_ti_inst"
    set subsys_sbr_names [list]
    foreach sbr_hier_inst $sbrList {
      lappend subsys_sbr_names [collage_get_hier_to_flat_name -hier_name $sbr_hier_inst]
    }

    #This procedure generates the clkreq/ack connectivity
    #proc collage_tb_generate_sbr_collaterals { design_inst sbr_post_ti sbr_tb_override sbr_ti_inst sbr_names} {}
    collage_tb_generate_sbr_collaterals $design_inst $sbr_post_ti $sbr_tb_override $sbr_ti_inst $subsys_sbr_names $use_force $gen_always
    
    #Copy output for each subsystem file into one merged file 
    set fh [open $sbr_post_ti]
    fcopy $fh $post_ti_fh
    close $fh
    file delete $sbr_post_ti

    set fh [open $sbr_tb_override]
    fcopy $fh $tb_override_fh
    close $fh
    file delete $sbr_tb_override

  }

  close $post_ti_fh
  close $tb_override_fh

}

proc collage_get_mi_hier_insts {folded_name} {
  set insts {}
  if {[llength [array names ::col_mi::flat_instances $folded_name,*]] != 0} {
    foreach all_insts [array names ::col_mi::flat_instances $folded_name,*] {
      foreach inst $::col_mi::flat_instances($all_insts) {
        set inst_name "/[collage_get_hier_name -ip_name $inst]"
        lappend insts $inst_name
      }
    }
  }
  return $insts
}

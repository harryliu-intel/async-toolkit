MODULE Main;
IMPORT Args;
IMPORT Wr, Rd;
IMPORT FileWr, FileRd;
IMPORT Text;
IMPORT TextReader;
IMPORT Thread;
IMPORT OSError;

<* FATAL Wr.Failure, Thread.Alerted, Rd.EndOfFile, Rd.Failure, OSError.E *>

CONST
  Delims = " ";
  RawVers = "$Id$";
VAR
  Version := Text.Sub(RawVers, 15, Text.Length(RawVers) - 17);

PROCEDURE FormatNames(args: TextReader.T; countLimit := LAST(INTEGER)): TEXT =
  VAR
    result: TEXT := "";
  BEGIN
    TRY
      FOR i := 1 TO countLimit DO
        result := result & ", " & args.nextE(Delims, TRUE);
      END;
    EXCEPT ELSE END;
    RETURN result;
  END FormatNames;

PROCEDURE WriteProc(commaArgs, instArgs, build, name: TEXT) =
  BEGIN
    Wr.PutText(out, "\nreadonly proc " & name & "(nm" &
      commaArgs & ") is\n    " & build & "_generic_" & mode &
      "(nm & \"" & nm & "\", \"" & nm & "\"" & instArgs & ")\nend\n");
  END WriteProc;

PROCEDURE WriteProcs(commaArgs, instArgs, suffix: TEXT := "") =
  BEGIN
    WriteProc(commaArgs, instArgs, "build", lowNM & suffix);
    WriteProc(commaArgs, instArgs, "Build", nm & suffix);
  END WriteProcs;

PROCEDURE Braquefy(a: TEXT): TEXT =
  VAR
    in := a;
  BEGIN
    IF Text.Length(in) # 0 THEN
      in := Text.Sub(in, 2, LAST(INTEGER));
      (* strip leading comma *)
    END;
    RETURN ", [" & in & "]";
  END Braquefy;

PROCEDURE DoModule() =
  VAR
    line1 := Rd.GetLine(in);
    line2 := Rd.GetLine(in);    
    args1 := NEW(TextReader.T).init(line1);
    args2 := NEW(TextReader.T).init(line2);
    com := 0;
    comma, bracket: ARRAY [0..2] OF TEXT;
    (* 0 = common, 1 = interface, 2 = implementation *)
  BEGIN
    Wr.PutText(out, "/* intf_args = \""&line1 &
      "\", impl_args = \""&line2&"\" */\n");
    TRY
      WHILE Text.Equal(args1.nextE(Delims, TRUE),
                       args2.nextE(Delims, TRUE)) DO
        INC(com);
      END;
    EXCEPT ELSE END;
    args1 := NEW(TextReader.T).init(line1);
    args2 := NEW(TextReader.T).init(line2);
    comma[0] := FormatNames(args1, com);
    comma[0] := FormatNames(args2, com);
    comma[1] := FormatNames(args1);
    comma[2] := FormatNames(args2);
    bracket[1] := Braquefy(comma[0] & comma[1]);
    bracket[2] := Braquefy(comma[0] & comma[2]);
    WriteProcs(comma[0] & comma[1] & comma[2], bracket[1] & bracket[2]);
    mode := "interface";
    WriteProcs(comma[0] & comma[1], bracket[1], "_intf");
    mode := "implementation";
    WriteProcs(comma[0] & comma[2], bracket[2], "_impl");
  END DoModule;

PROCEDURE DoOther() =
  VAR
    line := Rd.GetLine(in);
    args := NEW(TextReader.T).init(line);
    comma: TEXT;
  BEGIN
    Wr.PutText(out, "/* args = \""&line&"\" */\n");
    <* ASSERT Text.Equal(mode, "interface") OR
    Text.Equal(mode, "implementation") *>
    comma := FormatNames(args);
    WriteProcs(comma, Braquefy(comma));
  END DoOther;

PROCEDURE LowerFirst(a: TEXT): TEXT =
  VAR
    c := ORD(Text.GetChar(a, 0));
  BEGIN
    <* ASSERT c >= ORD('A') AND c <= ORD('Z') *>
    RETURN Text.FromChar(VAL(c + ORD('a') - ORD('A'), CHAR)) &
           Text.Sub(a, 1, Text.Length(a) - 1);
  END LowerFirst;

VAR
  in := FileRd.Open(Args.CommandLine()[0]);
  mode := Rd.GetLine(in);
  nm := Rd.GetLine(in);
  lowNM := LowerFirst(nm);
  out := FileWr.Open(nm & ".tmpl");
BEGIN
  Wr.PutText(out, "/* generated by m3tmplhack version " & Version & " */\n");
  Wr.PutText(out, "/* mode = " & mode & ", source = " & nm & ".*g */\n");
  IF Text.Equal(mode, "module") THEN
    DoModule();
  ELSE
    DoOther();
  END;
  Wr.Close(out);
END Main.

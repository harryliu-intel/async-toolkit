// Autogenerated Jamon implementation
// C:/Users/mhesseli/Documents/Perforce/rrc-5/reg-main/shared/java/src/./com/fulcrummicro/hw/verification/chip/mgmt/registers/templates/CTable.jamon

package com.fulcrummicro.hw.verification.chip.mgmt.registers.templates;

// 3, 1
import java.util.Collection;
// 4, 1
import com.fulcrummicro.util.misc.Utility;
// 5, 1
import com.fulcrummicro.hw.verification.chip.mgmt.registers.Register;
// 6, 1
import com.fulcrummicro.hw.verification.chip.mgmt.registers.RegisterType;

public class CTableImpl
  extends com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CImpl
  implements com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CTable.Intf

{
  private final Collection<Register> regs;
  private final String prefix;
  protected static com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CTable.ImplData __jamon_setOptionalArguments(com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CTable.ImplData p_implData)
  {
    com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CImpl.__jamon_setOptionalArguments(p_implData);
    return p_implData;
  }
  public CTableImpl(org.jamon.TemplateManager p_templateManager, com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CTable.ImplData p_implData)
  {
    super(p_templateManager, __jamon_setOptionalArguments(p_implData));
    regs = p_implData.getRegs();
    prefix = p_implData.getPrefix();
  }
  
  @Override protected void child_render_2(final java.io.Writer jamonWriter)
    throws java.io.IOException
  {
    // 19, 1
    
final String lcPrefix = Utility.underscoreToCamelCase(prefix, false);
final String ucPrefix = lcPrefix.toUpperCase();

    // 23, 1
    jamonWriter.write("/**\n * INTEL CONFIDENTIAL\n * Copyright ");
    // 25, 14
    {
      // 25, 14
      __jamon_innerUnit__copyright_year(jamonWriter, __jamon__get_Method_Opt_creationYear_default());
    }
    // 25, 35
    jamonWriter.write(" Intel Corporation. All Rights Reserved.\n *\n * The source code contained or described herein and all documents related\n * to the source code (\"Material\") are owned by Intel Corporation or its\n * suppliers or licensors. Title to the Material remains with Intel\n * Corporation or its suppliers and licensors. The Material contains trade\n * secrets and proprietary and confidential information of Intel or its\n * suppliers and licensors. The Material is protected by worldwide copyright\n * and trade secret laws and treaty provisions. No part of the Material may\n * be used, copied, reproduced, modified, published, uploaded, posted,\n * transmitted, distributed, or disclosed in any way without Intel's prior\n * express written permission.\n *\n * No license under any patent, copyright, trade secret or other intellectual\n * property right is granted to or conferred upon you by disclosure or\n * delivery of the Materials, either expressly, by implication, inducement,\n * estoppel or otherwise. Any license under such intellectual property rights\n * must be express and approved by Intel in writing.\n *\n * THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.\n * Last Updated ");
    // 45, 17
    {
      // 45, 17
      __jamon_innerUnit__timestamp(jamonWriter);
    }
    // 45, 33
    jamonWriter.write("\n */\n\n#include \"fm_sdk_");
    // 48, 18
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 48, 32
    jamonWriter.write("_int.h\"\n\n/*****************************************************************************\n * Data Structures\n *****************************************************************************/\n\n/**************************************************\n * Register default values\n **************************************************/\n\ntypedef struct _fm_");
    // 58, 20
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 58, 34
    jamonWriter.write("RegisterDefault\n{\n    /* Mask to be applied to register address. */\n    fm_uint32   addrMask;\n\n    /* Expected result of applying addrMask to the register address. If\n     * result matches, then this table entry applies to the register. */\n    fm_uint32   addrResult;\n\n    /* Default value for this word */\n    fm_uint32   def;\n\n} fm_");
    // 70, 6
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 70, 20
    jamonWriter.write("RegisterDefault;\n\n\n/**************************************************\n * Register field types\n **************************************************/\n\ntypedef struct _fm_");
    // 77, 20
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 77, 34
    jamonWriter.write("RegisterAccess\n{\n    /* Mask to be applied to register address. */\n    fm_uint32   addrMask;\n\n    /* Expected result of applying addrMask to the register address. If\n     * result matches, then this table entry applies to the register. */\n    fm_uint32   addrResult;\n\n    /* Mask of bits with RW access */\n    fm_uint32   rwMask;\n\n    /* Mask of bits with RO access */\n    fm_uint32   roMask;\n\n    /* Mask of bits with CW access */\n    fm_uint32   cwMask;\n\n    /* Mask of bits with CW1 access */\n    fm_uint32   cw1Mask;\n\n    /* Mask of bits with RV access */\n    fm_uint32   rvMask;\n\n} fm_");
    // 101, 6
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 101, 20
    jamonWriter.write("RegisterAccess;\n\n\n/**************************************************\n * Register reset domains\n **************************************************/\n\ntypedef struct _fm_");
    // 108, 20
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 108, 34
    jamonWriter.write("RegisterResetDomain\n{\n    fm_uint32 addrMask;\n\n    fm_uint32 addrResult;\n\n    fm_uint32 domainMask;\n\n} fm_");
    // 116, 6
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 116, 20
    jamonWriter.write("RegisterResetDomain;\n\n/*****************************************************************************\n * Register Tables\n *****************************************************************************/\n\n\n/**************************************************\n * List of register words that have at least one\n * bit not of type RW.\n **************************************************/\n\nconst fm_");
    // 128, 10
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 128, 24
    jamonWriter.write("RegisterAccess ");
    // 128, 39
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 128, 53
    jamonWriter.write("RegisterFieldTypeTable[] =\n{\n/*   addrMask    addrResult  rwMask      roMask      cwMask      cw1Mask     rvMask          name [word] */\n");
    // 131, 1
    for (Register reg : regs )
    {
      // 135, 1
      if (reg.getAlias() == null &&
     reg.getTypeMaskExpanded(null).cardinality() != 0 )
      {
        // 137, 1
        for (int i = 0, j = 0; i < reg.getEntryWidth(); i++, j += 32 )
        {
          // 138, 1
          if (reg.getTypeMaskExpanded(RegisterType.RW).getUnsignedInt(j) != 0xffffffff ||
     reg.getTypeMaskExpanded(RegisterType.RO).getUnsignedInt(j) != 0 ||
     reg.getTypeMaskExpanded(RegisterType.CW).getUnsignedInt(j) != 0 ||
     reg.getTypeMaskExpanded(RegisterType.CW1).getUnsignedInt(j) != 0 ||
     reg.getTypeMaskExpanded(RegisterType.RV).getUnsignedInt(j) != 0 )
          {
            // 142, 72
            jamonWriter.write("    {");
            // 143, 6
            {
              // 143, 6
              __jamon_innerUnit__xdisplay(jamonWriter, reg.getAddressMatchMaskExcludingWordBits(), 32 );
            }
            // 143, 76
            jamonWriter.write(", ");
            // 144, 1
            {
              // 144, 1
              __jamon_innerUnit__strfaddr(jamonWriter, reg.getAddress() + i );
            }
            // 144, 44
            jamonWriter.write(", ");
            // 145, 1
            {
              // 145, 1
              __jamon_innerUnit__xdisplay(jamonWriter, reg.getTypeMaskExpanded(RegisterType.RW).getUnsignedInt(j), 32 );
            }
            // 145, 87
            jamonWriter.write(", ");
            // 146, 1
            {
              // 146, 1
              __jamon_innerUnit__xdisplay(jamonWriter, reg.getTypeMaskExpanded(RegisterType.RO).getUnsignedInt(j), 32 );
            }
            // 146, 87
            jamonWriter.write(", ");
            // 147, 1
            {
              // 147, 1
              __jamon_innerUnit__xdisplay(jamonWriter, reg.getTypeMaskExpanded(RegisterType.CW).getUnsignedInt(j), 32 );
            }
            // 147, 87
            jamonWriter.write(", ");
            // 148, 1
            {
              // 148, 1
              __jamon_innerUnit__xdisplay(jamonWriter, reg.getTypeMaskExpanded(RegisterType.CW1).getUnsignedInt(j), 32 );
            }
            // 148, 88
            jamonWriter.write(", ");
            // 149, 1
            {
              // 149, 1
              __jamon_innerUnit__xdisplay(jamonWriter, reg.getTypeMaskExpanded(RegisterType.RV).getUnsignedInt(j), 32 );
            }
            // 149, 87
            jamonWriter.write("}, /* ");
            // 150, 4
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(reg.getName()), jamonWriter);
            // 150, 23
            if (reg.getEntryWidth()>1 )
            {
              // 150, 52
              jamonWriter.write(" [");
              // 150, 54
              org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(i), jamonWriter);
              // 150, 61
              jamonWriter.write("]");
            }
            // 150, 68
            jamonWriter.write(" */\n");
          }
        }
      }
    }
    // 154, 8
    jamonWriter.write("    /* Terminator */\n    {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}\n};\n\n\n/**************************************************\n * List of register words that have a non-zero\n * default value.\n **************************************************/\n\nconst fm_");
    // 165, 10
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 165, 24
    jamonWriter.write("RegisterDefault ");
    // 165, 40
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 165, 54
    jamonWriter.write("RegisterDefaultTable[] =\n{\n/*   addrMask    addrResult  default         name [word] */\n");
    // 168, 1
    for (Register reg : regs )
    {
      // 169, 1
      for (int j = 0; j < reg.getEntryWidth(); j++ )
      {
        // 170, 1
        if (reg.getDefault(0, j) != 0 )
        {
          // 170, 34
          jamonWriter.write("    {");
          // 171, 6
          {
            // 171, 6
            __jamon_innerUnit__xdisplay(jamonWriter, reg.getAddressMatchMaskExcludingWordBits(), 32 );
          }
          // 171, 76
          jamonWriter.write(", ");
          // 172, 1
          {
            // 172, 1
            __jamon_innerUnit__strfaddr(jamonWriter, reg.getAddress() + j );
          }
          // 172, 44
          jamonWriter.write(", ");
          // 173, 1
          {
            // 173, 1
            __jamon_innerUnit__xdisplay(jamonWriter, reg.getDefault(0, j), 32 );
          }
          // 173, 49
          jamonWriter.write("}, /* ");
          // 174, 4
          org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(reg.getName()), jamonWriter);
          // 174, 23
          if (reg.getEntryWidth()>1 )
          {
            // 174, 52
            jamonWriter.write(" [");
            // 174, 54
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(j), jamonWriter);
            // 174, 61
            jamonWriter.write("]");
          }
          // 174, 68
          jamonWriter.write(" */\n");
        }
      }
    }
    // 177, 8
    jamonWriter.write("    /* Terminator */\n    {0x00000000, 0x00000000, 0x00000000}\n};\n\n\n/**************************************************\n * List of register words that are on a separate\n * reset domain\n **************************************************/\n\nconst fm_");
    // 188, 10
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 188, 24
    jamonWriter.write("RegisterResetDomain ");
    // 188, 44
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 188, 58
    jamonWriter.write("ResetDomainTable[] =\n{\n/*   addrMask    addrResult  domainMask */\n");
    // 191, 1
    for (Register reg : regs )
    {
      // 191, 29
      jamonWriter.write("    {");
      // 192, 6
      {
        // 192, 6
        __jamon_innerUnit__xdisplay(jamonWriter, reg.getAddressMatchMask(), 32 );
      }
      // 192, 59
      jamonWriter.write(", ");
      // 193, 1
      {
        // 193, 1
        __jamon_innerUnit__strfaddr(jamonWriter, reg.getAddress() );
      }
      // 193, 40
      jamonWriter.write(", ");
      // 194, 1
      {
        // 194, 1
        __jamon_innerUnit__rstmask(jamonWriter, reg );
      }
      // 194, 23
      jamonWriter.write("}, /* ");
      // 194, 29
      org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(reg.getName()), jamonWriter);
      // 194, 48
      jamonWriter.write(" */\n");
    }
    // 195, 8
    jamonWriter.write("    /* Terminator */\n    {");
    // 197, 6
    {
      // 197, 6
      __jamon_innerUnit__xdisplay(jamonWriter, 0, 32 );
    }
    // 197, 35
    jamonWriter.write(", ");
    // 198, 1
    {
      // 198, 1
      __jamon_innerUnit__strfaddr(jamonWriter, 0 );
    }
    // 198, 25
    jamonWriter.write(", ");
    // 199, 1
    {
      // 199, 1
      __jamon_innerUnit__xdisplay(jamonWriter, 0, 32 );
    }
    // 199, 30
    jamonWriter.write("}\n};\n\n\n/*****************************************************************************\n * Public Functions\n *****************************************************************************/\n\n/*****************************************************************************/\n/** ");
    // 208, 5
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 208, 19
    jamonWriter.write("ModelFindRegisterResetDomain\n * \\ingroup intModel\n *\n * \\desc            Searches the set of reset domains for the given register for\n *                  the given reset domain.\n *\n * \\param[in]       addr is the register's address in the ");
    // 214, 59
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(ucPrefix), jamonWriter);
    // 214, 73
    jamonWriter.write(" register\n *                  space.\n *\n * \\param[in]       domain is the reset domain to search for.\n *\n * \\return          TRUE if the reset domain is found in the set of reset\n *                  domains for the given register.\n * \\return          FALSE otherwise\n *\n *****************************************************************************/\n");
    // 224, 1
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 224, 15
    jamonWriter.write("_resetDomain ");
    // 224, 28
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 224, 42
    jamonWriter.write("ModelFindRegisterResetDomain(fm_uint32 addr, ");
    // 224, 87
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 224, 101
    jamonWriter.write("_resetDomain domain)\n{\n    const fm_");
    // 226, 14
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 226, 28
    jamonWriter.write("RegisterResetDomain *rst;\n\n    /* Search the register reset domain table to check if this register is part\n     * of the given reset domain. */\n    rst = ");
    // 230, 11
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 230, 25
    jamonWriter.write("ResetDomainTable;\n\n    while (rst->addrMask)\n    {\n        if ( (addr & rst->addrMask) == rst->addrResult )\n        {\n            if ( ( rst->domainMask & (1 << domain) ) != 0 )\n            {\n                return TRUE;\n            }\n            break;\n        }\n        ++rst;\n    }\n\n    return FALSE;\n\n}   /* end ");
    // 247, 12
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 247, 26
    jamonWriter.write("ModelFindRegisterResetDomain */\n\n\n\n\n/*****************************************************************************/\n/** ");
    // 253, 5
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 253, 19
    jamonWriter.write("ModelGetRegisterDefault\n * \\ingroup intModel\n *\n * \\desc            Returns the default value for the given register.\n *                                                                      \\lb\\lb\n *                  The defaults table is searched for a non-zero default value.\n *                  If none, zero is returned as the default, otherwise the\n *                  default from the table is returned.\n *\n * \\param[in]       addr is the register's address in the ");
    // 262, 59
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(ucPrefix), jamonWriter);
    // 262, 73
    jamonWriter.write(" register\n *                  space.\n *\n * \\return          Default value\n *\n *****************************************************************************/\nfm_uint32 ");
    // 268, 11
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 268, 25
    jamonWriter.write("ModelGetRegisterDefault(fm_uint32 addr)\n{\n    const fm_");
    // 270, 14
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 270, 28
    jamonWriter.write("RegisterDefault *defaults;\n    fm_uint32                       rtnValue = 0;\n\n    /**************************************************\n     * Search the defaults table to see if this reg\n     * has a non-zero default value.\n     **************************************************/\n\n    defaults = ");
    // 278, 16
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 278, 30
    jamonWriter.write("RegisterDefaultTable;\n\n    while (defaults->addrMask)\n    {\n        /* Does masked address give the expected result? */\n        if ( (addr & defaults->addrMask) == defaults->addrResult )\n        {\n            rtnValue = defaults->def;\n            break;\n        }\n\n        ++defaults;\n    }\n\n    return rtnValue;\n\n}   /* end ");
    // 294, 12
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 294, 26
    jamonWriter.write("ModelGetRegisterDefault */\n\n\n\n/*****************************************************************************/\n/** ");
    // 299, 5
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 299, 19
    jamonWriter.write("ModelGetRegisterAccess\n * \\ingroup intModel\n *\n * \\desc            Returns various mask(Read-Write,Read-Only, etc.) values\n *                  for the given register.\n *\n * \\param[in]       addr is the register's address in the ");
    // 305, 59
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(ucPrefix), jamonWriter);
    // 305, 73
    jamonWriter.write(" register\n *                  space.\n *\n * \\param[out]      rwMask points to caller-allocated storage where this\n *                  function should place the mask identifying read-write bits.\n *\n * \\param[out]      roMask points to caller-allocated storage where this\n *                  function should place the mask identifying read-only bits.\n *\n * \\param[out]      cwMask points to caller-allocated storage where this\n *                  function should place the mask identifying clear-on-write\n *                  bits.\n *\n * \\param[out]      cw1Mask points to caller-allocated storage where this\n *                  function should place the mask identifying clear-on-write-1\n *                  bits.\n *\n * \\param[out]      rvMask points to caller-allocated storage where this\n *                  function should place the mask identifying reserved bits.\n *\n * \\return          None\n *\n *****************************************************************************/\nvoid ");
    // 328, 6
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 328, 20
    jamonWriter.write("ModelGetRegisterAccess(fm_uint32  addr,\n                                  fm_uint32 *rwMask,\n                                  fm_uint32 *roMask,\n                                  fm_uint32 *cwMask,\n                                  fm_uint32 *cw1Mask,\n                                  fm_uint32 *rvMask)\n{\n    const fm_");
    // 335, 14
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 335, 28
    jamonWriter.write("RegisterAccess *access;\n\n    /**************************************************\n     * Defaults for most registers.\n     **************************************************/\n\n    *rwMask  = 0xffffffff;\n    *roMask  = 0x00000000;\n    *cwMask  = 0x00000000;\n    *cw1Mask = 0x00000000;\n    *rvMask  = 0x00000000;\n\n    /**************************************************\n     * Search the access table to see if this reg\n     * has special access bit fields.\n     **************************************************/\n\n    access = ");
    // 352, 14
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 352, 28
    jamonWriter.write("RegisterFieldTypeTable;\n\n    while (access->addrMask)\n    {\n        /* Does masked address give the expected result? */\n        if ( (addr & access->addrMask) == access->addrResult )\n        {\n            *rwMask  = access->rwMask;\n            *roMask  = access->roMask;\n            *cwMask  = access->cwMask;\n            *cw1Mask = access->cw1Mask;\n            *rvMask  = access->rvMask;\n            break;\n        }\n\n        ++access;\n    }\n\n    return;\n\n}   /* end ");
    // 372, 12
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(lcPrefix), jamonWriter);
    // 372, 26
    jamonWriter.write("ModelGetRegisterAccess */\n\n");
  }
  
  
}

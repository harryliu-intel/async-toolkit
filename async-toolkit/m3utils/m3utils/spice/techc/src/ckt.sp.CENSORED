* tech comparison
.TEMP @TEMP@
.PARAM vtrue=@VOLT@

@OPTIONS@

.option search='@HSPICE_MODEL_ROOT@'
.lib '@HSPICE_MODEL@' @CORNER@

* std cell library with parasitics (optional):
@INCLUDELIB@

.SUBCKT nand_cell a b o1 vcc vssx 
* INPUT: a b 
* OUTPUT: o1 
* INOUT: vcc vssx 
*.PININFO a:I b:I 
*.PININFO o1:O 
*.PININFO vcc:B vssx:B 


************************
Mqn1 o1 a n1   vssx n@TRANSUFX@ @TRANSIZE@ 
Mqn2 n1 b vssx vssx n@TRANSUFX@ @TRANSIZE@ 
Mqp1 o1 a vcc  vcc  p@TRANSUFX@ @TRANSIZE@ 
Mqp2 o1 b vcc  vcc  p@TRANSUFX@ @TRANSIZE@ 
.ENDS  nand_cell


* the following is an Intel XOR
.SUBCKT xor_gate a b out0 vcc vssx VPP VBB
* VPP VBB unused
* INPUT: a b 
* OUTPUT: out0 
* INOUT: vcc vssx 

************************
Mg1.qna  n1   b  vssx VBB n@TRANSUFX@ @TRANSIZE@ 
Mg1.qpa  n1   b  vcc  VPP  p@TRANSUFX@ @TRANSIZE@ 
Mg2.qns  out0 a  n1   VBB n@TRANSUFX@ @TRANSIZE@ 
Mg2.qpsb out0 n3 n1   VPP  p@TRANSUFX@ @TRANSIZE@ 
Mg3.qna  n2   n1 vssx VBB n@TRANSUFX@ @TRANSIZE@ 
Mg3.qpa  n2   n1 vcc  VPP  p@TRANSUFX@ @TRANSIZE@ 
Mg4.qns  out0 n3 n2   VBB n@TRANSUFX@ @TRANSIZE@ 
Mg4.qpsb out0 a  n2   VPP  p@TRANSUFX@ @TRANSIZE@ 
Mg5.qna  n3   a  vssx VBB n@TRANSUFX@ @TRANSIZE@ 
Mg5.qpa  n3   a  vcc  VPP  p@TRANSUFX@ @TRANSIZE@ 
.ENDS 

* and a TSMC XOR
.subckt xor_cell_tsmc A1 A2 Z VDD VSS VPP VBB
.ends

.subckt buf_gate a o vcc vssx VPP VBB
*  INOUT: vcc vssx
*  INPUT: a
*  OUTPUT: o
Mg0.qpa.mp3 n1 a vcc VPP p@TRANSUFX@ @TRANSIZE@
Mg0.qna.mn2 n1 a vssx VBB n@TRANSUFX@ @TRANSIZE@
Mg101.qpa.mp3 o n1 vcc VPP p@TRANSUFX@ @TRANSIZE@
Mg101.qna.mn2 o n1 vssx VBB n@TRANSUFX@ @TRANSIZE@
.ends 

.subckt aoi_gate a b c o1 vcc vssx VPP VBB
*  INOUT: vcc vssx
*  INPUT: a b c
*  OUTPUT: o1
Mqnc1.mn2 n2 c vssx VBB n@TRANSUFX@ @TRANSIZE@
Mqnb1.mn2 o1 b n2 VBB n@TRANSUFX@ @TRANSIZE@
Mqna1.mn2 o1 a vssx VBB n@TRANSUFX@ @TRANSIZE@
Mqpc1.mp2 n1 c vcc VPP p@TRANSUFX@ @TRANSIZE@
Mqpb1.mp2 n1 b vcc VPP p@TRANSUFX@ @TRANSIZE@
Mqpa1.mp2 o1 a n1 VPP p@TRANSUFX@ @TRANSIZE@
.ends

.subckt oai_gate a b c o1 vcc vssx VPP VBB
*  INOUT: vcc vssx
*  INPUT: a b c
*  OUTPUT: o1
Mqpc1.mp2 n2 c vcc VPP p@TRANSUFX@ @TRANSIZE@
Mqpa1.mp2 o1 a vcc VPP p@TRANSUFX@ @TRANSIZE@
Mqpb1.mp2 o1 b n2 VPP p@TRANSUFX@ @TRANSIZE@
Mqna1.mn2 o1 a n1 VBB n@TRANSUFX@ @TRANSIZE@
Mqnb1.mn2 n1 b vssx VBB n@TRANSUFX@ @TRANSIZE@
Mqnc1.mn2 n1 c vssx VBB n@TRANSUFX@ @TRANSIZE@
.ends


**********************************************************************

.SUBCKT double_buf_cell in out vcc vssx
*  A     B     C       OUT  <--PWR-->
X0 @T0A@ @T0B@ @T0C@   xi   vcc  vssx  @PLUGTEXT@ @CELLNAME0@
X1 @T1A@ @T1B@ @T1C@   out  vcc  vssx  @PLUGTEXT@ @CELLNAME1@
.ENDS double_buf_cell

* Generic ring stage (make appropriate in/out/power connections to dut_cell)
.subckt ring_stage in out vcc vssx

* bfn000: a=in b=out vcc vssx
X0  in out vcc vssx double_buf_cell

.ends

* Fanout=1 => normal ring stage (alias subckt with vload port for scripting)
.subckt ring_stage_fo1 in out vcc vload vssx
xstage in out vcc vssx ring_stage
.ends

* Ring stage with fanout=N
*   => N-1 extra copies of dut_cell as load driven by in, with separate supply
.subckt ring_stage_fo2 in out vcc vload vssx
xstage in out vcc vssx ring_stage
xload in unc vload vssx ring_stage
.ends

.subckt ring_stage_fo3 in out vcc vload vssx
xstage in out vcc vssx ring_stage
xload0 in unc[0] vload vssx ring_stage
xload1 in unc[1] vload vssx ring_stage
.ends

.subckt ring_stage_fo4 in out vcc vload vssx
xstage in out vcc vssx ring_stage
xload0 in unc[0] vload vssx ring_stage
xload1 in unc[1] vload vssx ring_stage
xload2 in unc[2] vload vssx ring_stage
.ends

.subckt ring_stage_fo8 in out vcc vload vssx
xstage in out vcc vssx ring_stage
xload0 in unc[0] vload vssx ring_stage
xload1 in unc[1] vload vssx ring_stage
xload2 in unc[2] vload vssx ring_stage
xload3 in unc[3] vload vssx ring_stage
xload4 in unc[4] vload vssx ring_stage
xload5 in unc[5] vload vssx ring_stage
xload6 in unc[6] vload vssx ring_stage
.ends

* Ring oscillator with 20 DUT stages and 1 NAND2 enable
X1  x[0]   x[1]       vcc vload vssx ring_stage_fo@FANOUT@
X2  x[1]   x[2]       vcc vload vssx ring_stage_fo@FANOUT@
X3  x[2]   x[3]       vcc vload vssx ring_stage_fo@FANOUT@
X4  x[3]   x[4]       vcc vload vssx ring_stage_fo@FANOUT@
X5  x[4]   x[5]       vcc vload vssx ring_stage_fo@FANOUT@
X6  x[5]   x[6]       vcc vload vssx ring_stage_fo@FANOUT@
X7  x[6]   x[7]       vcc vload vssx ring_stage_fo@FANOUT@
X8  x[7]   x[8]       vcc vload vssx ring_stage_fo@FANOUT@
X9  x[8]   x[9]       vcc vload vssx ring_stage_fo@FANOUT@
X10 x[9]   x[10]      vcc vload vssx ring_stage_fo@FANOUT@
X11 x[10]  x[11]      vcc vload vssx ring_stage_fo@FANOUT@
X12 x[11]  x[12]      vcc vload vssx ring_stage_fo@FANOUT@
X13 x[12]  x[13]      vcc vload vssx ring_stage_fo@FANOUT@
X14 x[13]  x[14]      vcc vload vssx ring_stage_fo@FANOUT@
X15 x[14]  x[15]      vcc vload vssx ring_stage_fo@FANOUT@
X16 x[15]  x[16]      vcc vload vssx ring_stage_fo@FANOUT@
X17 x[16]  x[17]      vcc vload vssx ring_stage_fo@FANOUT@
X18 x[17]  x[18]      vcc vload vssx ring_stage_fo@FANOUT@
X19 x[18]  x[19]      vcc vload vssx ring_stage_fo@FANOUT@
X20 x[19]  x[20]      vcc vload vssx ring_stage_fo@FANOUT@
X21 _RESET x[20] x[0] vcc vssx nand_cell

* Ring oscillator with 20 DUT stages and 1 NAND2 enable
X101  x[100]   x[101]       vcc vload vssy ring_stage_fo@FANOUT@
X102  x[101]   x[102]       vcc vload vssy ring_stage_fo@FANOUT@
X103  x[102]   x[103]       vcc vload vssy ring_stage_fo@FANOUT@
X104  x[103]   x[104]       vcc vload vssy ring_stage_fo@FANOUT@
X105  x[104]   x[105]       vcc vload vssy ring_stage_fo@FANOUT@
X106  x[105]   x[106]       vcc vload vssy ring_stage_fo@FANOUT@
X107  x[106]   x[107]       vcc vload vssy ring_stage_fo@FANOUT@
X108  x[107]   x[108]       vcc vload vssy ring_stage_fo@FANOUT@
X109  x[108]   x[109]       vcc vload vssy ring_stage_fo@FANOUT@
X1010 x[109]   x[1010]      vcc vload vssy ring_stage_fo@FANOUT@
X1011 x[1010]  x[1011]      vcc vload vssy ring_stage_fo@FANOUT@
X1012 x[1011]  x[1012]      vcc vload vssy ring_stage_fo@FANOUT@
X1013 x[1012]  x[1013]      vcc vload vssy ring_stage_fo@FANOUT@
X1014 x[1013]  x[1014]      vcc vload vssy ring_stage_fo@FANOUT@
X1015 x[1014]  x[1015]      vcc vload vssy ring_stage_fo@FANOUT@
X1016 x[1015]  x[1016]      vcc vload vssy ring_stage_fo@FANOUT@
X1017 x[1016]  x[1017]      vcc vload vssy ring_stage_fo@FANOUT@
X1018 x[1017]  x[1018]      vcc vload vssy ring_stage_fo@FANOUT@
X1019 x[1018]  x[1019]      vcc vload vssy ring_stage_fo@FANOUT@
X1020 x[1019]  x[1020]      vcc vload vssy ring_stage_fo@FANOUT@
X1021 vssy x[1020] x[100] vcc vssy nand_cell

* Probes (for debugging)
*.PROBE TRAN v(*)
*.PROBE TRAN v(*.*)

* Probes (for measurement)
.PROBE TRAN v(x[0])
.PROBE TRAN v(vissx)
.PROBE TRAN v(vissy)
.PROBE TRAN v(vssx)
.PROBE TRAN v(vssy)

* Sources
@RESET_SOURCE@
Vvcc    vcc 0 DC=vtrue
Vvload  vload 0 DC=vtrue
Vtgnd    tgnd 0 DC=0

Vvssx   vssx tgnd DC=0
Vvssy   vssy tgnd DC=0
* sense voltage source for the current mirror

.PROBE TRAN i1(Vvssx)
.PROBE TRAN i1(Vvssy)

Fvssx vissx 0 Vvssx 1e6
Fvssy vissy 0 Vvssy 1e6
* multiply by 1M current mirror

Rsensex vissx 0 1
Rsensey vissy 0 1
* 1-ohm resistor from vissx to ground

.option autostop=1

* Simulate
.TRAN @TIMESTEP@ @NANOSECONDS@ns 

* Measure
.param twait=10ns
.param measure_cycles=14
.param skip_cycles=2
.param measure_holdoff=4ns

.measure tran Cycle
+ trig V(x[0]) val='vtrue*0.5' td='twait+measure_holdoff' rise='skip_cycles'
+ targ V(x[0]) val='vtrue*0.5' td='twait+measure_holdoff' rise='skip_cycles+measure_cycles'

.measure tran Tcyc          PARAM='(tmstop - tmstart)/measure_cycles'
.measure tran Freq          PARAM='measure_cycles/(tmstop - tmstart)'

.param hvdd='vtrue * 0.5'

.measure tran tmstart when v(x[0])=hvdd td=twait rise='skip_cycles'
.measure tran tmstop  when v(x[0])=hvdd td=twait rise='skip_cycles+measure_cycles'
.measure tran IdleCurrent   avg i(Vvcc) from='twait/2' to=twait

.measure tran IdlePower     PARAM='(-IdleCurrent*vtrue)'

.measure tran ActiveCurrent avg i(Vvcc) from=tmstart to=tmstop

.measure tran ActivePower   PARAM='(-ActiveCurrent*vtrue)'
.measure tran ActiveEnergy  PARAM='(ActivePower/Freq)'

.END

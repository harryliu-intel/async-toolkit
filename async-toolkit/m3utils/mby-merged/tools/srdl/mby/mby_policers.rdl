// DO NOT EDIT. Generated by reg2rdl hlp_policers.reg.

<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>



// POL_DIRECT_MAP_CTRL 

reg pol_direct_map_ctrl_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Policer Direct Mapping Access Control Register";
  desc = "
    Control Register for proxy access to the POL_STATE memory banks
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    hwclr;
    AccessType = "RW/V";
    desc = "
	    Go command and completion status.
        [list]
        [*] Set to 1 by software to initiate operation
        [*] Set to 0 by hardware when the operation is complete
        [/list]
           ";
    ValRandomize = true;
  } GO_COMPL[63:63] = 1'h0;
  field {
    AccessType = "RW/V";
    desc = "
	    Completion Status. Set by hardware upon completion of operation.[br]
	    0: Successful completion[br]
	    1: Address Out-of-Range error
           ";
    ValRandomize = true;
  } STATUS[62:62] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
            Operation Type:[br]
            0: Read[br]
            1: Write
           ";
    ValRandomize = true;
  } OP_TYPE[61:61] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "
	    Reserved
           ";
    ValRandomize = true;
  } _RSVD0_[60:48] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
	    Register File ID.[br]
	    0 - POL_CNTR_STATE  [br]
	    1 - POL_STATE       [br]
	    2-255 Reserved
           ";
    ValRandomize = true;
  } REG_ID[47:40] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	    Register File Sub Index.
        [list]
        [*] For REG_ID=0 (POL_CNTR_STATE), this field indicates the memory bank. 
            Valid values are 0 - 9, and data is written via POL_DIRECT_MAP_DATA_CTRn.
        [*] For REG_ID=1 (POL_STATE), this field indicates the policer metering function.
            Valid values are 0 (corresponding to memory banks 0, 1) and 1 (corresponding
            to memory banks 5, 6), and data is written via POL_DIRECT_MAP_DATA_POLn.
        [/list]
           ";
    ValRandomize = true;
  } REG_SUB_ID[39:32] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	    Register Entry Index. Indicates the memory bank (counter or policer) index.
        Valid values are 0 - 2047.
           ";
    ValRandomize = true;
  } REG_INDX[31:0] = 32'h0;
};



// POL_DIRECT_MAP_DATA_CTR0

reg pol_direct_map_data_ctr0_r {
  shared;
  HandCoded = true;
  name = "Counter Direct Mapping Access Data Register 0";
  desc = "
    Data register 0 for proxy access to the POL_CNTR_STATE counter state memory banks.
    Proxy accesses to counters are 128b atomic operations.
         ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
      Lower order part of 36 bit packet count.

           ";
    ValRandomize = true;
  } DATA_CNTP_LWR[63:44] = 20'h0;
  field {
    AccessType = "RW/V";
    desc = "
      Byte count

           ";
    ValRandomize = true;
  } DATA_CNTB[43:0] = 44'h0;
};



// POL_DIRECT_MAP_DATA_CTR1

reg pol_direct_map_data_ctr1_r {
  shared;
  HandCoded = true;
  name = "Counter Direct Mapping Access Data Register 1";
  desc = "
    Data register 1 for proxy access to the POL_CNTR_STATE counter state memory banks.
    Proxy accesses to counters are 128b atomic operations.
         ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
      Higher order part of 36 bit packet count.

           ";
    ValRandomize = true;
  } DATA_CNTP_UPR[15:0] = 16'h0;
};



// POL_DIRECT_MAP_DATA_POL0

reg pol_direct_map_data_pol0_r {
  shared;
  HandCoded = true;
  name = "Policer Direct Mapping Access Data Register 0";
  desc = "
    Data register 0 for proxy access to the POL_STATE policer state.
    Proxy accesses to policers are 256b atomic operations.
         ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
     Lower order part of the bytes available in the committed bucket at time_stored

           ";
    ValRandomize = true;
  } CTOK_HI_LWR[63:50] = 14'h0;
  field {
    AccessType = "RW/V";
    desc = "
     Tokens (fractional bytes) available in the committed bucket at time_stored.    [br]
     1 bit = 1024 tokens.   [br]
     1 byte = 8192 tokens.

           ";
    ValRandomize = true;
  } CTOK_LO[49:37] = 13'h0;
  field {
    AccessType = "RW/V";
    desc = "
     Bytes available in the excess bucket at time_stored

           ";
    ValRandomize = true;
  } ETOK_HI[36:13] = 24'h0;
  field {
    AccessType = "RW/V";
    desc = "
     Tokens (fractional bytes) available in the excess bucket at time_stored.   [br]
     1 bit = 1024 tokens.   [br]
     1 byte = 8192 tokens.

           ";
    ValRandomize = true;
  } ETOK_LO[12:0] = 13'h0;
};



// POL_DIRECT_MAP_DATA_POL1

reg pol_direct_map_data_pol1_r {
  shared;
  HandCoded = true;
  name = "Policer Direct Mapping Access Data Register 1";
  desc = "
    Data register 1 for proxy access to the POL_STATE policer state.
    Proxy accesses to policers are 256b atomic operations.
         ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     0: BS_1        [br]
     1: BS_10       [br]
     2: BS_100      [br]
     3: BS_1000

           ";
    ValRandomize = true;
  } EBS_UNIT[15:14] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects POL_CFG[cfg]. Configures entry enable C/E coupling (cf), payload type, and per-packet adjust.

           ";
    ValRandomize = true;
  } CFG[13:10] = 4'h0;
  field {
    AccessType = "RW/V";
    desc = "
     Higher order part of the bytes available in the committed bucket at time_stored

           ";
    ValRandomize = true;
  } CTOK_HI_UPR[9:0] = 10'h0;
};



// POL_DIRECT_MAP_DATA_POL2

reg pol_direct_map_data_pol2_r {
  shared;
  HandCoded = true;
  name = "Policer Direct Mapping Access Data Register 2";
  desc = "
    Data register 2 for proxy access to the POL_STATE policer state.
    Proxy accesses to policers are 256b atomic operations.
         ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    desc = "
     Lower order part of value of lower 24b of POL_TIME when this policer state was last written.  
     When last written includes both management writing new configuration and 
     token levels to the register and normal policer activity writing back 
     updated token levels.

           ";
    ValRandomize = true;
  } TIME_STORED_LWR[63:56] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
     Ultimate commited rate = cir * 10^cir_unit.  Result in 100kbps.

           ";
    ValRandomize = true;
  } CIR[55:45] = 11'h0;
  field {
    AccessType = "RW";
    desc = "
     0: IR_100K     [br]
     1: IR_1M       [br]
     2: IR_10M      [br]
     3: IR_100M     [br]
     4: IR_1G       [br]
     Only value 0 - 4 are valid, setting the field with an invalid value is 
     considered a programming error.

           ";
    ValRandomize = true;
  } CIR_UNIT[44:42] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
     Configures committed burst size to cbs * 10^cbs_unit.  Result in bytes.

           ";
    ValRandomize = true;
  } CBS[41:29] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     0: BS_1    [br]
     1: BS_10   [br]
     2: BS_100  [br]
     3: BS_1000 [br]

           ";
    ValRandomize = true;
  } CBS_UNIT[28:27] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Ultimate excess rate = eir * 10^eir_unit.  Result in 100kbps.

           ";
    ValRandomize = true;
  } EIR[26:16] = 11'h0;
  field {
    AccessType = "RW";
    desc = "
     0: IR_100K     [br]
     1: IR_1M       [br]
     2: IR_10M      [br]
     3: IR_100M     [br]
     4: IR_1G       [br]
     Only values 0 - 4 are valid, setting the field with an invalid value 
     is considered a programming error.

           ";
    ValRandomize = true;
  } EIR_UNIT[15:13] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
     Configures committed burst size to ebs * 10^ebs_unit.  Result in bytes.

           ";
    ValRandomize = true;
  } EBS[12:0] = 13'h0;
};



// POL_DIRECT_MAP_DATA_POL3

reg pol_direct_map_data_pol3_r {
  shared;
  HandCoded = true;
  name = "Policer Direct Mapping Access Data Register 3";
  desc = "
    Data register 3 for proxy access to the POL_STATE policer state.
    Proxy accesses to policers are 256b atomic operations.
         ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/V";
    desc = "
     Higher order part of value of lower 24b of POL_TIME when this policer state was last written.  
     When last written includes both management writing new configuration and 
     token levels to the register and normal policer activity writing back 
     updated token levels.

           ";
    ValRandomize = true;
  } TIME_STORED_UPR[15:0] = 16'h0;
};



// POL_CFG[0..1,0..15]

reg pol_cfg_r {
  shared;
  HandCoded = true;
  name = "Policer Configuration Profile";
  desc = "
  Indexed by (policer, 4-bit pol_state.cfg field in the policer_state).
  Defines policer operation.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "
      Reserved

           ";
    ValRandomize = true;
  } _RSVD1_[63:23] = 41'h0;
  field {
    AccessType = "RW";
    desc = "
     If set, CM drop causes policing to be disabled.

           ";
    ValRandomize = true;
  } UNPOLICE_DROP_CM[22:22] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     If set, Mapper/CGRP/MST/dmask drop causes policing to be disabled. (Always on, turn off for debug.)

           ";
    ValRandomize = true;
  } UNPOLICE_DROP_PRECM[21:21] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
     If set, all bytes of the frame are credited back on the last segment when
     the frame has a L4 checksum error, FCS error or FRAME error.  (Always on,
     turn off for debug.)

           ";
    ValRandomize = true;
  } CREDIT_FRAME_ERR[20:20] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
     If set, all bytes of the frame are credited back on the frame
     discarded due to L3 length check failure.

           ";
    ValRandomize = true;
  } CREDIT_L3_LEN_ERR[19:19] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "
      Reserved

           ";
    ValRandomize = true;
  } _RSVD0_[18:17] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Color-blind mode. If set, this policer will behave as if the
     ingress color were green (regardless of DSCP/VPRI value).

           ";
    ValRandomize = true;
  } CB[16:16] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Coupling Flag. Setting to 1 enables C->E overflow per MEF 10.2.

           ";
    ValRandomize = true;
  } CF[15:15] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select source of ingress color, and target of egress color.
     [list]
     [*] 0: Use VPRI as source and target of recoloring
     [*] 1: Use DSCP as source and target of recoloring
     [/list]

           ";
    ValRandomize = true;
  } COLOR_SELECT[14:14] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select whether the corresponding policer bank has precedence.
     [br][br]
      0:  the selected policer bank has precedence 0
     [br][br]
      1:  the selected policer bank has precedence 1
     [br][br]
     Precedence 1 represents the higher priority.
     [br][br]
     The precedence only takes place when the policer of precedence 1 results
     in egress color of red.  This condition prevents the precedence 0 policer
     from performing token bucket deduction and policer-linked counter accumulation.
     [br][br]
     The typical usage is to configure a layer 2 policer (using VPRI) 
     with precedence 1 and a layer 3 policer (using DSCP) with precedence 0 for
     the same packet flow. In this usage case, the color-blind mode of the
     two policers can also be independent.

           ";
    ValRandomize = true;
  } PRECEDENCEE[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     0: Select segment debit mode   [br]
     1: Select packet debit mode

           ";
    ValRandomize = true;
  } DEBIT_MODE[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select which l3_len to use for charging the bucket in packet debit mode:   [br]
     0: (otr_l3_len + parse_ptrs[OTR_L3_PTR])   [br]
     1: (inr_l3_len + parse_ptrs[INR_L3_PTR])

           ";
    ValRandomize = true;
  } L3_LEN_MODE[11:11] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Adjust the packet length:  [br]
     pkt_len = base_len - parse_ptrs[start_hdr] + sign_extend(adjust_len)
     [br][br]
     Here parse_ptrs[0]=0 for this calculation.  The adjustment is applied only on the 
     first segment of the packet (if deducting) or on the total packet length 
     (if crediting due to frame error).

           ";
    ValRandomize = true;
  } START_HDR[10:8] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
     See description of start_hdr.

           ";
    ValRandomize = true;
  } ADJUST_LEN[7:0] = 8'h0;
};
regfile pol_cfg_rf {
  pol_cfg_r POL_CFG[16] += 8;
};



// POL_DSCP[0..15,0..63]

reg pol_dscp_r {
  shared;
  HandCoded = true;
  name = "DSCP Color Definitions";
  desc = "
  Indexed by (operator ID, 6-bit DSCP value from ingress packet).
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-red.

           ";
    ValRandomize = true;
  } IR[14:14] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-green.

           ";
    ValRandomize = true;
  } IG[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Drop this packet if it egresses red.

           ";
    ValRandomize = true;
  } DROP_ER[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress DSCP value to use if marking this packet yellow.

           ";
    ValRandomize = true;
  } TO_YELLOW[11:6] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress DSCP value to use if marking this packet red.

           ";
    ValRandomize = true;
  } TO_RED[5:0] = 6'h0;
};
regfile pol_dscp_rf {
  pol_dscp_r POL_DSCP[64] += 8;
};



// POL_VPRI[0..15,0..15]

reg pol_vpri_r {
  shared;
  HandCoded = true;
  name = "VPRI Color Definitions";
  desc = "
  Indexed by (operator ID, 4-bit VPRI value from ingress packet).
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-red.

           ";
    ValRandomize = true;
  } IR[10:10] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-green.

           ";
    ValRandomize = true;
  } IG[9:9] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Drop this packet if it egresses red.

           ";
    ValRandomize = true;
  } DROP_ER[8:8] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress VPRI value to use if marking this packet yellow.

           ";
    ValRandomize = true;
  } TO_YELLOW[7:4] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress VPRI value to use if marking this packet red.

           ";
    ValRandomize = true;
  } TO_RED[3:0] = 4'h0;
};
regfile pol_vpri_rf {
  pol_vpri_r POL_VPRI[16] += 8;
};



// POL_TIME_UNIT

reg pol_time_unit_r {
  shared;
  HandCoded = true;
  name = "Rate of incrementing of POL_TIME";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
   Amount that timer should increment on each cycle.
   Program to 102.4 * 2^20 / switch_clk(MHz).

           ";
    ValRandomize = true;
  } POL_TIME_UNIT[19:0] = 20'h0;
};



// POL_TIME

reg pol_time_r {
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
     Increments at 102.4MHz.
     Lower 24b are written to policer state (used as timestamp).
     Upper 24b are provided for diagnostic purposes only.

           ";
    ValRandomize = true;
  } POL_TIME[47:0] = 48'h0;
};



// POL_SWEEP

reg pol_sweep_r {
  shared;
  HandCoded = true;
  name = "Policer Sweeper Control";
  desc = "
  POL_SWEEP configures two policer sweepers.
  The policer sweepers occasionally access every policer,
  to ensure that the 24-bit time value does not overflow.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Number of cycles that must elapse between sweeper operations.

           ";
    ValRandomize = true;
  } ELAPSE_CYCLE[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
    Number of mgmt+idle cycles that must elapse between sweeper
    operations.

           ";
    ValRandomize = true;
  } ELAPSE_SLOT[31:24] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
    Sweeper will cover indices 0..pol0_hi-1 in banks 0..1.
    Set to 0 to disable sweeping banks 0..1.

           ";
    ValRandomize = true;
  } POL0_HI[23:12] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
    Sweeper will cover indices 0..pol1_hi-1 in banks 5..6.
    Set to 0 to disable sweeping banks 5..6.

           ";
    ValRandomize = true;
  } POL1_HI[11:0] = 12'h0;
};



// POL_SWEEP_LAST

reg pol_sweep_last_r {
  shared;
  HandCoded = true;
  name = "Last sweep completion time.";
  desc = "
  Snapshot of POL_TIME when the last sweep completed.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "

           ";
    ValRandomize = true;
  } POL_SWEEP_LAST[47:0] = 48'h0;
};



// POL_SWEEP_PERIOD_MAX

reg pol_sweep_period_max_r {
  shared;
  HandCoded = true;
  name = "Largest observed sweep period.";
  desc = "
  Observed maximum sweep period (measured in POL_TIME unit)
  between any 2 consecutive sweep completions.

  When hardware writes POL_SWEEP_LAST, it also writes the
  difference (between old and new POL_SWEEP_LAST values)
  to POL_SWEEP_PERIOD_MAX if this difference is larger than the
  value already in POL_SWEEP_PERIOD_MAX.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "

           ";
    ValRandomize = true;
  } POL_SWEEP_PERIOD_MAX[47:0] = 48'h0;
};



// Begin reg2rdl addrmap section

addrmap mby_ppe_policers_map {
  name = "mby_policers";
  desc = "Policers Register Set";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  pol_direct_map_ctrl_r      POL_DIRECT_MAP_CTRL           @0x0;
  pol_direct_map_data_ctr0_r POL_DIRECT_MAP_DATA_CTR0      @0x8;
  pol_direct_map_data_ctr1_r POL_DIRECT_MAP_DATA_CTR1      @0x10;
  pol_direct_map_data_pol0_r POL_DIRECT_MAP_DATA_POL0      @0x18;
  pol_direct_map_data_pol1_r POL_DIRECT_MAP_DATA_POL1      @0x20;
  pol_direct_map_data_pol2_r POL_DIRECT_MAP_DATA_POL2      @0x28;
  pol_direct_map_data_pol3_r POL_DIRECT_MAP_DATA_POL3      @0x30;
  pol_cfg_rf                 POL_CFG[2]                    @0x0040 += 128;
  pol_dscp_rf                POL_DSCP[16]                  @0x2040 += 512;
  pol_vpri_rf                POL_VPRI[16]                  @0x4040 += 128;
  pol_time_unit_r            POL_TIME_UNIT                 @0x4840;
  pol_time_r                 POL_TIME                      @0x4848;
  pol_sweep_r                POL_SWEEP                     @0x4850;
  pol_sweep_last_r           POL_SWEEP_LAST                @0x4858;
  pol_sweep_period_max_r     POL_SWEEP_PERIOD_MAX          @0x4860;
};

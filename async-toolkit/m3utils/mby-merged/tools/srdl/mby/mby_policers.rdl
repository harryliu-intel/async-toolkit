// DO NOT EDIT. Generated by reg2rdl hlp_policers.reg.

<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>



// POL_CNTR_STATE[0..9,0..2047]

reg pol_cntr_state_r {
  shared;
  HandCoded = true;
  name = "Counter State";
  desc = "
  .Policer and counter actions share the same physical policer memory banks.
  .Indexed by (bank, action index).
  .Any bank can be used as a counter.
  .Banks 0..1 can be combined and used as a policer.
  .Banks 5..6 can also be combined and used as another, independent policer.
  . 
  The POL_CNTR_STATE register is to be used when management is accessing counter data.  Management accesses to counters are 128b atomic operations.
  . 
  The POL_STATE register is to be used when management is accessing policer data.  Management accesses to policer data are 256b atomic operations.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RW/V";
    desc = "
     packet count

           ";
    ValRandomize = true;
  } DATA_CNTP[79:44] = 36'h0;
  field {
    AccessType = "RW/V";
    desc = "
     byte count

           ";
    ValRandomize = true;
  } DATA_CNTB[43:0] = 44'h0;
};
regfile pol_cntr_state_rf {
  pol_cntr_state_r POL_CNTR_STATE[2048] += 16;
};



// POL_STATE[0..1,0..2047]

reg pol_state_r {
  shared;
  HandCoded = true;
  name = "Policer State";
  desc = "
  This register provides management with 256b atomic access to policer data stored in combined policer memory banks as described in the POL_CNTR_STATE register.
  .Indexed by (policer, action index).
  .policer=0 corresponds to the policer located in combined memory banks 0..1.
  .policer=1 corresponds to the policer located in combined memory banks 5..6.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 256;
  accesswidth = 256;
  field {
    AccessType = "RO/V";
    desc = "
     Value of lower 24b of POL_TIME when this policer state was last written.  When last written includes both management writing new configuration and token levels to the register and normal policer activity writing back updated token levels.

           ";
    ValRandomize = true;
  } TIME_STORED[207:184] = 24'h0;
  field {
    AccessType = "RW";
    desc = "
     ultimate commited rate = cir * 10^cir_unit.  Result in 100kbps.

           ";
    ValRandomize = true;
  } CIR[183:173] = 11'h0;
  field {
    AccessType = "RW";
    desc = "
     .IR_100K (0)
     .IR_1M   (1)
     .IR_10M  (2)
     .IR_100M (3)
     .IR_1G   (4)
     only value 0 ~ 4 are valid, setting the field with invalid value is considered as programming error 

           ";
    ValRandomize = true;
  } CIR_UNIT[172:170] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
     configures committed burst size to cbs * 10^cbs_unit.  Result in bytes.

           ";
    ValRandomize = true;
  } CBS[169:157] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
     .BS_1    (0)
     .BS_10   (1)
     .BS_100  (2)
     .BS_1000 (3)

           ";
    ValRandomize = true;
  } CBS_UNIT[156:155] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     ultimate excess rate = eir * 10^eir_unit.  Result in 100kbps.

           ";
    ValRandomize = true;
  } EIR[154:144] = 11'h0;
  field {
    AccessType = "RW";
    desc = "
     .IR_100K (0)
     .IR_1M   (1)
     .IR_10M  (2)
     .IR_100M (3)
     .IR_1G   (4)
     only value 0 ~ 4 are valid, setting the field with invalid value is considered as programming error 

           ";
    ValRandomize = true;
  } EIR_UNIT[143:141] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
     configures committed burst size to ebs * 10^ebs_unit.  Result in bytes.

           ";
    ValRandomize = true;
  } EBS[140:128] = 13'h0;
  field {
    AccessType = "RO";
    desc = "
     read returns zeros

           ";
    ValRandomize = true;
  } _RSVD_[127:80] = 48'h0;
  field {
    AccessType = "RW";
    desc = "
     .BS_1    (0)
     .BS_10   (1)
     .BS_100  (2)
     .BS_1000 (3)

           ";
    ValRandomize = true;
  } EBS_UNIT[79:78] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     selects POL_CFG[cfg].  Configures entry enable C/E coupling (cf), payload type, and per-packet adjust.

           ";
    ValRandomize = true;
  } CFG[77:74] = 4'h0;
  field {
    AccessType = "RW/V";
    desc = "
     bytes available in the committed bucket at time_stored

           ";
    ValRandomize = true;
  } CTOK_HI[73:50] = 24'h0;
  field {
    AccessType = "RW/V";
    desc = "
     tokens (fractional bytes) available in the committed bucket at time_stored.    1 bit = 1024 tokens.   1 byte = 8192 tokens.

           ";
    ValRandomize = true;
  } CTOK_LO[49:37] = 13'h0;
  field {
    AccessType = "RW/V";
    desc = "
     bytes available in the excess bucket at time_stored

           ";
    ValRandomize = true;
  } ETOK_HI[36:13] = 24'h0;
  field {
    AccessType = "RW/V";
    desc = "
     tokens (fractional bytes) available in the excess bucket at time_stored.    1 bit = 1024 tokens.   1 byte = 8192 tokens.

           ";
    ValRandomize = true;
  } ETOK_LO[12:0] = 13'h0;
};
regfile pol_state_rf {
  pol_state_r POL_STATE[2048] += 32;
};



// POL_CFG[0..1,0..15]

reg pol_cfg_r {
  shared;
  HandCoded = true;
  name = "Policer Configuration Profile";
  desc = "
  Indexed by (policer, 4-bit pol_state.cfg field in the policer_state).
  Defines policer operation.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     If set, CM drop causes policing to be disabled.

           ";
    ValRandomize = true;
  } UNPOLICE_DROP_CM[22:22] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     If set, Mapper/FFU/MST/dmask drop causes policing to be disabled. (Always on, turn off for debug.)

           ";
    ValRandomize = true;
  } UNPOLICE_DROP_PRECM[21:21] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
     If set, all bytes of the frame are credited back on the last segment when
     the frame has a L4 checksum error, FCS error or FRAME error.  (Always on,
     turn off for debug.)

           ";
    ValRandomize = true;
  } CREDIT_FRAME_ERR[20:20] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
     If set, all bytes of the frame are credited back on the frame
     discarded due to L3 length check failure.

           ";
    ValRandomize = true;
  } CREDIT_L3_LEN_ERR[19:19] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     If set, policer marking will be applied to metadata with 2-bit color
     value at the position indicated by md_position bit.  The 2-bit egress color encoding is:
.    00:  No Policing Action
.    01:  green
.    10:  yellow
.    11:  red
     Expected use case is to have only one policer enabled when the egress color is to be written to the packet meta data.  If both policers are enabled, the packet meta data is modified ONLY IF both policers have mark_md set and both policers are configured with the same md_position setting.

           ";
    ValRandomize = true;
  } MARK_MD[18:18] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
.     0:  Metadata DW7, bit 12:11
.     1:  Metadata DW4, bit 14:13

           ";
    ValRandomize = true;
  } MD_POSITION[17:17] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Color-blind mode. If set, this policer will behave as if the
     ingress color were green (regardless of DSCP/VPRI value).

           ";
    ValRandomize = true;
  } CB[16:16] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Coupling Flag. (1) Enables C->E overflow per MEF 10.2.

           ";
    ValRandomize = true;
  } CF[15:15] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select source of ingress color, and target of egress color.
     * 0: Use VPRI as source and target of recoloring
     * 1: Use DSCP as source and target of recoloring

           ";
    ValRandomize = true;
  } COLOR_SELECT[14:14] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select whether the corresponding policer bank has precedence.
     * 0:  the selected policer bank has precedence 0
     * 1:  the selected policer bank has precedence 1

     Precedence 1 represents the higher priority.

     The precedence only takes place when the policer of precedence 1 results
     in egress color of red.  This condition prevents the precedence 0 policer
     from performing token bucket deduction and policer-linked counter accumulation.

     The typical usage is to configure a layer 2 policer (using VPRI) 
     with precedence 1 and a layer 3 policer (using DSCP) with precedence 0 for
     the same packet flow. In this usage case, the color-blind mode of the
     two policers can also be independent.

           ";
    ValRandomize = true;
  } PRECEDENCEE[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select segment debit mode (0) or packet debit mode(1).

           ";
    ValRandomize = true;
  } DEBIT_MODE[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Select which l3_len to use for charging the bucket in packet debit mode:

     If L3_LEN_MODE is 0:
     * (otr_l3_len + parse_ptrs[OTR_L3_PTR])

     If L3_LEN_MODE is 1:
     * (inr_l3_len + parse_ptrs[INR_L3_PTR])

           ";
    ValRandomize = true;
  } L3_LEN_MODE[11:11] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
     Adjust the packet length.
     * pkt_len = base_len - parse_ptrs[start_hdr] + sign_extend(adjust_len)

     Here parse_ptrs[0]=0 for this calculation.  The adjustment is applied only on the 
     first segment of the packet (if deducting) or on the total packet length 
     (if crediting due to frame error).

           ";
    ValRandomize = true;
  } START_HDR[10:8] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
     See description of start_hdr.

           ";
    ValRandomize = true;
  } ADJUST_LEN[7:0] = 8'h0;
};
regfile pol_cfg_rf {
  pol_cfg_r POL_CFG[16] += 8;
};



// POL_DSCP[0..15,0..63]

reg pol_dscp_r {
  shared;
  HandCoded = true;
  name = "DSCP Color Definitions";
  desc = "
  Indexed by (operator ID, 6-bit DSCP value from ingress packet).
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-red.

           ";
    ValRandomize = true;
  } IR[14:14] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-green.

           ";
    ValRandomize = true;
  } IG[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Drop this packet if it egresses red.

           ";
    ValRandomize = true;
  } DROP_ER[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress DSCP value to use if marking this packet yellow.

           ";
    ValRandomize = true;
  } TO_YELLOW[11:6] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress DSCP value to use if marking this packet red.

           ";
    ValRandomize = true;
  } TO_RED[5:0] = 6'h0;
};
regfile pol_dscp_rf {
  pol_dscp_r POL_DSCP[64] += 8;
};



// POL_VPRI[0..15,0..15]

reg pol_vpri_r {
  shared;
  HandCoded = true;
  name = "VPRI Color Definitions";
  desc = "
  Indexed by (operator ID, 4-bit VPRI value from ingress packet).
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-red.

           ";
    ValRandomize = true;
  } IR[10:10] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    This color is considered ingress-green.

           ";
    ValRandomize = true;
  } IG[9:9] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Drop this packet if it egresses red.

           ";
    ValRandomize = true;
  } DROP_ER[8:8] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress VPRI value to use if marking this packet yellow.

           ";
    ValRandomize = true;
  } TO_YELLOW[7:4] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
    Egress VPRI value to use if marking this packet red.

           ";
    ValRandomize = true;
  } TO_RED[3:0] = 4'h0;
};
regfile pol_vpri_rf {
  pol_vpri_r POL_VPRI[16] += 8;
};



// POL_TIME_UNIT

reg pol_time_unit_r {
  shared;
  HandCoded = true;
  name = "Rate of incrementing of POL_TIME";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
   Amount that timer should increment on each cycle.
   Program to 102.4 * 2^20 / switch_clk(MHz).

           ";
    ValRandomize = true;
  } POL_TIME_UNIT[19:0] = 20'h0;
};



// POL_TIME

reg pol_time_r {
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "
     Increments at 102.4MHz.
     Lower 24b are written to policer state (used as timestamp).
     Upper 24b are provided for diagnostic purposes only.

           ";
    ValRandomize = true;
  } POL_TIME[47:0] = 48'h0;
};



// POL_SWEEP

reg pol_sweep_r {
  shared;
  HandCoded = true;
  name = "Policer Sweeper Control";
  desc = "
  POL_SWEEP configures two policer sweepers.
  The policer sweepers occasionally access every policer,
  to ensure that the 24-bit time value does not overflow.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Number of cycles that must elapse between sweeper operations.

           ";
    ValRandomize = true;
  } ELAPSE_CYCLE[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
    Number of mgmt+idle cycles that must elapse between sweeper
    operations.

           ";
    ValRandomize = true;
  } ELAPSE_SLOT[31:24] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
    Sweeper will cover indices 0..pol0_hi-1 in banks 0..1.
    Set to 0 to disable sweeping banks 0..1.

           ";
    ValRandomize = true;
  } POL0_HI[23:12] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
    Sweeper will cover indices 0..pol1_hi-1 in banks 5..6.
    Set to 0 to disable sweeping banks 5..6.

           ";
    ValRandomize = true;
  } POL1_HI[11:0] = 12'h0;
};



// POL_SWEEP_LAST

reg pol_sweep_last_r {
  shared;
  HandCoded = true;
  name = "Last sweep completion time.";
  desc = "
  Snapshot of POL_TIME when the last sweep completed.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "

           ";
    ValRandomize = true;
  } POL_SWEEP_LAST[47:0] = 48'h0;
};



// POL_SWEEP_PERIOD_MAX

reg pol_sweep_period_max_r {
  shared;
  HandCoded = true;
  name = "Largest observed sweep period.";
  desc = "
  Observed maximum sweep period (measured in POL_TIME unit)
  between any 2 consecutive sweep completions.

  When hardware writes POL_SWEEP_LAST, it also writes the
  difference (between old and new POL_SWEEP_LAST values)
  to POL_SWEEP_PERIOD_MAX if this difference is larger than the
  value already in POL_SWEEP_PERIOD_MAX.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/V";
    desc = "

           ";
    ValRandomize = true;
  } POL_SWEEP_PERIOD_MAX[47:0] = 48'h0;
};



// Begin reg2rdl addrmap section

addrmap mby_ppe_policers_map {
  name = "mby_policers";
  desc = "Policers Register Set";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  pol_cntr_state_rf          POL_CNTR_STATE[10]            @0x0 += 32768;
  pol_state_rf               POL_STATE[2]                  @0x80000 += 65536;
  pol_cfg_rf                 POL_CFG[2]                    @0xa0000 += 128;
  pol_dscp_rf                POL_DSCP[16]                  @0xa2000 += 512;
  pol_vpri_rf                POL_VPRI[16]                  @0xa4000 += 128;
  pol_time_unit_r            POL_TIME_UNIT                 @0xa4800;
  pol_time_r                 POL_TIME                      @0xa4808;
  pol_sweep_r                POL_SWEEP                     @0xa4810;
  pol_sweep_last_r           POL_SWEEP_LAST                @0xa4818;
  pol_sweep_period_max_r     POL_SWEEP_PERIOD_MAX          @0xa4820;
}; // final size: 0xa4828 <= 0x100000 = 8<<17

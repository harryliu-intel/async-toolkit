$Id$

Basic design of Scheme/Modula-3 stub generator
==============================================

At this point, we have a Scheme interpreter coded in Modula-3.  It exists
in the GC repository under "mscheme".  The organization of the source is
as follows:

mscheme/src             Basic interpreter sources
mscheme/schemesig       Signal handling for interactive interpreter
mscheme/interactive     Interactive Scheme interpreter using normal Unix I/O
mscheme/interactive_r   As above, but with "readline" editing
mscheme/schemereadline  Support code for interactive_r
mscheme/doc             Documentation directory
mscheme/sstubgen        This program
mscheme/modula3scheme   Modula-3 interfacing

The Scheme interpreter is documented (work in progress) at
mscheme/doc/mscheme.{ps,pdf}.

What's important for us here is that the mscheme interpreter is coded
in straightforward Modula-3 and all Scheme types map straightforwardly
to Modula-3 types.  In particular, SchemeObject.T is exactly the same
as a Modula-3 REFANY (reference to any traced, i.e., garbage collected,
type).  This means that any reference types from Modula-3 can be passed
into Scheme as opaque objects without further ado.  [Note that the full
mapping of mscheme types to Modula-3 types is specified in the file
mscheme/src/TYPES.]

Modula-3 Type System
--------------------

Modula-3 is a statically typed language, and this means that at
runtime, we cannot straightforwardly define new types.  We are limited
to the types defined at compile time.  This property defines how
mscheme and the basic Modula-3 system must interact.  Namely, mscheme
should be able to handle any Modula-3 types.  However, unlike Java,
Modula-3 does not have very extensive support for runtime
"introspection".  Modula-3 runtime introspection is limited to the
following:

1. Testing whether a reference is to an object of a certain type (or its
   subtypes [subtype = subclass in M3 terminology]).

2. Extracting the TYPECODE of a certain reference.  Each type is known 
   to the compiler at compile time and has a unique TYPECODE in the running
   instance of the program.  (The TYPECODE can be converted to a "type
   fingerprint", which is a cryptographic hash that is guaranteed to be
   the same between all programs that declare the same type, but we 
   probably don't need to worry about that much here.)

3. Checking whether one TYPECODE corresponds to a super- or subtype 
   of another.

Since Modula-3's types cannot change at runtime, the straightforward
way of combining Modula-3 and Scheme is to process the Modula-3 sources
at compile time and export information about the available types to
Scheme.  The Scheme further needs to be provided with "hooks" so that it
is possible to call Modula-3 routines from Scheme.  

Modula-3 is cleanly separated into two types of files: INTERFACE ("header")
and MODULE ("code") files.  We should only need to look at the INTERFACEs.

Text Example
------------

To take a simple example, let's consider the file Text.i3, which defines
the interface to Modula-3 TEXTs (strings).  Here is a part of this file:



INTERFACE Text;

IMPORT Word;

TYPE T = TEXT;

CONST Brand = "Text-1.0";

PROCEDURE Cat(t, u: T): T;
(* Return the concatenation of "t" and "u". *)

PROCEDURE Equal(t, u: T): BOOLEAN;
(* Return "TRUE" if "t" and "u" have the same length and
   (case-sensitive) contents. *)

PROCEDURE GetChar(t: T; i: CARDINAL): CHAR;
(* Return character "i" of "t".  It is a checked runtime error if "i
   >= Length(t)". *)

PROCEDURE Length(t: T): CARDINAL;
(* Return the number of characters in "t". *)


In Scheme, one might want to be able to call each of these routines.
For instance,

(call-m3-procedure Text.Cat t u)

Should call the given Modula-3 procedure, which should fail if t and u
are not of type Text.T (=TEXT).  (It should fail, but not crash.  As
an option, one might want to be able to specify that pointers should
also be non-NIL.)  If it passes the type test, it should then return
the result of running Text.Cat(t,u).  Since TEXT is a Modula-3 reference
type, it is, by design of mscheme, also of type Scheme.Object and can
be stored in lists, etc.


Precedent: SchemeAutoTbl
------------------------

An example of what a Scheme/Modula-3 interface looks like is provided by the
generic SchemeAutoTbl.ig/SchemeAutoTbl.mg in the mscheme/modula3scheme
package directory.  This system works as follows:

SchemeM3TableOps   -- allows operations to be registered for a given  
                      Modula-3 TYPECODE.

For instance, let's say we have Modula-3 type M3Type:

TYPE M3Type = ...

If M3Type is a reference type (an OBJECT or a REF to something), we can
call 

SchemeM3TableOps.Register(TYPECODE(M3Type), "op-name", OpProc)

and after this, if the user of the Scheme interpreter calls the following
routine AND ref is of type M3Type 

(modula-3-op ref 'op-name args)

[where args is optional], then the Modula-3 procedure OpProc will be called
as follows:

OpProc(ref, args, "op-name")

where "op-name" is of type SchemeSymbol.T (which is the same as the
Modula-3 type Atom.T).

The SchemeAutoTbl system uses several advanced Modula-3 features that
probably won't be necessary for a fully automated stub generator.  These
features are used simply to reduce the amount of typing the programmer
has to do, which doesn't matter to an automatic stub generator.  But
for completeness, the way it works is this:

In order to use SchemeAutoTbl, provide it with a type that is an OBJECT
type ("class" in C++/Java).  Normally the type should be an instance
of Modula-3's GENERIC Table (Table.ig), but this actually isn't necessary,
as long as it declares the same methods so that the uses of the Table
methods in SchemeAutoTbl.mg are syntactically correct. 

The way this is all done in practice is by adding a single line to the
m3makefile, for instance:

SchemeAutoTbl("TextRef", "TextRefTbl", "M3toSTextString", "M3toSRefany")

which calls the code (in "quake") in schemeautotbl.tmpl, 

readonly proc SchemeAutoTbl(nm, tbl, k, v) is
  Build_generic_module(nm & "SchemeAutoTbl", "SchemeAutoTbl", [tbl, k, v], [tbl, k, v])
end

Which instantiates the SchemeAutoTbl.ig GENERIC INTERFACE with arguments
TextRefTbl, M3toSTextSTring, M3toSRefany and the SchemeAutoTbl.mg GENERIC
MODULE with the same arguments.  In other words, in order to "register" a new
table type with this M3/Scheme interfacing code, all the programmer need do
is add the abovementioned line

SchemeAutoTbl("TextRef", "TextRefTbl", "M3toSTextString", "M3toSRefany")

to his m3makefile.

Modula-3 Types that Need to be Handled
--------------------------------------

Ideally, all the normal types in Modula-3 should be handled by the
system.  That is, all normal stack-allocatable types, such as INTEGER,
CARDINAL, CHAR, Types that aren't reference types will have to be
wrapped in references.  It's inefficient, but all of Scheme is
relatively inefficient.  But types like LONGREAL and INTEGER can be
converted directly from Scheme, after performing appropriate range and
precision checks.  Perhaps Modula-3 ARRAYs can always be represented
by Scheme vectors; etc.

So this may be the biggest part of the job: defining a mapping from
every conceivable Modula-3 type to legal Scheme code for the
interface.  All of Modula-3's types are defined in Section 2 of the
Modula-3 Report, pp. 2--17 (see references section below).  The only
types that one can really reject completely are types used in UNSAFE
modules, that is, ADDRESS and UNTRACED types.  There really aren't
that many types in Modula-3...

For each type a number of things should be provided, if relevant.  For
instance, for all reference types, Modula-3's NEW should be provided.
For OBJECT types, it should be possible to call each method available
in the INTERFACEs.  [Should one have to do something analogous to
IMPORT?  Maybe.  Something like this perhaps:

(define (text-cat u v)
  (let ((Text (import-modula-3-interface "Text")))
	  (Text "Cat" u v)))

]

For ordinal types, FIRST, LAST, and NUMBER can be provided, as well as 
ORD and VAL.

Since Scheme is an interactive system, the stubs should try hard to
avoid runtime errors, which crash the entire runtime.  Perhaps it should
be possible (and very easy) to define additional code to do further checking
on parameters.

Existing Stub Generator Code
----------------------------

Several stub generators have already been built for various purposes,
see below.


References and Tricks
---------------------

Most Modula-3 interfaces can easily be found on the Web by typing things
like "Text.i3 Modula-3" into Google.  Otherwise, on pluto, they are under
/usr/local/lib/m3/pkg, e.g., at the pluto Unix prompt,

> find /usr/local/lib/m3/pkg -name Text.i3
/usr/local/lib/m3/pkg/m3core/src/text/Text.i3
>


The Modula-3 report is DECSRC Research Report 52, available from (among
many other places),

http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-052.html

(Report 31 is the original spec, now superseded.)

Network Objects are specified in DECSRC 115,

http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-115.html

They are also available in the DECSRC directory in the repository.

Documentation on the Modula-3 Toolkit is a little harder to come by.  In
the repository, we have

calarm/smalltalk/doc/p66-jordan.pdf

which describes the toolkit.

The Modula-3 Toolkit tutorial is also available in

calarm/smalltalk/m3tk-tutorial

For instance, run it as follows:

> cd calarm/smalltalk/m3tk-tutorial/m3astcontent/src
> m3build -O
> ../FreeBSD4/m3astcontent Main.m3
... lots of scrolling output from m3astcontent ...

which is an example of how to run the Modula-3 tools.

A more relevant example (it goes through similar steps to the proposed
Scheme stub generator) is the Network Objects stub generator, "stubgen".
It is available, together with the rest of the Network Objects system,
by untarring the file (on pluto) ~mika/m3-comm.tgz.  It may not compile
with m3build, because of the new type LONGINT in the newer compiler that
it supports.





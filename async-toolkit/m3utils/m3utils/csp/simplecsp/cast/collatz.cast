module collatz;

int NWORKERS = 15;
int W        = 63;

int STATUSW = 128 + 2 * W; // why can't this go in attributes cell?
int INTERVAL = 1000;

define common attributes {
  csp {
    
    structure longest_so_far =
      (
       int(W) num;
       int(W) length;
       );

    structure status =
      (
       int(128) ops;
       longest_so_far l;
       );

    function even(int -n) : bool =
      ( even = ((n & 1) == 0) );

    function odd(int -n) : bool =
      ( odd = ~even(n) );

  }
}

define WORKER()(bd(W) -STRT; bd(STATUSW) +STATUS) <+ common
{
  csp {

    function sendStatus(int -len, -num, -steps) =
      (
       //       print ("sendStatus : sending len=" + len + " num=" + num  + " steps=" + steps);
       status s;
       s::l::length = len;
       s::l::num    = num;
       s::ops       = steps;

       STATUS!(pack(s));
       steps = 0;
       );

    int(W) i;
    int(W) steps  = 0;
    int(W) maxlen = 0;

    int(W) id;
    
    STRT?id;
    print ("id = " + id);
    
    *[
      int(W) idx = i * NWORKERS + id; // this is the index of the odd number
      int(W) num = 2 * idx + 1;       // this is the actual number we shall work on
      int(W) len = 0;
      int    snum = num;
      
      // do the Collatz loop
      *[ num != 1 ->
         [  odd(num) -> num = 3 * num + 1
         [] even(num) -> num = num / 2
         ];
         len++
       ]
      ;
      assert(num == 1);
      steps += len;
      
      [  len > maxlen ->
         maxlen = len;
         sendStatus(len, snum, steps)
         
      [] (len <= maxlen) && (i % 1000 == 0)    ->
         sendStatus(0, 0, steps)

      [] else -> skip   
      ];
      i++
    ]
    }
}

define MANAGER()(bd(W) +STRT; bd(STATUSW) -STATUS) <+ common
{
  csp {
    STRT!0;
    status save;
    
    *[ STATUS?x ;
       status s;

       unpack(s,x);

       #[ s::l::num != 0 -> save = s ];
       
       print ("STATUS? ( ops = " + s::ops +
              " ; num = " + save::l::num +
              " ; chain = " + save::l::length) ]
  }

}

define SMERGE()(bd(STATUSW) -L[0..1], +R) <+ common
{
  csp {
    
    function recv(int which; status +-s) =
      (
       L[which]?xs;

       status q;
       unpack(q, xs);

       #[ q::l::length > s::l::length ->
          s::l = q::l
        ];

       s::ops += q::ops;
       );

    function checksend(status -os, -s) =
      (
       #[ (os::ops % INTERVAL != s::ops % INTERVAL)
          ||
          os::l::length != s::l::length ->
          R!s; s::ops = 0
          ]
       );
      

    status s;
    
    *[
      status os = s;
      [
       #L[0] && #L[1] -> recv(0,s); recv(1,s)
       :
       #L[0] -> recv(0,s)
       :
       #L[1] -> recv(1,s)
       ];

      checksend(os, s)
      ]
  }
}

define TEST()() <+ common
{
  csp {
    status s, q;

    q::ops += 1;
    
    s::ops += q::ops;

    print(s::ops)
  }
}

define STATUS_TREE(int N)(bd(STATUSW) -L[0..N-1], +R)  <+ common
{
  [ N == 1 -> subcells { L[0] = R; } ]
  [ N == 2 -> subcells { SMERGE m(L, R); } ]
  [ N > 2  ->
      subcells {
        bd(STATUSW) X[0..(N+1)/2 - 1];
        <i : 0.. N / 2 - 1 :SMERGE m[i]({L[2*i], L[2*i + 1]}, X[i]); >
        STATUS_TREE((N+1)/2) tree(X, R);

        <i: N/2 .. (N+1)/2 - 1 : L[2*i] = X[i];>
    }

      ]
}

define COLLATZ()()  <+ common
{
  subcells {
    bd(W) S, STRT[0..NWORKERS-1];
    bd(STATUSW) WSTATUS[0..NWORKERS-1], STATUS;
    MANAGER mgr(S, STATUS);
    START_TREE(0, NWORKERS) start_tree(S, STRT);
    <i:0..NWORKERS-1: WORKER() wrkr[i](STRT[i], WSTATUS[i]);>
    STATUS_TREE(NWORKERS) status_tree(WSTATUS, STATUS);
  }
}

define STARTSPLIT(int level)(bd(W) -L, +R[0..1]) <+ common
{
  csp {
    L?i; R[0]!i, R[1]!(i + 2**level)
  }
}

define START_TREE(int level, N)(bd(W) -L, +R[0..N-1]) <+ common
// level is the level of the output of the tree
{
    [ N==1 -> subcells { L = R[0]; } ]
      [ N==2 -> subcells { STARTSPLIT(level) s(L, R); } ]
    [ N > 2 ->
      subcells {
        bd(W) X[0..(N+1)/2 - 1];
        <i : 0.. N / 2 - 1 : STARTSPLIT(level)
           s[i](X[i], {R[2*i], R[2*i + 1]}); >
           
        START_TREE(level + 1, (N+1)/2) tree(L, X);

        <i: N/2 .. (N+1)/2 - 1 : R[2*i] = X[i];>
           }
    ]
}


      

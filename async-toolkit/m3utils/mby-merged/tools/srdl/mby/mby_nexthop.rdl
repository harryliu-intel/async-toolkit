// INTEL TOP SECRET
// Copyright 2014 Intel Corporation. All Rights Reserved.
//
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>


reg nexthop_entry_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Stores next-hop information for IP routing and GLORT forwarding.";
  desc = "Stores next-hop entry and related fields for IP routing and GLORT forwarding.";
  regwidth = 128;
  accesswidth = 128;
  field {
    AccessType = "RW";
    desc = "
           0: Entry is used for GLORT forwarding. DST_MAC, EVID and IPV6_ENTRY are ignored.
           [br][br]
           1: Entry is used for IP routing. DST_MAC provides the next hop router's DMAC
                  and DGLORT indicates the egress port to which the next hop router is connected.
           ";
    ValRandomize = true;
  } ENTRY_TYPE[121:121] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
           Indicates whether to derive the DMAC from the IPv6 DIP when 
           doing IP routing and stateless autoconfig is enabled on the network.[br]
           Ignored if ENTRY_TYPE=0.
           ";
    ValRandomize = true;
  } IPV6_ENTRY[120:120] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
           Marks the packet as routed when doing GLORT forwarding so that Modify will update 
           the appropriate header fields.[br]
           Ignored if ENTRY_TYPE=1.
           ";
    ValRandomize = true;
  } MARK_ROUTED[119:119] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
           Indicates to update the L3 domain value.
           ";
    ValRandomize = true;
  } UPDATE_L3_DOMAIN[118:118] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
           Indicates to update the L2 domain value.
           ";
    ValRandomize = true;
  } UPDATE_L2_DOMAIN[117:117] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
           New L3 domain value to use if UPDATE_L3_DOMAIN=1
           ";
    ValRandomize = true;
  } L3_DOMAIN[116:111] = 6'h00;
  field {
    AccessType = "RW";
    desc = "
           New L2 domain value to use if UPDATE_L2_DOMAIN=1
           ";
    ValRandomize = true;
  } L2_DOMAIN[110:103] = 8'h00;
  field {
    AccessType = "RW";
    desc = "
           Modify index MOD_IDX.
           ";
    ValRandomize = true;
  } MOD_IDX[102:79] = 24'h00;
  field {
    AccessType = "RW";
    desc = "
            Index into the MTU size check table.
           ";
    ValRandomize = true;
  } MTU_INDEX[78:76] = 3'h00;
  field {
    AccessType = "RW";
    desc = "
            Egress VLAN ID used for IP routing. [br]
            Ignored if ENTRY_TYPE=0.
           ";
    ValRandomize = true;
  } EVID[75:64] = 12'h00;
  field {
    AccessType = "RW";
    desc = "
           Indicates the destination GLORT for both GLORT forrwarding and IP routing.
           ";
    ValRandomize = true;
  } DGLORT[63:48] = 16'h00;
  field {
    AccessType = "RW";
    desc = "
            Destination MAC address for IP routing.[br]
            Ignored if ENTRY_TYPE=0.
           ";
    ValRandomize = true;
  } DST_MAC[47:0] = 48'h00;
};

reg flood_glort_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Flood Glort Table";
  desc = "Glorts for flooding, broadcast and multicast indexed by egress L2 domain.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Defines the glort used for broadcast. 
           ";
    ValRandomize = true;
  } BROADCAST_GLORT[47:32] = 16'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines the glort to use when flooding multicast frames if the FFU 
            does not already provide a flood glort. For DLF flood control, set 
            to a glort with a zero destination mask.
           ";
    ValRandomize = true;
  } FLOOD_MULTICAST_GLORT[31:16] = 16'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines the glort to use when flooding unicast frames if the FFU 
            does not already provide a flood glort. For DLF flood control, set 
            to a glort with a zero destination mask.
           ";
    ValRandomize = true;
  } FLOOD_UNICAST_GLORT[15:0] = 16'h00;
};

reg nexthop_used_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Tracks if hardware has used each ARP entry.";
  desc = "
          Each time NEXTHOP_TABLE[index] entry is used to forward a frame, the 
          chip sets the NEXTHOP_USED[index{13:6}]{index{5:0}} bit to 1. When 
          software writes a word to this table, any bits that are 1 in the 
          word will clear the corresponding bit in NEXTHOP_USED to 0. The software 
          should read a word into x, record which entries have been used since 
          the last sample, and then write x back to NEXTHOP_USED to clear the bits.
          This avoids any race between the hardware and software. The concept 
          is similar to an interrupt register.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
            64 consecutive bits marking usage of corresponding NEXTHOP_TABLE 
            entries.
           ";
    ValRandomize = true;
  } USED[63:0] = 64'h00;
};

reg ingress_vid_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Ingress VLAN table";
  desc = "Contains VLAN membership states, IGMP trap enable and reflection state for the
          ingress VLAN lookup.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            Indicates if the IGMP frames on this VLAN shall be trapped or 
            switched normally. The IGMP frames are trapped to the CPU glort.
           ";
    ValRandomize = true;
  } TRAP_IGMP[18:18] = 1'h00;
  field {
    AccessType = "RW";
    desc = "
            If this bit is set and PORT_CFG_2 destination mask include itself, 
            then layer 2 packets associated with this VLAN are allowed to go 
            back on the port they come from (subject to LOOPBACK_SUPPRESS 
            registers).

            If this bit is not set, then layer 2 packets associated with this 
            VLAN are not allowed to go back on the port they come from.
          
            Routed packets are always allowed to go back where they come from 
            and this bit is not used in this case.
           ";
    ValRandomize = true;
  } REFLECT[17:17] = 1'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines port membership for this VLAN. A '1' in each bit position 
            includes that port in the VLAN membership.
           ";
    ValRandomize = true;
  } MEMBERSHIP[16:0] = 17'h00;
};

reg egress_vid_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Egress VLAN table";
  desc = "Contains VLAN membership state and downstream associated trigger ID for the egress VLAN lookup.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            VLAN trigger match condition identifier.
           ";
    ValRandomize = true;
  } TRIG_ID[29:24] = 6'h00;
  field {
    AccessType = "RW";
    desc = "
            Defines if this port is member of this VLAN or not.
           ";
    ValRandomize = true;
  } MEMBERSHIP[23:0] = 24'h00;
};

reg fwd_hashing_cfg_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  name = "Configures hashing of L2/L3/L4 headers for LAG";
  desc = "This register selects which fields are enabled for inclusion in the calculation of the 
          hash value used for link aggregation and GLORT lookup.  See the hashing chapter for more
          details.";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "
      Reserved

           ";
    ValRandomize = true;
  } _RSVD1_[63:13] = 51'h0;
  field {
    AccessType = "RW";
    desc = "
            Specifies one of two 12-bit hash rotations for use in ECMP
            binning. 
           ";
    ValRandomize = true;
  } ECMP_ROTATION[12:12] = 1'h00;
  field {
    AccessType = "RW";
    desc = "
            Specifies one of four 12-bit rotations for use as Rotation B.
           ";
    ValRandomize = true;
  } ROTATION_B[11:10] = 2'h01;
  field {
    AccessType = "RW";
    desc = "
            Specifies one of four 12-bit rotations for use as Rotation A.
           ";
    ValRandomize = true;
  } ROTATION_A[9:8] = 2'h00;
  field {
    AccessType = "RSV";
    desc = "
      Reserved

           ";
    ValRandomize = true;
  } _RSVD0_[7:0] = 8'h0;
};

reg mtu_table_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "MA Table frame watermark";
  desc = "
          Defines the list of MTUs supported by the switch.
         ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
            MTU size in bytes.
           ";
    ValRandomize = true;
  } MTU[13:0] = 14'h00;
};

addrmap mby_ppe_nexthop_map {
  name = "Nexthop table, flowlets, and VLANs";
  desc = "Address Resolution Protocol Registers and VLAN lookup";
  addressing = fullalign;
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary=true;
  
  nexthop_entry_table_r   NEXTHOP_TABLE[16384]    ;
  ingress_vid_table_r     INGRESS_VID_TABLE[4096] ;
  egress_vid_table_r      EGRESS_VID_TABLE[4096]  ;
  flood_glort_table_r     FLOOD_GLORT_TABLE[256]  ;
  nexthop_used_r          NEXTHOP_USED[256]       ;
  mtu_table_r             MTU_TABLE[8]            ;
  fwd_hashing_cfg_r       FWD_HASHING_CFG         ;
};


#!/usr/bin/perl

my $tfile = shift(@ARGV);
my $header = shift(@ARGV);
my $src = shift(@ARGV);

if (!$tfile || !$header || !$src)
{
    printf("ERROR!\n");
    exit(1);
}

my $md5 = `md5sum $tfile`; chomp $md5;
$md5 =~ s/(\S+)\s*\S+/$1/;

my $table = [];

open(TAB, "<$tfile") || die("Can't open $tfile for reading");
my $maxWidth = 0;

while(<TAB>)
{
    chomp;

    if (m/^(\S+)\s*(.*)$/)
    {
        push(@$table, { name => $1, desc => $2 });

        if (length($1) > $maxWidth)
        {
            $maxWidth = length($1);
        }
    }
}

close(TAB);

my $maxError = scalar(@$table);

open(HF, ">$header") || die("Can't open $header for writing");

my $creationDate = `date +"%B %-d, %Y"`; chomp ($creationDate);

print HF <<EOF;
/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces)  */
/*****************************************************************************
 * File:            fm_errno.h
 * Creation Date:   September 16, 2005
 * Last updated:    $creationDate
 * Description:     Constants and string table for error messages and return
 *                  constants. 
 *
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM, DO
 *                  NOT MODIFY THIS FILE.  MODIFY common/ERRORS INSTEAD.
 *                  MD5 HASH OF SOURCE IS $md5.
 *
 * INTEL CONFIDENTIAL
 * Copyright 2005 - 2011 Intel Corporation. All Rights Reserved. 
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material may
 * be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or 
 * delivery of the Materials, either expressly, by implication, inducement,
 * estoppel or otherwise. Any license under such intellectual property rights
 * must be express and approved by Intel in writing.
 *****************************************************************************/

#include "fm_std.h"

#ifndef __FM_FM_ERRNO_H
#define __FM_FM_ERRNO_H

/** A status word returned by Fulcrum API functions to
 *  indicate the success or failure of the function call. */
typedef fm_int fm_status;

/**************************************************/
/** Fulcrum error codes
 *  \\ingroup constStatus
 *  \\page statusCodes
 *
 *  These constants are the status code values
 *  returned by most API services as type fm_status.
 **************************************************/
/** \\ingroup constStatus
 * @\{ */

EOF

for (my $errNum = 0; $errNum < scalar(@$table); $errNum++)
{
    my $formatStr = sprintf("#define %%-%d\s %%\d\n\n", $maxWidth);
    my $desc = $table->[$errNum]->{desc};
    $desc =~ s/\\(.)/$1/g;
    printf(HF "/** %s */\n", $desc);
    printf(HF $formatStr, $table->[$errNum]->{name}, $errNum);
}

print HF <<EOF;

/** \@} (end of Doxygen group) */


/* returns error string for given error */
const char *fmErrorMsg(fm_int err);

/* returns status code given a string containing the status code name */
fm_status fmErrorCode(const char *errString);

#endif /* __FM_FM_ERRNO_H */
EOF

close(HF);

open(SF, ">$src") || die("Can't open $src for writing");

print SF <<EOF;
/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces)  */
/*****************************************************************************
 * File:            fm_errno.c
 * Creation Date:   September 16, 2005
 * Last updated:    $creationDate
 * Description:     Constants and string table for error messages and
 *                  return constants
 *
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM, DO
 *                  NOT MODIFY THIS FILE.  MODIFY common/ERRORS INSTEAD.
 *                  MD5 HASH OF SOURCE IS $md5.
 *
 * INTEL CONFIDENTIAL
 * Copyright 2005 - 2011 Intel Corporation. All Rights Reserved. 
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material may
 * be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or 
 * delivery of the Materials, either expressly, by implication, inducement,
 * estoppel or otherwise. Any license under such intellectual property rights
 * must be express and approved by Intel in writing.
 *****************************************************************************/

#include <fm_sdk_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/*****************************************************************************
 * Local Variables
 *****************************************************************************/

/* String table used by fmErrorMsg */
static const char *const fmErrorStrings[] =
{
EOF

for (my $errNum = 0; $errNum < scalar(@$table); $errNum++)
{
    printf(SF "    /* %s */\n", $table->[$errNum]->{name});
    printf(SF "    \"%s\",\n\n", $table->[$errNum]->{desc});
}

print SF <<EOF;
};


/*****************************************************************************
 * Local function prototypes.
 *****************************************************************************/


/*****************************************************************************
 * Local Functions
 *****************************************************************************/


/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/** fmErrorMsg
 * \\ingroup common
 *
 * \\desc            Returns the error string for a given error code.
 *
 * \\param[in]       err is the error code to translate. 
 *
 *
 * \\return          The corresponding error string or an error message if
 *                  the code is invalid.
 *
 *****************************************************************************/
const char *fmErrorMsg(fm_int err)
{
    if ( (err < 0) || (err >= $maxError) )
    {
        return "Invalid error number (no such error)";
    }

    return fmErrorStrings[err];

}   /* end fmErrorMsg */




/*****************************************************************************/
/** fmErrorCode
 * \\ingroup common
 *
 * \\desc            Returns the error code given a string fragment.
 *
 * \\param[in]       errString points to a string fragment to search for.
 *
 *
 * \\return          The corresponding error code or -1 if the code is invalid.
 *
 *****************************************************************************/
fm_status fmErrorCode(const char *errString)
{
    fm_int err;

    for ( err = 0 ; err < $maxError ; err++ )
    {
        if (strcasecmp(errString, fmErrorStrings[err]) == 0)
        {
            return err;
        }
    }

    return -1;

}   /* end fmErrorCode */
EOF

close(SF);

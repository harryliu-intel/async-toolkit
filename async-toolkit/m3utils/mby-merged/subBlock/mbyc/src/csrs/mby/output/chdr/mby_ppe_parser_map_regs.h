/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_parser_map_regs.h                                  
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_PARSER_MAP_REGS_H_
#define _MBY_PPE_PARSER_MAP_REGS_H_

#define PARSER_MSGPORT     0x0
#define PARSER_PARSER_PORT_CFG_MSGREGADDR 0x0
#define PARSER_PARSER_CSUM_CFG_MSGREGADDR 0x80
#define PARSER_PARSER_IP_MSGREGADDR 0x100
#define PARSER_PARSER_IM_MSGREGADDR 0x108
#define PARSER_PARSER_KEY_W_MSGREGADDR 0x1000
#define PARSER_PARSER_KEY_S_MSGREGADDR 0x2000
#define PARSER_PARSER_ANA_W_MSGREGADDR 0x3000
#define PARSER_PARSER_ANA_S_MSGREGADDR 0x4000
#define PARSER_PARSER_EXC_MSGREGADDR 0x5000
#define PARSER_PARSER_EXT_MSGREGADDR 0x6000
#define PARSER_PARSER_PTYPE_TCAM_MSGREGADDR 0x8000
#define PARSER_PARSER_PTYPE_RAM_MSGREGADDR 0x8400
#define PARSER_PARSER_EXTRACT_CFG_MSGREGADDR 0x0C000
#define PARSER_PARSER_COUNTERS_MSGREGADDR 0x10000

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_FLAG
// PARSER_PORT_CFG desc:  indexed by interface and logical port number. Sets the initial
// ptr/state/op, and indicates byte offsets of w0/w1/w2 in the packet.
// The configuration for interface j and port i is found at index
// (j*8)+i.
typedef union {
    struct {
        uint64_t  INITIAL_OP_ROT       :   4;    // 
        uint64_t  INITIAL_OP_MASK      :  12;    // 
        uint64_t  INITIAL_STATE        :  16;    // 
        uint64_t  INITIAL_PTR          :   8;    // 
        uint64_t  INITIAL_W2_OFFSET    :   8;    // 
        uint64_t  INITIAL_W1_OFFSET    :   8;    // 
        uint64_t  INITIAL_W0_OFFSET    :   8;    // 

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_BITFIELD_COUNT 0x07
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_ROT_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_ROT_MSB 0x0003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_ROT_RANGE 0x0004
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_ROT_MASK 0x0000000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_ROT_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_MASK_LSB 0x0004
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_MASK_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_MASK_RANGE 0x000c
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_MASK_MASK 0x0000fff0
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_OP_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_STATE_LSB 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_STATE_MSB 0x001f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_STATE_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_STATE_MASK 0xffff0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_STATE_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_PTR_LSB 0x0020
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_PTR_MSB 0x0027
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_PTR_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_PTR_MASK 0xff00000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_PTR_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W2_OFFSET_LSB 0x0028
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W2_OFFSET_MSB 0x002f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W2_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W2_OFFSET_MASK 0xff0000000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W2_OFFSET_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W1_OFFSET_LSB 0x0030
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W1_OFFSET_MSB 0x0037
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W1_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W1_OFFSET_MASK 0xff000000000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W1_OFFSET_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W0_OFFSET_LSB 0x0038
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W0_OFFSET_MSB 0x003f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W0_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W0_OFFSET_MASK 0xff00000000000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_INITIAL_W0_OFFSET_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_FLAG
// PARSER_CSUM_CFG desc: 
typedef union {
    struct {
        uint64_t  VALIDATE_L3_LENGTH   :   2;    //  Enable validation of the
                                                 // payload length field in the L3
                                                 // header
        uint64_t  COMPUTE_L4_CSUM      :   1;    //  Insert computed outer L4 UDP
                                                 // checksum into the packet.
        uint64_t  STORE_L4_PARTIAL_CSUM :   1;    //  Enable partial checksum
                                                 // write to metadata on
                                                 // fragments.
        uint64_t  VALIDATE_L4_CSUM     :   2;    //  Enable checksum validation
                                                 // and/or drop on L4 checksum
                                                 // error (for TCP, UDP & SCTP).
        uint64_t  VALIDATE_IPV4_LENGTH :   1;    //  IPv4 length check validation
                                                 // and/or drop on IPV4 length
                                                 // check error,
        uint64_t  VALIDATE_IPV4_HDR_LENGTH :   1;    //  IPv4 header length value
                                                 // check and/or drop on IPV4
                                                 // header length value check
                                                 // error,
        uint64_t  VALIDATE_IPV4_HDR_TRUNCATION :   1;    //  IPv4 header trucation check
                                                 // and/or drop on IPV4 header
                                                 // tuncation check error,
        uint64_t  VALIDATE_IPV4_HDR_CSUM :   1;    //  IPv4 header checksum and/or
                                                 // drop on IPV4 header checksum
                                                 // error,
        uint64_t  RSVD_0               :  54;    // Nebulon auto filled RSVD [63:10]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_OFFSET 0x80
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_BITFIELD_COUNT 0x08
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L3_LENGTH_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L3_LENGTH_MSB 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L3_LENGTH_RANGE 0x0002
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L3_LENGTH_MASK 0x00000003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L3_LENGTH_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_COMPUTE_L4_CSUM_LSB 0x0002
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_COMPUTE_L4_CSUM_MSB 0x0002
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_COMPUTE_L4_CSUM_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_COMPUTE_L4_CSUM_MASK 0x00000004
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_COMPUTE_L4_CSUM_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_STORE_L4_PARTIAL_CSUM_LSB 0x0003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_STORE_L4_PARTIAL_CSUM_MSB 0x0003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_STORE_L4_PARTIAL_CSUM_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_STORE_L4_PARTIAL_CSUM_MASK 0x00000008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_STORE_L4_PARTIAL_CSUM_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L4_CSUM_LSB 0x0004
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L4_CSUM_MSB 0x0005
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L4_CSUM_RANGE 0x0002
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L4_CSUM_MASK 0x00000030
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_L4_CSUM_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_LENGTH_LSB 0x0006
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_LENGTH_MSB 0x0006
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_LENGTH_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_LENGTH_MASK 0x00000040
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_LENGTH_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_LENGTH_LSB 0x0007
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_LENGTH_MSB 0x0007
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_LENGTH_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_LENGTH_MASK 0x00000080
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_LENGTH_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_TRUNCATION_LSB 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_TRUNCATION_MSB 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_TRUNCATION_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_TRUNCATION_MASK 0x00000100
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_TRUNCATION_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_CSUM_LSB 0x0009
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_CSUM_MSB 0x0009
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_CSUM_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_CSUM_MASK 0x00000200
#define MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_VALIDATE_IPV4_HDR_CSUM_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_IP_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_FLAG
// PARSER_IP desc: 
typedef union {
    struct {
        uint64_t  MEM_ERROR            :   1;    //  Memory ECC or parity error
                                                 // reported by the local memory
                                                 // controller. Check all
                                                 // PA_*_STATUS registers to find
                                                 // the source.
        uint64_t  RSVD_0               :  63;    // Nebulon auto filled RSVD [63:1]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_IP_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_BITFIELD_COUNT 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_MEM_ERROR_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_MEM_ERROR_MSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_MEM_ERROR_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_MEM_ERROR_MASK 0x00000001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IP_MEM_ERROR_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_IM_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_FLAG
// PARSER_IM desc:  The interrupt mask register controls if the corresponding interrupt
// source is presented to the interrupt hierarchy (bit is set to 0) or
// masked out (bit is set to 1).
typedef union {
    struct {
        uint64_t  MEM_ERROR            :   1;    //  Memory ECC or parity error
                                                 // reported by the local memory
                                                 // controller. Check all
                                                 // PA_*_STATUS registers to find
                                                 // the source.
        uint64_t  RSVD_0               :  63;    // Nebulon auto filled RSVD [63:1]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_IM_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_OFFSET 0x08
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_BITFIELD_COUNT 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_RESET 0x00000001

#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_MEM_ERROR_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_MEM_ERROR_MSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_MEM_ERROR_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_MEM_ERROR_MASK 0x00000001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_IM_MEM_ERROR_RESET_VALUE 0x00000001


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_FLAG
// PARSER_KEY_W desc:  w0 matches if (w0 & w0_mask) == w0_value w1 matches if (w1 &
// w1_mask) == w1_value
typedef union {
    struct {
        uint64_t  W0_MASK              :  16;    // 
        uint64_t  W0_VALUE             :  16;    // 
        uint64_t  W1_MASK              :  16;    // 
        uint64_t  W1_VALUE             :  16;    // 

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_BITFIELD_COUNT 0x04
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_RESET 0xffff0000ffff0000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_MASK_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_MASK_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_MASK_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_MASK_MASK 0x0000ffff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_VALUE_LSB 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_VALUE_MSB 0x001f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_VALUE_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_VALUE_MASK 0xffff0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W0_VALUE_RESET_VALUE 0x0000ffff

#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_MASK_LSB 0x0020
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_MASK_MSB 0x002f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_MASK_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_MASK_MASK 0xffff00000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_VALUE_LSB 0x0030
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_VALUE_MSB 0x003f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_VALUE_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_VALUE_MASK 0xffff000000000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_W1_VALUE_RESET_VALUE 0x0000ffff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_FLAG
// PARSER_KEY_S desc:  state matches if (state & state_mask) == state_value. To disable a
// rule, set state_mask=0 and state_value=1.
typedef union {
    struct {
        uint64_t  STATE_MASK           :  16;    // 
        uint64_t  STATE_VALUE          :  16;    // 
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_BITFIELD_COUNT 0x02
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_RESET 0xffff0000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_MASK_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_MASK_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_MASK_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_MASK_MASK 0x0000ffff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_VALUE_LSB 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_VALUE_MSB 0x001f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_VALUE_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_VALUE_MASK 0xffff0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_STATE_VALUE_RESET_VALUE 0x0000ffff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_FLAG
// PARSER_ANA_W desc:  Note that NEXTW0/W1/W2_OFFSET and SKIP should be even. Hardware
// will ignore the lsb of these fields.
typedef union {
    struct {
        uint64_t  SKIP                 :   8;    //  Next ptr relative to current
                                                 // ptr + op(w2).
        uint64_t  NEXT_W2_OFFSET       :   8;    //  Offset of next w2 relative
                                                 // to current ptr + op(w2).
        uint64_t  NEXT_W1_OFFSET       :   8;    //  Offset of next w1 relative
                                                 // to current ptr + op(w2).
        uint64_t  NEXT_W0_OFFSET       :   8;    //  Offset of next w0 relative
                                                 // to current ptr + op(w2).
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_BITFIELD_COUNT 0x04
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SKIP_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SKIP_MSB 0x0007
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SKIP_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SKIP_MASK 0x000000ff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_SKIP_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W2_OFFSET_LSB 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W2_OFFSET_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W2_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W2_OFFSET_MASK 0x0000ff00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W2_OFFSET_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W1_OFFSET_LSB 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W1_OFFSET_MSB 0x0017
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W1_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W1_OFFSET_MASK 0x00ff0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W1_OFFSET_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W0_OFFSET_LSB 0x0018
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W0_OFFSET_MSB 0x001f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W0_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W0_OFFSET_MASK 0xff000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_NEXT_W0_OFFSET_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_FLAG
// PARSER_ANA_S desc: 
typedef union {
    struct {
        uint64_t  NEXT_OP              :  16;    //  ALU operation to apply to
                                                 // next w2.
        uint64_t  NEXT_STATE_MASK      :  16;    //  Bitwise state write control.
        uint64_t  NEXT_STATE           :  16;    //  Bit values to be written
                                                 // into next state.
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_BITFIELD_COUNT 0x03
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_OP_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_OP_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_OP_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_OP_MASK 0x0000ffff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_OP_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MASK_LSB 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MASK_MSB 0x001f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MASK_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MASK_MASK 0xffff0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_LSB 0x0020
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MSB 0x002f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_RANGE 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_MASK 0xffff00000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_NEXT_STATE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_FLAG
// PARSER_EXC desc: 
typedef union {
    struct {
        uint64_t  PARSING_DONE         :   1;    //  Raises a ParsingDone
                                                 // exception. On a ParsingDone
                                                 // exception, all downstream
                                                 // rules are disabled. A
                                                 // ParsingDone exception may be
                                                 // raised on either a good packet
                                                 // or bad packet to prevent
                                                 // further parsing. In a good
                                                 // packet, ParsingDone should be
                                                 // raised as the last header is
                                                 // parsed. In a bad packet,
                                                 // ParsingDone should be raised
                                                 // and another flag should be
                                                 // set (via ext_action) to
                                                 // indicate parsing failure.
        uint64_t  EX_OFFSET            :   8;    //  Raises an EOF exception if
                                                 // packet_len & lt. ptr +
                                                 // ex_offset. On an EOF
                                                 // exception, this rule and all
                                                 // downstream rules are disabled.
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_BITFIELD_COUNT 0x02
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_PARSING_DONE_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_PARSING_DONE_MSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_PARSING_DONE_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_PARSING_DONE_MASK 0x00000001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_PARSING_DONE_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_EX_OFFSET_LSB 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_EX_OFFSET_MSB 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_EX_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_EX_OFFSET_MASK 0x000001fe
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_EX_OFFSET_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG
// PARSER_EXT desc:  Two extract actions are at (stage, rule) and (stage, rule+16). Note
// that OFFSET should be even. Hardware will ignore the lsb of these
// fields.
typedef union {
    struct {
        uint64_t  PTR_NUM              :   3;    //  Indicates which of 8 header
                                                 // pointer entries to write with
                                                 // the protocol_id and base
                                                 // offset, if PROTOCOL_ID is not
                                                 // 0xFF.
        uint64_t  FLAG_VALUE           :   1;    //  Value to assign to flag
        uint64_t  FLAG_NUM             :   6;    //  Which flag to assign. Use
                                                 // flag_num=0 to disable writing
                                                 // flags.
        uint64_t  OFFSET               :   8;    //  An offset to add to the
                                                 // current parsing ptr, the sum
                                                 // being stored in the header
                                                 // pointer entry as the base
                                                 // offset for the corresponding
                                                 // protocol_id.
        uint64_t  PROTOCOL_ID          :   8;    //  The protocol identifier
                                                 // value to store to the header
                                                 // pointer entry identified by
                                                 // PTR_NUM. Set to 0xFF to
                                                 // prevent this action from
                                                 // setting any header pointer.
        uint64_t  RSVD_0               :  38;    // Nebulon auto filled RSVD [63:26]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_BITFIELD_COUNT 0x05
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_RESET 0x03fc0000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PTR_NUM_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PTR_NUM_MSB 0x0002
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PTR_NUM_RANGE 0x0003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PTR_NUM_MASK 0x00000007
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PTR_NUM_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_VALUE_LSB 0x0003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_VALUE_MSB 0x0003
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_VALUE_RANGE 0x0001
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_VALUE_MASK 0x00000008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_VALUE_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_NUM_LSB 0x0004
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_NUM_MSB 0x0009
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_NUM_RANGE 0x0006
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_NUM_MASK 0x000003f0
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_FLAG_NUM_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_OFFSET_LSB 0x000a
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_OFFSET_MSB 0x0011
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_OFFSET_MASK 0x0003fc00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_OFFSET_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PROTOCOL_ID_LSB 0x0012
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PROTOCOL_ID_MSB 0x0019
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PROTOCOL_ID_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PROTOCOL_ID_MASK 0x03fc0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_PROTOCOL_ID_RESET_VALUE 0x000000ff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_FLAG
// PARSER_PTYPE_TCAM desc:  The packet type TCAM matches on a key consisting of the lower 32b of
// the parser flag output. The output of the TCAM is a 6b packet type.
// [br][br] A match occurs when the data searched is equal to the key
// and the entry is valid. The table below shows the encoded data value
// stored (Content) based on the state of the data (KEY) and mask
// (KEY_INVERT) values in the TCAM bitcell. [code]
// +-----------------------------------------------------+ | Mask
// storage | Data storage | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// highest index has precedence in case there is more than one match.
typedef union {
    struct {
        uint64_t  KEY                  :  32;    //  The key to match on.
        uint64_t  KEY_INVERT           :  32;    //  The inverted key to match
                                                 // on.

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_BITFIELD_COUNT 0x02
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_MSB 0x001f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_RANGE 0x0020
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_MASK 0xffffffff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_INVERT_LSB 0x0020
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_INVERT_MSB 0x003f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_INVERT_RANGE 0x0020
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_INVERT_MASK 0xffffffff00000000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_KEY_INVERT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_FLAG
// PARSER_PTYPE_RAM desc:  Contains the packet type and extraction index as a result of the
// match in PARSER_PTYPE_TCAM.
typedef union {
    struct {
        uint64_t  PTYPE                :  10;    //  The packet type result
        uint64_t  EXTRACT_IDX          :   4;    //  The extraction index in
                                                 // PARSER_EXTRACT_CFG to use for
                                                 // this packet type
        uint64_t  RSVD_0               :  50;    // Nebulon auto filled RSVD [63:14]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_BITFIELD_COUNT 0x02
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_PTYPE_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_PTYPE_MSB 0x0009
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_PTYPE_RANGE 0x000a
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_PTYPE_MASK 0x000003ff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_PTYPE_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_EXTRACT_IDX_LSB 0x000a
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_EXTRACT_IDX_MSB 0x000d
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_EXTRACT_IDX_RANGE 0x0004
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_EXTRACT_IDX_MASK 0x00003c00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_EXTRACT_IDX_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_FLAG
// PARSER_EXTRACT_CFG desc:  Provides 16 extraction profiles, each indicating the 80 16b words to
// extract from the packet buffer into the field vector. This register
// is indexed first by extraction index, then by word number. [br][br]
// During extraction, the 8 header pointer entries will be compared for
// matching protocol_id values. When a match is found, the OFFSET value
// will be summed with the base offset from the header pointer entry and
// the result used as an absolute index into the packet from which the
// 16b word is extracted and loaded into the field vector.
typedef union {
    struct {
        uint64_t  PROTOCOL_ID          :   8;    //  The protocol ID to use to
                                                 // source this 16b word
        uint64_t  OFFSET               :   8;    //  The relative offset from
                                                 // which to source this 16b word
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_BITFIELD_COUNT 0x02
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_RESET 0x000000ff

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_PROTOCOL_ID_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_PROTOCOL_ID_MSB 0x0007
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_PROTOCOL_ID_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_PROTOCOL_ID_MASK 0x000000ff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_PROTOCOL_ID_RESET_VALUE 0x000000ff

#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_OFFSET_LSB 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_OFFSET_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_OFFSET_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_OFFSET_MASK 0x0000ff00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_OFFSET_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_FLAG
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_FLAG
// PARSER_COUNTERS desc:  A set of 8-bit counters, each incremented when a particular parsing
// event occurs. Counted events are generally considered to be the
// result of misconfiguration. [br][br] Counter values will increment
// until they reach their maximum value, then will remain saturated
// without rolling over. [br][br] Each counter may be individually
// reset to zero by writing 0xFF to the counter.
typedef union {
    struct {
        uint64_t  EXT_SEG_BOUNDARY     :   8;    //  The packet segment was
                                                 // exceeded when attempting to
                                                 // extract a 16b field vector
                                                 // entry.
        uint64_t  EXT_UNKNOWN_PROTID   :   8;    //  A protocol ID specified for
                                                 // field extraction did not
                                                 // appear in the pointer headers.
        uint64_t  EXT_DUP_PROTID       :   8;    //  A protocol ID specified for
                                                 // field extraction appears more
                                                 // than once in the pointer
                                                 // headers.
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_t;
#endif
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_OFFSET 0x00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_SCOPE 0x01
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_SIZE 64
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_BITFIELD_COUNT 0x03
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_RESET 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_SEG_BOUNDARY_LSB 0x0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_SEG_BOUNDARY_MSB 0x0007
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_SEG_BOUNDARY_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_SEG_BOUNDARY_MASK 0x000000ff
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_SEG_BOUNDARY_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_UNKNOWN_PROTID_LSB 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_UNKNOWN_PROTID_MSB 0x000f
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_UNKNOWN_PROTID_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_UNKNOWN_PROTID_MASK 0x0000ff00
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_UNKNOWN_PROTID_RESET_VALUE 0x00000000

#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_DUP_PROTID_LSB 0x0010
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_DUP_PROTID_MSB 0x0017
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_DUP_PROTID_RANGE 0x0008
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_DUP_PROTID_MASK 0x00ff0000
#define MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_EXT_DUP_PROTID_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_PARSER_MAP_MSG_PARSER_PORT_CFG_t PARSER_PORT_CFG[16]; // offset 4'h0, width 64
    MBY_PPE_PARSER_MAP_MSG_PARSER_CSUM_CFG_t PARSER_CSUM_CFG[16]; // offset 8'h80, width 64
    MBY_PPE_PARSER_MAP_MSG_PARSER_IP_t PARSER_IP;        // offset 12'h100, width 64
    MBY_PPE_PARSER_MAP_MSG_PARSER_IM_t PARSER_IM;        // offset 12'h108, width 64
    uint8_t                    rsvd0[3824];
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_W_t PARSER_KEY_W[16]; // offset 4'h0, width 64
    } PARSER_KEY_W[32];                          // offset 16'h1000, size: 128
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_KEY_S_t PARSER_KEY_S[16]; // offset 4'h0, width 64
    } PARSER_KEY_S[32];                          // offset 16'h2000, size: 128
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_W_t PARSER_ANA_W[16]; // offset 4'h0, width 64
    } PARSER_ANA_W[32];                          // offset 16'h3000, size: 128
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_ANA_S_t PARSER_ANA_S[16]; // offset 4'h0, width 64
    } PARSER_ANA_S[32];                          // offset 16'h4000, size: 128
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_EXC_t PARSER_EXC[16];   // offset 4'h0, width 64
    } PARSER_EXC[32];                            // offset 16'h5000, size: 128
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_EXT_t PARSER_EXT[32];   // offset 4'h0, width 64
    } PARSER_EXT[32];                            // offset 16'h6000, size: 256
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_TCAM_t PARSER_PTYPE_TCAM[64]; // offset 4'h0, width 64
    } PARSER_PTYPE_TCAM[2];                      // offset 16'h8000, size: 512
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_PTYPE_RAM_t PARSER_PTYPE_RAM[64]; // offset 4'h0, width 64
    } PARSER_PTYPE_RAM[2];                       // offset 16'h8400, size: 512
    uint8_t                    rsvd1[14336];
    // starting the regfile section
    struct {
        MBY_PPE_PARSER_MAP_MSG_PARSER_EXTRACT_CFG_t PARSER_EXTRACT_CFG[80]; // offset 4'h0, width 64
    } PARSER_EXTRACT_CFG[16];                    // offset 20'h0C000, size: 640
    uint8_t                    rsvd2[6144];
    MBY_PPE_PARSER_MAP_MSG_PARSER_COUNTERS_t PARSER_COUNTERS;  // offset 20'h10000, width 64
} mby_ppe_parser_map_t;                          // size:  20'h10008


#endif // _MBY_PPE_PARSER_MAP_REGS_H_


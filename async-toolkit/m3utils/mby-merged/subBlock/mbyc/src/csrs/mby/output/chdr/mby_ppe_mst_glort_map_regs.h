/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_mst_glort_map_regs.h                               
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_MST_GLORT_MAP_REGS_H_
#define _MBY_PPE_MST_GLORT_MAP_REGS_H_

#define MST_GLORT_MSGPORT     0x0
#define MST_GLORT_EGRESS_VID_TABLE_MSGREGADDR 0x0
#define MST_GLORT_EGRESS_VID_CFG_MSGREGADDR 0x40000
#define MST_GLORT_INGRESS_MST_TABLE_MSGREGADDR 0x48000
#define MST_GLORT_EGRESS_MST_TABLE_MSGREGADDR 0x80000
#define MST_GLORT_GLORT_DIRECT_MAP_CTRL_MSGREGADDR 0x0C0000
#define MST_GLORT_GLORT_DIRECT_MAP_DST0_MSGREGADDR 0x0C0008
#define MST_GLORT_GLORT_DIRECT_MAP_DST1_MSGREGADDR 0x0C0010
#define MST_GLORT_GLORT_DIRECT_MAP_DST2_MSGREGADDR 0x0C0018
#define MST_GLORT_GLORT_DIRECT_MAP_DST3_MSGREGADDR 0x0C0020
#define MST_GLORT_GLORT_DIRECT_MAP_DST4_MSGREGADDR 0x0C0028
#define MST_GLORT_GLORT_RAM_MSGREGADDR 0x0C0200
#define MST_GLORT_GLORT_CAM_MSGREGADDR 0x0C0400
#define MST_GLORT_CGRP_USED_TABLE_MSGREGADDR 0x0C0760

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_FLAG
// EGRESS_VID_TABLE desc:  Contains egress port membership state for the egress VLAN lookup.
// Indexed first by VLAN ID and then by chunk, where each chunk is 64
// ports worth of the 258 bit membership port mask.
typedef union {
    struct {
        uint64_t  MEMBERSHIP           :  64;    //  For 64 ports of the total
                                                 // 258 bit mask, defines if this
                                                 // port is member of this VLAN or
                                                 // not.

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_MEMBERSHIP_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_MEMBERSHIP_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_MEMBERSHIP_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_MEMBERSHIP_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_MEMBERSHIP_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_FLAG
// EGRESS_VID_CFG desc:  Contains a trigger ID per egress VLAN.
typedef union {
    struct {
        uint64_t  TRIG_ID              :   6;    //  VLAN trigger match condition
                                                 // identifier.
        uint64_t  RSVD_0               :  58;    // Nebulon auto filled RSVD [63:6]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_TRIG_ID_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_TRIG_ID_MSB 0x0005
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_TRIG_ID_RANGE 0x0006
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_TRIG_ID_MASK 0x0000003f
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_TRIG_ID_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_FLAG
// INGRESS_MST_TABLE desc:  INGRESS_MST_TABLE holds the ingress spanning-tree state per ingress
// port. Each port has two bits of spanning tree state associated to it.
// These states are: [code] DISABLE = 0 LISTENING = 1 LEARNING = 2
// FORWARD = 3 [/code]
typedef union {
    struct {
        uint64_t  STP_STATE_0          :   2;    //  Two bits of spanning tree
                                                 // state for port 0.
        uint64_t  STP_STATE_1          :   2;    //  Two bits of spanning tree
                                                 // state for port 1.
        uint64_t  STP_STATE_2          :   2;    //  Two bits of spanning tree
                                                 // state for port 2.
        uint64_t  STP_STATE_3          :   2;    //  Two bits of spanning tree
                                                 // state for port 3.
        uint64_t  STP_STATE_4          :   2;    //  Two bits of spanning tree
                                                 // state for port 4.
        uint64_t  STP_STATE_5          :   2;    //  Two bits of spanning tree
                                                 // state for port 5.
        uint64_t  STP_STATE_6          :   2;    //  Two bits of spanning tree
                                                 // state for port 6.
        uint64_t  STP_STATE_7          :   2;    //  Two bits of spanning tree
                                                 // state for port 7.
        uint64_t  STP_STATE_8          :   2;    //  Two bits of spanning tree
                                                 // state for port 8.
        uint64_t  STP_STATE_9          :   2;    //  Two bits of spanning tree
                                                 // state for port 9.
        uint64_t  STP_STATE_10         :   2;    //  Two bits of spanning tree
                                                 // state for port 10.
        uint64_t  STP_STATE_11         :   2;    //  Two bits of spanning tree
                                                 // state for port 11.
        uint64_t  STP_STATE_12         :   2;    //  Two bits of spanning tree
                                                 // state for port 12.
        uint64_t  STP_STATE_13         :   2;    //  Two bits of spanning tree
                                                 // state for port 13.
        uint64_t  STP_STATE_14         :   2;    //  Two bits of spanning tree
                                                 // state for port 14.
        uint64_t  STP_STATE_15         :   2;    //  Two bits of spanning tree
                                                 // state for port 15.
        uint64_t  STP_STATE_16         :   2;    //  Two bits of spanning tree
                                                 // state for port 16.
        uint64_t  STP_STATE_17         :   2;    //  Two bits of spanning tree
                                                 // state for port 17.
        uint64_t  RSVD_0               :  28;    // Nebulon auto filled RSVD [63:36]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_BITFIELD_COUNT 0x12
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_0_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_0_MSB 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_0_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_0_MASK 0x00000003
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_0_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_1_LSB 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_1_MSB 0x0003
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_1_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_1_MASK 0x0000000c
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_1_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_2_LSB 0x0004
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_2_MSB 0x0005
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_2_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_2_MASK 0x00000030
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_2_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_3_LSB 0x0006
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_3_MSB 0x0007
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_3_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_3_MASK 0x000000c0
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_3_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_4_LSB 0x0008
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_4_MSB 0x0009
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_4_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_4_MASK 0x00000300
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_4_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_5_LSB 0x000a
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_5_MSB 0x000b
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_5_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_5_MASK 0x00000c00
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_5_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_6_LSB 0x000c
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_6_MSB 0x000d
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_6_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_6_MASK 0x00003000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_6_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_7_LSB 0x000e
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_7_MSB 0x000f
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_7_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_7_MASK 0x0000c000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_7_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_8_LSB 0x0010
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_8_MSB 0x0011
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_8_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_8_MASK 0x00030000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_8_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_9_LSB 0x0012
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_9_MSB 0x0013
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_9_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_9_MASK 0x000c0000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_9_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_10_LSB 0x0014
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_10_MSB 0x0015
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_10_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_10_MASK 0x00300000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_10_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_11_LSB 0x0016
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_11_MSB 0x0017
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_11_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_11_MASK 0x00c00000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_11_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_12_LSB 0x0018
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_12_MSB 0x0019
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_12_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_12_MASK 0x03000000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_12_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_13_LSB 0x001a
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_13_MSB 0x001b
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_13_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_13_MASK 0x0c000000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_13_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_14_LSB 0x001c
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_14_MSB 0x001d
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_14_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_14_MASK 0x30000000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_14_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_15_LSB 0x001e
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_15_MSB 0x001f
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_15_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_15_MASK 0xc0000000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_15_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_16_LSB 0x0020
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_16_MSB 0x0021
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_16_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_16_MASK 0x300000000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_16_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_17_LSB 0x0022
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_17_MSB 0x0023
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_17_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_17_MASK 0xc00000000
#define MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_STP_STATE_17_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FLAG
// EGRESS_MST_TABLE desc:  Contains egress spanning-tree state for each port in the VLAN. Each
// port has one bit of spanning tree forwarding state associated with it.
// [br][br] Indexed first by VLAN ID and then by chunk, where each
// chunk is 64 ports worth of spanning-tree state.
typedef union {
    struct {
        uint64_t  FORWARDING           :  64;    //  Defines forwarding state for
                                                 // 64 of 258 ports.

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FORWARDING_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FORWARDING_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FORWARDING_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FORWARDING_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_FORWARDING_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_FLAG
// GLORT_DIRECT_MAP_CTRL desc:  Control Register for proxy access to the GLORT_DEST_TABLE.
typedef union {
    struct {
        uint64_t  REG_INDX             :  32;    //  Register Entry Index.
                                                 // Indicates the GLORT_DEST_TABLE
                                                 // index. Valid values are 0 -
                                                 // 4095.
        uint64_t  REG_SUB_ID           :   8;    //  Register File Sub Index. Not
                                                 // used. Set to zero.
        uint64_t  REG_ID               :   8;    //  Register File ID.[br] 0 -
                                                 // GLORT_DEST_TABLE [br] 1-255
                                                 // Reserved
        uint64_t  _RSVD0_              :  13;    //  Reserved
        uint64_t  OP_TYPE              :   1;    //  Operation Type:[br] 0:
                                                 // Read[br] 1: Write
        uint64_t  STATUS               :   1;    //  Completion Status. Set by
                                                 // hardware upon completion of
                                                 // operation.[br] 0: Successful
                                                 // completion[br] 1: Address
                                                 // Out-of-Range error
        uint64_t  GO_COMPL             :   1;    //  Go command and completion
                                                 // status. [list] [*] Set to 1
                                                 // by software to initiate
                                                 // operation [*] Set to 0 by
                                                 // hardware when the operation is
                                                 // complete [/list]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_BITFIELD_COUNT 0x07
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_INDX_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_INDX_MSB 0x001f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_INDX_RANGE 0x0020
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_INDX_MASK 0xffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_INDX_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_SUB_ID_LSB 0x0020
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_SUB_ID_MSB 0x0027
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_SUB_ID_RANGE 0x0008
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_SUB_ID_MASK 0xff00000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_SUB_ID_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_ID_LSB 0x0028
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_ID_MSB 0x002f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_ID_RANGE 0x0008
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_ID_MASK 0xff0000000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_REG_ID_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL__RSVD0__LSB 0x0030
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL__RSVD0__MSB 0x003c
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL__RSVD0__RANGE 0x000d
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL__RSVD0__MASK 0x1fff000000000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_OP_TYPE_LSB 0x003d
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_OP_TYPE_MSB 0x003d
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_OP_TYPE_RANGE 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_OP_TYPE_MASK 0x2000000000000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_OP_TYPE_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_STATUS_LSB 0x003e
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_STATUS_MSB 0x003e
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_STATUS_RANGE 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_STATUS_MASK 0x4000000000000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_STATUS_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_GO_COMPL_LSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_GO_COMPL_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_GO_COMPL_RANGE 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_GO_COMPL_MASK 0x8000000000000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_GO_COMPL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_FLAG
// GLORT_DIRECT_MAP_DST0 desc:  Data register 0 for proxy access to the GLORT_DEST_TABLE. [br][br]
// GLORT_DEST_TABLE defines the destination ports for a given GLORT. The
// DestMask is a bit vector indicating which ports will receive normal
// (not logged or mirrored) copies of the frame. If an IP_MulticastIndex
// is specified (with value different than 0), then RXQ_MCAST_DEST_TABLE
// will be used to retrieve lists of VLANs for each port to use during
// IP multicast replication. [br][br] Proxy accesses to
// GLORT_DEST_TABLE are 320b atomic operations.
typedef union {
    struct {
        uint64_t  DEST_MASK            :  64;    //  Contains bits 0..63 of the
                                                 // 258-bit destination port mask
                                                 // (not including logged or
                                                 // mirrored copies of the
                                                 // packet).

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_OFFSET 0x08
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_DEST_MASK_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_DEST_MASK_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_DEST_MASK_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_FLAG
// GLORT_DIRECT_MAP_DST1 desc:  Data register 1 for proxy access to the GLORT_DEST_TABLE. See
// GLORT_DIRECT_MAP_DST0 for more information.
typedef union {
    struct {
        uint64_t  DEST_MASK            :  64;    //  Contains bits 64..127 of the
                                                 // 258-bit destination port mask
                                                 // (not including logged or
                                                 // mirrored copies of the
                                                 // packet).

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_OFFSET 0x10
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_DEST_MASK_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_DEST_MASK_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_DEST_MASK_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_FLAG
// GLORT_DIRECT_MAP_DST2 desc:  Data register 2 for proxy access to the GLORT_DEST_TABLE. See
// GLORT_DIRECT_MAP_DST0 for more information.
typedef union {
    struct {
        uint64_t  DEST_MASK            :  64;    //  Contains bits 128..191 of
                                                 // the 258-bit destination port
                                                 // mask (not including logged or
                                                 // mirrored copies of the
                                                 // packet).

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_OFFSET 0x18
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_DEST_MASK_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_DEST_MASK_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_DEST_MASK_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_FLAG
// GLORT_DIRECT_MAP_DST3 desc:  Data register 3 for proxy access to the GLORT_DEST_TABLE. See
// GLORT_DIRECT_MAP_DST0 for more information.
typedef union {
    struct {
        uint64_t  DEST_MASK            :  64;    //  Contains bits 192..255 of
                                                 // the 258-bit destination port
                                                 // mask (not including logged or
                                                 // mirrored copies of the
                                                 // packet).

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_OFFSET 0x20
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_DEST_MASK_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_DEST_MASK_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_DEST_MASK_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_FLAG
// GLORT_DIRECT_MAP_DST4 desc:  Data register 4 for proxy access to the GLORT_DEST_TABLE. See
// GLORT_DIRECT_MAP_DST0 for more information.
typedef union {
    struct {
        uint64_t  DEST_MASK            :   2;    //  Contains bits 256..257 of
                                                 // the 258-bit destination port
                                                 // mask (not including logged or
                                                 // mirrored copies of the
                                                 // packet).
        uint64_t  IP_MULTICAST_INDEX   :  12;    //  Selects the IP multicast
                                                 // profile: used as an index into
                                                 // RXQ_MCAST_DEST_TABLE.
        uint64_t  RSVD_0               :  50;    // Nebulon auto filled RSVD [63:14]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_OFFSET 0x28
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_BITFIELD_COUNT 0x02
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_DEST_MASK_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_DEST_MASK_MSB 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_DEST_MASK_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_DEST_MASK_MASK 0x00000003
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_DEST_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_IP_MULTICAST_INDEX_LSB 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_IP_MULTICAST_INDEX_MSB 0x000d
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_IP_MULTICAST_INDEX_RANGE 0x000c
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_IP_MULTICAST_INDEX_MASK 0x00003ffc
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_IP_MULTICAST_INDEX_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_FLAG
// GLORT_RAM desc:  Data associated with each CAM entry. The entry defines how to
// compute the index for indexing the GLORT_DEST_TABLE to retrieve the
// final destination. See the Destination Mask Generation chapter in the
// HAS for details on the various fields.
typedef union {
    struct {
        uint64_t  STRICT               :   2;    //  Determines whether the
                                                 // destination index is chosen
                                                 // explicitly or via hashing.
                                                 // [list] [*] Hashed(0) [*]
                                                 // Reserved (1) [*] Targeted
                                                 // Deterministic (2) [*]
                                                 // Deterministic (3) [/list]
        uint64_t  DEST_INDEX           :  12;    //  Defines the base index of
                                                 // the first entry into the
                                                 // GLORT_DEST_TABLE which
                                                 // contains the destination.
        uint64_t  RANGE_SUB_INDEX_A    :   8;    //  Defines a field GLORTA
                                                 // extracted from the GLORT (bits
                                                 // 3..0 is bit position, bits
                                                 // 7..4 is the length) to use as
                                                 // a parameter for indexing into
                                                 // the GLORT_DEST_TABLE.
        uint64_t  RANGE_SUB_INDEX_B    :   8;    //  Defines a field GLORTB
                                                 // extracted from the GLORT (bits
                                                 // 3..0 is bit position, bits
                                                 // 7..4 is the length) to use as
                                                 // a parameter for indexing into
                                                 // the GLORT_DEST_TABLE.
        uint64_t  DEST_COUNT           :   4;    //  Defines the number of
                                                 // DestMask entries in the
                                                 // GLORT_DEST_TABLE over which
                                                 // frames will be hashed. A value
                                                 // of 0 is interpreted as 16. For
                                                 // distributed link aggregation
                                                 // pruning, this corresponds to
                                                 // the number of ports in the
                                                 // LAG.
        uint64_t  HASH_ROTATION        :   1;    //  Selects hash Rotation A (0)
                                                 // or Rotation B (1) for
                                                 // calculating the destination
                                                 // mask index.
        uint64_t  SKIP_DGLORT_DEC      :   1;    //  Indicate to skip DGLORT
                                                 // decrement.
        uint64_t  RSVD_0               :  28;    // Nebulon auto filled RSVD [63:36]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_BITFIELD_COUNT 0x07
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_STRICT_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_STRICT_MSB 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_STRICT_RANGE 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_STRICT_MASK 0x00000003
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_STRICT_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_INDEX_LSB 0x0002
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_INDEX_MSB 0x000d
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_INDEX_RANGE 0x000c
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_INDEX_MASK 0x00003ffc
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_INDEX_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_A_LSB 0x000e
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_A_MSB 0x0015
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_A_RANGE 0x0008
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_A_MASK 0x003fc000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_A_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_B_LSB 0x0016
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_B_MSB 0x001d
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_B_RANGE 0x0008
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_B_MASK 0x3fc00000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_RANGE_SUB_INDEX_B_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_COUNT_LSB 0x001e
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_COUNT_MSB 0x0021
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_COUNT_RANGE 0x0004
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_COUNT_MASK 0x3c0000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_DEST_COUNT_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_HASH_ROTATION_LSB 0x0022
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_HASH_ROTATION_MSB 0x0022
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_HASH_ROTATION_RANGE 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_HASH_ROTATION_MASK 0x400000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_HASH_ROTATION_RESET_VALUE 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SKIP_DGLORT_DEC_LSB 0x0023
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SKIP_DGLORT_DEC_MSB 0x0023
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SKIP_DGLORT_DEC_RANGE 0x0001
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SKIP_DGLORT_DEC_MASK 0x800000000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_SKIP_DGLORT_DEC_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_FLAG
// GLORT_CAM desc:  Configures an entry in the GLORT CAM. The CAM entries are readable
// but the value returned will be masked out according to the mask
// originally written along with the value. [br][br] A match occurs
// when the data searched is equal to the key and the entry is valid.
// The table below shows the encoded data value stored (Content) based
// on the state of the data (Key) and mask (KeyInvert) values in the
// TCAM bitcell. [code]
// +-----------------------------------------------------+ | Mask
// storage | Data storage | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// highest index has precedence in case there is more than one match.
typedef union {
    struct {
        uint64_t  KEY                  :  16;    //  Glort value.
        uint64_t  KEY_INVERT           :  16;    //  Glort Mask. Write the
                                                 // inverse to match exactly.
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_OFFSET 0x00
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_BITFIELD_COUNT 0x02
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_RESET 0xffffffff

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_MSB 0x000f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_RANGE 0x0010
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_MASK 0x0000ffff
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_RESET_VALUE 0x0000ffff

#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_INVERT_LSB 0x0010
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_INVERT_MSB 0x001f
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_INVERT_RANGE 0x0010
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_INVERT_MASK 0xffff0000
#define MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_KEY_INVERT_RESET_VALUE 0x0000ffff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_FLAG
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_FLAG
// CGRP_USED_TABLE desc:  Used for aging out MAC address table entries. Provides one bit for
// each EM_B hash or CAM entry that might be used for SMAC matching.
// When an EM_B hash or CAM entry hits on a packet and employs a USED
// action, the corresponding bit in this table will be set by hardware.
// Software clears individual bits by writing a 1 to them. [br][br]
// Indexes 0..63 correspond to the EM_B hash table entries and index 64
// corresponds to the EM_B CAM table. Note that the CAM has only 32
// entries, corresponding to the low-order 32 bits of
// CGRP_USED_TABLE[64].
typedef union {
    struct {
        uint64_t  USED                 :  64;    //  Used bits corresponding to
                                                 // 64 EM_B table entries.

    }                                field;
    uint64_t                         val;
} MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_t;
#endif
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_OFFSET 0x60
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_SCOPE 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_SIZE 64
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_BITFIELD_COUNT 0x01
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_RESET 0x00000000

#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_USED_LSB 0x0000
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_USED_MSB 0x003f
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_USED_RANGE 0x0040
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_USED_MASK 0xffffffffffffffff
#define MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_USED_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    // starting the regfile section
    struct {
        MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_TABLE_t EGRESS_VID_TABLE[5]; // offset 4'h0, width 64
    } EGRESS_VID_TABLE[4096];                    // offset 4'h0, size: 40
    uint8_t                    rsvd0[98304];
    MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_VID_CFG_t EGRESS_VID_CFG[4096]; // offset 20'h40000, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_INGRESS_MST_TABLE_t INGRESS_MST_TABLE[4096]; // offset 20'h48000, width 64
    uint8_t                    rsvd1[196608];
    // starting the regfile section
    struct {
        MBY_PPE_MST_GLORT_MAP_MSG_EGRESS_MST_TABLE_t EGRESS_MST_TABLE[5]; // offset 4'h0, width 64
    } EGRESS_MST_TABLE[4096];                    // offset 20'h80000, size: 40
    uint8_t                    rsvd2[98304];
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_CTRL_t GLORT_DIRECT_MAP_CTRL; // offset 24'h0C0000, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST0_t GLORT_DIRECT_MAP_DST0; // offset 24'h0C0008, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST1_t GLORT_DIRECT_MAP_DST1; // offset 24'h0C0010, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST2_t GLORT_DIRECT_MAP_DST2; // offset 24'h0C0018, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST3_t GLORT_DIRECT_MAP_DST3; // offset 24'h0C0020, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_DIRECT_MAP_DST4_t GLORT_DIRECT_MAP_DST4; // offset 24'h0C0028, width 64
    uint8_t                    rsvd3[464];
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_RAM_t GLORT_RAM[64];    // offset 24'h0C0200, width 64
    MBY_PPE_MST_GLORT_MAP_MSG_GLORT_CAM_t GLORT_CAM[64];    // offset 24'h0C0400, width 64
    uint8_t                    rsvd4[352];
    MBY_PPE_MST_GLORT_MAP_MSG_CGRP_USED_TABLE_t CGRP_USED_TABLE[65]; // offset 24'h0C0760, width 64
} mby_ppe_mst_glort_map_t;                       // size:  24'h0C0968


#endif // _MBY_PPE_MST_GLORT_MAP_REGS_H_


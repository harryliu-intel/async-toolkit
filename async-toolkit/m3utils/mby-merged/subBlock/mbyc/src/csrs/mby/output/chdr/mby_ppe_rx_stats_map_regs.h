/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_rx_stats_map_regs.h                                
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_RX_STATS_MAP_REGS_H_
#define _MBY_PPE_RX_STATS_MAP_REGS_H_

#define STATS_MSGPORT     0x0
#define STATS_RX_STATS_BANK_FRAME_MSGREGADDR 0x0
#define STATS_RX_STATS_BANK_BYTE_MSGREGADDR 0x4000
#define STATS_RX_STATS_VLAN_FRAME_MSGREGADDR 0x8000
#define STATS_RX_STATS_VLAN_BYTE_MSGREGADDR 0x28000

#ifndef MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FLAG
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FLAG
// RX_STATS_BANK_FRAME desc:  Each entry corresponds to a port x statistics class. There are 4
// banks in total. See specification chapter for more details. [br][br]
// The first index identifies the group, while the second index is the
// counter for that group. [list] [*] Group 0:
// RX_STATS_BANK_FRAME[0,port*18+type], type defined in RX_STATS_BANK_0
// [*] Group 1: RX_STATS_BANK_FRAME[1,port*18+type], type defined in
// RX_STATS_BANK_1 [*] Group 2: RX_STATS_BANK_FRAME[2,port*18+type],
// type defined in RX_STATS_BANK_2 [*] Group 3:
// RX_STATS_BANK_FRAME[3,port*18+type], type defined in RX_STATS_BANK_3
// [/list]
typedef union {
    struct {
        uint64_t  FRAME_COUNTER        :  48;    //  Number of frames received.
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_t;
#endif
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_OFFSET 0x00
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_SCOPE 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_SIZE 64
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_BITFIELD_COUNT 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_RESET 0x00000000

#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FRAME_COUNTER_LSB 0x0000
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FRAME_COUNTER_MSB 0x002f
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FRAME_COUNTER_RANGE 0x0030
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FRAME_COUNTER_MASK 0xffffffffffff
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_FRAME_COUNTER_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_FLAG
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_FLAG
// RX_STATS_BANK_BYTE desc:  Each entry corresponds to a port x statistics class. There are 4
// banks in total. See specification chapter for more details. [br][br]
// The first index identifies the group, while the second index is the
// counter for that group. [br][br] [*] Group 0:
// RX_STATS_BANK_BYTE[0,port*18+type], type defined in RX_STATS_BANK_0
// [*] Group 1: RX_STATS_BANK_BYTE[1,port*18+type], type defined in
// RX_STATS_BANK_1 [*] Group 2: RX_STATS_BANK_BYTE[2,port*18+type], type
// defined in RX_STATS_BANK_2 [*] Group 3:
// RX_STATS_BANK_BYTE[3,port*18+type], type defined in RX_STATS_BANK_3
// [/list]
typedef union {
    struct {
        uint64_t  BYTE_COUNTER         :  56;    //  Number of bytes received.
        uint64_t  RSVD_0               :   8;    // Nebulon auto filled RSVD [63:56]

    }                                field;
    uint64_t                         val;
} MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_t;
#endif
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_OFFSET 0x00
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_SCOPE 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_SIZE 64
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_BITFIELD_COUNT 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_RESET 0x00000000

#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_BYTE_COUNTER_LSB 0x0000
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_BYTE_COUNTER_MSB 0x0037
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_BYTE_COUNTER_RANGE 0x0038
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_BYTE_COUNTER_MASK 0xffffffffffffff
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_BYTE_COUNTER_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FLAG
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FLAG
// RX_STATS_VLAN_FRAME desc:  Each entry corresponds to a bin counter within a counter set. There
// are 4K counter sets total, 4 bins in each counter set.
// RX_STATS_VLAN_FRAME[vlan_couter,ftype], ftype is Unicast(0),
// Multicast(1), Broadcast(2), or Drop (3). The first index identifies
// the counter set, while the second index (ftype) identifies the bin of
// that counter set.
typedef union {
    struct {
        uint64_t  FRAME_COUNTER        :  36;    //  Number of vlan frames
                                                 // received.
        uint64_t  RSVD_0               :  28;    // Nebulon auto filled RSVD [63:36]

    }                                field;
    uint64_t                         val;
} MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_t;
#endif
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_OFFSET 0x00
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_SCOPE 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_SIZE 64
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_BITFIELD_COUNT 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_RESET 0x00000000

#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FRAME_COUNTER_LSB 0x0000
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FRAME_COUNTER_MSB 0x0023
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FRAME_COUNTER_RANGE 0x0024
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FRAME_COUNTER_MASK 0xfffffffff
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_FRAME_COUNTER_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_FLAG
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_FLAG
// RX_STATS_VLAN_BYTE desc:  Each entry corresponds to a bin counter within a counter set. There
// are 4K counter sets total, 4 bins in each counter set.
// RX_STATS_VLAN_BYTE[vlan_couter,ftype], ftype is Unicast(0),
// Multicast(1), Broadcast(2), or Drop (3). The first index identifies
// the counter set, while the second index (ftype) identifies the bin of
// that counter set.
typedef union {
    struct {
        uint64_t  BYTE_COUNTER         :  44;    //  Number of vlan bytes
                                                 // received.
        uint64_t  RSVD_0               :  20;    // Nebulon auto filled RSVD [63:44]

    }                                field;
    uint64_t                         val;
} MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_t;
#endif
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_OFFSET 0x00
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_SCOPE 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_SIZE 64
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_BITFIELD_COUNT 0x01
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_RESET 0x00000000

#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_BYTE_COUNTER_LSB 0x0000
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_BYTE_COUNTER_MSB 0x002b
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_BYTE_COUNTER_RANGE 0x002c
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_BYTE_COUNTER_MASK 0xfffffffffff
#define MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_BYTE_COUNTER_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    // starting the regfile section
    struct {
        MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_FRAME_t RX_STATS_BANK_FRAME[144]; // offset 4'h0, width 64
    } RX_STATS_BANK_FRAME[4];                    // offset 4'h0, size: 1152
    uint8_t                    rsvd0[11776];
    // starting the regfile section
    struct {
        MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_BANK_BYTE_t RX_STATS_BANK_BYTE[144]; // offset 4'h0, width 64
    } RX_STATS_BANK_BYTE[4];                     // offset 16'h4000, size: 1152
    uint8_t                    rsvd1[11776];
    MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_FRAME_t RX_STATS_VLAN_FRAME[16128]; // offset 16'h8000, width 64
    uint8_t                    rsvd2[2048];
    MBY_PPE_RX_STATS_MAP_MSG_RX_STATS_VLAN_BYTE_t RX_STATS_VLAN_BYTE[16128]; // offset 20'h28000, width 64
} mby_ppe_rx_stats_map_t;                        // size:  20'h47800


#endif // _MBY_PPE_RX_STATS_MAP_REGS_H_


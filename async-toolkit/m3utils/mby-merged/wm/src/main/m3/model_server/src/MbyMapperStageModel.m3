MODULE MbyMapperStageModel EXPORTS MbyMapperStageModel, MbyMapperSizes;

IMPORT mby_top_map_addr AS TopAddr;

IMPORT mby_ppe_mapper_map AS Map;
IMPORT mby_ppe_mapper_map_addr AS MapAddr;

IMPORT ServerPacket AS Pkt;
IMPORT Metadata;
IMPORT MbyParserToMapperMeta;
IMPORT MbyMapperToClassifierMeta;
IMPORT ModelStageResult;
IMPORT MbyMeta;
IMPORT MbyParserTypes; 
IMPORT MbyPaFlags, MbyPaKeys AS PK;
FROM MbyDoRealignKeys IMPORT RealignKeys, RaKeys;
IMPORT Word;
FROM mby_ppe_mapper_map IMPORT map_domain_tcam_r, T_MapDomainTcam_type;
FROM WmUtils IMPORT GetUnnamedField, ModfyUnnamedField;
IMPORT MbyRealignKeys AS RK;
IMPORT MbyTypes;

PROCEDURE HandlePacket(ipkt    : Pkt.T;
                       h       : TopAddr.H;
                       indices : Indices;
                       imd     : Metadata.T;
                       out     : ModelStageResult.T) =
  BEGIN
    (* purpose of this routine is to map the records,
       it should probably be autogenerated!  *)
    HandlePacketInt(h.read  .Mpt[indices.MptIdx].RxPpe.Mapper,
                    h.update.Mpt[indices.MptIdx].RxPpe.Mapper,
                    imd,
                    out)
  END HandlePacket;
  
PROCEDURE HandlePacketInt(READONLY r  : Map.T;
                          READONLY u  : MapAddr.U;
                          im          : Metadata.T;
                          out         : ModelStageResult.T) =
  VAR
    mbm : MbyMeta.T :=
        im.ofType(TYPECODE(MbyMeta.T));
    p2m : MbyParserToMapperMeta.T :=
        im.ofType(TYPECODE(MbyParserToMapperMeta.T));

    isIpV4, isIpV6 := ARRAY [0..NIsIpBits-1] OF BOOLEAN { FALSE, .. };

    realignedKeys  : RaKeys;
    ihlOk, ihlFits : BOOLEAN;
  BEGIN
    (* we dont actually use the ipkt here -- should adjust param list *)
    WITH
      portCfg = r.MapPortCfg[mbm.rxPort]
     DO
      IF p2m.paFlags[MbyPaFlags.T.InrL3V] THEN
        isIpV4[1] := p2m.paKeys[PK.InnerIpHdr].v;
        isIpV6[1] := NOT isIpV4[1];
      END;
      IF p2m.paFlags[MbyPaFlags.T.OtrL3V] THEN
        isIpV4[0] := p2m.paKeys[PK.OuterIpHdr].v;
        isIpV6[0] := NOT isIpV4[1];
      END;

      RealignKeys(isIpV4,
                  isIpV6,
                  p2m.paKeys,
                  realignedKeys,
                  ihlOk,
                  ihlFits
      );

      EVAL LookUpDomainTcam(mbm.rxPort,
                       VlanV { GetUnnamedField(realignedKeys[RK.OuterVlan1].k,0,12),
                               p2m.paFlags[MbyPaFlags.T.OtrL2Vlan1] },
                       VlanV { GetUnnamedField(realignedKeys[RK.OuterVlan2].k,0,12),
                               p2m.paFlags[MbyPaFlags.T.OtrL2Vlan2] },
                       
                       r.MapDomainTcam

                       );

      InsertDefaults();

      MapScalar();

      GetParserInfo();

      GetProfile();

      MapRewrite();
      
    END;

    (* the next line s.b. moved up to HandlePacket *)
    out.push(opkt := NIL, om := NEW(MbyMapperToClassifierMeta.T))
  END HandlePacketInt;

TYPE VlanV = RECORD vid : MbyTypes.VlanId; v : BOOLEAN END;

PROCEDURE  LookUpDomainTcam(rxPort        : MbyTypes.Port;
                            vid1, vid2    : VlanV;
                            READONLY arry : T_MapDomainTcam_type) :
  [FIRST(T_MapDomainTcam_type)..LAST(T_MapDomainTcam_type)] =
  (* this really should use some sort of tcam object *)
  BEGIN
  END LookUpDomainTcam;
  
PROCEDURE  InsertDefaults() =
  BEGIN
  END InsertDefaults;
  
PROCEDURE  MapScalar() =
  BEGIN
  END MapScalar;
  
PROCEDURE  GetParserInfo() =
  BEGIN
  END GetParserInfo;
  
PROCEDURE  GetProfile() =
  BEGIN
  END GetProfile;
  
PROCEDURE  MapRewrite() =
  BEGIN
  END MapRewrite;

BEGIN END MbyMapperStageModel.

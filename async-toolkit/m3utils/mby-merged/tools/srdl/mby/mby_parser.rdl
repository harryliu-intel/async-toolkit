<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

enum parser_csum_cfg_validate_l4_csum_enum {
  DISABLE = 2'd0 { desc = " Disable the check."; };
  DROP = 2'd1 { desc = " Validate and drop in case of error."; };
  MARK = 2'd2 { desc = " Validate and mark the result in metadata."; };
};


enum parser_csum_cfg_validate_l3_length_enum {
  DISABLE = 2'd0 { desc = " Disable the check."; };
  DROP = 2'd1 { desc = " Validate and drop in case of error."; };
  MARK = 2'd2 { desc = " Validate and mark the result in metadata."; };
};





// PARSER_PORT_CFG[0..23]

reg parser_port_cfg_r {
  shared;
  HandCoded = true;
  name = "Sets initial analyzer state";
  desc = "
  indexed by interface and logical port number. Sets the initial ptr/state/op,
  and indicates byte offsets of w0/w1/w2 in the packet.  The configuration for
  interface j and port i is found at index (j*8)+i.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_W0_OFFSET[63:56] = 8'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_W1_OFFSET[55:48] = 8'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_W2_OFFSET[47:40] = 8'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_PTR[39:32] = 8'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_STATE[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_OP_MASK[15:4] = 12'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } INITIAL_OP_ROT[3:0] = 4'h0;
};



// PARSER_CSUM_CFG[0..23]

reg parser_csum_cfg_r {
  shared;
  HandCoded = true;
  name = "Per-interface and per-port config for which csum calculations and length validation checks are enabled.  The configuration for interface j and port i is found at index (j*8)+i.";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    encode = parser_csum_cfg_validate_l4_csum_enum;
    AccessType = "RW";
    desc = "
        Enable checksum validation and/or drop on L4 checksum error (for TCP, UDP & SCTP).  

           ";
    ValRandomize = true;
  } VALIDATE_L4_CSUM[5:4] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable partial checksum write to metadata on fragments.

           ";
    ValRandomize = true;
  } STORE_L4_PARTIAL_CSUM[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Insert computed outer L4 UDP checksum into the packet.

           ";
    ValRandomize = true;
  } COMPUTE_L4_CSUM[2:2] = 1'h0;
  field {
    encode = parser_csum_cfg_validate_l3_length_enum;
    AccessType = "RW";
    desc = "
        Enable validation of the payload length field in the L3 header

           ";
    ValRandomize = true;
  } VALIDATE_L3_LENGTH[1:0] = 2'h0;
};



// PARSER_IP

reg parser_ip_r {
  shared;
  HandCoded = true;
  name = "Parser Interrupt Pending";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Memory ECC or parity error reported by the local memory controller.
        Check all PA_*_STATUS registers to find the source.

           ";
    ValRandomize = true;
  } MEM_ERROR[0:0] = 1'h0;
};



// PARSER_IM

reg parser_im_r {
  shared;
  HandCoded = true;
  name = "Parser Interrupt Mask";
  desc = "
  The interrupt mask register controls if the corresponding interrupt source
  is presented to the interrupt hierarchy (bit is set to 0) or masked out
  (bit is set to 1).
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Memory ECC or parity error reported by the local memory controller.
        Check all PA_*_STATUS registers to find the source.

           ";
    ValRandomize = true;
  } MEM_ERROR[0:0] = 1'h1;
};



// PARSER_KEY_W[0..31,0..15]

reg parser_key_w_r {
  shared;
  HandCoded = true;
  name = "Sets TCAM key W0/W1 per (stage, rule)";
  desc = "
  w0 matches if (w0 & w0_mask) == w0_value
  w1 matches if (w1 & w1_mask) == w1_value
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } W1_VALUE[63:48] = 16'hffff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } W1_MASK[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } W0_VALUE[31:16] = 16'hffff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } W0_MASK[15:0] = 16'h0;
};
regfile parser_key_w_rf {
  parser_key_w_r PARSER_KEY_W[16] += 8;
};



// PARSER_KEY_S[0..31,0..15]

reg parser_key_s_r {
  shared;
  HandCoded = true;
  name = "Sets TCAM key STATE per (stage, rule)";
  desc = "
  state matches if (state & state_mask) == state_value.
  To disable a rule, set state_mask=0 and state_value=1.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } STATE_VALUE[31:16] = 16'hffff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } STATE_MASK[15:0] = 16'h0;
};
regfile parser_key_s_rf {
  parser_key_s_r PARSER_KEY_S[16] += 8;
};



// PARSER_ANA_W[0..31,0..15]

reg parser_ana_w_r {
  shared;
  HandCoded = true;
  name = "Sets Analyzer W0..2/skip action per (stage, rule)";
  desc = "
  Note that NEXTW0/W1/W2_OFFSET and SKIP should be even.
  Hardware will ignore the lsb of these fields.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
	Offset of next w0 relative to current ptr + op(w2).

           ";
    ValRandomize = true;
  } NEXT_W0_OFFSET[31:24] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	Offset of next w1 relative to current ptr + op(w2).

           ";
    ValRandomize = true;
  } NEXT_W1_OFFSET[23:16] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	Offset of next w2 relative to current ptr + op(w2).

           ";
    ValRandomize = true;
  } NEXT_W2_OFFSET[15:8] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	Next ptr relative to current ptr + op(w2).

           ";
    ValRandomize = true;
  } SKIP[7:0] = 8'h0;
};
regfile parser_ana_w_rf {
  parser_ana_w_r PARSER_ANA_W[16] += 8;
};



// PARSER_ANA_S[0..31,0..15]

reg parser_ana_s_r {
  shared;
  HandCoded = true;
  name = "Sets Analyzer State/Op action per (stage, rule)";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
	Bit values to be written into next state.

           ";
    ValRandomize = true;
  } NEXT_STATE[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
  	Bitwise state write control.

           ";
    ValRandomize = true;
  } NEXT_STATE_MASK[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
	ALU operation to apply to next w2.

           ";
    ValRandomize = true;
  } NEXT_OP[15:0] = 16'h0;
};
regfile parser_ana_s_rf {
  parser_ana_s_r PARSER_ANA_S[16] += 8;
};



// PARSER_EXC[0..31,0..15]

reg parser_exc_r {
  shared;
  HandCoded = true;
  name = "Set Exception action per (stage, rule)";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
	Raises an EOF exception if packet_len & lt. ptr + ex_offset.
        On an EOF exception, this rule and all downstream rules are disabled.

           ";
    ValRandomize = true;
  } EX_OFFSET[8:1] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	Raises a ParsingDone exception.
        On a ParsingDone exception, all downstream rules are disabled.

        A ParsingDone exception may be raised on either a good packet
        or bad packet to prevent further parsing. In a good packet,
        ParsingDone should be raised as the last header is parsed. In
        a bad packet, ParsingDone should be raised and another flag
        should be set (via ext_action) to indicate parsing failure.

           ";
    ValRandomize = true;
  } PARSING_DONE[0:0] = 1'h0;
};
regfile parser_exc_rf {
  parser_exc_r PARSER_EXC[16] += 8;
};



// PARSER_EXT[0..31,0..31]

reg parser_ext_r {
  shared;
  HandCoded = true;
  name = "Sets Extract action per (stage, 2*rule)";
  desc = "
  Two extract actions are at (stage, rule) and (stage, rule+16).
  Note that OFFSET should be even.
  Hardware will ignore the lsb of these fields.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
	The protocol identifier value to store to the header pointer entry 
    identified by PTR_NUM. Set to 0xFF to prevent this action from
    setting any header pointer.

           ";
    ValRandomize = true;
  } PROTOCOL_ID[25:18] = 8'hff;
  field {
    AccessType = "RW";
    desc = "
	An offset to add to the current parsing ptr, the sum being stored
    in the header pointer entry as the base offset for the 
    corresponding protocol_id.

           ";
    ValRandomize = true;
  } OFFSET[17:10] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
	Which flag to assign.
        Use flag_num=0 to disable writing flags.

           ";
    ValRandomize = true;
  } FLAG_NUM[9:4] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
	Value to assign to flag

           ";
    ValRandomize = true;
  } FLAG_VALUE[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
	Indicates which of 8 header pointer entries to write with the protocol_id and 
    base offset, if PROTOCOL_ID is not 0xFF.

           ";
    ValRandomize = true;
  } PTR_NUM[2:0] = 3'h0;
};
regfile parser_ext_rf {
  parser_ext_r PARSER_EXT[32] += 8;
};

reg parser_ptype_tcam_r {
  shared;
  HandCoded = true;
  name = "Derives the packet type";
  desc = "
    The packet type TCAM matches on a key consisting of the lower 32b of
    the parser flag output.  The output of the TCAM is a 6b packet type.
    [br][br]
    A match occurs when the data searched is equal to the key and the 
    entry is valid. The table below shows the encoded data value stored 
    (Content) based on the state of the data (KEY) and mask (KEY_INVERT) 
    values in the TCAM bitcell.
  
    [code]
    +-----------------------------------------------------+
    | Mask storage | Data storage |        Content        |
    =======================================================
    |      0       |      0       |   X (always match)    |
    +-----------------------------------------------------+
    |      0       |      1       |           1           |
    +-----------------------------------------------------+
    |      1       |      0       |           0           |
    +-----------------------------------------------------+
    |      1       |      1       | Always mismatch state |
    +-----------------------------------------------------+
    [/code]
  
    The highest index has precedence in case there is more than one match.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        The inverted key to match on.
           ";
    ValRandomize = true;
  } KEY_INVERT[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "The key to match on."; 
    ValRandomize = true;
  } KEY[31:0] = 32'h0;
};
regfile parser_ptype_tcam_rf {
  parser_ptype_tcam_r PARSER_PTYPE_TCAM[64] += 8;
};

reg parser_ptype_ram_r {
  shared;
  HandCoded = true;
  name = "Derives the packet type";
  desc = "
    Contains the packet type and extraction index as a result of the match in
    PARSER_PTYPE_TCAM.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "The extraction index in PARSER_EXTRACT_CFG to use for this packet type";
    ValRandomize = true;
  } EXTRACT_IDX[13:10] = 4'h0;
  field {
    AccessType = "RW";
    desc = "The packet type result";
    ValRandomize = true;
  } PTYPE[9:0] = 10'h0;
};
regfile parser_ptype_ram_rf {
  parser_ptype_ram_r PARSER_PTYPE_RAM[64] += 8;
};


// PARSER_EXTRACT_CFG[0..15][0..79]

reg parser_extract_cfg_r {
  shared;
  HandCoded = true;
  name = "Extracts the field vector";
  desc = "
    Provides 16 extraction profiles, each indicating the 80 16b words to 
    extract from the packet buffer into the field vector.  This register 
    is indexed first by extraction index, then by word number.
    [br][br]
    During extraction, the 8 header pointer entries will be compared for matching
    protocol_id values. When a match is found, the OFFSET value will be summed
    with the base offset from the header pointer entry and the result used as an 
    absolute index into the packet from which the 16b word is extracted and
    loaded into the field vector.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "The relative offset from which to source this 16b word";
    ValRandomize = true;
  } OFFSET[15:8] = 8'h0;
  field {
    AccessType = "RW";
    desc = "The protocol ID to use to source this 16b word";
    ValRandomize = true;
  } PROTOCOL_ID[7:0] = 8'hff;
};
regfile parser_extract_cfg_rf {
  parser_extract_cfg_r PARSER_EXTRACT_CFG[80] += 8;
};


reg parser_counters_r {
  shared;
  HandCoded = true;
  name = "Parser counters";
  desc = "
    A set of 8-bit counters, each incremented when a particular parsing
    event occurs. Counted events are generally considered to be the 
    result of misconfiguration.
    [br][br]
    Counter values will increment until they reach their maximum value,
    then will remain saturated without rolling over.
    [br][br]
    Each counter may be individually reset to zero by writing 
    0xFF to the counter.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  default woclr;
  field {
    AccessType = "RW/1C/V";
    desc = "
        A protocol ID specified for field extraction
        appears more than once in the pointer headers.
           ";
    ValRandomize = true;
    counter;
    incrsaturate = 8'hff;
  } EXT_DUP_PROTID[23:16] = 8'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        A protocol ID specified for field extraction did not 
        appear in the pointer headers.
           ";
    ValRandomize = true;
    counter;
    incrsaturate = 8'hff;
  } EXT_UNKNOWN_PROTID[15:8] = 8'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        The packet segment was exceeded when attempting to extract a
        16b field vector entry.
           ";
    ValRandomize = true;
    counter;
    incrsaturate = 8'hff;
  } EXT_SEG_BOUNDARY[7:0] = 8'h0;
};



addrmap mby_ppe_parser_map {
  name = "mby_parser";
  desc = "Parser Register Set";
  //AddressBits = 16;
  //ResetDomains = "SWITCH,MGMT";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  parser_port_cfg_r          PARSER_PORT_CFG[16];
  parser_csum_cfg_r          PARSER_CSUM_CFG[16];
  parser_ip_r                PARSER_IP;
  parser_im_r                PARSER_IM;
  parser_key_w_rf            PARSER_KEY_W[32];
  parser_key_s_rf            PARSER_KEY_S[32];
  parser_ana_w_rf            PARSER_ANA_W[32];
  parser_ana_s_rf            PARSER_ANA_S[32];
  parser_exc_rf              PARSER_EXC[32];
  parser_ext_rf              PARSER_EXT[32];
  parser_ptype_tcam_rf       PARSER_PTYPE_TCAM[2];
  parser_ptype_ram_rf        PARSER_PTYPE_RAM[2];
  parser_extract_cfg_rf      PARSER_EXTRACT_CFG[16];
  parser_counters_r          PARSER_COUNTERS;
}; 

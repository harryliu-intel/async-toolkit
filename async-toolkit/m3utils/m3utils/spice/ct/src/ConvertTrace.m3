MODULE ConvertTrace EXPORTS Main;

(* ct program -- 

   convert 
          spice trace files (ASCII .tr0 files) 
                    to 
          aspice .names and .trace files

   Aspice output file is created in the fast format (blocked by node)

   Algorithm is external (uses numerous disk files for reordering)

   Author : Mika Nystrom <mika.nystroem@intel.com>

   SCROLL DOWN FOR Usage !

*)

IMPORT FileRd;
IMPORT Rd;
IMPORT Debug;
IMPORT TextSeqSeq;
IMPORT FileWr, Wr;
FROM Fmt IMPORT LongReal, Int, F;
IMPORT FS;
IMPORT ParseParams;
IMPORT Stdio;
IMPORT Pathname;
IMPORT OSError, AL;
IMPORT Thread;
IMPORT Params;
IMPORT TextSet, TextSetDef;
IMPORT Tr0;
IMPORT DataBlock;
IMPORT RegExList;
IMPORT RegEx;
IMPORT CitTextUtils AS TextUtils;
IMPORT Fsdb;
IMPORT TraceFile, FileNamer;
IMPORT TempReader;
IMPORT Text;
IMPORT Env;
IMPORT CtDocBundle;
IMPORT Process;
IMPORT BundleRep;
IMPORT RepeatMe;
IMPORT Conversion;
IMPORT ConversionList;
IMPORT Time;
IMPORT Watchdog;
IMPORT Scan;
IMPORT Lex, FloatMode;

<*FATAL Thread.Alerted*>

CONST LR = LongReal;
      TE = Text.Equal;
      
VAR doDebug := Debug.DebugThis("CT");

    (* see doc/ct.txt for documentation *)

CONST DefMaxFiles = 1000;

VAR maxFiles := LAST(CARDINAL);
    
CONST 
  MaxMem = 16*1024*1024; (* fit at least one row *)

VAR nFiles : CARDINAL;

PROCEDURE FileRd_Open(fn : Pathname.T) : Rd.T RAISES { OSError.E } =
  BEGIN
    IF doDebug THEN
      Debug.Out(F("opening file \"%s\"", fn));
    END;
    RETURN FileRd.Open(fn)
  END FileRd_Open;

PROCEDURE ReadEntireFile(tempReader   : TempReader.T;
                         idx          : CARDINAL;
                         VAR data     : ARRAY OF LONGREAL)
  RAISES { Rd.Failure, OSError.E } =
  BEGIN
    tempReader.readEntireFile(idx, data)
  END ReadEntireFile;
  
PROCEDURE CreateBuffers(tempReader     : TempReader.T;
                        fnr            : FileNamer.T;
                        VAR time, data : REF ARRAY OF LONGREAL)
  RAISES { OSError.E, Rd.Failure } =
  (* create time and data buffers, and read time into the time buffer *)
  VAR
    aLen : CARDINAL;
  BEGIN
    WITH timeIdx = 0,
         fn      = fnr.name(timeIdx),
         rd      = FileRd_Open(fn) DO
      aLen := DataBlock.DataCount(rd, timeIdx);
      Rd.Close(rd)
    END;

    Debug.Out(F("Creating time/data buffers: %s timesteps",
                Int(aLen)));
    time := NEW(REF ARRAY OF LONGREAL, aLen); (* alloc time *)
    data := NEW(REF ARRAY OF LONGREAL, aLen); (* alloc data *)

    IF doDebug THEN Debug.Out("Reading time data") END;
    
    ReadEntireFile(tempReader, 0, time^);

    IF NUMBER(time^) = 0 THEN
      Debug.Out("Time is empty")
    ELSE
      Debug.Out(F("Time %s -> %s", LR(time[FIRST(time^)]), LR(time[LAST(time^)])))
    END
  END CreateBuffers;
  
PROCEDURE WriteSources(ofn          : Pathname.T;
                       tempReader   : TempReader.T;
                       fnr          : FileNamer.T) =
  (* read data from each file in temp directory and output
     as PWL voltage sources to be used as a stimulus(?) *)
  VAR
    tFn := ofn & ".sources";
    sWr : Wr.T;
    time, data : REF ARRAY OF LONGREAL;
  BEGIN
    TRY
      sWr := FileWr.Open(tFn)
    EXCEPT
      OSError.E(x) => Debug.Error("Unable to open sources file \"" & tFn & "\" for writing : OSError.E : " & AL.Format(x))
    END;

    TRY
      Wr.PutText(sWr, "* sources file generated by ConvertTrace.m3\n");
    EXCEPT
      Wr.Failure(x) => Debug.Error("Write error on sources file : Wr.Failure : " & AL.Format(x))
    END;

    FOR i := 0 TO names.size() - 1 DO
      WITH fn   = fnr.name(i) DO
        TRY
          IF i = 0 THEN
            CreateBuffers(tempReader, fnr, time, data)
          ELSE
              Wr.PutText(sWr, "* source for " & names.get(i).get(0) & "\n");
              ReadEntireFile(tempReader, i, data^);
              Wr.PutText(sWr, F("V%s src%s 0 PWL (\n", Int(i), Int(i)));
              FOR i := FIRST(data^) TO LAST(data^) DO
                Wr.PutText(sWr, F("+   %20s       %20s\n",
                                  LongReal(time[i]),
                                  LongReal(data[i])))
              END;
              Wr.PutText(sWr, "+)\n\n");
          END
        EXCEPT
          OSError.E(x) =>
          Debug.Error("Unable to open temp file \"" & fn & "\" for reading : OSError.E : " & AL.Format(x))
        |
          Rd.Failure(x) =>
          Debug.Error("Read error on temp file \"" & fn & "\" for reading : Rd.Failure : " & AL.Format(x))
        |
          Wr.Failure(x) =>
          Debug.Error("Write error on sources file, lately reading \"" & fn & "\" : Wr.Failure : " & AL.Format(x))
        END
      END
    END;
    
    TRY
      Wr.Close(sWr)
    EXCEPT
      Wr.Failure(x) =>
      Debug.Error("Trouble closing sources file : Wr.Failure : " &
        AL.Format(x))
    END
  END WriteSources;

PROCEDURE Unslash(fn : Pathname.T) : Pathname.T =
  BEGIN
    RETURN TextUtils.Replace(fn, "/", "::")
  END Unslash;

PROCEDURE WriteFiles(ofn        : Pathname.T;
                     tempReader : TempReader.T;
                     fnr        : FileNamer.T) =
  (* read data from each file in temp directory and output
     in simple ASCII format, one file per signal *)
  VAR
    tDn := ofn & ".files";
    sWr : Wr.T;
    time, data : REF ARRAY OF LONGREAL;
    sFn : Pathname.T;
  BEGIN
    TRY
      FS.CreateDirectory(tDn);
    EXCEPT
    ELSE
    END;
    
    FOR i := 0 TO names.size() - 1 DO
      WITH fn   = fnr.name(i) DO
        TRY
          IF i = 0 THEN
            CreateBuffers(tempReader, fnr, time, data);
          ELSE
            TRY
              sFn := tDn & "/" & Unslash(names.get(i).get(0));
              sWr := FileWr.Open(sFn)
            EXCEPT
              OSError.E(x) => Debug.Error("Unable to open file \"" & sFn & "\" for writing : OSError.E : " & AL.Format(x))
            END;
            
            ReadEntireFile(tempReader, i, data^);
            
            FOR i := FIRST(data^) TO LAST(data^) DO
              Wr.PutText(sWr, F("%20s       %20s\n",
                                LongReal(time[i]),
                                LongReal(data[i])))
            END;
            TRY
              Wr.Close(sWr);
            EXCEPT
              Wr.Failure(x) => Debug.Error("Trouble closing sources file "&sFn&" : Wr.Failure : " &
                AL.Format(x))
            END
          END
        EXCEPT
          OSError.E(x) =>
          Debug.Error("Unable to open temp file \"" & fn & "\" for reading : OSError.E : " & AL.Format(x))
        |
          Rd.Failure(x) =>
          Debug.Error("Read error on temp file \"" & fn & "\" for reading : Rd.Failure : " & AL.Format(x))
        |
          Wr.Failure(x) =>
          Debug.Error("Write error on sources file, lately reading \"" & fn & "\" : Wr.Failure : " & AL.Format(x))
        END
      END
    END
  END WriteFiles;

PROCEDURE WriteTrace(ofn : Pathname.T;
                     fnr : FileNamer.T;
                     fmt : TraceFile.Version) : Pathname.T =
  BEGIN
    Debug.Out(F("ConvertTrace.WriteTrace : fmt %s",
                TraceFile.VersionNames[fmt]));
    
    WITH tr = NEW(TraceFile.T).init(ofn, nFiles, names.size(), fnr) DO
      IF wthreads > 1 THEN
        RETURN tr.writePll(wthreads, writeTraceCmdPath, fmt)
      ELSE
        RETURN tr.write(fmt)
      END
    END
  END WriteTrace;

PROCEDURE DoConversion(conv : Conversion.T) =
  VAR
    ifn := conv.ifn;
    ofn := conv.ofn;
    doBuild := TRUE;
  BEGIN

    (* check if all required traces are already built first *)
    IF doTrace THEN
      doBuild := FALSE;
      FOR f := FIRST(TraceFile.Version) TO LAST(TraceFile.Version) DO
        IF f IN formats THEN
          WITH sfx      = TraceFile.VersionSuffixes[f],
               ufn      = ofn & "." & sfx DO

            Debug.Out(F("DoConversion checking existence of TraceFile version %s : %s",
                        TraceFile.VersionNames[f],
                        ufn));

            TRY
              WITH status = FS.Status(ufn) DO
                Debug.Out(F("DoConversion checking modification time of %s : status.modificationTime = %s, ignoreTime = %s",
                            ufn, LR(status.modificationTime), LR(ignoreTime)));
                
                IF status.modificationTime <= ignoreTime THEN
                  (* file is old, rebuild it *)
                  doBuild := TRUE;
                  EXIT
                END
              END
            EXCEPT
              OSError.E(x) =>
              Debug.Out(F("DoConversion caught OSError.E (%s) while looking for %s, continuing", AL.Format(x), ufn));
              doBuild := TRUE;
              EXIT
            END            
          END
        END
      END
    END;

    IF doBuild = FALSE THEN
      Debug.Out(F("DoConversion : not building %s because we found a new version of every trace file", ofn));
      RETURN
    ELSE
      Debug.Out(F("DoConversion : continuing .. building %s", ofn))
    END;

    (* at least one trace does not exist, continue ... *)
              
    TRY
      IF doDebug THEN
        Debug.Out(F("ConvertTrace parsing... ifn=%s ofn=%s", ifn, ofn));
      END;
      CASE parseFmt OF
        ParseFmt.Tr0 =>

        VAR
          rd : Rd.T;
        BEGIN
          TRY
            rd  := FileRd_Open(ifn)
          EXCEPT
            OSError.E(x) => Debug.Error("Trouble opening input file \"" & ifn & "\": OSError.E : " & AL.Format(x))
          END;
          
          names.addhi(Tr0.Seq1("TIME"));
          Tr0.Parse(wd,
                    ofn,
                    names,
                    maxFiles,
                    nFiles,
                    MaxMem,
                    timeScaleFactor,
                    timeOffset,
                    voltageScaleFactor,
                    voltageOffset,
                    dutName,
                    rd,
                    wait,
                    restrictNodes,
                    regExList,
                    maxNodes,
                    translate, noX);

          TRY Rd.Close(rd) EXCEPT ELSE END
        END
      |
        ParseFmt.Fsdb =>
        Fsdb.Parse(wd,
                   ofn,
                   names,
                   maxFiles,
                   nFiles,
                   timeScaleFactor,
                   timeOffset,
                   voltageScaleFactor,
                   voltageOffset,
                   dutName,
                   ifn,
                   wait,
                   restrictNodes,
                   regExList,
                   maxNodes,
                   translate, noX,
                   scopesep,
                   fsdbCmdPath,
                   Fsdb.Compress {
        compressCmdPath,
        compressPrec,
        compressQuick
        },
                   threads,
                   interpolate,
                   maxTime)
      END;
      IF doDebug THEN
        Debug.Out("ConvertTrace parsing done.")
      END
      
    EXCEPT
      Tr0.SyntaxError(e) => Debug.Error("Syntax error on line " & Int(lNo) & " : " &
        e)
    |
      Tr0.ShortRead => Debug.Warning("Tr0.ShortRead: Short read on final line, data may be corrupted")
    |
      Rd.Failure(x) => Debug.Error("Trouble reading input file : Rd.Failure : " & AL.Format(x))
    END;

    WITH fnr = NEW(FileNamer.T).init(wd, nFiles, names.size()) DO

      VAR
        tempReader := NEW(TempReader.T).init(fnr);
      BEGIN
        
        IF doSources THEN
          WriteSources(ofn, tempReader, fnr)
        END;
        
        IF doFiles THEN
          WriteFiles(ofn, tempReader, fnr)
        END
      END;

      IF doTrace THEN
        FOR f := FIRST(TraceFile.Version) TO LAST(TraceFile.Version) DO
          IF f IN formats THEN
            Debug.Out("Writing TraceFile version " & TraceFile.VersionNames[f]);
            WITH temproot = wd & "/inprogress",
                 tempfile = WriteTrace(temproot, fnr, f),
                 sfx      = TraceFile.VersionSuffixes[f],
                 ufn      = ofn & "." & sfx DO
              TRY
                Debug.Out(F("Done writing TraceFile version %s : moving %s -> %s",
                            TraceFile.VersionNames[f],
                            tempfile,
                            ufn));
                FS.Rename(tempfile, ufn)
              EXCEPT
                OSError.E(x) =>
                Debug.Error(F("Couldnt rename %s -> %s : OSError.E : %s",
                              tempfile, ufn, AL.Format(x)))
              END
            END
          END
        END
      END;

    END
  END DoConversion;
  
VAR
  names := NEW(TextSeqSeq.T).init();
  convList : ConversionList.T := NIL;

  wd      : Pathname.T      := "ct.ctwork";
  dutName : TEXT            := NIL;
  pp                        := NEW(ParseParams.T).init(Stdio.stderr);
  timeScaleFactor,
  voltageScaleFactor        := 1.0d0;
  timeOffset, voltageOffset := 0.0d0;
  lNo                       := 1;
  doSources                 := FALSE;
  doFiles                   := FALSE;

  restrictNodes : TextSet.T := NIL;
  doTrace                   := TRUE; (* default output *)

  wait                      := FALSE;

  wrWorkers                 := 1;
  regExList : RegExList.T   := NIL;

  fsdbCmdPath       : Pathname.T := NIL;
  compressCmdPath   : Pathname.T := NIL;
  writeTraceCmdPath : Pathname.T := NIL;

  parseFmt            := ParseFmt.Tr0;

  threads  : CARDINAL := 1;
  wthreads : CARDINAL := 1;

  interpolate         := Fsdb.NoInterpolate;

  compressPrec        := 0.01d0;
  maxTime             := LAST(LONGREAL);

  formats             := SET OF TraceFile.Version {};

  maxNodes            := LAST(CARDINAL);

  translate, noX : BOOLEAN;
  compressQuick       : BOOLEAN;

  scopesep            := ".";
  copyRootName        := FALSE;

  ignoreTime          : Time.T := LAST(Time.T);
  (* dont rebuild files newer than this *)
  
CONST
  DefFormats =
    SET OF TraceFile.Version { TraceFile.Version.Reordered };
  
TYPE
  ParseFmt = { Tr0, Fsdb };

CONST
  ImmediateQuit = 117;

VAR
  M3Utils := Env.Get("M3UTILS");
  watchdog : Watchdog.T := NIL;
  runtimeLimit := LAST(LONGREAL);
  
BEGIN
  Debug.SetOptions(SET OF Debug.Options {Debug.Options.PrintThreadID, Debug.Options.PrintPID });
  
  TRY

    IF pp.keywordPresent("-execute") THEN
      (* this is the -execute version *)
      IF pp.keywordPresent("-runtimelimit") THEN
        runtimeLimit := pp.getNextLongReal()
      ELSE
        WITH rlvar = Env.Get("CTRUNTIMELIMIT") DO
          IF rlvar # NIL THEN
            TRY
              runtimeLimit := Scan.LongReal(rlvar)
            EXCEPT
              FloatMode.Trap, Lex.Error => RAISE ParseParams.Error
            END
            
          END
        END;
        IF runtimeLimit # LAST(LONGREAL) THEN
          watchdog := NEW(Watchdog.T).init(runtimeLimit)
        END
      END
    ELSE
      VAR
        timeLimit := 0.0d0;
      BEGIN
        IF runtimeLimit # LAST(LONGREAL) THEN
          timeLimit := 1.0d0 * runtimeLimit + 10.0d0
        END;
        RepeatMe.Repeat("-execute",
                        10,
                        1.0d0,
                        immediateQuit := ImmediateQuit,
                        addArgs := ARRAY [0..1] OF TEXT { "-starttime",
                                                          LR(Time.Now()) },
                        maxTime := timeLimit)
      END
    END;

    IF pp.keywordPresent("-starttime") THEN
      ignoreTime := pp.getNextLongReal()
    END;

    IF pp.keywordPresent("-force") THEN
      ignoreTime := LAST(Time.T)
      (* set ignoreTime to the end of eternity, so all files are rebuilt *)
    END;

    translate := pp.keywordPresent("-translate");
    noX       := pp.keywordPresent("-noX");

    copyRootName := pp.keywordPresent("-copyrootname") OR pp.keywordPresent("-C");

    IF pp.keywordPresent("-help") OR pp.keywordPresent("--help") THEN
      <*FATAL Wr.Failure*>
      BEGIN
        Wr.PutText(Stdio.stderr, CtDocBundle.Get().get("../doc/ct.txt"));
        Process.Exit(0)
      END
    END;
    
    IF    pp.keywordPresent("-scopesep") THEN
      scopesep := pp.getNext()
    END;
    IF    pp.keywordPresent("-rename") THEN
      dutName := pp.getNext()
    END;
    IF pp.keywordPresent("-scaletime") THEN
      timeScaleFactor := pp.getNextLongReal()
    END;

    IF pp.keywordPresent("-maxtime") THEN
      maxTime := pp.getNextLongReal()
    END;

    IF pp.keywordPresent("-nochop") THEN
      maxTime := FIRST(LONGREAL)
    END;

    IF pp.keywordPresent("-resample") OR pp.keywordPresent("-R") THEN
      interpolate := pp.getNextLongReal()
    END;

    IF pp.keywordPresent("-format") THEN
      REPEAT
        VAR fnm     := pp.getNext();
            success := FALSE;
        BEGIN
          FOR f := FIRST(TraceFile.Version) TO LAST(TraceFile.Version) DO
            IF TE(fnm, TraceFile.VersionNames[f]) THEN
              formats := formats + SET OF TraceFile.Version { f };
              success := TRUE;
              EXIT
            END
          END;
          IF NOT success THEN
            Debug.Error(F("Unknown output format \"%s\"", fnm))
          END
        END
      UNTIL NOT pp.keywordPresent("-format")
    ELSE
      formats := DefFormats
    END;

    IF pp.keywordPresent("-z") THEN
      formats :=  SET OF TraceFile.Version { TraceFile.Version.CompressedV1 };
    END;

    compressQuick := pp.keywordPresent("-quick");

    compressCmdPath := Env.Get("CT_COMPRESS_PATH");

    IF TraceFile.Version.CompressedV1 IN formats AND M3Utils # NIL THEN
      (* default compress setting *)
      compressCmdPath := M3Utils & "/spice/spicecompress/spicestream/AMD64_LINUX/spicestream"
    END;
    
    fsdbCmdPath := Env.Get("CT_NANOSIMRD_PATH");
    IF fsdbCmdPath # NIL THEN
      parseFmt := ParseFmt.Fsdb
    END;

    IF pp.keywordPresent("-F") THEN
      IF M3Utils = NIL THEN Debug.Error("Must set M3UTILS") END;
      fsdbCmdPath := M3Utils & "/spice/fsdb/src/nanosimrd";
      parseFmt := ParseFmt.Fsdb;
    END;

    IF pp.keywordPresent("-Fnetbatch") THEN
      IF M3Utils = NIL THEN Debug.Error("Must set M3UTILS") END;
      fsdbCmdPath := M3Utils & "/spice/fsdb/src/nanosimrd.nb";
      parseFmt := ParseFmt.Fsdb;
    END;
    
    IF pp.keywordPresent("-fsdb") THEN
      fsdbCmdPath := pp.getNext();
      parseFmt := ParseFmt.Fsdb;
    END;

    IF pp.keywordPresent("-compress") THEN
      compressCmdPath := pp.getNext();
    END;

    IF pp.keywordPresent("-prec") THEN
      compressPrec := pp.getNextLongReal()
    END;
    
    IF pp.keywordPresent("-wrtrace") THEN
      writeTraceCmdPath := pp.getNext()
    END;
    
    IF pp.keywordPresent("-scalevoltage") THEN
      voltageScaleFactor := pp.getNextLongReal()
    END;
    IF pp.keywordPresent("-offsettime") THEN
      timeOffset := pp.getNextLongReal()
    END;
    IF pp.keywordPresent("-offsetvoltage") THEN
      voltageOffset := pp.getNextLongReal()
    END;
    IF pp.keywordPresent("-dosources") THEN
      doSources := TRUE
    END;
    IF pp.keywordPresent("-dofiles") THEN
      doFiles := TRUE
    END;
    IF pp.keywordPresent("-notrace") THEN
      doTrace := FALSE
    END;
    IF pp.keywordPresent("-threads") THEN
      threads := pp.getNextInt()
    END;
    IF pp.keywordPresent("-wthreads") THEN
      wthreads := pp.getNextInt()
    END;
    IF pp.keywordPresent("-maxfiles") THEN
      maxFiles := pp.getNextInt()
    END;
    IF pp.keywordPresent("-maxnodes") THEN
      maxNodes := pp.getNextInt()
    END;

    WHILE pp.keywordPresent("-n") DO
      IF restrictNodes = NIL THEN
        restrictNodes := NEW(TextSetDef.T).init()
      END;
      EVAL restrictNodes.insert(pp.getNext())
    END;

    WHILE pp.keywordPresent("-r") DO
      WITH regExStr = pp.getNext() DO
        TRY
          regExList := RegExList.Cons(RegEx.Compile(regExStr), regExList)
        EXCEPT
          RegEx.Error(x) =>
          Debug.Error(F("Cannot compile regex /%s/ : RegEx.Error : %s",
                        regExStr,
                        x))
        END
      END
    END;
    
    wait := pp.keywordPresent("-w") OR pp.keywordPresent("-wait");

    IF pp.keywordPresent("-wd") OR pp.keywordPresent("-workdir") THEN
      wd := pp.getNext()
    END;

    IF pp.keywordPresent("-wrworkers") THEN
      wrWorkers := pp.getNextInt()
    END;

    pp.skipParsed();

    VAR
      ifn, ofn : Pathname.T;
    BEGIN
      WHILE pp.next < NUMBER(pp.arg^) DO

        ifn := pp.getNext();

        IF copyRootName THEN
          WITH pos = Text.FindCharR(ifn, '.') DO
            IF pos = -1 THEN
              Debug.Error("-copyrootname and no . in input name")
            ELSE
              ofn := Text.Sub(ifn, 0, pos)
            END
          END
        ELSE
          ofn := pp.getNext()
        END;

        convList := ConversionList.Cons(Conversion.T { ifn, ofn }, convList)
      END
    END;
    
    pp.finish();
  EXCEPT
    ParseParams.Error => Debug.Error("Can't parse command-line parameters\nUsage: " & Params.Get(0) & "\n" & CtDocBundle.Get().get("../doc/ct.txt"),
                                     exitCode := ImmediateQuit)
  END;

  IF TraceFile.Version.CompressedV1 IN formats AND compressCmdPath = NIL THEN
    Debug.Error("If format is CompressedV1, must also specify compress (command path)", exitCode := ImmediateQuit)
  END;

  IF maxFiles = LAST(CARDINAL) THEN
    maxFiles := MIN(10 * threads, DefMaxFiles)
  END;

  maxFiles := MAX(2, maxFiles);
  (* must have at least one TIME file and one data file *)
  
  IF wthreads # 1 THEN
    Debug.Warning("wthreads > 1 not recommended")
  END;

  IF wd = NIL THEN wd := "ct.work" END;
  
  TRY FS.CreateDirectory(wd) EXCEPT ELSE END;

  VAR
    p := convList;
  BEGIN
    WHILE p # NIL DO
      DoConversion(Conversion.T { p.head.ifn, p.head.ofn });
      p := p.tail
    END
  END

END ConvertTrace.

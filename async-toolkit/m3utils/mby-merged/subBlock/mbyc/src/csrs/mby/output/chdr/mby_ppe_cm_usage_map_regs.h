/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_cm_usage_map_regs.h                                
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_CM_USAGE_MAP_REGS_H_
#define _MBY_PPE_CM_USAGE_MAP_REGS_H_

#define CM_USAGE_MSGPORT     0x0
#define CM_USAGE_CM_TX_TC_PRIVATE_WM_MSGREGADDR 0x0
#define CM_USAGE_CM_TX_TC_HOG_WM_MSGREGADDR 0x1000
#define CM_USAGE_CM_RX_SMP_PRIVATE_WM_MSGREGADDR 0x2000
#define CM_USAGE_CM_RX_SMP_HOG_WM_MSGREGADDR 0x2200
#define CM_USAGE_CM_RX_SMP_PAUSE_WM_MSGREGADDR 0x2400
#define CM_USAGE_CM_SHARED_WM_MSGREGADDR 0x2600
#define CM_USAGE_CM_SOFTDROP_WM_MSGREGADDR 0x2640
#define CM_USAGE_CM_SHARED_SMP_PAUSE_WM_MSGREGADDR 0x2680
#define CM_USAGE_CM_GLOBAL_WM_MSGREGADDR 0x2690
#define CM_USAGE_CM_PAUSE_PHYS_PORT_CFG_MSGREGADDR 0x2700
#define CM_USAGE_CM_FORCE_PAUSE_CFG_MSGREGADDR 0x2800
#define CM_USAGE_CM_AQM_EWMA_CFG_MSGREGADDR 0x2C00
#define CM_USAGE_CM_AQM_DCTCP_CFG_MSGREGADDR 0x3000
#define CM_USAGE_CM_GLOBAL_CFG_MSGREGADDR 0x3400
#define CM_USAGE_CM_SHARED_SMP_PAUSE_CFG_MSGREGADDR 0x3410
#define CM_USAGE_CM_SWEEPER_TC_TO_SMP_MSGREGADDR 0x3420
#define CM_USAGE_CM_GLOBAL_USAGE_MSGREGADDR 0x3428
#define CM_USAGE_CM_GLOBAL_USAGE_MAX_MSGREGADDR 0x3430
#define CM_USAGE_CM_MCAST_EPOCH_USAGE_MSGREGADDR 0x3440
#define CM_USAGE_CM_SHARED_SMP_USAGE_MSGREGADDR 0x3450
#define CM_USAGE_CM_SMP_USAGE_MSGREGADDR 0x3460
#define CM_USAGE_CM_RX_SMP_USAGE_MSGREGADDR 0x3600
#define CM_USAGE_CM_RX_SMP_USAGE_MAX_MSGREGADDR 0x3800
#define CM_USAGE_CM_RX_SMP_USAGE_MAX_CTRL_MSGREGADDR 0x3840
#define CM_USAGE_CM_PAUSE_GEN_STATE_MSGREGADDR 0x3900
#define CM_USAGE_CM_TX_TC_USAGE_MSGREGADDR 0x4000
#define CM_USAGE_CM_TX_EWMA_MSGREGADDR 0x5000

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_FLAG
// CM_TX_TC_PRIVATE_WM desc:  Defines the watermark above which a transmit frame copy on this
// port can potentially be dropped.
typedef union {
    struct {
        uint64_t  WATERMARK            :  15;    //  Number of segments.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_RESET 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_WATERMARK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_WATERMARK_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_WATERMARK_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_WATERMARK_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_WATERMARK_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_FLAG
// CM_TX_TC_HOG_WM desc:  Defines the hog watermark per port and per traffic class above which
// frames are not queued on this port.
typedef union {
    struct {
        uint64_t  WATERMARK            :  15;    //  Number of segments.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_RESET 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_WATERMARK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_WATERMARK_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_WATERMARK_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_WATERMARK_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_WATERMARK_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_FLAG
// CM_RX_SMP_PRIVATE_WM desc:  Defines the private watermark per SMP per RX above which frames can
// get potentially dropped.
typedef union {
    struct {
        uint64_t  WATERMARK            :  15;    //  Number of segments.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_RESET 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_WATERMARK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_WATERMARK_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_WATERMARK_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_WATERMARK_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_WATERMARK_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_FLAG
// CM_RX_SMP_HOG_WM desc:  Defines the maximum number of segments allowed per receiver per SMP
// before a new frame is discarded.
typedef union {
    struct {
        uint64_t  WATERMARK            :  15;    //  Number of segments.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_RESET 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_WATERMARK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_WATERMARK_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_WATERMARK_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_WATERMARK_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_WATERMARK_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_FLAG
// CM_RX_SMP_PAUSE_WM desc:  Defines the watermark per SMP per RX above which pause frames are
// started or stopped.
typedef union {
    struct {
        uint64_t  PAUSE_ON             :  15;    //  Level at which a pause ON is
                                                 // sent.
        uint64_t  PAUSE_OFF            :  15;    //  Level at which a pause OFF
                                                 // is sent.
        uint64_t  RSVD_0               :  34;    // Nebulon auto filled RSVD [63:30]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_RESET 0x3fffffff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_ON_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_ON_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_ON_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_ON_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_ON_RESET_VALUE 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_OFF_LSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_OFF_MSB 0x001d
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_OFF_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_OFF_MASK 0x3fff8000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_PAUSE_OFF_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_FLAG
// CM_SHARED_WM desc:  Defines the shared watermark per switch priority above which packets
// are dropped if the shared pool usage, CM_SHARED_SMP_USAGE for the SMP
// used by this switch priority is above this limit.
typedef union {
    struct {
        uint64_t  WATERMARK            :  15;    //  Number of segments.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_RESET 0x0000021c

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_WATERMARK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_WATERMARK_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_WATERMARK_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_WATERMARK_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_WATERMARK_RESET_VALUE 0x0000021c


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_FLAG
// CM_SOFTDROP_WM desc:  Configures TX soft dropping based on RX usage. Whenever the total
// RX usage within an SMP exceeds SoftDropSegmentLimit (plus a six-bit
// random jitter term), TX soft dropping will be enabled such that the
// TX_TC queues consuming the most memory (and exceeding their TX_TC
// watermarks) will be penalized most. Frames will be dropped with 100%
// probability if the RX SMP usage exceeds HogSegmentLimit. Indexed by
// ISL_PRI. All watermarks are compared to
// CM_SHARED_USAGE[SMP].SegmentCount where SMP is the value mapped from
// the frame's ISL_PRI.
typedef union {
    struct {
        uint64_t  SOFT_DROP_SEGMENT_LIMIT :  15;    //  TX soft dropping is enabled
                                                 // whenever the total RX SMP
                                                 // segment usage exceeds this
                                                 // watermark plus a random
                                                 // six-bit jitter term.
        uint64_t  HOG_SEGMENT_LIMIT    :  15;    //  Frames belonging to this
                                                 // ISL_PRI will be dropped with
                                                 // 100% probability whenever the
                                                 // total RX SMP segment usage
                                                 // exceeds this watermark.
        uint64_t  RSVD_0               :  34;    // Nebulon auto filled RSVD [63:30]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_OFFSET 0x40
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_RESET 0x3fffffff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SOFT_DROP_SEGMENT_LIMIT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SOFT_DROP_SEGMENT_LIMIT_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SOFT_DROP_SEGMENT_LIMIT_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SOFT_DROP_SEGMENT_LIMIT_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_SOFT_DROP_SEGMENT_LIMIT_RESET_VALUE 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_HOG_SEGMENT_LIMIT_LSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_HOG_SEGMENT_LIMIT_MSB 0x001d
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_HOG_SEGMENT_LIMIT_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_HOG_SEGMENT_LIMIT_MASK 0x3fff8000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_HOG_SEGMENT_LIMIT_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_FLAG
// CM_SHARED_SMP_PAUSE_WM desc:  Defines the watermark per SMP compared against CM_SHARED_SMP_USAGE
// for sending pause frames.
typedef union {
    struct {
        uint64_t  PAUSE_ON             :  15;    //  Level at which a pause ON is
                                                 // sent.
        uint64_t  PAUSE_OFF            :  15;    //  Level at which a pause OFF
                                                 // is sent.
        uint64_t  RSVD_0               :  34;    // Nebulon auto filled RSVD [63:30]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_OFFSET 0x80
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_RESET 0x3fffffff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_ON_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_ON_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_ON_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_ON_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_ON_RESET_VALUE 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_OFF_LSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_OFF_MSB 0x001d
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_OFF_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_OFF_MASK 0x3fff8000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_PAUSE_OFF_RESET_VALUE 0x00007fff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_FLAG
// CM_GLOBAL_WM desc:  Defines the global watermark above which no new frames are accepted.
typedef union {
    struct {
        uint64_t  WATERMARK            :  15;    //  Number of segments.
        uint64_t  RSVD_0               :  49;    // Nebulon auto filled RSVD [63:15]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_OFFSET 0x90
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_RESET 0x00005e20

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_WATERMARK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_WATERMARK_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_WATERMARK_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_WATERMARK_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_WATERMARK_RESET_VALUE 0x00005e20


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_FLAG
// CM_PAUSE_PHYS_PORT_CFG desc:  Defines the physical port number for the corresponding logical port.
typedef union {
    struct {
        uint64_t  PHYS_PORT            :   5;    //  Physical port.
        uint64_t  RSVD_0               :  59;    // Nebulon auto filled RSVD [63:5]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_PHYS_PORT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_PHYS_PORT_MSB 0x0004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_PHYS_PORT_RANGE 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_PHYS_PORT_MASK 0x0000001f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_PHYS_PORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FLAG
// CM_FORCE_PAUSE_CFG desc:  Defines force pause condition for the corresponding SMP.
typedef union {
    struct {
        uint64_t  FORCE_ON             :   2;    //  Force pause on.
        uint64_t  FORCE_OFF            :   2;    //  Force pause off.
        uint64_t  RSVD_0               :  60;    // Nebulon auto filled RSVD [63:4]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_ON_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_ON_MSB 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_ON_RANGE 0x0002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_ON_MASK 0x00000003
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_ON_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_OFF_LSB 0x0002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_OFF_MSB 0x0003
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_OFF_RANGE 0x0002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_OFF_MASK 0x0000000c
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_FORCE_OFF_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_FLAG
// CM_AQM_EWMA_CFG desc:  Defines the configuration for each of the Exponentially Weighted
// Moving Average trackers. The first index is the logical Tx port, and
// the second index enables 2 different TCs to support EWMA.
typedef union {
    struct {
        uint64_t  MAX_TH               :  15;    //  Max threshold (in units of
                                                 // segments) for EWMA
                                                 // quantization.
        uint64_t  MIN_TH               :  15;    //  Min threshold (in units of
                                                 // segments) for EWMA
                                                 // quantization.
        uint64_t  TC                   :   3;    //  Traffic class that is
                                                 // tracked in the EWMA
                                                 // calculation.
        uint64_t  W                    :   4;    //  Sets the Weight for the EWMA
                                                 // calculation, represented as a
                                                 // negative power of 2 to
                                                 // simplify the implementation
                                                 // (i.e. Weight = 1/2^W). It is
                                                 // recommended to set this field
                                                 // to a value less than or equal
                                                 // to 8. Setting this field to a
                                                 // value greater than 8 will lose
                                                 // accuracy in calculating the
                                                 // moving average queue size.
        uint64_t  UPDATE_INTERVAL      :   8;    //  Sweeper updates the EWMA
                                                 // calculations every
                                                 // UpdateInterval *
                                                 // CM_GLOBAL_CFG.NumSweeperPort
                                                 // cycles. Setting
                                                 // UpdateInterval==0 disables the
                                                 // EWMA updates.
        uint64_t  RSVD_0               :  19;    // Nebulon auto filled RSVD [63:45]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_BITFIELD_COUNT 0x05
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_RESET 0x10004b0384

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MAX_TH_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MAX_TH_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MAX_TH_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MAX_TH_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MAX_TH_RESET_VALUE 0x00000384

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MIN_TH_LSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MIN_TH_MSB 0x001d
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MIN_TH_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MIN_TH_MASK 0x3fff8000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_MIN_TH_RESET_VALUE 0x00000096

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_TC_LSB 0x001e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_TC_MSB 0x0020
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_TC_RANGE 0x0003
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_TC_MASK 0x1c0000000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_TC_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_W_LSB 0x0021
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_W_MSB 0x0024
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_W_RANGE 0x0004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_W_MASK 0x1e00000000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_W_RESET_VALUE 0x00000008

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_UPDATE_INTERVAL_LSB 0x0025
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_UPDATE_INTERVAL_MSB 0x002c
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_UPDATE_INTERVAL_RANGE 0x0008
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_UPDATE_INTERVAL_MASK 0x1fe000000000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_UPDATE_INTERVAL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_FLAG
// CM_AQM_DCTCP_CFG desc:  Defines the configuration for each of the DCTCP threshold
// comparisons. The first index is the logical Tx port, and the second
// index enables 2 different TCs to support DCTCP.
typedef union {
    struct {
        uint64_t  THRESHOLD            :  15;    //  Defines the marking
                                                 // threshold (in units of
                                                 // segments) above which all
                                                 // packets will be marked.
        uint64_t  TC                   :   3;    //  Traffic class that is used
                                                 // in the DCTCP calculation.
        uint64_t  RSVD_0               :  46;    // Nebulon auto filled RSVD [63:18]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_RESET 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_THRESHOLD_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_THRESHOLD_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_THRESHOLD_RANGE 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_THRESHOLD_MASK 0x00007fff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_THRESHOLD_RESET_VALUE 0x00007fff

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_TC_LSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_TC_MSB 0x0011
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_TC_RANGE 0x0003
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_TC_MASK 0x00038000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_TC_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_FLAG
// CM_GLOBAL_CFG desc:  Global Congestion Management Configuration
typedef union {
    struct {
        uint64_t  NUM_SWEEPER_PORTS    :   5;    //  Number of ports to sweep.
                                                 // Must be set to the number of
                                                 // ports (or a minimum of 4) for
                                                 // normal CM operation.
        uint64_t  SWEEPER_EN           :   1;    //  Controls if the sweeper is
                                                 // enabled or not.
        uint64_t  RSVD_0               :  58;    // Nebulon auto filled RSVD [63:6]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_NUM_SWEEPER_PORTS_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_NUM_SWEEPER_PORTS_MSB 0x0004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_NUM_SWEEPER_PORTS_RANGE 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_NUM_SWEEPER_PORTS_MASK 0x0000001f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_NUM_SWEEPER_PORTS_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SWEEPER_EN_LSB 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SWEEPER_EN_MSB 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SWEEPER_EN_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SWEEPER_EN_MASK 0x00000020
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_SWEEPER_EN_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_FLAG
// CM_SHARED_SMP_PAUSE_CFG desc:  Defines whether RX shared pool pause flow control is enabled per
// port.
typedef union {
    struct {
        uint64_t  ENABLE_MASK          :  24;    //  Port mask that enables RX
                                                 // shared pool per port. Set to 1
                                                 // to enable.
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_OFFSET 0x10
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_ENABLE_MASK_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_ENABLE_MASK_MSB 0x0017
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_ENABLE_MASK_RANGE 0x0018
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_ENABLE_MASK_MASK 0x00ffffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_ENABLE_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_FLAG
// CM_SWEEPER_TC_TO_SMP desc:  Defines the SMP membership per traffic class. The choices are: 0:
// SMP 0 1: SMP 1
typedef union {
    struct {
        uint64_t  SMP_0                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_1                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_2                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_3                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_4                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_5                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_6                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  SMP_7                :   1;    //  SMP Membership for traffic
                                                 // class N.
        uint64_t  RSVD_0               :  56;    // Nebulon auto filled RSVD [63:8]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_OFFSET 0x20
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_BITFIELD_COUNT 0x08
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_0_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_0_MSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_0_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_0_MASK 0x00000001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_0_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_1_LSB 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_1_MSB 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_1_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_1_MASK 0x00000002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_1_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_2_LSB 0x0002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_2_MSB 0x0002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_2_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_2_MASK 0x00000004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_2_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_3_LSB 0x0003
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_3_MSB 0x0003
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_3_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_3_MASK 0x00000008
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_3_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_4_LSB 0x0004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_4_MSB 0x0004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_4_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_4_MASK 0x00000010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_4_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_5_LSB 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_5_MSB 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_5_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_5_MASK 0x00000020
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_5_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_6_LSB 0x0006
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_6_MSB 0x0006
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_6_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_6_MASK 0x00000040
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_6_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_7_LSB 0x0007
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_7_MSB 0x0007
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_7_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_7_MASK 0x00000080
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_SMP_7_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_FLAG
// CM_GLOBAL_USAGE desc:  Stores the total number of segments used currently in the switch.
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_OFFSET 0x28
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_FLAG
// CM_GLOBAL_USAGE_MAX desc:  Stores the maximum total number of segments observed to be used in
// the switch.
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_OFFSET 0x30
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_FLAG
// CM_MCAST_EPOCH_USAGE desc:  Tracks the total number of segments used currently in the switch
// per value of MCAST_EPOCH. Used to safely garbage-collect old entries
// from MCAST_VLAN_TABLE, after all frames using them have left the
// switch.
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_OFFSET 0x40
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_FLAG
// CM_SHARED_SMP_USAGE desc:  Contains the current number of segments stored in each SMP excluding
// those used in the RX private queues. A segment is only counted in
// this shared pool if all private watermarks have been exceeded.
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_OFFSET 0x50
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_FLAG
// CM_SMP_USAGE desc:  Contains the current number of segments stored in each SMP.
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_OFFSET 0x60
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_FLAG
// CM_RX_SMP_USAGE desc:  Stores the number of segments per port per SMPs
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_FLAG
// CM_RX_SMP_USAGE_MAX desc:  Stores the maximum number of segments observed per port per SMPs
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_FLAG
// CM_RX_SMP_USAGE_MAX_CTRL desc:  Determines which 4 logical ports are used for CM_RX_SMP_USAGE_MAX
// registers
typedef union {
    struct {
        uint64_t  PORT0                :   5;    //  Port used for
                                                 // CM_RX_SMP_USAGE_MAX[0].
        uint64_t  PORT1                :   5;    //  Port used for
                                                 // CM_RX_SMP_USAGE_MAX[1].
        uint64_t  PORT2                :   5;    //  Port used for
                                                 // CM_RX_SMP_USAGE_MAX[2].
        uint64_t  PORT3                :   5;    //  Port used for
                                                 // CM_RX_SMP_USAGE_MAX[3].
        uint64_t  RSVD_0               :  44;    // Nebulon auto filled RSVD [63:20]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_OFFSET 0x40
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_BITFIELD_COUNT 0x04
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT0_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT0_MSB 0x0004
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT0_RANGE 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT0_MASK 0x0000001f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT0_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT1_LSB 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT1_MSB 0x0009
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT1_RANGE 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT1_MASK 0x000003e0
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT1_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT2_LSB 0x000a
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT2_MSB 0x000e
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT2_RANGE 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT2_MASK 0x00007c00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT2_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT3_LSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT3_MSB 0x0013
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT3_RANGE 0x0005
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT3_MASK 0x000f8000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_PORT3_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_FLAG
// CM_PAUSE_GEN_STATE desc:  Specifies the pause state of each port per smp. For each port in
// each smp, 1 means it is paused and 0 means it is not paused
typedef union {
    struct {
        uint64_t  SMP0                 :   1;    //  SMP0 is paused.
        uint64_t  SMP1                 :   1;    //  SMP1 is paused.
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_BITFIELD_COUNT 0x02
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP0_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP0_MSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP0_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP0_MASK 0x00000001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP0_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP1_LSB 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP1_MSB 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP1_RANGE 0x0001
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP1_MASK 0x00000002
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_SMP1_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_FLAG
// CM_TX_TC_USAGE desc:  Stores the number of segments per TX port per traffic class.
typedef union {
    struct {
        uint64_t  COUNT                :  16;    //  Number of segments.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_COUNT_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_COUNT_MSB 0x000f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_COUNT_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_COUNT_MASK 0x0000ffff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_FLAG
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_FLAG
// CM_TX_EWMA desc:  Stores the current Exponential Weighted Moving Average values per
// tx port.
typedef union {
    struct {
        uint64_t  EWMA_FRAC            :   8;    //  Fractional digits of EWMA
                                                 // value (ewma_frac/256).
        uint64_t  EWMA_WHOLE           :  16;    //  Whole digits of EWMA value.
        uint64_t  INTERVAL             :   8;    //  Number of times the sweeper
                                                 // has serviced this EWMA since
                                                 // the last update. The EWMA
                                                 // values are updated when
                                                 // CM_AQM_EWMA_CFG.UpdateInterval
                                                 // intervals have passed, at
                                                 // which point Interval is reset
                                                 // to 0.
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_t;
#endif
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_OFFSET 0x00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_SCOPE 0x01
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_SIZE 64
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_BITFIELD_COUNT 0x03
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_RESET 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_FRAC_LSB 0x0000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_FRAC_MSB 0x0007
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_FRAC_RANGE 0x0008
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_FRAC_MASK 0x000000ff
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_FRAC_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_WHOLE_LSB 0x0008
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_WHOLE_MSB 0x0017
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_WHOLE_RANGE 0x0010
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_WHOLE_MASK 0x00ffff00
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_EWMA_WHOLE_RESET_VALUE 0x00000000

#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_INTERVAL_LSB 0x0018
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_INTERVAL_MSB 0x001f
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_INTERVAL_RANGE 0x0008
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_INTERVAL_MASK 0xff000000
#define MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_INTERVAL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_PRIVATE_WM_t CM_TX_TC_PRIVATE_WM[8]; // offset 4'h0, width 64
    } CM_TX_TC_PRIVATE_WM[64];                   // offset 4'h0, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_HOG_WM_t CM_TX_TC_HOG_WM[8]; // offset 4'h0, width 64
    } CM_TX_TC_HOG_WM[64];                       // offset 16'h1000, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PRIVATE_WM_t CM_RX_SMP_PRIVATE_WM[2]; // offset 4'h0, width 64
    } CM_RX_SMP_PRIVATE_WM[32];                  // offset 16'h2000, size: 16
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_HOG_WM_t CM_RX_SMP_HOG_WM[2]; // offset 4'h0, width 64
    } CM_RX_SMP_HOG_WM[32];                      // offset 16'h2200, size: 16
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_PAUSE_WM_t CM_RX_SMP_PAUSE_WM[2]; // offset 4'h0, width 64
    } CM_RX_SMP_PAUSE_WM[32];                    // offset 16'h2400, size: 16
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_WM_t CM_SHARED_WM[8];  // offset 16'h2600, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SOFTDROP_WM_t CM_SOFTDROP_WM[8]; // offset 16'h2640, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_WM_t CM_SHARED_SMP_PAUSE_WM[2]; // offset 16'h2680, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_WM_t CM_GLOBAL_WM;     // offset 16'h2690, width 64
    uint8_t                    rsvd0[104];
    MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_PHYS_PORT_CFG_t CM_PAUSE_PHYS_PORT_CFG[32]; // offset 16'h2700, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_FORCE_PAUSE_CFG_t CM_FORCE_PAUSE_CFG; // offset 16'h2800, width 64
    uint8_t                    rsvd1[1016];
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_EWMA_CFG_t CM_AQM_EWMA_CFG[2]; // offset 4'h0, width 64
    } CM_AQM_EWMA_CFG[64];                       // offset 16'h2C00, size: 16
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_AQM_DCTCP_CFG_t CM_AQM_DCTCP_CFG[2]; // offset 4'h0, width 64
    } CM_AQM_DCTCP_CFG[64];                      // offset 16'h3000, size: 16
    MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_CFG_t CM_GLOBAL_CFG;    // offset 16'h3400, width 64
    uint8_t                    rsvd2[8];
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_PAUSE_CFG_t CM_SHARED_SMP_PAUSE_CFG[2]; // offset 16'h3410, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SWEEPER_TC_TO_SMP_t CM_SWEEPER_TC_TO_SMP; // offset 16'h3420, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_t CM_GLOBAL_USAGE;  // offset 16'h3428, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_GLOBAL_USAGE_MAX_t CM_GLOBAL_USAGE_MAX; // offset 16'h3430, width 64
    uint8_t                    rsvd3[8];
    MBY_PPE_CM_USAGE_MAP_MSG_CM_MCAST_EPOCH_USAGE_t CM_MCAST_EPOCH_USAGE[2]; // offset 16'h3440, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SHARED_SMP_USAGE_t CM_SHARED_SMP_USAGE[2]; // offset 16'h3450, width 64
    MBY_PPE_CM_USAGE_MAP_MSG_CM_SMP_USAGE_t CM_SMP_USAGE[2];  // offset 16'h3460, width 64
    uint8_t                    rsvd4[400];
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_t CM_RX_SMP_USAGE[2]; // offset 4'h0, width 64
    } CM_RX_SMP_USAGE[32];                       // offset 16'h3600, size: 16
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_t CM_RX_SMP_USAGE_MAX[2]; // offset 4'h0, width 64
    } CM_RX_SMP_USAGE_MAX[4];                    // offset 16'h3800, size: 16
    MBY_PPE_CM_USAGE_MAP_MSG_CM_RX_SMP_USAGE_MAX_CTRL_t CM_RX_SMP_USAGE_MAX_CTRL; // offset 16'h3840, width 64
    uint8_t                    rsvd5[184];
    MBY_PPE_CM_USAGE_MAP_MSG_CM_PAUSE_GEN_STATE_t CM_PAUSE_GEN_STATE[32]; // offset 16'h3900, width 64
    uint8_t                    rsvd6[1536];
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_TC_USAGE_t CM_TX_TC_USAGE[8]; // offset 4'h0, width 64
    } CM_TX_TC_USAGE[64];                        // offset 16'h4000, size: 64
    // starting the regfile section
    struct {
        MBY_PPE_CM_USAGE_MAP_MSG_CM_TX_EWMA_t CM_TX_EWMA[2];    // offset 4'h0, width 64
    } CM_TX_EWMA[64];                            // offset 16'h5000, size: 16
} mby_ppe_cm_usage_map_t;                        // size:  16'h5400


#endif // _MBY_PPE_CM_USAGE_MAP_REGS_H_


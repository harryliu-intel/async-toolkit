#!/usr/intel/bin/perl -w

use strict;
use Getopt::Long;

my $out_dir = ".";

my $modulename="module";
my $bitsname="BITS";
my $addr_depthname="MEM_HEIGHT";
my $addr_widthname="MEM_WIDTH";

sub usage {
print STDERR "Usage: gen_sram_scan_wrap.pl [--out-dir=(dir)] mem1.v mem2.v ...\n";
exit 1;
}

GetOptions ( "out-dir=s" => \$out_dir) or usage;

while (@ARGV) {
    print "Creating wrapper for $ARGV[0].\n";
    eval {
        my $param = parse_artisan_sram_verilog($ARGV[0]);
        write_wrapper($ARGV[0], $out_dir, $param);
    };
    if ($@) {
        foreach my $f ($@) {
            print STDERR $f;
        }
        print STDERR "Error processing $ARGV[0]. Skipping.\n";
    }
    shift;
}


sub parse_artisan_sram_verilog {
    my $file = shift;

    my $param = {};

    open (SRAM_IN, $file) || die "Couldn't read $file.\n";
    while (<SRAM_IN>) {
        if (/^module\s+([^\s]+)/) {
            $param->{$modulename} = $1;
        }
        if (/^\s*parameter\s+([^\s=]+)\s*=\s*([^;]+);/) {
            $param->{$1} = $2;
        }
    }
    close SRAM_IN;
    if (!exists $param->{$modulename}) {
        die "No module declaration in $file.\n";
    }
    if (!exists $param->{$bitsname}) {
        die "No BITS parameter in $file.\n";
    }
    # not really used
    if (!exists $param->{$addr_depthname}) {
        # 130nm vs 65nm compilers
        if (exists $param->{word_depth}) {
            $param->{$addr_depthname} = $param->{word_depth};
        }
        else {
            die "No word_depth parameter in $file.\n";
        }
    }
    if (!exists $param->{$addr_widthname}) {
        # 130nm vs 65nm compilers
        if (exists $param->{addr_width}) {
            $param->{$addr_widthname} = $param->{addr_width};
        }
        else {
            die "No addr_width parameter in $file.\n";
        }
    }
    return $param;
}

# TODO: Handler dual-ported case
sub write_wrapper {
    my $file     = shift;
    my $wrap_dir = shift;
    my $param    = shift;

    my $wrap_file = "";
    if ($file =~ /([^\/]+)\.v$/) {
        $wrap_file = $wrap_dir . "/SR_" . $1 . ".v";
    }
    else {
        die "Badly formatted filename $file.\n";
    }

    my $data_range = sprintf("[%d:0]", $param->{$bitsname}-1);
    my $addr_range = sprintf("[%d:0]", $param->{$addr_widthname}-1);
    my $now        = localtime();

    open (SRAM_OUT, ">$wrap_file") || die "Couldn't write to $wrap_file.\n";
    print SRAM_OUT <<eof;
/* 
 * Wrapper for Artisan memory core $param->{$modulename}.
 * Adds scan shadow flops on all inputs & outputs.
 * Adds repair address implemented with sideband flip-flops.
 * Autogenerated by gen_sram_scan_wrap.pl on $now 
 */
module SR_$param->{$modulename} (
eof
    if ($param->{$modulename} =~ /_SP$/ or $param->{$modulename} =~ /_SP_R90$/) {
        print SRAM_OUT <<eof;
    // standard memory interface
    output $data_range Q,
    input         CLK,
    input         CEN,
    input         WEN,
    input  $addr_range A,
    input  $data_range D,
    // added scan & repair interface
    output        SCAN_OUT,
    input         SCAN_IN,
    input         SCAN_EN,
    input         SCAN_MODE,
    input  $addr_range REPAIR_CFG
  );

  wire sram_cen;
  wire sram_wen;
  wire $addr_range sram_a;
  wire $data_range sram_d;
  wire $data_range sram_q;

  SP_SRAM_WRAP #($param->{$addr_widthname}, $param->{$bitsname}) wrap(
    .CLK(CLK),
    .SCAN_EN(SCAN_EN), .SCAN_MODE(SCAN_MODE),
    .SCAN_IN(SCAN_IN), .SCAN_OUT(SCAN_OUT), 
    .INPUT_CEN(CEN), .INPUT_WEN(WEN),
    .INPUT_A(A), .INPUT_D(D),
    .REPAIR_CFG(REPAIR_CFG),
    .TO_SRAM_CEN(sram_cen), .TO_SRAM_WEN(sram_wen),
    .TO_SRAM_A(sram_a), .TO_SRAM_D(sram_d),
    .FROM_SRAM_Q(sram_q),
    .OUTPUT_Q(Q)
  );

  $param->{$modulename} core(
    .Q(sram_q), .CLK(CLK), .CEN(sram_cen), .WEN(sram_wen),
    .A(sram_a), .D(sram_d)
  );
endmodule
eof
    }
    elsif ($param->{$modulename} =~ /_DP$/ or $param->{$modulename} =~ /_DP_R90$/) {
        print SRAM_OUT <<eof;
    // standard dual-ported memory interface
    // IMPORTANT: CLKA and CLKB must be the same clock
    output $data_range QA,
    input         CLKA,
    input         CENA,
    input         WENA,
    input  $addr_range AA,
    input  $data_range DA,
    output $data_range QB,
    input         CLKB,
    input         CENB,
    input         WENB,
    input  $addr_range AB,
    input  $data_range DB,
    // added scan & repair interface
    output        SCAN_OUT,
    input         SCAN_IN,
    input         SCAN_EN,
    input         SCAN_MODE,
    input  $addr_range REPAIR_CFG
  );

  wire sram_cena, sram_cenb;
  wire sram_wena, sram_wenb;
  wire $addr_range sram_aa, sram_ab;
  wire $data_range sram_da, sram_db;
  wire $data_range sram_qa, sram_qb;

  DP_SRAM_WRAP #($param->{$addr_widthname}, $param->{$bitsname}) wrap(
    .CLK(CLKA),
    .SCAN_EN(SCAN_EN), .SCAN_MODE(SCAN_MODE),
    .SCAN_IN(SCAN_IN), .SCAN_OUT(SCAN_OUT), 
    .INPUT_CENA(CENA), .INPUT_WENA(WENA),
    .INPUT_AA(AA), .INPUT_DA(DA),
    .INPUT_CENB(CENB), .INPUT_WENB(WENB),
    .INPUT_AB(AB), .INPUT_DB(DB),
    .REPAIR_CFG(REPAIR_CFG),
    .TO_SRAM_CENA(sram_cena), .TO_SRAM_WENA(sram_wena),
    .TO_SRAM_AA(sram_aa), .TO_SRAM_DA(sram_da),
    .TO_SRAM_CENB(sram_cenb), .TO_SRAM_WENB(sram_wenb),
    .TO_SRAM_AB(sram_ab), .TO_SRAM_DB(sram_db),
    .FROM_SRAM_QA(sram_qa),
    .FROM_SRAM_QB(sram_qb),
    .OUTPUT_QA(QA),
    .OUTPUT_QB(QB)
  );

  $param->{$modulename} core(
    .QA(sram_qa), .CLKA(CLKA), .CENA(sram_cena), .WENA(sram_wena),
    .AA(sram_aa), .DA(sram_da),
    .QB(sram_qb), .CLKB(CLKB), .CENB(sram_cenb), .WENB(sram_wenb),
    .AB(sram_ab), .DB(sram_db)
  );
endmodule
eof
    }
    else {
        die "Unknown memory type $param->{$modulename}.\n";
    }
    close SRAM_OUT;
}

#!/usr/intel/bin/perl -w

use FileHandle;
use IPC::Open2;

#############################################################################
# Generate LIB file for TCAM nodes
#############################################################################

# configuration
$process = "tt";
$vdd = 1.08;
$temp = 125;
$lines = 512;
$bits = 36;
$slew_frac = 0.333;
$mindelay = 0;
$debug = 1;
@prsTau  = (40,160); # ps
@lumpCap = (10,40); # fF
while (@ARGV>0 && $ARGV[0] =~ /--([^=]*)=*(.*)/ ) {
    $key = $1;
    $value = $2;
    shift @ARGV;
    if (!defined($value)) { $value=""; }
    if    ($key eq "prsTau")    { @prsTau = split(",",$value); }
    elsif ($key eq "lumpCap")   { @lumpCap = split(",",$value); }
    elsif ($key eq "lines")     { $lines = $value; }
    elsif ($key eq "bits")      { $bits = $value; }
    elsif ($key eq "process")   { $process = $value; }
    elsif ($key eq "vdd")       { $vdd = $value; }
    elsif ($key eq "temp")      { $temp = $value; }
    elsif ($key eq "min")       { $mindelay = $value; }
    elsif ($key eq "slew-fraction")  { $slew_frac = $value; }
    elsif ($key eq "debug")     { $debug = $value; }
    elsif ($key eq "help")      { banner(); }
}

# usage banner
sub banner {
    die "USAGE: tcam_lib\n" .
        "  [--process=$process]\n" .
        "  [--vdd=$vdd]\n" .
        "  [--temp=$temp]\n" .
        "  [--min=$mindelay]\n" .
        "  [--bits=$bits]\n" .
        "  [--lines=$lines]\n" .
        "  [--prsTau=@prsTau]\n" .
        "  [--lumpCap=@lumpCap]\n" .
        "  [--slew-fraction=$slew_frac]\n" . 
        "  [--debug=$debug]\n";
}

# derived values
$slew_low  = $slew_frac * 100;
$slew_high = (1-$slew_frac) * 100;
$last_line = $lines-1;
$last_bit = $bits-1;
$cell = "lib.cam.sync_tcam.TCAM${lines}_${bits}.600";
$" = ", ";

# convert prsTau's to slew times in ns
@slews = ();
foreach my $tau (@prsTau) {
    push @slews, int (0.5 + $tau * (log(1-$slew_frac) - log($slew_frac)))/1000;
}
@loads = ();
foreach my $cap (@lumpCap) {
    push @loads, $cap*1e-3; # fF to pF
}

# input capacitances
my %cap = ();
open IN, "<TCAM${lines}_${bits}.cap" or die "Can't read TCAM${lines}_${bits}";
while (my $line = <IN>) {
    chomp($line);
    my @args = split(" ",$line);
    if (@args==2) {
        my $c = $args[1]/1e-12; # convert to pF
        if    ($args[0] =~ /^ADDR/ ) {
            $cap{"ADDR"} = $mindelay ? my_min($cap{"ADDR"},$c) : 
                                       my_max($cap{"ADDR"},$c);
        } elsif ($args[0] =~ /^CMD/ )  {
            $cap{"CMD"} = $mindelay ? my_min($cap{"CMD"},$c) :
                                      my_max($cap{"CMD"},$c);
        } elsif ($args[0] =~ /^DATA/ ) {
            $cap{"DATA"} = $mindelay ? my_min($cap{"DATA"},$c) :
                                       my_max($cap{"DATA"},$c);
        } elsif ($args[0] =~ /^MASK/ ) {
            $cap{"MASK"} = $mindelay ? my_min($cap{"MASK"},$c) :
                                       my_max($cap{"MASK"},$c)
        }
        elsif ($args[0] eq "CLK")    { $cap{"CLK"}    = $c; }
        elsif ($args[0] eq "_reset") { $cap{"_reset"} = $c; }
        elsif ($args[0] eq "VALID")  { $cap{"VALID"}  = $c; }
        elsif ($args[0] eq "CASE")   { $cap{"CASE"}   = $c; }
    }
}
close IN;
if ($debug) {
    for my $key (sort keys %cap) {
        print STDERR "cap{$key} = $cap{$key}\n";
    }
}

# load raw measurements into hash tables
my %delay_min = ();
my %delay_max = ();
my %fall_delay_min = ();
my %fall_delay_max = ();
my %rise_delay_min = ();
my %rise_delay_max = ();
my %fall_slew_min = ();
my %fall_slew_max = ();
my %rise_slew_min = ();
my %rise_slew_max = ();
foreach my $tau (@prsTau) {
    foreach my $cap (@lumpCap) {
        my $file = "tcam_${tau}_${cap}/lib/cam/sync_tcam/TCAM${lines}_${bits}/600/layout/extracted/aspice/empty/${process}/${vdd}V/${temp}C/1ns/0.95_1.05/tcam.measure";
        open IN, "<$file" or die "ERROR: can't read $file\n";
        while (my $line = <IN>) {
            chomp($line);
            my @args = split(" ",$line);
            my $key = "${args[1]}:${tau}:${cap}";
            if ($args[0] eq "delay") {
                $delay_min{$key} = my_min($delay_min{$key},$args[2]);
                $delay_max{$key} = my_max($delay_max{$key},$args[3]);
            } elsif ($args[0] eq "rise_delay") {
                $rise_delay_min{$key} = my_min($rise_delay_min{$key},$args[2]);
                $rise_delay_max{$key} = my_max($rise_delay_max{$key},$args[3]);
            } elsif ($args[0] eq "fall_delay") {
                $fall_delay_min{$key} = my_min($fall_delay_min{$key},$args[2]);
                $fall_delay_max{$key} = my_max($fall_delay_max{$key},$args[3]);
            } elsif ($args[0] eq "rise_slew") {
                $rise_slew_min{$key} = my_min($rise_slew_min{$key},$args[2]);
                $rise_slew_max{$key} = my_max($rise_slew_max{$key},$args[3]);
            } elsif ($args[0] eq "fall_slew") {
                $fall_slew_min{$key} = my_min($fall_slew_min{$key},$args[2]);
                $fall_slew_max{$key} = my_max($fall_slew_max{$key},$args[3]);
            }
            }
        close IN;
    }
}

# debugging
if ($debug) {
    foreach my $key (sort keys %delay_min) {
        print STDERR "delay_min{$key} = $delay_min{$key}\n";
    }
    foreach my $key (sort keys %delay_max) {
        print STDERR "delay_max{$key} = $delay_max{$key}\n";
    }
    foreach my $key (sort keys %rise_delay_min) {
        print STDERR "rise_delay_min{$key} = $rise_delay_min{$key}\n";
    }
    foreach my $key (sort keys %rise_delay_max) {
        print STDERR "rise_delay_max{$key} = $rise_delay_max{$key}\n";
    }
    foreach my $key (sort keys %fall_delay_min) {
        print STDERR "fall_delay_min{$key} = $fall_delay_min{$key}\n";
    }
    foreach my $key (sort keys %fall_delay_max) {
        print STDERR "fall_delay_max{$key} = $fall_delay_max{$key}\n";
    }
    foreach my $key (sort keys %rise_slew_min) {
        print STDERR "rise_slew_min{$key} = $rise_slew_min{$key}\n";
    }
    foreach my $key (sort keys %rise_slew_max) {
        print STDERR "rise_slew_max{$key} = $rise_slew_max{$key}\n";
    }
    foreach my $key (sort keys %fall_slew_min) {
        print STDERR "fall_slew_min{$key} = $fall_slew_min{$key}\n";
    }
    foreach my $key (sort keys %fall_slew_max) {
        print STDERR "fall_slew_max{$key} = $fall_slew_max{$key}\n";
    }
}

# library values
my %setup_rise = ();
my %setup_fall = ();
my %hold_rise = ();
my %hold_fall = ();
my %delay_rise = ();
my %delay_fall = ();
my %slew_rise = ();
my %slew_fall = ();

# setup/hold times don't depend on cap, so use last cap only
$cap = $lumpCap[@lumpCap-1];

# _reset pin (conservatively estimated timing)
my @setup = (0.5, 0.5, 0.5, 0.5);
my @hold  = (0.5, 0.5, 0.5, 0.5);
$setup_rise{"_reset"} = $setup_fall{"_reset"} = format_2x2(@setup);
$hold_rise{"_reset"}  = $hold_fall{"_reset"}  = format_2x2(@hold);

# VALID/CASE setup/hold
@setup = ();
@hold = ();
foreach my $tau2 (@prsTau) { # clock
    foreach my $tau1 (@prsTau) { # data
        push @setup, $delay_max{"valid.k:${tau1}:${cap}"} -
            $delay_min{"valid.CLK:${tau2}:${cap}"};
        push @hold, $delay_max{"valid._K:${tau2}:${cap}"} -
            $delay_min{"valid.k:${tau1}:${cap}"};
    }
}
foreach $name ("VALID", "CASE") {
    $setup_rise{$name} = $setup_fall{$name} = format_2x2(@setup);
    $hold_rise{$name}  = $hold_fall{$name}  = format_2x2(@hold);
}

# DATA/MASK setup/hold
@setup = ();
@hold = ();
foreach my $tau2 (@prsTau) { # clock
    foreach my $tau1 (@prsTau) { # data
        push @setup, $delay_max{"data.k:${tau1}:${cap}"} -
            $delay_min{"data.CLK:${tau2}:${cap}"};
        push @hold, $delay_max{"data._K:${tau2}:${cap}"} -
            $delay_min{"data.k:${tau1}:${cap}"};
    }
}
foreach $name ("DATA", "MASK") {
    $setup_rise{$name} = $setup_fall{$name} = format_2x2(@setup);
    $hold_rise{$name}  = $hold_fall{$name}  = format_2x2(@hold);
}

# ADDR setup/hold
@setup = ();
@hold = ();
foreach my $tau2 (@prsTau) { # clock
    foreach my $tau1 (@prsTau) { # data
        push @setup, $delay_max{"addr.a:${tau1}:${cap}"} -
            $delay_min{"addr.CLK:${tau2}:${cap}"};
        push @hold, $delay_max{"addr._V:${tau2}:${cap}"} -
            $delay_min{"addr.a:${tau1}:${cap}"};
    }
}
$setup_rise{"ADDR"} = $setup_fall{"ADDR"} = format_2x2(@setup);
$hold_rise{"ADDR"}  = $hold_fall{"ADDR"}  = format_2x2(@hold);

# CMD setup/hold
@setup = ();
@hold = ();
foreach my $tau2 (@prsTau) { # clock
    foreach my $tau1 (@prsTau) { # data
        push @setup, $delay_max{"ctrl.l:${tau1}:${cap}"} -
            0; # unbuffered clock
        push @hold,  $delay_max{"ctrl._LK:${tau2}:${cap}"} -
            $delay_min{"ctrl.l:${tau1}:${cap}"};
    }
}
$setup_rise{"CMD"} = $setup_fall{"CMD"} = format_2x2(@setup);
$hold_rise{"CMD"}  = $hold_fall{"CMD"}  = format_2x2(@hold);

# HIT delay/slew
my @d_rise = ();
my @s_rise = ();
my @d_fall = ();
my @s_fall = ();
foreach my $cap (@lumpCap) {
    foreach my $tau (@prsTau) {
        if ($mindelay) {
            push @d_rise, $rise_delay_min{"HIT:${tau}:${cap}"};
            push @d_fall, $fall_delay_min{"HIT:${tau}:${cap}"};
            push @s_rise, $rise_slew_min{"HIT:${tau}:${cap}"};
            push @s_fall, $fall_slew_min{"HIT:${tau}:${cap}"};
        } else {
            push @d_rise, $rise_delay_max{"HIT:${tau}:${cap}"};
            push @d_fall, $fall_delay_max{"HIT:${tau}:${cap}"};
            push @s_rise, $rise_slew_max{"HIT:${tau}:${cap}"};
            push @s_fall, $fall_slew_max{"HIT:${tau}:${cap}"};
        }
    }
}
$delay_rise{"HIT"} = format_2x2(@d_rise);
$delay_fall{"HIT"} = format_2x2(@d_fall);
$slew_rise{"HIT"}  = format_2x2(@s_rise);
$slew_fall{"HIT"}  = format_2x2(@s_fall);

# READ delay/slew
@d_rise = ();
@s_rise = ();
@d_fall = ();
@s_fall = ();
foreach my $cap (@lumpCap) {
    foreach my $tau (@prsTau) {
        if ($mindelay) {
            push @d_rise, $rise_delay_min{"READ:${tau}:${cap}"};
            push @d_fall, $fall_delay_min{"READ:${tau}:${cap}"};
            push @s_rise, $rise_slew_min{"READ:${tau}:${cap}"};
            push @s_fall, $fall_slew_min{"READ:${tau}:${cap}"};
        } else {
            push @d_rise, $rise_delay_max{"READ:${tau}:${cap}"};
            push @d_fall, $fall_delay_max{"READ:${tau}:${cap}"};
            push @s_rise, $rise_slew_max{"READ:${tau}:${cap}"};
            push @s_fall, $fall_slew_max{"READ:${tau}:${cap}"};
        }
    }
}
foreach my $name ("READ_DATA", "READ_MASK", "READ_VALID", "READ_CASE") {
    $delay_rise{$name} = format_2x2(@d_rise);
    $delay_fall{$name} = format_2x2(@d_fall);
    $slew_rise{$name}  = format_2x2(@s_rise);
    $slew_fall{$name}  = format_2x2(@s_fall);
}

# library header
my $date = `date`; chomp($date);
my $header = <<EOF;
/* \$Id\$
 * Copyright (c) 2006 Fulcrum Microsystems, Inc. All Rights Reserved.
 *
 * CONFIDENTIAL AND PROPRIETARY DATA OF Fulcrum Microsystems, Inc.
 *
 * This file contains valuable trade secrets and proprietary information
 * of Fulcrum Microsystems, Inc., and is protected by U.S. and
 * international laws and/or treaties.
 *
 * The copyright notice(s) in this file does not indicate actual or intended
 * publication of this file.
 *
 * created $date
 *
 * process ($process), voltage ($vdd), temp ($temp)
 *
 * corner: ${vdd}_${temp}_${process}
 */
library(TCAM${lines}_${bits}) {

  /* general attributes */

  delay_model : table_lookup;
  in_place_swap_mode : match_footprint;
  library_features(report_delay_calculation);

  /* documentation attributes */

  revision : 1.0;
  date : "$date";
  comment : "Copyright (c) 2006 Fulcrum Microsystems, Inc. All Rights Reserved."

  /* unit attributes */

  time_unit : "1ns";
  voltage_unit : "1V";
  current_unit : "1mA";
  capacitive_load_unit (1,pF);
  pulling_resistance_unit : "1kohm";
  leakage_power_unit : "1pW";

  /* operation conditions */

  nom_process     : 1;
  nom_temperature : $temp;
  nom_voltage     : $vdd;
  operating_conditions(typical) {
    process     : 1;
    temperature : $temp;
    voltage     : $vdd;
    tree_type   : balanced_tree
  }
  default_operating_conditions : typical;

  /* threshold definitions */

  slew_lower_threshold_pct_fall : $slew_low;
  slew_upper_threshold_pct_fall : $slew_high;
  slew_lower_threshold_pct_rise : $slew_low;
  slew_upper_threshold_pct_rise : $slew_high;
  input_threshold_pct_fall      : 50.0;
  input_threshold_pct_rise      : 50.0;
  output_threshold_pct_fall     : 50.0;
  output_threshold_pct_rise     : 50.0;

  /* default attributes */

  default_leakage_power_density : 0.0;
  slew_derate_from_library      : 1.0;
  default_cell_leakage_power    : 0.0;
  default_fanout_load           : 1.0;
  default_output_pin_cap        : 0.0;
  default_inout_pin_cap         : 0.0;
  default_input_pin_cap         : 0.0;
  default_max_transition        : 1.0;

  /* default setup/hold/delay lookup tables */

  lu_table_template(delay_template_2x2) {
    variable_1 : input_net_transition;
    variable_2 : total_output_net_capacitance;
    index_1 ("1000, 1001");
    index_2 ("1000, 1001");
  }

  lu_table_template(setup_template_2x2) {
    variable_1 : constrained_pin_transition;
    variable_2 : related_pin_transition;
    index_1 ("1000, 1001");
    index_2 ("1000, 1001");
  }

  lu_table_template(hold_template_2x2) {
    variable_1 : constrained_pin_transition;
    variable_2 : related_pin_transition;
    index_1 ("1000, 1001");
    index_2 ("1000, 1001");
  }

  /* define TCAM busses */
  
  type(TCAM_DATA) {
    base_type : array;
    data_type : bit;
    bit_width : $bits;
    bit_from : $last_bit;
    bit_to : 0;
    downto : true;
  }

  type(TCAM_ADDR) {
    base_type : array;
    data_type : bit;
    bit_width : 9;
    bit_from : 8;
    bit_to : 0;
    downto : true;
  }

  type(TCAM_HIT) {
    base_type : array;
    data_type : bit;
    bit_width : $lines;
    bit_from : $last_line;
    bit_to : 0;
    downto : true;
  }

  type(TCAM_CMD) {
    base_type : array;
    data_type : bit;
    bit_width : 2;
    bit_from : 1;
    bit_to : 0;
    downto : true;
  }

  /* Begin TCAM cell */

  cell($cell) {
    dont_use	 : TRUE;
    dont_touch	 : TRUE;
    interface_timing : TRUE;
    
    pin(CLK) {
      direction   : input;
      capacitance : $cap{CLK};
      clock	  : true;
      min_pulse_width_low  : 0.5;
      min_pulse_width_high : 0.5;
      min_period           : 2;
      max_transition	   : 1.5;
    }

EOF

my $footer = <<EOF;
  }
}
EOF

# print the library
print "$header";
input_pin("_reset");
input_pin("VALID");
input_pin("CASE");
input_pin("DATA","TCAM_DATA");
input_pin("MASK","TCAM_DATA");
input_pin("ADDR","TCAM_ADDR");
input_pin("CMD","TCAM_CMD");
output_pin("READ_VALID","rising_edge");
output_pin("READ_CASE","rising_edge");
output_pin("READ_DATA","rising_edge","TCAM_DATA");
output_pin("READ_MASK","rising_edge","TCAM_DATA");
output_pin("HIT","falling_edge","TCAM_HIT");
print "$footer";

# describe an input pin
sub input_pin {
    my ($name,$bus) = @_;
    if (defined($bus)) {
        print "    bus($name) {\n" .
              "      bus_type : ${bus};\n";
    } else {
        print "    pin($name) {\n";
    }
    my $out = <<EOF;
      direction : input;
      capacitance : $cap{$name};
      timing() {
        related_pin : "CLK";
        timing_type : setup_rising;
        rise_constraint(setup_template_2x2) {
          index_1 ("@slews");
          index_2 ("@slews");
          values  ($setup_rise{$name});
        }
        fall_constraint(setup_template_2x2) {
          index_1 ("@slews");
          index_2 ("@slews");
          values  ($setup_fall{$name});
        }
      }
      timing() {
        related_pin : "CLK";
        timing_type : hold_rising;
        rise_constraint(hold_template_2x2) {
          index_1 ("@slews");
          index_2 ("@slews");
          values  ($hold_rise{$name});
        }
        fall_constraint(hold_template_2x2) {
          index_1 ("@slews");
          index_2 ("@slews");
          values  ($hold_fall{$name});
        }
      }
    }

EOF
  print "$out";
}

# describe an output pin
sub output_pin {
    my ($name,$edge,$bus) = @_;
    if (defined($bus)) {
        print "    bus($name) {\n" .
              "      bus_type : ${bus};\n";
    } else {
        print "    pin($name) {\n";
    }
    my $out = <<EOF;
      direction : output;
      capacitance : 0.0;
      timing() {
        related_pin : "CLK";
        timing_type : $edge;
        timing_sense : non_unate;
        cell_rise(delay_template_2x2) {
          index_1 ("@slews");
          index_2 ("@loads");
          values  ($delay_rise{$name});
        }
        cell_fall(delay_template_2x2) {
          index_1 ("@slews");
          index_2 ("@loads");
          values  ($delay_fall{$name});
        }
        rise_transition(delay_template_2x2) {
          index_1 ("@slews");
          index_2 ("@loads");
          values  ($slew_rise{$name});
        }
        fall_transition(delay_template_2x2) {
          index_1 ("@slews");
          index_2 ("@loads");
          values  ($slew_fall{$name});
        }
      }
    }

EOF
  print "$out";
}

sub format_2x2 {
    my @values = @_;
    for ($i=0; $i<4; $i++) {
        if (!defined($values[$i])) { $values[$i] = "UNDEFINED"; }
        else { $values[$i] = int(1000*$values[$i]+0.5)/1000; }
    }
    return "\"$values[0], $values[1]\", \"$values[2], $values[3]\"";
}

sub my_min {
    my ($a, $b) = @_;
    if (!defined($a) || $b<$a) { return $b; }
    return $a;
}

sub my_max {
    my ($a, $b) = @_;
    if (!defined($a) || $b>$a) { return $b; }
    return $a;
}

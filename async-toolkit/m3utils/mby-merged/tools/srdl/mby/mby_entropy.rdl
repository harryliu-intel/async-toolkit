// DO NOT EDIT. Generated by reg2rdl hlp_entropy.reg.

<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>



// ENTROPY_HASH_CFG0[0..1][0..63]

reg entropy_hash_cfg0_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how each of the 2 hash values (hash0/1) should be calculated.
  The value in this register has the same format as FFU_HASH_CFG0.

  * hash0 configuration is ENTROPY_HASH_CFG0[0][HASH_PROF[0]].
  * hash1 configuration is ENTROPY_HASH_CFG0[1][HASH_PROF[1]].
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Selects Classifier KEY8s to participate in hashing and matching. 
     key_mask8[i] selects key8[i].

           ";
    ValRandomize = true;
  } KEY_MASK8[63:0] = 64'h0;
};
regfile entropy_hash_cfg0_rf {
  entropy_hash_cfg0_r ENTROPY_HASH_CFG0[64] += 8;
};



// ENTROPY_HASH_CFG1[0..1][0..63]

reg entropy_hash_cfg1_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how each of the 4 hash values (hash0/1) should be calculated.
  The value in this register has the same format as FFU_HASH_CFG1.
  [list]
  [*] hash0 configuration is ENTROPY_HASH_CFG0[0][HASH_PROF[0]].
  [*] hash1 configuration is ENTROPY_HASH_CFG0[1][HASH_PROF[1]].
  [/list]
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Controls KeySubmask1.

           ";
    ValRandomize = true;
  } KEY_SUBMODE1[51:50] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
    [list]
    [*] if key_submode0=0, apply key_submask0 bitmask to key16 24..25 (MPLS 0)
    [*] if key_submode0=1, apply key_submask0 bitmask to key16 26..27 (MPLS 1)
    [*] if key_submode0=2, apply key_submask0 nybblemask to key16 24..31 (MPLS 0-3)
    [*] if key_submode0=3, apply key_submask0 nybblemask to key32 0..3 (outer SIP/DIP IPv4, or outer SIPv6)    
    [/list]

           ";
    ValRandomize = true;
  } KEY_SUBMODE0[49:48] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects Classifier KEY32s to participate in hashing and matching. 
     key_mask32[i] selects key32[i].

           ";
    ValRandomize = true;
  } KEY_MASK32[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
     Selects Classifier KEY16s to participate in hashing and matching. 
     key_mask16[i] selects key16[i].

           ";
    ValRandomize = true;
  } KEY_MASK16[31:0] = 32'h0;
};
regfile entropy_hash_cfg1_rf {
  entropy_hash_cfg1_r ENTROPY_HASH_CFG1[64] += 8;
};



// ENTROPY_HASH_CFG2[0..1][0..63]

reg entropy_hash_cfg2_r {
  shared;
  HandCoded = true;
  name = "Configures hash value calculation";
  desc = "
  Configure how each of the 4 hash values (hash0/1) should be calculated.
  The value in this register has the same format as FFU_HASH_CFG2. 
  [list]
  [*] hash0 configuration is ENTROPY_HASH_CFG2[0][HASH_PROF[0]].
  [*] hash1 configuration is ENTROPY_HASH_CFG2[1][HASH_PROF[1]]. 
  [/list]
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Similar to KeySubmask0. Provides a second mask operation.

           ";
    ValRandomize = true;
  } KEY_SUBMASK1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "
     Bit- or nybble-mask to apply to special keys.
     Setting a mask bit to 0 causes the bit or nybble to be zeroed
     out without shifting other bits/nybbles in the compacted key.

           ";
    ValRandomize = true;
  } KEY_SUBMASK0[31:0] = 32'h0;
};
regfile entropy_hash_cfg2_rf {
  entropy_hash_cfg2_r ENTROPY_HASH_CFG2[64] += 8;
};



// ENTROPY_META_CFG[0..63]

reg entropy_meta_cfg_r {
  shared;
  HandCoded = true;
  name = "Configures packing of Modify Metadata.";
  desc = "
  Configure how to pack FFU_META and hash1 into mod_meta.
  This register is indexed by HASH_PROF[1] (the FFU action).
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
     Controls default setting for each metadata byte.
     Byte_Defaults[b*2 +: 2] controls byte b.
     The values are interpreted as follows:
     [list]
     [*] 0: default byte value is FFU_META[0]
     [*] 1: default byte value is FFU_META[1]
     [*] 2: default byte value is FFU_META[2]
     [*] 3: default byte value is 0.
     [/list]

           ";
    ValRandomize = true;
  } BYTE_DEFAULTS[23:12] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
     Location (0..47) to start inserting hash1 into mod_meta.
     Hardware does not rotate the hash, but does a simple mask insertion.

           ";
    ValRandomize = true;
  } HASH_START[11:6] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
     Number of bits to copy from hash1 into mod_meta.

           ";
    ValRandomize = true;
  } HASH_SIZE[5:0] = 6'h0;
};



// Begin reg2rdl addrmap section

addrmap mby_ppe_entropy_map {
  name = "mby_entropy";
  desc = "Entropy Generator Register Set";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  entropy_hash_cfg0_rf       ENTROPY_HASH_CFG0[3]          ;
  entropy_hash_cfg1_rf       ENTROPY_HASH_CFG1[3]          ;
  entropy_hash_cfg2_rf       ENTROPY_HASH_CFG2[3]          ;
  entropy_meta_cfg_r         ENTROPY_META_CFG[64]          ;
}; // final size: 0xe00 <= 0x1000 = 8<<9

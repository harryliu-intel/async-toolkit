// DO NOT EDIT. Generated by reg2rdl saf.reg.

`include "hlp_udp.rdl"
<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>



// SAF_HEAD_CACHE[0..23]

reg saf_head_cache_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "For Debug Only, Reserved.";
  desc = "
    Stores the forwarded head data for each port.  This register is for debug use ONLY.  This register requires 512-bit atomic access.  Only one master may access it at a time.  A read of bits [63:0] triggers the memory read.  Bits [511:64] are automatically loaded into a local storage register for future SB-IOSF read accesses.
           ";
  regwidth = 512;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "
      read returns zeros.

           ";
    ValRandomize = true;
  } _RSVD1_[511:448] = 64'h0;
  field {
    AccessType = "RSV";
    desc = "
      read returns zeros.

           ";
    ValRandomize = true;
  } _RSVD0_[447:384] = 64'h0;
  field {
    AccessType = "RW/V";
    desc = "
      The data is stored in the following little-endian order:
        reserved(padding), fwd_sched, fwd_modify, fwd_extra, rx_drop(1b), saf_state(2b).

           ";
    ValRandomize = true;
  } DATA5[383:320] = 64'h0;
  field {
    AccessType = "RW/V";
    desc = "
      The data is stored in the following little-endian order:
        reserved(padding), fwd_sched, fwd_modify, fwd_extra, rx_drop(1b), saf_state(2b).

           ";
    ValRandomize = true;
  } DATA4[319:256] = 64'h0;
  field {
    AccessType = "RW/V";
    desc = "
      The data is stored in the following little-endian order:
        reserved(padding), fwd_sched, fwd_modify, fwd_extra, rx_drop(1b), saf_state(2b).

           ";
    ValRandomize = true;
  } DATA3[255:192] = 64'h0;
  field {
    AccessType = "RW/V";
    desc = "
      The data is stored in the following little-endian order:
        reserved(padding), fwd_sched, fwd_modify, fwd_extra, rx_drop(1b), saf_state(2b).

           ";
    ValRandomize = true;
  } DATA2[191:128] = 64'h0;
  field {
    AccessType = "RW/V";
    desc = "
      The data is stored in the following little-endian order:
        reserved(padding), fwd_sched, fwd_modify, fwd_extra, rx_drop(1b), saf_state(2b).

           ";
    ValRandomize = true;
  } DATA1[127:64] = 64'h0;
  field {
    AccessType = "RW/V";
    desc = "
      The data is stored in the following little-endian order:
        reserved(padding), fwd_sched, fwd_modify, fwd_extra, rx_drop(1b), saf_state(2b).

           ";
    ValRandomize = true;
  } DATA0[63:0] = 64'h0;
};



// SAF_MATRIX[0..23]

reg saf_matrix_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Store and forward matrix";
  desc = "
    Defines the mode of operation, store-and-forward or cut-through, for each
ingress to egress pair of ports.  A frame received from port src_port will be
store-and-forwarded if (SAF_MATRIX[src_port].EnableSNF & DMASK) != 0.

    CutThruMode 0 and any of the error ignore modes should not be used unless 
    CM is configured to prevent an out-of-memory condition.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Enable store-and-forward when a frame from this source port is queued
        to each egress port.

           ";
    ValRandomize = true;
  } ENABLE_SNF[26:3] = 24'h0;
  field {
    AccessType = "RW";
    desc = "
        Any frame that is not store-and-forwarded as a result of its
        destination port mask's EnableSNF test is eligible for cut-through
        forwarding.  The forwarding behavior of such frames is selected from
        the following four modes:

        0: Full cut-thru.  The frame will be eligible for egress scheduling
immediately.

        1: One segment SnF.  The frame will be eligible for egress scheduling 
once its first segment has been entirely received.

        2: Two segment SnF.  The frame will be eligible for egress scheduling 
once its second segment has been entirely received.

        3: End-of-frame SnF.  Frames arriving from this port will always be
fully stored to memory before being egress scheduled.

           ";
    ValRandomize = true;
  } CUT_THRU_MODE[2:1] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        Send the frame as if it were in full-cut thru mode, even if it has a 
        FCS, framing or internal error.

           ";
    ValRandomize = true;
  } IGNORE_FRAME_ERROR[0:0] = 1'h0;
};


// TAIL_CSUM_CFG
reg tail_csum_cfg_r {
  Security_PolicyGroup     = <%=$Security_Props{'HLP_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'HLP_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'HLP_PG1_WAC_AGENTS'}%>;
  shared;
  HandCoded = true;
  name = "Tail Checksum control tunneling/NAT";
  desc = "
  Defines which encap and decap packet types require ingress SAF
  for checksum or length calculation over the entire packet.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      If set, and the FFU has set the MOD_IDX[decap] bit,
      and the outer packet is UDP, then the packet is forced SAF.  
      This field is reserved and should always be zero.

           ";
    ValRandomize = true;
  } SAF_DECAP_UDP[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      If set, and the FFU has set the MOD_IDX[encap] bit,
      and the outer packet is IP but not UDP or TCP,
      then the packet is forced SAF.
      This field is reserved and should always be zero.

           ";
    ValRandomize = true;
  } SAF_ENCAP_NON_L4[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      If set, and the FFU has set the MOD_IDX[encap] bit,
      and the outer packet is UDP,
      then the packet is forced SAF.
      This field is reserved and should always be zero.

           ";
    ValRandomize = true;
  } SAF_ENCAP_L4[0:0] = 1'h0;
};


// Begin reg2rdl addrmap section

addrmap hlp_SAF_map {
  name = "hlp_SAF";
  desc = "Store and Forward Registers";
  addressing = fullalign;
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary=true;
  AddressBits = 8;
  ResetDomains = "SWITCH,MGMT";

  saf_head_cache_r           SAF_HEAD_CACHE[24]            @0x0 += 64;
  saf_matrix_r               SAF_MATRIX[24]                @0x800 += 8;
  tail_csum_cfg_r            TAIL_CSUM_CFG                 @0xA00;
}; // final size: 0xA08 <= 0x1000 = 8<<9

<html>
<head>
<title>Internals of the Cast Parser</title>
</head>

<body>

<p>
Cast is parsed by <a href="http://www.antlr.org">ANTLR</a>-generated
Java.  There were massive syntax changes at the end of 2001 which
caused the creation of a new parser.  The main files of the old parser
are com/avlsi/cast/impl/Cast.g and com/avlsi/cast/impl/CastTree.g.
The equivalent files in the new parser are
com/avlsi/cast2/impl/CastTwo.g and
com/avlsi/cast2/impl/CastTwoTree.g.  The old parser is deprecated.  It
should be kept working, but no bug fixes or code tidying are
occuring.  Many of the Java utility files in com/avlsi/cast/ and
com/avlsi/cast/impl are used by both the old and the new parsers.  All
tools work with the old and the new parsers, controlled by the option
"--cast-version=#", where the number is either 1 or 2.  Other utility
files are in com/avlsi/cell and com/avlsi/tools/cosim.

<p>
CastTwo.g produces a <a href="CastTwoLexer.html">lexer</a> and a <a
href="CastTwoParser.html">parser</a>.  For each file, the parser
generates an <a href="../../cast/impl/ASTWithInfo.html">abstract
syntax tree</a> of lexer tokens which retains information on the file,
line, and column each token came from.  <a
href="#error_handling">Error handling</a> in the <a
href="CastTwoTreeParser.html">tree parser</a> uses this information to
print out informative error messages.  <a name="artificial tokens">Many tokens are artificially
generated.  If these tokens are used for file/line/column info, they
must have it set, either by cloning it from a real token using the
copyInfo() function, or by converting one of the tokens originally
discarded by the parser into another token type.  Lack of
file/line/column info can be hard to find programmatically, so <a
href="http://internal/bugzilla/show_bug.cgi?id=762">bug 762</a> is a
dropbox for cast that causes error messages with bad file/line/column
information.

<p>
Much of the complexity of cast parsing is in CastTwoTree.g, the <a
href="CastTwoTreeParser.html">tree parser</a>.  Complex,
hard-to-understand, and likely to fail parts of this include <a
href="#baseType">baseType</a>, <a href="#environment">the many
meanings of "environment"</a>, and <a href="#refinement">refinement,
the inheritance process</a>.

<p>
The tree parser can accept the ASTs of files generated by the
first-sweep parser, but most of its work is done on individual cells,
not files.  When given a file, the tree parser pulls in the imported
files and cells, handles the instantiation of anything at the top
level (which <a href="#deprecated syntax">shouldn't happen any
more</a>), and makes <a
href="../../cast/impl/UserDefinedValue.html">UserDefinedValue</a>s
out of the cell and channel definitions.  UserDefinedValues are very
close to the original AST and contain most of it, split into different
trees for the body, the ports, and so on.

<p>
The main work of the tree parser is producing <a
href="../../cast/impl/InstanceValue.html">InstanceValue</a>s.
InstanceValues represent instances of cells or channels.  They have
their metaparameters filled in and they have been fully-processed,
lacking only context (the cell they will be instantiated in).  In
fact, they contain a <a
href="../../cell/CellInterface.html">CellInterface</a>.
The <a
href="../../cast/impl/CastParserEnvironment.html">CastParserEnvironment</a>
requests instances via <a
href="CastTwoTreeParser.html#doBaseType(antlr.collections.AST,%20com.avlsi.cast.impl.Environment,%20com.avlsi.cell.CellImpl,%20com.avlsi.file.common.HierName,%20boolean)">doBaseType()</a>,
or they may be triggered in response to subcells and ports of a cell
that has already been requested.

<h3>Error Handling</h3>

<p>
<a name="error_handling">There are three basic sorts of error handling in cast parsing:
syntaxError, fatalError, and SemanticWrapperException</a>.
syntaxError is a function in both CastTwo.g and CastTwoTree.g.  It's
not properly an error.  Its purpose is to report, without stopping or
changing the parsing, on deprecated or otherwise frowned-upon syntax.
It is controlled by the verbose flag.  fatalError produces the same
sort of message as syntaxError does, but halts parsing immediately and
doesn't heed the verbose flag.  It might be implemented via
SemanticWrapperException in the future.

<p>
Each antlr function in the tree parser evaluates to a java function
which throws RecognitionException and SemanticException.  These mean,
respectively, "got a weirdly-formed tree/got an unexpected token" and
"something more complicated went wrong".  We've subclassed
SemanticException to <a
href="../../cast/impl/SemanticWrapperException.html">SemanticWrapperException</a>,
which wraps another exception together with file/line/column
information.  SemanticWrapperException preserves the original stack
trace to make debugging easier.  It gets the file/line/column info
from an ASTWithInfo.  In <a href="#artificial tokens">some cases</a>
the ASTWithInfo doesn't have proper info; <a
href="http://internal/bugzilla/show_bug.cgi?id=762">bug 762</a>
addresses these.  They're almost always easy to fix.  (<a
href="http://internal/bugzilla/show_bug.cgi?id=589">bug 589</a> is an
example of one which is harder to fix)

<p>
Any thrown exception which doesn't go through
SemanticWrapperException confuses later tools.  This includes any sort
of RunTimeException, and, in most places, RecognitionException.
RecognitionExceptions have their own file/line numbers, but they're
still annoying for tools like dsim, which often want to catch parsing
errors and continue.

<h3>Ambiguous Terms</h3>
<ul>
<li><a name="environment">environment
  <ul>
  <li>The environment block contains named environments for testing
  the cell.  Named environments are themselves cells (though they're
  not allowed to have environment blocks and are forced to have the
  same ports, in the opposite direction, as the cell).  This is what
  any parser-user will mean by the word "environment".</li>
  <li>The <a href="../../cast/impl/Environment.html">Environment
  class</a> is the symbol table for the tree parser.  Different
  subclasses of it occur all through treeparsing.  They map Symbols to
  Values.  UserDefinedValues and InstanceValues have internal
  Environments.</li>
  <li>DSim instantiates cells inside of environment cells, artificial
  top-level CellImpls.</li>
  </ul>
</li>
<li>type &mdash; fortunately most of the messiness here is in
CastTwo.g, which is simpler and more static than CastTwoTree.g or much
of the other code.
</li>
<li>port/parameter &mdash; Cast cells have three connections to their
contexts: metaparameters, regular ports, and implied ports.  "Ports"
can mean regular ports only or regular ports and implied ports.
"Parameters" is used to mean any combination of the three.</li>
</ul>

<h3>Differences Between Old and New Cast Syntax</h3>

<p>
<a name="deprecated syntax">First of all, the transition is not
complete.  The new javablock syntax is useful for most current tasks,
but <a href="http://internal/bugzilla/show_bug.cgi?id=699">not
complete</a>.  Much of the old syntax is still accepted with only a
syntaxError (warning), even though parts of it will misbehave when
combined with refinement.  All tools are designed to use either one, and
most internal data structures are part of both parsers.  (Some of the
data structures are unique to new cast.)

<p><a href="http://internal/~mid/flow/castv2spec.html">Mike's spec for
new cast</a>

<h3>Dangerous Areas</h3>

<p><a name="baseType"><b>baseType</b>, in the tree parser.  It's been
split up into a couple of utility functions, but it needs refactoring
and care.  Much of the work of refinment is here; the rest is in
CellImpl and the data structures inside CellImpl.

<p><b>IDENT parsing</b> in the lexer.  There's currently no good way to fix
<a href="http://internal/bugzilla/show_bug.cgi?id=501">bug 501</a>.  A
possible way around this might be to make DOT_IDENT a lexer-generated
token instead of a parser rule.

<p><a name="refinement"><b>Refinement</b>.  Refinement mostly uses data from
CellImpl, which is a datatype intended for the <em>users</em> of the
cast parser.  Many of the restrictions on things not changing during
refinement (removing ports, refining flattened cells, etc) are due to
this.

<p><b>Ex-globals</b>.  Implied ports and refinable constants in the top-level
of a cell have taken the place of globals, but there's still a lot of
code extant that either supports the <a
href="../../tools/dsim/DSim.ScopedGlobalHack.html">scoped global
hack</a> (a previous solution to having different "globals" in
different areas of the chip) or otherwise treats nodes with names
ending in '!' differently.

</body>
</html>




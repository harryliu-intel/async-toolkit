/*
 * Copyright 2004 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 */

package com.avlsi.tools.presto;

import java.util.Arrays;
import com.avlsi.util.container.CollectionUtils;
import java.util.Date;
import java.text.DateFormat;
import com.avlsi.tools.presto.template.DeclarationsImpl;
import java.util.LinkedList;
import com.avlsi.util.container.MappingIterator;
import com.avlsi.tools.presto.output.Organizer;
import com.avlsi.tools.presto.output.Power;
import java.io.PrintWriter;
import java.io.StringWriter;
import com.avlsi.tools.presto.output.PrsPrinter;
import com.avlsi.tools.presto.template.SectionFactory;
import java.util.Set;
import com.avlsi.util.text.StringUtil;
import com.avlsi.tools.presto.template.Template;
import com.avlsi.util.functions.UnaryFunction;

public class Presto2 {
    public static void mkEnv(PrintWriter w, int indent,
                             ChannelName[] inputs, ChannelName[] outputs) {
        String i = StringUtil.repeatString(" ", indent);

        for (int j = 0; j < inputs.length; j++)
            w.println(i + "rsource_e1of" + inputs[j].get1of() + " _(" +
                      inputs[j].getNameWithIndices() + ");");

        for (int j = 0; j < outputs.length; j++)
            w.println(i + "bitbucket_e1of" + outputs[j].get1of() + " _(" +
                      outputs[j].getNameWithIndices() + ");");
    }

    /**
     * Synthesizes a leaf cell for a given set of truth tables.
     * @param  w   where to send the output
     * @param  tt  truth tables
     * @param  go  a Set of Strings, names of output channel which should
     *             use a go signal
     * @param  version  the build identifier of the package
     */
    public static void presto(PrintWriter w, TruthTable[] tt, Set go,
                              String version, WarningAccumulator wacc) {
        String user = System.getProperty("user.name");
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        ChannelName[] inputs = tt[0].getInputs();
        for (int i=0; i < inputs.length; i++)
            if (inputs[i].getName().equals("tie") || 
                inputs[i].getName().equals("tiehi") || 
                inputs[i].getName().equals("tielo")) {
                System.err.println("Error: Port names tie/tiehi/tielo not compatible with PReSto");
                System.exit(32);
            }
        for (int i=0; i < tt.length; i++)
            if (tt[i].getOutput().getName().equals("tie") || 
                tt[i].getOutput().getName().equals("tiehi") || 
                tt[i].getOutput().getName().equals("tielo")) {
                System.err.println("Error: Port names tie/tiehi/tielo not compatible with PReSto");
                System.exit(32);
            }
        
        w.println("  prs {");
        String date = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,
                                        DateFormat.SHORT).format(new Date());
        w.println("    /* Generated on " + date + " by " +
                  user + " with " + "PReSto.");
        w.println("     * " + version);
        if (go.size() > 0)
            w.println("     * Options: --go=" +
                      StringUtil.join((String[])
                                      go.toArray(new String[0]), ','));
        DeclarationsImpl decl = new DeclarationsImpl();
        Organizer org = new Organizer();
        StringBuffer cycle_node = new StringBuffer();
        int ntpc = Template.doTemplate(tt, org, decl, go, cycle_node, wacc);
        wacc.print("     * ", w);
        w.println("     * If you manually edit this PRS block, " +
                  "please add a comment here");
        w.println("     * saying what you changed-- otherwise, " +
                  "we will assume the PRS block");
        w.println("     * can be regenerated by running PReSto again. */");
        decl.emit(pw, 4, 78);
        PrsPrinter prs = new PrsPrinter();
        org.simplify(prs);
        prs.emit(pw, 4, 4, 50, SectionFactory.mkAncestorSection());
        if (Power.getIsCalled()) {
            w.println("    node tiehi, tielo;");
            w.println("    lib.util.tie.LOCAL_TIE tie;");
        }
        
        w.println(sw.toString());
        w.println("  }");
        w.println();
        w.println("  directives {");
        w.println("    owner = " + user + ';');
        if (wacc.hasWarnings())
            w.println("    " + user + "_must_fix_warnings = true; " +
                      "// bogus directive; delete when fixed");
        w.println("  }");
        w.println();
        w.println("  env {");
        w.println("    digital {");
        w.println("      subcells {");
        mkEnv(w, 8, tt[0].getInputs(), (ChannelName[]) CollectionUtils
              .addAll(new LinkedList(),
                      new MappingIterator(Arrays.asList(tt).iterator(),
                                          new UnaryFunction() {
                                              public Object execute(Object a) {
                                                  return ((TruthTable)a)
                                                      .getOutput();
                                              }
                                          })).toArray(new ChannelName[0]));
        w.println("      }");
        w.println("      directives {");
        w.println("        ntpc_spec(" + cycle_node + ") = " + ntpc + ";");
        w.println("      }");
        w.println("    }");
        w.println("  }");
    }
}

// DO NOT EDIT. Generated by reg2rdl pcie_pf.reg.

<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>
`include "lib_udp.rdl"

enum pcie_rxdctl_drop_on_empty_enum {
  DROP = 1'd1 { desc = " Drop the frame if queue has no descriptors"; };
  HOLD = 1'd0 { desc = " Hold onto the frame if queue has no descriptors until descriptors become available. "; };
};


enum pcie_txdctl_push_desc_enum {
  PUSH = 1'd1 { desc = " Descriptors written by host into controller "; };
  PULL = 1'd0 { desc = " Descriptors read by controller from host memory"; };
};


enum pcie_tqdloc_size_enum {
  FIVE = 4'd32 { desc = " when DMA_CTRL.MaxNumOfQs is set to 00b (256 Qs)."; };
  SIX = 4'd64  { desc = " when DMA_CTRL.MaxNumOfQs is set to 01b (128 Qs)."; };
  SEVEN = 4'd128  { desc = " when DMA_CTRL.MaxNumOfQs  is set to 10b (64 Qs)."; };
};




// PCIE_CTRL

reg pcie_ctrl_r {
  shared;
  HandCoded = true;
  name = "Device Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        When low, holds the LTSSM in the Detect state until any necessary configuration has completed. This bit is cleared only by PCIE reset events, and shall never be cleared by host or SW/BSM.

           ";
    ValRandomize = true;
  } LTSSM_ENABLE[5:5] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        When asserted incoming configuration requests are completed with a configuration request retry status.

           ";
    ValRandomize = true;
  } REQ_RETRY_EN[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        This register bit is set after a COLD_RESET and can be cleared to block future access to BAR4.   

           ";
    ValRandomize = true;
  } BAR4_Allowed[3:3] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "
       Reserved for PCIE_VFCTRL.  

           ";
    ValRandomize = true;
  } __reservedVF__[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
       Enable the physical RX lane flip so that a physical layout problem of lane reversed can be fixed. This bit 0 indicates that core currently requires the LSB lane (i.e lane0) to be physically presented. When this bit is asserted 1 enables the flip of the MSB lane to lane0. The field shall be set to the proper value by NVM/BSM.
Lane flip feature is not supported in RRC. The bit shall be always set to 0.

           ";
    ValRandomize = true;
  } RxLaneflipEn[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
       Enable the physical TX lane flip so that a physical layout problem of lane reversed can be fixed. This bit 0 indicates that core currently requires the LSB lane (i.e lane0) to be physically presented. When this bit is asserted 1 enables the flip of the MSB lane to lane0. The field shall be set to the proper value by NVM/BSM.
Lane flip feature is not supported in RRC. The bit shall be always set to 0.

           ";
    ValRandomize = true;
  } TxLaneflipEn[0:0] = 1'h0;
};



// PCIE_CTRL_EXT

reg pcie_ctrl_ext_r {
  shared;
  HandCoded = true;
  name = "Extended Device Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        No Snoop Disable. This bit is non functional in RRC. It shall remain set to 0.

           ";
    ValRandomize = true;
  } NS_DIS[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Relaxed Ordering Disable. When set to 1b, the device does not request any relaxed ordering transactions. When this bit is cleared and the Enable Relaxed Ordering bit in the Device Control register is set, the device requests relaxed ordering transactions per queues as configured in the TPH_RXCTRL[n] and TPH_TXCTRL[n] registers.

           ";
    ValRandomize = true;
  } RO_DIS[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Enables a switch loopback. When set, packets sent to switch will be looped back to PEP and packets sent by switch will be looped back to switch. Set to 0 for normal operation. This field resets on COLD_RESET events.  

        This field may not be written while traffic is flowing.

           ";
    ValRandomize = true;
  } SwitchLoopback[0:0] = 1'h1;
};



// PCIE_EXVET

reg pcie_exvet_r {
  shared;
  HandCoded = true;
  name = "Extended Ethernet Type Support";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Extra ethernet type. TX parser jumps over if detected, RX parser jumps over and set VEXT2 in the RX descriptor.

           ";
    ValRandomize = true;
  } EthernetType[18:3] = 16'h8100;
  field {
    AccessType = "RW";
    desc = "
        Size in 16-bit quanta, size supported are 1,2,3. Setting to 0 is disabling detection of this type. 

           ";
    ValRandomize = true;
  } TagSize[2:1] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines if the extended tag is expected before VLAN (8100) tag (0) or after VLAN tag (1).         

           ";
    ValRandomize = true;
  } AfterVLAN[0:0] = 1'h0;
};



// PCIE_GCR

reg pcie_gcr_r {
  shared;
  HandCoded = true;
  name = "PCIe Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved1[18:10] = 9'h4;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved2[9:1] = 9'h0;
  field {
    AccessType = "RO";
    desc = "
        Read only field reporting supported PCIe capability version.

        0b = Capability version: 0x1.

        1b = Capability version: 0x2.

           ";
    ValRandomize = true;
  } PCIeCapabilityVersion[0:0] = 1'h1;
};



// PCIE_FACTPS

reg pcie_factps_r {
  shared;
  HandCoded = true;
  name = "Function Active and Power State to Manageability";
  desc = "
    Register for use by the device firmware for configuration.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Power state indication of function 0.

            * 00b = DR.
            * 01b = D0u.
            * 10b = D0a.
            * 11b = D3.

           ";
    ValRandomize = true;
  } Func0PowerState[3:2] = 2'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Function 0 Auxiliary (AUX) Power PM Enable bit shadow from the configuration space.

           ";
    ValRandomize = true;
  } Func0Aux_En[0:0] = 1'h0;
};



// PCIE_GCR_EXT

reg pcie_gcr_ext_r {
  shared;
  HandCoded = true;
  name = "PCIe Control Extended Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Auto PBA Clear Disable. When set to 1b, Software can clear the PBA only by direct write to clear access to the PBA bit. When set to 0b, any active PBA entry is cleared on the falling edge of the appropriate interrupt request to the PCIe block. The appropriate interrupt request is cleared when software sets the associated interrupt mask bit in the EIMR (re-enabling the interrupt) or by direct write to clear to the PBA.

        *** NOT IMPLEMENTED IN RED ROCK CANYON, the PBA is set when an interrupt is detected, and cleared when the MSI-X is sent. *** 

           ";
    ValRandomize = true;
  } APBACD[0:0] = 1'h0;
};



// PCIE_EICR

reg pcie_eicr_r {
  shared;
  HandCoded = true;
  name = "Extended Interrupt Cause Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Reports PCIE_PCA_FAULT.Valid

           ";
    ValRandomize = true;
  } PCA_Fault[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reserved to report PCIE_RHI_FAULT.Valid.

           ";
    ValRandomize = true;
  } RHI_Fault[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reserved to report PCIE_THI_FAULT.Valid

           ";
    ValRandomize = true;
  } THI_Fault[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reserved to report PCIE_RPP_FAULT.Valid

           ";
    ValRandomize = true;
  } RPP_Fault[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reserved to report PCIE_TPP_FAULT.Valid

           ";
    ValRandomize = true;
  } TPP_Fault[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reports PCIE_FUM_FAULT.Valid

           ";
    ValRandomize = true;
  } FUM_Fault[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Reports a mailbox interrupt. Read PCIE_MBICR to determine the sending VF and PCIE_GMBX to if SM is the sender. Write 1 to clear. 

           ";
    ValRandomize = true;
  } MailBox[7:7] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Reports a switch transition from not ready to ready. Write 1 to clear. 

           ";
    ValRandomize = true;
  } SwitchReady[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Reports a switch transition from reday to not ready. Write 1 to clear.

           ";
    ValRandomize = true;
  } SwitchNotReady[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Interrupt from switch active. 

           ";
    ValRandomize = true;
  } SwitchInterrupt[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicates a correctable or an uncorrectable ECC/parity error occurred on an SRAM of the PEP. Read PCIE_SRAM_IP register to retrieve the concerned block. The bit is kept asserted until all asserted bits in PCIE_SRAM_IP are cleared by the appropriate reset or by CW1. This interrupt is relevant only for the PEP that hosts the SM, it should be masked otherwise.

           ";
    ValRandomize = true;
  } SramError[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reports a VFLR event occurred. Read PCIE_PFVFLRE to retrieve the VF.  

           ";
    ValRandomize = true;
  } VFLR[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicates the max hold timer has timed out for a receive queue. It means a receive queue that was configured with DropOnEmpty=0 waited for available Rx descriptors for a longer time than PCIE_DMA_CTRL.MaxHoldTime. The device has set DropOnEmpty to 1 for that queue in return. Read PCIE_MAXHOLDQ registers to retrieve the concerned queue(s). The bit is kept asserted until all asserted bits in PCIE_MAXHOLDQ are cleared by CW1.

           ";
    ValRandomize = true;
  } MaxHoldTime[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Reports a Visa trap event occurred. For debugging purposes only.  

           ";
    ValRandomize = true;
  } VisaTrap[0:0] = 1'h0;
};



// PCIE_EIMR

reg pcie_eimr_r {
  shared;
  HandCoded = true;
  name = "Extended Interrupt Mask Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_0[31:30] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_1[29:28] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_2[27:26] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_3[25:24] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_4[23:22] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_5[21:20] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_6[19:18] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_7[17:16] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_8[15:14] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_9[13:12] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_10[11:10] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_11[9:8] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_12[7:6] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_13[5:4] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_14[3:2] = 2'h1;
  field {
    AccessType = "RW";
    desc = "
        Read as 1 if the corresponding interrupt is masked. The last 2 items are reserved.

          * 0 or 3: do not change the mode
          * 1: disable the corresponding interrupt cause (set the mask)
          * 2: enable the corresponding interrupt cause (clear the mask)

           ";
    ValRandomize = true;
  } Mask_15[1:0] = 2'h1;
};



// PCIE_PCA_FAULT

reg pcie_pca_fault_r {
  shared;
  HandCoded = true;
  name = "PCI Core Access Fault";
  desc = "
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        The address at the time the fault was detected.

           ";
    ValRandomize = true;
  } Address[111:48] = 64'h0 ;
  field {
    AccessType = "RO";
    desc = "
        Extra info on this fault (fault dependent). Field not used, reserved for future use. 

           ";
    ValRandomize = true;
  } FaultSpecificInfo[47:16] = 32'h0 ;
  field {
    AccessType = "RO";
    desc = "
          * 0: PCA_NO_FAULT
          * 1: PCA_UNMAPPED_ADDR
          * 2: PCA_BAD_QACCESS_PF
          * 3: PCA_BAD_QACCESS_VF
          * 4: PCA_MALICIOUS_REQ
          * 5: PCA_POISONED_TLP
          * 6: PCA_TLP_ABORT

           ";
    ValRandomize = true;
  } FaultType[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicate VF that made the fault

           ";
    ValRandomize = true;
  } VF[7:2] = 6'h0;
  field {
    AccessType = "RO";
    desc = "
        Set by hardware to 1 to indicate fault was made by PF

           ";
    ValRandomize = true;
  } PF[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set by hardware to 1 when a fault is logged, no further fault reported for this sub-unit until this bit is cleared. 

           ";
    ValRandomize = true;
  } Valid[0:0] = 1'h0;
};



// PCIE_RHI_FAULT

reg pcie_rhi_fault_r {
  shared;
  HandCoded = true;
  name = "Receiver Host Interface Fault";
  desc = "
    This register is not implemented, reserved for future use.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved[111:0] = 112'h0 ;
};



// PCIE_THI_FAULT

reg pcie_thi_fault_r {
  shared;
  HandCoded = true;
  name = "Transmitter Host Interface Fault";
  desc = "
    This register reports Tx descriptor fault events where a Tx queue is disabled by the device and remapped to the PF further to a non-consistent contents in a Tx descriptor.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        The Tx queue index on which the fault occured.

           ";
    ValRandomize = true;
  } Address[111:48] = 64'h0 ;
  field {
    AccessType = "RO";
    desc = "
        Extra info on this fault (fault dependent). Field not used, reserved for future use. 

           ";
    ValRandomize = true;
  } FaultSpecificInfo[47:16] = 32'h0 ;
  field {
    AccessType = "RO";
    desc = "
        Fault type values reported:    
          * 0: THI_NO_FAULT
          * 1: THI_MAL_DIS_Q_FAULT

           ";
    ValRandomize = true;
  } FaultType[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicate VF that made the fault

           ";
    ValRandomize = true;
  } VF[7:2] = 6'h0;
  field {
    AccessType = "RO";
    desc = "
        Set by hardware to 1 to indicate fault was made by PF

           ";
    ValRandomize = true;
  } PF[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set by hardware to 1 when a fault is logged, no further fault reported for this sub-unit until this bit is cleared. 

           ";
    ValRandomize = true;
  } Valid[0:0] = 1'h0;
};



// PCIE_RPP_FAULT

reg pcie_rpp_fault_r {
  shared;
  HandCoded = true;
  name = "Receiver Packet Processing Fault";
  desc = "
    This register is not implemented, reserved for future use.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved[111:0] = 112'h0 ;
};



// PCIE_TPP_FAULT

reg pcie_tpp_fault_r {
  shared;
  HandCoded = true;
  name = "Transmitter Packet Processing Fault";
  desc = "
    This register is not implemented, reserved for future use.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved[111:0] = 112'h0 ;
};



// PCIE_FUM_FAULT

reg pcie_fum_fault_r {
  shared;
  HandCoded = true;
  name = "Function Manager Fault";
  desc = "
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        The Double-Word address at the time the fault was detected. Only the lower 22 bits in this field are valid, the rest are reserved, and always 0.

           ";
    ValRandomize = true;
  } Address[111:48] = 64'h0 ;
  field {
    AccessType = "RO";
    desc = "
        Extra info on this fault (fault dependent). Field not used, reserved for future use. 

           ";
    ValRandomize = true;
  } FaultSpecificInfo[47:16] = 32'h0 ;
  field {
    AccessType = "RO";
    desc = "
          * 0: FUM_NO_FAULT
          * 1: FUM_UNMAPPED_ADDR
          * 2: Reserved
          * 3: FUM_BAD_VF_QACCESS
          * 4: FUM_ADD_DECODE_ERR
          * 5: FUM_RO_ERROR
          * 6: FUM_QPRC_CRC_ERROR
          * 7: FUM_CSR_TIMEOUT
          * 8: FUM_INVALID_TYPE
          * 9: FUM_INVALID_LENGTH
          * A: FUM_INVALID_BE
          * B: FUM_INVALID_ALIGN

           ";
    ValRandomize = true;
  } FaultType[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicate VF that made the fault

           ";
    ValRandomize = true;
  } VF[7:2] = 6'h0;
  field {
    AccessType = "RO";
    desc = "
        Set by hardware to 1 to indicate fault was made by PF

           ";
    ValRandomize = true;
  } PF[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set by hardware to 1 when a fault is logged, no further fault reported for this sub-unit until this bit is cleared.      

           ";
    ValRandomize = true;
  } Valid[0:0] = 1'h0;
};



// PCIE_MAXHOLDQ[0..7]

reg pcie_maxholdq_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
   Indicates the receive queue(s) for which the max hold timer has timed out. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_0[31:31] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_1[30:30] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_2[29:29] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_3[28:28] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_4[27:27] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_5[26:26] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_6[25:25] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_7[24:24] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_8[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_9[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_10[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_11[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_12[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_13[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_14[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_15[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_16[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_17[14:14] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_18[13:13] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_19[12:12] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_20[11:11] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_21[10:10] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_22[9:9] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_23[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_24[7:7] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_25[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_26[5:5] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_27[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_28[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_29[2:2] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_30[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
   Each bit 'n' in register 'i' represents receive queue index 32*i+n.

           ";
    ValRandomize = true;
  } MaxHoldQ_31[0:0] = 1'h0;
};



// PCIE_SM_AREA

reg pcie_sm_area_r {
  shared;
  HandCoded = true;
  name = "Switch Manager Area";
  desc = "
           ";
  regwidth = 256;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Serial Number copied by SM at boot time from PCIe config space (registers PCIE_SPD_NUMBER_L/H). The Serial Number is
        encoded big endian. 
        
        * SerialNumber[7:0]   = EUI[7]
        * SerialNumber[15:8]  = EUI[6]
        * SerialNumber[23:16] = EUI[5]
        * SerialNumber[31:24] = EUI[4]
        * SerialNumber[39:40] = EUI[3]
        * SerialNumber[47:40] = EUI[2]
        * SerialNumber[55:48] = EUI[1]
        * SerialNumber[63:56] = EUI[0]          

           ";
    ValRandomize = true;
  } SerialNumber[255:192] = 64'h0;
  field {
    AccessType = "RW";
    desc = "
        Reserved for future use by SM

           ";
    ValRandomize = true;
  } __reserved__[191:0] = 192'h0;
};



// PCIE_DGLORTMAP[0..7]

reg pcie_dglortmap_r {
  shared;
  HandCoded = true;
  name = "Glort mapping register";
  desc = "
     The register set is used for comparing incoming DGLORT from fabric to known patterns. The patterns are in form a VALUE/MASK. The DGLORT is compared to all patterns and the highest matching pattern defines how the DGLORT is interpreted. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         Value to compare.

           ";
    ValRandomize = true;
  } Value[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
         Selects which bits to compare. Setting to 0xFFFF means all bits are significant for comparison to Value. Setting to 0x0000 and value to 0x0000 is always match. Setting mask to 0x0000 and value to other than 0x0000 will never match. 

           ";
    ValRandomize = true;
  } Mask[15:0] = 16'h0;
};



// PCIE_DGLORTDEC[0..7]

reg pcie_dglortdec_r {
  shared;
  HandCoded = true;
  name = "Glort decoding";
  desc = "
    This register defines how to decode the DGLORT, the index 'n' selected correspond to the highest matching DGLORT in PCIE_GLORTMAP.
    
    The DGLORT contains the Queue Number and the VF number. The size of the queue number and the size of the VF number is variable.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines the length in bits for the Queue number encoded in DGLORT. A value of 0 means that the queue # is not present in the DGLORT. Maximum width is 8 bits. 

           ";
    ValRandomize = true;
  } Qlength[27:24] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines the length in bits for the VSI number encoded in DGLORT, relative to VSI Base. A value of 0 means that the VSIbase is used as the VSI number.  

           ";
    ValRandomize = true;
  } VSIlength[23:21] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
        The VSI base number.

           ";
    ValRandomize = true;
  } VSIbase[20:14] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines how many bits of Priority Class are included in the queue number computation. A value of 0 means that VPRI has no influence in the queue selection.   

           ";
    ValRandomize = true;
  } PClength[13:12] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        The first queue of a block of queues for this decoder. 

           ";
    ValRandomize = true;
  } Qbase[11:4] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        The number of bits used out of the RETA table value. A value of 0 means the hash key is not computed and the RETA indirect table is not used.    

           ";
    ValRandomize = true;
  } RSSlength[3:1] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
        Use the inner header for RSS (if present). A value of 0 means to always use the outer header regardless if there is a recognized tunnel. A value of 1 means to use the inner header if a tunnel is detected.

           ";
    ValRandomize = true;
  } InnerRSS[0:0] = 1'h0;
};



// PCIE_TUNNEL_CFG

reg pcie_tunnel_cfg_r {
  shared;
  HandCoded = true;
  name = "Tunnel configuration";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         Defines the L4 port used for VXLAN. Setting to 0 disable VXLAN
         detection. 

           ";
    ValRandomize = true;
  } VXLAN_PORT[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
         Defined the encapstulation ID for NVGRE and the Next Protocol type supported inside NGE headers. Setting to 0 disable GRE
         detection. Next Protocol type supported is for Ethernet, which uses the value of 0x6558.

           ";
    ValRandomize = true;
  } Protocol_Type[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
         Defines the L4 port used for NGE. Setting to 0 disable NGE detection. UDP port defined for NGE (a.k.a. Geneve) is 6081 (decimal).

           ";
    ValRandomize = true;
  } NGE_PORT[15:0] = 16'h0;
};



// PCIE_SWPRI_MAP[0..15]

reg pcie_swpri_map_r {
  shared;
  HandCoded = true;
  name = "Switch Priority Map";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines the priority class for queue selection from the FTAG SWPRI.     

           ";
    ValRandomize = true;
  } pc[2:0] = 3'h0;
};



// PCIE_RSSRK[0..64,0..9]

reg pcie_rssrk_r {
  shared;
  HandCoded = true;
  name = "RSS Random Key Register";
  desc = "
    Index 1..64 is for VF, index 0 is for PF. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        RSS Key Byte [4*n+0] of the RSS random key, for each register [n].

           ";
    ValRandomize = true;
  } K0[31:24] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        RSS Key Byte [4*n+1] of the RSS random key, for each register [n].

           ";
    ValRandomize = true;
  } K1[23:16] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        RSS Key Byte [4*n+2] of the RSS random key, for each register [n].

           ";
    ValRandomize = true;
  } K2[15:8] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        RSS Key Byte [4*n+3] of the RSS random key, for each register [n].

           ";
    ValRandomize = true;
  } K3[7:0] = 8'h0;
};
regfile pcie_rssrk_rf {
  pcie_rssrk_r PCIE_RSSRK[10] += 8;
};



// PCIE_RETA[0..64,0..31]

reg pcie_reta_r {
  shared;
  HandCoded = true;
  name = "Redirection Table";
  desc = "
    Index 1..64 is for VF, index 0 is for PF. 
    The contents of the redirection table are not defined following reset of the Memory Configuration registers. System software must initialize the table prior to enabling multiple receive queues. It can also update the redirection table during run time. Such updates of the table are not synchronized with the arrival time of received packets. Therefore, it is not guaranteed that a table update takes effect on a specific packet boundary.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Entry0 defines the RSS output index for hash value [4*n+0]. While [n] is the register index, equals to 0...31.

           ";
    ValRandomize = true;
  } Entry0[31:24] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Entry1 defines the RSS output index for hash value [4*n+1]. While [n] is the register index, equals to 0...31.

           ";
    ValRandomize = true;
  } Entry1[23:16] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Entry2 defines the RSS output index for hash value [4*n+2]. While [n] is the register index, equals to 0...31.

           ";
    ValRandomize = true;
  } Entry2[15:8] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Entry3 defines the RSS output index for hash value [4*n+3]. While [n] is the register index, equals to 0...31.

           ";
    ValRandomize = true;
  } Entry3[7:0] = 8'h0;
};
regfile pcie_reta_rf {
  pcie_reta_r PCIE_RETA[32] += 8;
};



// PCIE_TC_CREDIT[0..63]

reg pcie_tc_credit_r {
  shared;
  HandCoded = true;
  name = "Traffic Class Credit";
  desc = "
     Implements a token bucket for rate control of traffic shaping group n. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         Signed number.  
         
         Current credit in bytes available for this traffic class. Packets are not pulled from memory when the credit is negative. Credits are substracted when memory reads are issued to host. Credits are added periodically (once per Interval refresh periods) by the Quanta value and saturate at MaxCredit.    

           ";
    ValRandomize = true;
  } Credit[31:11] = 21'hFFFF;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_10_8_[10:8] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
        IntervalLeft counter counts down from Interval, once every refresh period. Credits are added when IntervalLeft reaches zero. 

           ";
    ValRandomize = true;
  } IntervalLeft[7:0] = 8'h1;
};



// PCIE_TC_MAXCREDIT[0..63]

reg pcie_tc_maxcredit_r {
  shared;
  HandCoded = true;
  name = "Traffic Class Max Credit";
  desc = "
     Implements a token bucket for rate control of traffic shaping group n. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         Unsigned number. 
     
         The maximum credit available for a given queue. 

           ";
    ValRandomize = true;
  } MaxCredit[31:12] = 20'hFFFF;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_11_0_[11:0] = 12'h0     ;
};



// PCIE_TC_RATE[0..63]

reg pcie_tc_rate_r {
  shared;
  HandCoded = true;
  name = "Traffic Class Rate";
  desc = "
     Implements a token bucket for rate control of traffic shaping group n. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         The additional credits allowed per time interval.

           ";
    ValRandomize = true;
  } Quanta[31:16] = 16'hFFFF;
  field {
    AccessType = "RW";
    desc = "
         The time interval to give credits in units of refresh periods. A refresh period is 512ns in gen3 mode, 1024ns in gen2 mode, or 2048ns in gen1 mode. An Interval value of 0 is treated the same as 1.

           ";
    ValRandomize = true;
  } Interval[15:8] = 8'h1;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_7_0_[7:0] = 8'h0     ;
};



// PCIE_TC_RATE_STATUS

reg pcie_tc_rate_status_r {
  shared;
  HandCoded = true;
  name = "Traffic Class Status";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_0[63:63] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_1[62:62] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_2[61:61] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_3[60:60] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_4[59:59] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_5[58:58] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_6[57:57] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_7[56:56] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_8[55:55] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_9[54:54] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_10[53:53] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_11[52:52] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_12[51:51] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_13[50:50] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_14[49:49] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_15[48:48] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_16[47:47] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_17[46:46] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_18[45:45] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_19[44:44] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_20[43:43] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_21[42:42] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_22[41:41] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_23[40:40] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_24[39:39] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_25[38:38] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_26[37:37] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_27[36:36] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_28[35:35] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_29[34:34] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_30[33:33] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_31[32:32] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_32[31:31] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_33[30:30] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_34[29:29] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_35[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_36[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_37[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_38[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_39[24:24] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_40[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_41[22:22] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_42[21:21] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_43[20:20] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_44[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_45[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_46[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_47[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_48[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_49[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_50[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_51[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_52[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_53[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_54[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_55[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_56[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_57[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_58[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_59[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_60[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_61[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_62[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Reflects if a traffic class currently has non-negative Credit, allowing packets to be transmitted.

           ";
    ValRandomize = true;
  } Allowed_63[0:0] = 1'h0;
};



// PCIE_PAUSE

reg pcie_pause_r {
  shared;
  HandCoded = true;
  name = "Pause Status Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_0[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_1[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_2[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_3[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_4[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_5[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_6[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if a Tx Priority Class is currently paused or not.          

           ";
    ValRandomize = true;
  } TxPause_7[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_0[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_1[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_2[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_3[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_4[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_5[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_6[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if an Rx Priority Class is currently paused or not. 
         **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } RxPause_7[0:0] = 1'h0;
};



// PCIE_DMA_CTRL

reg pcie_dma_ctrl_r {
  shared;
  HandCoded = true;
  name = "DMA Control Register";
  desc = "
     Excepted to the DataPathReset bit, all the RW fields of this register can be changed only once all the Rx and Tx queues are disabled.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         Defines if TX DMA is active or not. Setting this bit to 0 will cause the TX DMA controller to stop gracefully (i.e., not issue further PCIe requests). Once TxEnable is reasserted, Tx queues have to be re-initialized to resume operation.

           ";
    ValRandomize = true;
  } TxEnable[31:31] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if TX DMA has pending host requests.   

           ";
    ValRandomize = true;
  } TxHostPending[30:30] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if TX DMA has pending data waiting to be transmitted to
         Ethernet fabric

           ";
    ValRandomize = true;
  } TxData[29:29] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if TX DMA is active, i.e. there is some pending work in Tx. 

           ";
    ValRandomize = true;
  } TxActive[28:28] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
         Defines if RX DMA is active or not. Setting this bit to 0 will cause the RX DMA controller to stop gracefully (i.e., the controller will stop issuing further PCIe requests). Once RxEnable is reasserted, Rx queues have to be re-initialized to resume operation.

           ";
    ValRandomize = true;
  } RxEnable[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if RX DMA has pending host requests.   

           ";
    ValRandomize = true;
  } RxHostPending[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if RX DMA has pending data being processed. This bit is cleared if there is no packet being processed at that time.  

           ";
    ValRandomize = true;
  } RxData[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         Indicates if RX DMA is active, i.e. there is some pending work in Rx. 

           ";
    ValRandomize = true;
  } RxActive[24:24] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
         Defines the Rx Descriptor sise: 
           * 0 : 16-byte descriptors.
           * 1 : 32-byte descriptors.
         Must be set to 1. Only 32-byte descriptors are supported.

           ";
    ValRandomize = true;
  } RxDescSize[23:23] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
         Minimum MSS allowed. If a TSO session request an MSS lower than this limit, then the queue is shut down and an event is posted.

           ";
    ValRandomize = true;
  } MinMSS[22:9] = 14'h64;
  field {
    AccessType = "RW";
    desc = "
         Defines log2() of maximum waiting time for descriptors to become available. The maximum time is 2^^31 * PCLK.  

           ";
    ValRandomize = true;
  } MaxHoldTime[8:4] = 5'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_3_[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
         Resets the PEP internal data path. The bit is cleared by hardware.

           ";
    ValRandomize = true;
  } DataPathReset[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
         Defines the maximum number of queues that will be enabled. It induces the maximum number of Rx descriptors that can be stored per queue in the internal Rx descriptor cache. The same configuration shall be made in all TQDLOC[Q] registers for the number of Tx descriptors stored internally per queue. An undefined PEP behavior may result in case PF enables more queues than the upper limit specified by this field. 
           * 00b : maximum of 256 queues, i.e. internal storage capacity for up to 32 Rx descriptors per queue.
           * 01b : maximum of 128 queues, i.e. internal storage capacity for up to 64 Rx descriptors per queue.
           * 10b : maximum of 64 queues, i.e. internal storage capacity for up to 128 Rx descriptors per queue.

           ";
    ValRandomize = true;
  } MaxNumOfQs[1:0] = 2'h0;
};



// PCIE_DMA_CTRL2

reg pcie_dma_ctrl2_r {
  shared;
  HandCoded = true;
  name = "DMA Control 2 Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_22_18_[22:18] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
         Defines time between from starting frame transmit to switch to next start frame. The time is defined in 2ns increment for GEN3, 4ns for GEN2 and 8ns for GEN1. Setting this value to anything smaller than 10 is equivalent to sending frames back to back with no space in between frames as the time would be smaller than the minimum packet size (72B). 
This feature is not supported, the field shall be set to 0.         

           ";
    ValRandomize = true;
  } TxFrameSpacing[17:10] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicates if the switch is ready or not. 

           ";
    ValRandomize = true;
  } SwitchReady[9:9] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Controls the relative priority of Rx descriptor read w.r.t. Tx descriptor and Tx data read processes. Each process shall be mapped to a unique priority value:   
           0: - Highet priority
           1, 3, 2 - Round-robin at medium priority
           4 - Lowest priority
The driver shall never set the same value in two or more DMA_CTRL2.xxxReadPrio fields.
It is recommended to use only the default setting.

           ";
    ValRandomize = true;
  } RxDescReadPrio[8:6] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
        Controls the relative priority of Tx descriptor read w.r.t. Rx descriptor and Tx data read processes. Each process shall be mapped to a unique priority value:   
           0: - Highet priority
           1, 3, 2 - Round-robin at medium priority
           4 - Lowest priority
The driver shall never set the same value in two or more DMA_CTRL2.xxxReadPrio fields.
It is recommended to use only the default setting.

           ";
    ValRandomize = true;
  } TxDescReadPrio[5:3] = 3'h1;
  field {
    AccessType = "RW";
    desc = "
        Controls the relative priority of Tx data read w.r.t. Rx descriptor and Tx deacriptor read processes. Each process shall be mapped to a unique priority value:   
           0: - Highet priority
           1, 3, 2 - Round-robin at medium priority
           4 - Lowest priority
The driver shall never set the same value in two or more DMA_CTRL2.xxxReadPrio fields.
It is recommended to use only the default setting.

           ";
    ValRandomize = true;
  } TxDataReadPrio[2:0] = 3'h4;
};



// PCIE_DTXTCPFLGL

reg pcie_dtxtcpflgl_r {
  shared;
  HandCoded = true;
  name = "DMA Tx TCP Flags Control Low";
  desc = "
    This register holds the mask bits for the TCP flags in Tx segmentation.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        TCP Flags First Segment. Bits that make AND operation with the TCP flags at TCP header in the first segment.

           ";
    ValRandomize = true;
  } TCP_flg_first_seg[31:20] = 12'hFF6;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_19_16_[19:16] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
        TCP Flags Middle Segments. The low bits that make AND operation with the TCP flags at TCP header in the middle segments.

           ";
    ValRandomize = true;
  } TCP_Flg_mid_seg[15:4] = 12'hFF6;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_3_0_[3:0] = 4'h0;
};



// PCIE_DTXTCPFLGH

reg pcie_dtxtcpflgh_r {
  shared;
  HandCoded = true;
  name = "DMA Tx TCP Flags Control High";
  desc = "
    This register holds the mask bits for the TCP flags in Tx segmentation.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        TCP Flags Last Segment. Bits that make AND operation with the TCP flags at TCP header in the last segment.

           ";
    ValRandomize = true;
  } TCP_Flg_lst_seg[31:20] = 12'hF7F;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_19_0_[19:0] = 20'h0;
};



// PCIE_TPH_CTRL

reg pcie_tph_ctrl_r {
  shared;
  HandCoded = true;
  name = "TPH Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_11_5_[11:5] = 7'h0;
  field {
    AccessType = "RO";
    desc = "
        Disable Read Hint: If clear, RRC uses the RXCTL.CPUID field for receive PCIe read transactions with TPH bit set and the TXCTL.CPUID for transmit PCIe read transactions. If set to 1, a CPUID value of zero is used in receive and transmit PCIe read transactions.

        * This field is not operational in RRC, has been fixed to 1 *

           ";
    ValRandomize = true;
  } DisableReadHint[4:4] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Descriptor PH - defines the PH field used when a TPH hint is given for descriptor associated traffic (descriptor fetch, descriptor write back).

           ";
    ValRandomize = true;
  } DescPH[3:2] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        RW Data PH - defines the PH field used when a TPH hint is given for data associated traffic (Tx data read, Rx data write).        

           ";
    ValRandomize = true;
  } DataPH[1:0] = 2'h2;
};



// PCIE_MRQC[0..64]

reg pcie_mrqc_r {
  shared;
  HandCoded = true;
  name = "Multiple Receive Queues Command Register";
  desc = "
    Queue assignment control. Index 1..64 is for VF, index 0 is for PF. Each bit, when set, enables a specific field selection to be used by the hash function. Several bits can be set at the same time. The bit PCIE_DGLORTDEC[x].InnerRSS controls if fields are from outer or inner IP header (if present). 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Enable TcpIPv4 hash function.

           ";
    ValRandomize = true;
  } TcpIPv4[7:7] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable IPv4 hash function.

           ";
    ValRandomize = true;
  } IPv4[6:6] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_5_4_[5:4] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable IPv6 hash function.

           ";
    ValRandomize = true;
  } IPv6[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable TcpIPv6 hash function.

           ";
    ValRandomize = true;
  } TcpIPv6[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable UdpIPv4 hash function.

           ";
    ValRandomize = true;
  } UdpIPv4[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable UdpIPv6 hash function.

           ";
    ValRandomize = true;
  } UdpIPv6[0:0] = 1'h0;
};



// PCIE_TQMAP[0..2047]

reg pcie_tqmap_r {
  shared;
  HandCoded = true;
  name = "Transmit Queue Mapping";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Defines the physical queue number for a virtual queue on TX. If NumVFs is greater than 8, then the index is (vf*32 + q&amp;31), otherwise, the index is (vf*256 + q).   

           ";
    ValRandomize = true;
  } PhysicalQueue[7:0] = 8'h0;
};



// PCIE_RQMAP[0..2047]

reg pcie_rqmap_r {
  shared;
  HandCoded = true;
  name = "Receive Queue Mapping";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Defines the physical queue number for a virtual queue on RX. If NumVFs is greater than 8, then the index is (vf*32 + q&amp;31), otherwise, the index is (vf*256 + q).   

           ";
    ValRandomize = true;
  } PhysicalQueue[7:0] = 8'h0;
};



// PCIE_STATS_TIMEOUT

reg pcie_stats_timeout_r {
  shared;
  HandCoded = true;
  name = "Count Completion Timeouts";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of PEP requests to PCIe which ended as completion Timeout.

           ";
    ValRandomize = true;
  } Timeout[31:0] = 32'h0;
};



// PCIE_STATS_UR

reg pcie_stats_ur_r {
  shared;
  HandCoded = true;
  name = "Count Unsupported Requests";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of PEP requests to PCIe which completed as Unsupported Request (UR).

           ";
    ValRandomize = true;
  } Timeout[31:0] = 32'h0;
};



// PCIE_STATS_CA

reg pcie_stats_ca_r {
  shared;
  HandCoded = true;
  name = "Count Completer Aborts";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of PEP requests to PCIe which ended as Completer Abort (CA).

           ";
    ValRandomize = true;
  } Timeout[31:0] = 32'h0;
};



// PCIE_STATS_UM

reg pcie_stats_um_r {
  shared;
  HandCoded = true;
  name = "Count Unsupported Messages Received *Register not implemented in A0 step*";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of PCIe messages received from host which are not supported by the PEP and that were silently dropped.

           ";
    ValRandomize = true;
  } Timeout[31:0] = 32'h0;
};



// PCIE_STATS_XEC

reg pcie_stats_xec_r {
  shared;
  HandCoded = true;
  name = "Count Packet with Checksum Errors";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of packets received with either IPv4, TCP, UDP or SCTP XSUM errors. Counter not when a packet has any MAC error (CRC, length, under-size, over-size, byte error or symbol error).

           ";
    ValRandomize = true;
  } XEC[31:0] = 32'h0;
};



// PCIE_STATS_VLAN_DROP

reg pcie_stats_vlan_drop_r {
  shared;
  HandCoded = true;
  name = "Count VLAN Membership Drops";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Count the number of packets dropped due to VLAN membership. 

           ";
    ValRandomize = true;
  } Drop[31:0] = 32'h0;
};



// PCIE_STATS_LOOPBACK_DROP

reg pcie_stats_loopback_drop_r {
  shared;
  HandCoded = true;
  name = "Count Loopback Suppress Drops";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Count the number of packets dropped due to loopback suppress.  

           ";
    ValRandomize = true;
  } Drop[31:0] = 32'h0;
};



// PCIE_STATS_NODESC_DROP

reg pcie_stats_nodesc_drop_r {
  shared;
  HandCoded = true;
  name = "Count No Descriptors Drop";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Count the number of packets dropped due to lack of descriptors. 

           ";
    ValRandomize = true;
  } Drop[31:0] = 32'h0;
};



// PCIE_RRTIME_CFG

reg pcie_rrtime_cfg_r {
  shared;
  HandCoded = true;
  name = "Read Response Time Configuration";
  desc = "
    Defines the read response time measurement filter. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Define ID to watch. 

           ";
    ValRandomize = true;
  } UnitID[13:6] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines what is being monitored:
        
            * 0 : don't filter, all read completion measured
            * 1 : only tracks read requests for PF
            * 2 : only tracks read requests for VF defined in UnitID
            * 3 : only tracks read requests for queue defined in UnitID

           ";
    ValRandomize = true;
  } FilterType[5:4] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines what type of read request is monitored:
        
            * bit 0: watch RX descriptor read requests
            * bit 1: watch TX descriptor read requests
            * bit 2: watch TX packet read requests

           ";
    ValRandomize = true;
  } TransactionType[3:1] = 3'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Request to clear all RRTIME_COUNT registers. The bit is self-cleared by the device once the counters have been reset. 

           ";
    ValRandomize = true;
  } ResetCounts[0:0] = 1'h0;
};



// PCIE_RRTIME_LIMIT[0..2]

reg pcie_rrtime_limit_r {
  shared;
  HandCoded = true;
  name = "Read Response Time Limit";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines the time limit for counting purpose.  

           ";
    ValRandomize = true;
  } TimeLimit[15:0] = 16'h0;
};



// PCIE_RRTIME_COUNT[0..3]

reg pcie_rrtime_count_r {
  shared;
  HandCoded = true;
  name = "Read Response Time Event Count";
  desc = "
    Tracks event count for each bin:
    
        * RRTIME_COUNT[0] : count if time &lt;= RRTIME_LIMIT[0]
        * RRTIME_COUNT[1] : count if time &lt;= RRTIME_LIMIT[1]
        * RRTIME_COUNT[2] : count if time &lt;= RRTIME_LIMIT[2]
        * RRTIME_COUNT[3] : count if time  &gt; RRTIME_LIMIT[2]
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
         Count the events on that bin.

           ";
    ValRandomize = true;
  } CountEvent[31:0] = 32'h0;
};



// PCIE_SYSTIME

reg pcie_systime_r {
  shared;
  HandCoded = true;
  name = "System Time";
  desc = "
    Time reference. The time unit is system implementation depended but should
    normally represent nanoseconds.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        System time.

           ";
    ValRandomize = true;
  } CurrentTime[63:0] = 64'h0;
};



// PCIE_SYSTIME0

reg pcie_systime0_r {
  shared;
  HandCoded = true;
  name = "System Time Initial Value";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        The content of this register is transfered to PCIE_SYSTIME at 
        time 0 reset from management. 

           ";
    ValRandomize = true;
  } Time0[63:0] = 64'h0;
};



// PCIE_SYSTIME_CFG

reg pcie_systime_cfg_r {
  shared;
  HandCoded = true;
  name = "System Time Configuration";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        The number of time unit per tick. This shall be at least 2, values or 1 or 0 are not surported.  

           ";
    ValRandomize = true;
  } Step[3:0] = 4'h1;
};



// PCIE_PFVFBME

reg pcie_pfvfbme_r {
  shared;
  HandCoded = true;
  name = "BME bit state of the VFs";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Bit [n] reflects the current setting of the BME bit in the VF[n] configuration space.  

           ";
    ValRandomize = true;
  } VFBME[63:0] = 64'h0;
};



// PCIE_PHYADDR

reg pcie_phyaddr_r {
  shared;
  HandCoded = true;
  name = "Physical Address Space Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Bitmask that defines the size of the host physical address space. Out of range accesses are not sent to host and are terminated internally as Unsupported Requests(UR). Default is a 48-bits address space.
       * 00000000000000000000000000000000b: 32-bit address space.
       * 00000000000000000000000000000001b: 33-bit address space.
       * 00000000000000000000000000000011b: 34-bit address space.
       * etc.
       * 00000000000000001111111111111111b: 48-bit address space.
       * etc.
       * 01111111111111111111111111111111b: 63-bit address space.
       * 11111111111111111111111111111111b: 64-bit address space.

           ";
    ValRandomize = true;
  } PhyAddrSpace[31:0] = 32'h0000FFFF;
};



// PCIE_RDBAL

reg pcie_rdbal_r {
  shared;
  HandCoded = true;
  name = "Receive Descriptor Base Address Low";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_31_25_[31:25] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Receive Descriptor Base Address Low.

      This register contains the lower bits of the 64-bit descriptor base address. The lower 7 bits are always ignored. The receive descriptor base address must point to a 128 byte-aligned block of data.

           ";
    ValRandomize = true;
  } RDBAL[24:0] = 25'h0;
};



// PCIE_RDBAH

reg pcie_rdbah_r {
  shared;
  HandCoded = true;
  name = "Receive Descriptor Base Address High";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Receive Descriptor Base Address [63:32].

      This register contains the upper 32 bits of the 64-bit descriptor base address.

           ";
    ValRandomize = true;
  } RDBAH[31:0] = 32'h0;
};



// PCIE_RDLEN

reg pcie_rdlen_r {
  shared;
  HandCoded = true;
  name = "Receive Descriptor Length";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_19_13_[19:13] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Descriptor Ring Length. This register sets the number of bytes allocated for descriptors in the circular descriptor buffer. It is expressed in units of 128 bytes. Minimum supported value for this field is 32 (128 descriptors of 32B each).

        Note: Validated lengths up to 512KB (32768 descriptors of 16B or 16K descriptors of 32B).

           ";
    ValRandomize = true;
  } LEN[12:0] = 13'h20;
};



// PCIE_TPH_RXCTRL

reg pcie_tph_rxctrl_r {
  shared;
  HandCoded = true;
  name = "Rx TPH Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved1_31_27[31:27] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
        Descriptor TPH EN. When set, hardware enables TPH for all Rx descriptors written back into memory. When cleared, hardware does not enable TPH for descriptor write-backs.

           ";
    ValRandomize = true;
  } RxDescriptorTPHEN[26:26] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Rx Header TPH EN. When set, hardware enables TPH for all received header buffers. When cleared, hardware does not enable TPH for Rx Headers.

           ";
    ValRandomize = true;
  } RxHeaderTPHEN[25:25] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Payload TPH EN. When set, hardware enables TPH for all Ethernet payloads written into memory. When cleared, hardware does not enable TPH for Ethernet payloads. Default cleared.

           ";
    ValRandomize = true;
  } RxPayloadTPHEN[24:24] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved2[23:23] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Rx Descriptor Read Relax Order Enable

           ";
    ValRandomize = true;
  } RXdescReadROEn[22:22] = 1'h1;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved3[21:21] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Rx Descriptor Write Back Relax Order Enable. This bit must be 0b to enable correct functionality of the descriptors write back.

           ";
    ValRandomize = true;
  } RXdescWBROen[20:20] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved4[19:19] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Rx data Write Relax Order Enable

           ";
    ValRandomize = true;
  } RXdataWriteROEn[18:18] = 1'h1;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved5[17:17] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Rx Split Header Relax Order Enable

           ";
    ValRandomize = true;
  } RxRepHeaderROEn[16:16] = 1'h1;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved6[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Physical ID for TPH operated in DeviceSpecific mode.

        Legacy TPH capable platforms -- the device driver, upon discovery of the physical CPU ID and CPU bus ID, programs the CPUID field with the physical CPU and bus ID associated with this Rx queue.

        TPH 1.0 capable platforms -- the device driver programs a value, based on the relevant APIC ID, associated with this Rx queue.

        * This field is not operational in RRC, has been made RO *

           ";
    ValRandomize = true;
  } CPUID[7:0] = 8'h0;
};



// PCIE_RDH

reg pcie_rdh_r {
  shared;
  HandCoded = true;
  name = "Receive Descriptor Head";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Receive Descriptor Head. This register holds the head pointer for the receive descriptor buffer in descriptor units. The RDH is controlled by hardware.

           ";
    ValRandomize = true;
  } RDH[15:0] = 16'h0;
};



// PCIE_RDT

reg pcie_rdt_r {
  shared;
  HandCoded = true;
  name = "Receive Descriptor Tail";
  desc = "
    This register contains the tail pointer for the receive descriptor buffer in descriptor units. Software writes the tail register to add receive descriptors to the hardware free list for the ring.

    The tail pointer should be set to one descriptor beyond the last empty descriptor in host descriptor ring.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Receive Descriptor Tail.

           ";
    ValRandomize = true;
  } RDT[15:0] = 16'h0;
};



// PCIE_RXQCTL

reg pcie_rxqctl_r {
  shared;
  HandCoded = true;
  name = "Receive Queue Control";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Receive Queue Enable. When set, the ENABLE bit enables the operation of the specific receive queue.

           ";
    ValRandomize = true;
  } ENABLE[8:8] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[7:7] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Indicates to which VF this queue belongs. This register is RW when accessed from PF and RO when accessed from VF. Driver is allowed to change this field only while the ENABLE bit is clear.

           ";
    ValRandomize = true;
  } VF[6:1] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
        Indicates this queue belongs to a Virtual Function, it overrides the VF field if cleared. This register is RW when accessed from PF and RO when accessed from VF. Driver is allowed to change this field only while the ENABLE bit is clear.

           ";
    ValRandomize = true;
  } OwnedByVF[0:0] = 1'h0;
};



// PCIE_RXDCTL

reg pcie_rxdctl_r {
  shared;
  HandCoded = true;
  name = "Receive Descriptor Control";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Max time before writing back descriptors. Time is in 512 * PCLK periods.   A value of 0 means no delay. Only used on end of packet descriptors. For non-end of packet descriptors, the descriptors are hold until a cache line if full and then written. This field can be modified only while the queue is disabled.    

           ";
    ValRandomize = true;
  } MaxTime[10:3] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
       Defines if descriptor written back immediately regardless how full is a 64B cache line. This field can be modified only while the queue is disabled.    

           ";
    ValRandomize = true;
  } WriteBackImm[2:2] = 1'h0;
  field {
    encode = pcie_rxdctl_drop_on_empty_enum;
    AccessType = "RW";
    desc = "
        Defines if frames are dropped or hold when a queue is empty.
        

           ";
    ValRandomize = true;
  } DropOnEmpty[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines, for 16B descriptor, if the RSS-HASH field or DGLORT/SGLORT gets written to the descriptor. For 32B descriptors, both fields get written.
        
           * RSS_HASH(1) : write RSS Hash (32b) to descriptor
           * DGLORT/SGLORT : write DGLORT/SGLORT to descriptor
        
        **OBSOLETE, NOT IMPLEMENTED**

           ";
    ValRandomize = true;
  } WriteRSSHash[0:0] = 1'h0;
};



// PCIE_RXINT

reg pcie_rxint_r {
  shared;
  HandCoded = true;
  name = "Receive Interrupt Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines the MSI-X interrupt vector number used by this queue. This number is relative to the base of the interrupt blocks assigned to a VF or PF.

           ";
    ValRandomize = true;
  } Interrupt[9:2] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines which timer to use for interrupt vector. Valid values are 0,1,2 or 3:
        
        * 0 : use ITR timer 0
        * 1 : use ITR timer 1
        * 2 : use ITR timer 2 (immediate, no timer)
        * 3 : disable this interrupt

           ";
    ValRandomize = true;
  } InterruptTimer[1:0] = 2'h0;
};



// PCIE_SRRCTL

reg pcie_srrctl_r {
  shared;
  HandCoded = true;
  name = "Split Receive Control Registers";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Receive Buffer Size for Packet Buffer. The value is in 256 bytes resolution. Value can be from 256B to 16KB. Default buffer size is 2 KB. This field should not be set to 0x0. 

           ";
    ValRandomize = true;
  } BSIZEPACKET[31:24] = 8'h8;
  field {
    AccessType = "RW";
    desc = "
        Receive Buffer Size for Header Buffer. The value is in 64 bytes resolution. Value can be from 64 bytes to 1024 bytes. Note that the maximum supported header size is limited to 1023. Default buffer size is 256 bytes. 

        Values above 1024 bytes are reserved for internal use only.

           ";
    ValRandomize = true;
  } BSIZEHEADER[23:18] = 6'h4;
  field {
    AccessType = "RW";
    desc = "
        Define the descriptor type in Rx:
        
        * 0: No header split
        * 1: Header split. Header uses header buffer, unless it can't fit. Packet split boundary defined in PSRTYPE.  
        * 2: Small/larger split. Small packets use small packet buffer, large packets use normal packet data buffer.
        
        Note: If DESCTYPE is set to 1 or 2, then BSIZEHEADER must be bigger than zero and BufferChainingEn must be set to zero. Otherwise, no header split occurs.

           ";
    ValRandomize = true;
  } DESCTYPE[17:16] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_0[15:15] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_1[14:14] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_2[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_3[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_4[11:11] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_5[10:10] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_6[9:9] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_7[8:8] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_8[7:7] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_9[6:6] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_10[5:5] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_11[4:4] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_12[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Packets are split according to the lowest-indexed entry that applies to the packet and that is enabled. For example, if bits 6 and 8 are set, then an IPv4 packet that is not TCP is split after the IPv4 header.
    
        This bit mask table enables or disables each type of header to be split. A value of 1b enables an entry.
        
            * PSTYPE[0]: split after TCP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[1]: split after UDP of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[2]: split after IPv4 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[3]: split after IPv6 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[4]: split after L2 of inner header (VXLAN, NVGRE, or NGE)
            * PSTYPE[5]: split after NVGRE/VXLAN/NGE header, but not inner packet
            * PSTYPE[6]: split after TCP of outer header
            * PSTYPE[7]: split after UDP of outer header
            * PSTYPE[8]: split after IPv4 of outer header
            * PSTYPE[9]: split after IPv6 of outer header
            * PSTYPE[10]: split after L2 of outer header

           ";
    ValRandomize = true;
  } PSRTYPE_13[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines if Loopback Suppress (compare SGLORT) is enabled or not. 

           ";
    ValRandomize = true;
  } LoopbackSuppress[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Buffer Chaining enable. When set to 1b, a packet can be spread over more than one single receive data buffer. When clear to 0b, any packet longer than the data buffer size is terminated with a TOO_BIG error status in Rx descriptor write-back. The remainder of the frame is not posted to host, it is silently dropped.

           ";
    ValRandomize = true;
  } BufferChainingEn[0:0] = 1'h0;
};



// PCIE_QPRC

reg pcie_qprc_r {
  shared;
  HandCoded = true;
  name = "Queue Packets Received Count";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of packets received for the queue. 

           ";
    ValRandomize = true;
  } PRC[31:0] = 32'h0;
};



// PCIE_QPRDC

reg pcie_qprdc_r {
  shared;
  HandCoded = true;
  name = "Queue Packets Received Drop Count";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Total number of receive packets dropped for the queue. Packets can be dropped for the following reasons:

          * Rx queue is disabled in the RXQCTL[n] register.
          * No free descriptors in the Rx queue and set to drop in this case. 
          * VLAN membership violation (also counted in PCIE_STATS_VLAN_DROP).
          * Loopback suppress (also counted in PCIE_STATS_LOOPBACK_DROP).
          * Packet too small (smaller than 48B, though the switch will never forward such packets to the PEP).
          * Rx path disabled, i.e. DMA_CTRL.RxEnable bit is cleared.

           ";
    ValRandomize = true;
  } PRDC[31:0] = 32'h0;
};



// PCIE_QBRC_L

reg pcie_qbrc_l_r {
  shared;
  HandCoded = true;
  name = "Queue Bytes Received Count Low";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Lower 32 bits of the statistic counter. The QBRC_L[n] and QBRC_H[n] registers make up a logical 48-bit counter of received bytes that were posted to the programmed Rx queues of the packets counted by QPRC[n].

        The counter counts all bytes from DMAC (included) to TIME TAG (excluded). 

           ";
    ValRandomize = true;
  } BRC_L[31:0] = 32'h0;
};



// PCIE_QBRC_H

reg pcie_qbrc_h_r {
  shared;
  HandCoded = true;
  name = "Queue Bytes Received Count High";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Higher 16 bits of the statistic counter described in QBRC_L.

           ";
    ValRandomize = true;
  } BRC_H[15:0] = 16'h0;
};



// PCIE_RX_SGLORT

reg pcie_rx_sglort_r {
  shared;
  HandCoded = true;
  name = "Source Glort for each Q";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         Source GLORT to use when checking for loopback suppress. 

           ";
    ValRandomize = true;
  } SGlort[15:0] = 16'h0;
};



// PCIE_TDBAL

reg pcie_tdbal_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Base Address Low";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[31:25] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Transmit Descriptor Base Address Low.

      This register contains the lower bits of the 64-bit descriptor base address. The lower seven bits are ignored. The Transmit Descriptor Base Address must point to a 128 byte-aligned block of data.

           ";
    ValRandomize = true;
  } TDBAL[24:0] = 25'h0;
};



// PCIE_TDBAH

reg pcie_tdbah_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Base Address High";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Transmit Descriptor Base Address [63:32].

      This register contains the upper 32 bits of the 64 bit Descriptor base address.

           ";
    ValRandomize = true;
  } TDBAH[31:0] = 32'h0;
};



// PCIE_TDLEN

reg pcie_tdlen_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Length";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[19:13] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Descriptor Ring Length. This register sets the number of bytes allocated for descriptors in the circular descriptor buffer. It is expressed in units of 128 bytes. Minimum supported value for this field is 4 (32 descriptors of 16B each). 

        Note: Validated lengths up to 512KB (32768 descriptors of 16B).

           ";
    ValRandomize = true;
  } LEN[12:0] = 13'h4;
};



// PCIE_TPH_TXCTRL

reg pcie_tph_txctrl_r {
  shared;
  HandCoded = true;
  name = "Tx TPH Control Registers";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_31_27_[31:27] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
        Descriptor TPH Enable. When set, hardware enables TPH for all Tx descriptors written back into memory. When cleared, hardware does not enable TPH for descriptor write-backs. This bit is cleared as a default.

           ";
    ValRandomize = true;
  } TxDescriptorTPHEN[26:26] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_25_23_[25:23] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
        Tx Descriptor Read Relax Order Enable.

           ";
    ValRandomize = true;
  } TXdescRDROEn[22:22] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_21_[21:21] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Relax Order Enable of Tx Descriptor as well as head pointer write back (when set).

           ";
    ValRandomize = true;
  } TXdescWBROen[20:20] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_19_[19:19] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Tx Data Read Relax Order Enable.

           ";
    ValRandomize = true;
  } TXDataReadROEn[18:18] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_17_8_[17:8] = 10'h0;
  field {
    AccessType = "RO";
    desc = "
        Physical ID for TPH operated in DeviceSpecific mode.

        Legacy TPH capable platforms -- the device driver, upon discovery of the physical CPU ID and CPU bus ID, programs the CPUID field with the physical CPU and bus ID associated with this Tx queue.

        TPH 1.0 capable platforms -- the device driver programs a value, based on the relevant APIC ID, associated with this Tx queue.

        * This field is not operational in RRC, has been made RO *

           ";
    ValRandomize = true;
  } CPUID[7:0] = 8'h0;
};



// PCIE_TDH

reg pcie_tdh_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Head";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Transmit Descriptor Head.
        
        This register contains the head pointer for the transmit descriptor ring. It is expressed in descriptor units. Hardware controls this pointer.
        
        The values in these registers might point to descriptors that are still not in the host memory. As a result, the host cannot rely on these values in order to determine which descriptor to release.
        
        The only time that software should write to this register is after a reset (hardware reset or CTRL.RST) and before enabling the transmit function (TXDCTL.ENABLE). If software were to write to this register while the transmit function was enabled, the on-chip descriptor buffers might be invalidated and the hardware could become confused.

           ";
    ValRandomize = true;
  } TDH[15:0] = 16'h0;
};



// PCIE_TDT

reg pcie_tdt_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Tail";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Transmit Descriptor Tail.
        
        This register contains the tail pointer for the transmit descriptor ring. It is expressed in descriptor units. Software writes the tail pointer to add more descriptors to the transmit ready queue. Hardware attempts to transmit all packets referenced by descriptors between head and tail.

           ";
    ValRandomize = true;
  } TDT[15:0] = 16'h0;
};



// PCIE_TXDCTL

reg pcie_txdctl_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Control";
  desc = "
    This register controls the fetching and write-back of transmit descriptors. The two threshold values are used to determine when descriptors is read from host memory and only applies in the pull descriptor model. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        **OBSOLETE, NOT IMPLEMENTED**

        Pre-Fetch Threshold

        Controls when a prefetch of descriptors is considered. This threshold refers to the number of valid, unprocessed transmit descriptors the  has in its on-chip buffer. If this number drops below PTHRESH, the algorithm considers pre-fetching descriptors from host memory. However, this fetch does not happen unless there are at least HTHRESH valid descriptors in host memory to fetch.

        Note: HTHRESH should be given a non-zero value each time PTHRESH is used.

           ";
    ValRandomize = true;
  } PTHRESH[28:22] = 7'h0;
  field {
    AccessType = "RO";
    desc = "
        **OBSOLETE, NOT IMPLEMENTED**

        Host Threshold.

           ";
    ValRandomize = true;
  } HTHRESH[21:15] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Transmit Queue Enable.

        When set, this bit enables the operation of a specific transmit queue:

        Default value for all queues is 0b.

           ";
    ValRandomize = true;
  } ENABLE[14:14] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Max idle time before posting last descriptor write back and an interrupt. Time is in 512 * PCLK periods. The RS overwrites the write back. A value of 0 means no delay.

           ";
    ValRandomize = true;
  } MaxTime[12:1] = 12'h0;
  field {
    encode = pcie_txdctl_push_desc_enum;
    AccessType = "RW";
    desc = "
        Defines if this queue has the descriptors written into the controller (push model) or if the controller read descriptors from host memory (pull model). 
        

           ";
    ValRandomize = true;
  } PushDesc[0:0] = 1'h0;
};



// PCIE_TXQCTL

reg pcie_txqctl_r {
  shared;
  HandCoded = true;
  name = "Transmit Queue Control";
  desc = "
    This register is RW when accessed from PF and RO when accessed from VF. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Indicates to which VF this queue belongs. This register is RW when accessed from PF and RO when accessed from VF. Driver is allowed to change this field only while the ENABLE bit of the queue is clear.

           ";
    ValRandomize = true;
  } VF[29:24] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
        Indicates this queue belongs to a Virtual Function, it invalidates the VF field if cleared. This register is RW when accessed from PF and RO when accessed from VF. Driver is allowed to change this field only while the ENABLE bit of the queue is clear.

           ";
    ValRandomize = true;
  } OwnedByVF[23:23] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines the Priority Flow Control Class (Pause Class). This register is RW when accessed from PF and RO when accessed from VF.

           ";
    ValRandomize = true;
  } PC[22:20] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
        Traffic class, defines the shaping group to which this queue belongs. Meaningful only when UnlimitedBW bit is cleared.

           ";
    ValRandomize = true;
  } TC[19:14] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines the default VLAN ID for the queue if none supplied. This value could be 0. If this default VLAN ID is set to 0 and the host set to 0 then the switch will assign a default VLAN ID.

           ";
    ValRandomize = true;
  } VID[13:2] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
        This bit provides the ability to create a 65th TC with unlimited bandwidth. Usage model envisaged is for the PF's queue when there are 64 enabled VFs, each one with its own TC. Setting this bit makes the TC field meaningless.

           ";
    ValRandomize = true;
  } UnlimitedBW[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        This bit provides the ability for the PF to not allow the VF to use the queue in push mode. This is a chicken bit for the case a security issue will be found in push mode. 

           ";
    ValRandomize = true;
  } PushModeDis[0:0] = 1'h0;
};



// PCIE_TXINT

reg pcie_txint_r {
  shared;
  HandCoded = true;
  name = "Transmit Interrupt Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines the MSI-X interrupt vector number used by this queue. This number is relative to the base of the interrupt blocks assigned to a VF or PF.

           ";
    ValRandomize = true;
  } Interrupt[9:2] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines which timer to use for interrupt vector. Valid values are 0,1,2 or 3:
        
        * 0 : use ITR timer 0
        * 1 : use ITR timer 1
        * 2 : use ITR timer 2 (immediate, no timer)
        * 3 : disable this interrupt        

           ";
    ValRandomize = true;
  } InterruptTimer[1:0] = 2'h0;
};



// PCIE_QPTC

reg pcie_qptc_r {
  shared;
  HandCoded = true;
  name = "Queue Packets Transmitted Count";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Number of packets transmitted for the queue. A packet is considered as transmitted if it is was forwarded to the Ethernet switch for switching and transmission to the network. 

           ";
    ValRandomize = true;
  } PTC[31:0] = 32'h0;
};



// PCIE_QBTC_L

reg pcie_qbtc_l_r {
  shared;
  HandCoded = true;
  name = "Queue Bytes Transmitted Count Low";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Lower 32 bits of the statistic counter. The QBTC_L and QBTC_H registers make up a logical 48-bit counter of transmitted bytes of the packets counted by the matched QPTC counter. These registers count all bytes in the packets from the DMAC field (included) through the TIME TAG field (excluded). These registers must be accessed as two consecutive 32-bit entities while the QBTC_L register is read first, or a single 64-bit read cycle. 

           ";
    ValRandomize = true;
  } BTCL[31:0] = 32'h0;
};



// PCIE_QBTC_H

reg pcie_qbtc_h_r {
  shared;
  HandCoded = true;
  name = "Queue Bytes Transmitted Count High";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Higher 16 bits of the statistic counter described in QBTC_L.

           ";
    ValRandomize = true;
  } BTCH[15:0] = 16'h0;
};



// PCIE_TQDLOC

reg pcie_tqdloc_r {
  shared;
  HandCoded = true;
  name = "Tx Descriptors Location in Tx Cache";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines the base location of the descriptor area in 64B chunks. Only 3 allocation schemes are supported where Base for Q index i is set to 
           * ix8: when DMA_CTRL.MaxNumOfQs is set to 00b (256 Qs).
           * ix16: when DMA_CTRL.MaxNumOfQs is set to 01b (128 Qs).
           * ix32: when DMA_CTRL.MaxNumOfQs is set to 10b (64 Qs).

        This field is read only when accessed from VF.

           ";
    ValRandomize = true;
  } Base[19:4] = 16'h0;
  field {
    encode = pcie_tqdloc_size_enum;
    AccessType = "RW";
    desc = "
        Defines the size of the descriptor area in log2(N). Minimum is 2 (4 descriptors) and maximum is 8 (256 descriptors).  Only 3 Sizes supported
        
        This field is read only when accessed from VF.

           ";
    ValRandomize = true;
  } Size[3:0] = 4'h0;
};



// PCIE_TX_SGLORT

reg pcie_tx_sglort_r {
  shared;
  HandCoded = true;
  name = "Source Glort for each Q";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Source GLORT to use when sending a packet to switch for this Q.

           ";
    ValRandomize = true;
  } SGlort[15:0] = 16'h0;
};



// PCIE_PFVTCTL

reg pcie_pfvtctl_r {
  shared;
  HandCoded = true;
  name = "VT Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Indicates if a Tx Queue is allowed to send packets with FTAG or not. 

           ";
    ValRandomize = true;
  } FTagDescEnable[0:0] = 1'h0;
};



// PCIE_TX_DESC[0..255,0..255,0..3]

reg pcie_tx_desc_r {
  shared;
  HandCoded = true;
  name = "Transmit Descriptor Cache";
  desc = "
    Used to store data and control. Indexing is [queue#,desc#,word#].
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1S/V";
    desc = "

           ";
    ValRandomize = true;
  } Data[31:0] = 32'h0;
};
regfile pcie_tx_desc_rf {
  pcie_tx_desc_r PCIE_TX_DESC[4] += 8;
};
regfile pcie_tx_desc_rff {
  pcie_tx_desc_rf PCIE_TX_DESC[256] += 32;
};



// PCIE_PBACL[0..71]

reg pcie_pbacl_r {
  shared;
  HandCoded = true;
  name = "Pending Bit Array Table";
  desc = "
    MSI-X bit pending array. Indexes 0 to 7 are for physical function and 8..71 for virtual functions.  The PBACL[8..71] are also visible through VF BAR2/3.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a pending bit. Writings '1's clear corresponding bit. Reading returns current value. 

           ";
    ValRandomize = true;
  } PendingBits[31:0] = 32'h0;
};



// PCIE_INT_MAP[0..15]

reg pcie_int_map_r {
  shared;
  HandCoded = true;
  name = "Interrupt Mapping Register";
  desc = "
    Defines the interrupt number for each source (PF). The index to this table indicates the type of interrupt and the output is the index to the MSI-X vector table. See Interrupt and Faults section for interrupt allocation. 
    
    The following vectors are used:
    
    * PCIE_INT_MAP[0]: Mailbox
    * PCIE_INT_MAP[1]: Fault
    * PCIE_INT_MAP[2]: Switch up/down event
    * PCIE_INT_MAP[3]: Switch interrupt
    * PCIE_INT_MAP[4]: SRAM interrupt. Must be mapped to MSI-X vector 0.
    * PCIE_INT_MAP[5]: VFLR interrupt
    * PCIE_INT_MAP[6]: Max hold time interrupt
    * PCIE_INT_MAP[7]: Visa trap interrupt
    
    The PCIE_INT_MAP[8..15] are not used in this design.  
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Interrupt number.

           ";
    ValRandomize = true;
  } Interrupt[9:2] = 8'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines which timer to use for interrupt vector. Valid values are 0,1,2 or 3:
        
        * 0 : use ITR timer 0
        * 1 : use ITR timer 1
        * 2 : use ITR timer 2 (immediate, no timer)
        * 3 : disabled interrupt
        
        Whenever an INT_MAP register is transitioned in/out of Timer 3 (disabled) state, the driver shall either disable the interrupt before, or clean up any associated cause thereafter. 

           ";
    ValRandomize = true;
  } InterruptTimer[1:0] = 2'h0;
};



// PCIE_MSIX_VECTOR[0..767]

reg pcie_msix_vector_r {
  shared;
  HandCoded = true;
  name = "MSI-X Vector Table";
  desc = "
    This table should normally be accessed through the
    BAR2/3 map and not through the normal PF register map (BAR0/1). 
    
    When accessed through PF BAR2/3 only entries [0..255] are visible (PF reserved area). When accessed through VF BAR 2/3 only the portion allowed to this VF is visible (per VF reserved area). 
    
    The structure of this table is defined in PCI Local Bus Specification 3.0 and PCI Express Bus Specification 3.0.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Message Signal Interrupt address. Lower 2 bits must be set to 0.

           ";
    ValRandomize = true;
  } Addr[96:33] = 64'h0;
  field {
    AccessType = "RW";
    desc = "
        Message Signal Interrupt data.

           ";
    ValRandomize = true;
  } Data[32:1] = 32'h0;
  field {
    AccessType = "RW";
    desc = "
        When this bit is set, the function is prohibited from sending a message using this MSI-X Table entry. However, any other MSI-X Table entries programmed with the same vector will still be capable of sending an equivalent message unless they are also masked. This bit's state after reset is 1 (entry is masked). This bit shall be kept asserted to 1 until write to Addr and Data fields is completed. 

           ";
    ValRandomize = true;
  } Mask[0:0] = 1'h1;
};



// PCIE_INT_CTRL

reg pcie_int_ctrl_r {
  shared;
  HandCoded = true;
  name = "Interrupt Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines/holds next vector to process. Software could update any time, hardware updates as it walks through vectors. 

           ";
    ValRandomize = true;
  } NextVector[10:1] = 10'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable interrupt moderators. This bit shall normally be set to 1, it could be temporarily set to 0 to change the link lists of timers in a non-orderly manner (disabling moderator isn't required if software proceed in order when changing link lists). If set to 0, the software shall wait 50ns before starting to make changes to the link list.  

           ";
    ValRandomize = true;
  } EnableModerator[0:0] = 1'h0;
};



// PCIE_ITR[0..767]

reg pcie_itr_r {
  shared;
  HandCoded = true;
  name = "Interrupt Timers";
  desc = "
    The entire set of 768 registers is visible from PF, and a portion is visible through VF.  
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines minimum interval between interrupts, timer 0

           ";
    ValRandomize = true;
  } Interval0[31:20] = 12'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines minimum interval between interrupts, timer 1

           ";
    ValRandomize = true;
  } Interval1[19:8] = 12'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicates timer 0 has expired

           ";
    ValRandomize = true;
  } Timer0Expired[7:7] = 1'h0 ;
  field {
    AccessType = "RO";
    desc = "
        Indicates timer 1 has expired

           ";
    ValRandomize = true;
  } Timer1Expired[6:6] = 1'h0 ;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Indicates a pending event is waiting for time 0 expiration. Writing '1' sets the interrupt. Writing 0 has no effect. 

           ";
    ValRandomize = true;
  } Pending0[5:5] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Indicates a pending event is waiting for time 1 expiration. Writing '1' sets the interrupt. Writing 0 has no effect.

           ";
    ValRandomize = true;
  } Pending1[4:4] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Indicates a pending event is waiting for time 2 expiration. Writing '1' sets the interrupt. Writing 0 has no effect.

           ";
    ValRandomize = true;
  } Pending2[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Defines if interrupt is auto masked by hardware. If set to '1', the hardware will automatically block interrupts (Mask set to 1) when the interrupt is posted thus block future interrupts until the software writes the clear mask command in the Mask field.  

           ";
    ValRandomize = true;
  } AutoMask[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Control masking of this interrupt:
        
        On write:
        
            * 0 : do not change mask status
            * 1 : set mask (block interrupts)
            * 2 : clear mask (unblock interrupts)
            
        On read:
        
            * 0 : interrupt not blocked
            * 1 : interrupt blocked

           ";
    ValRandomize = true;
  } Mask[1:0] = 2'h1;
};



// PCIE_ITR2[0..767]

reg pcie_itr2_r {
  shared;
  HandCoded = true;
  name = "Interrupt Timers Config 2";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Defines next vector in the linked list

           ";
    ValRandomize = true;
  } NextVector[57:48] = 10'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __set__[47:16] = 32'h0;
  field {
    AccessType = "RO";
    desc = "
        Hold last time an MSI-X interrupt was posted. 

           ";
    ValRandomize = true;
  } LastPosting[15:0] = 16'h0;
};



// PCIE_IP

reg pcie_ip_r {
  shared;
  HandCoded = true;
  name = "Interrupt from PEP Register";
  desc = "
    Indicates interrupts from PCIe. Resets on COLD_RESET. Register not accessible while the PEP is on WARM_RESET.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a hot reset (a.k.a. PCIe in-band reset) or a PCIe link down occurred.  

           ";
    ValRandomize = true;
  } HotReset[10:10] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a device state change occurred (e.g. D0 to D3hot or D3hot to D0).

           ";
    ValRandomize = true;
  } DeviceStateChange[9:9] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Global Mailbox Interrupt pending. Read PCIE_GMBX register to recover source of interrupt.  

           ";
    ValRandomize = true;
  } Mailbox[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a VPD request from the host. 

           ";
    ValRandomize = true;
  } VPD_Request[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicates a correctable or an uncorrectable ECC/parity error occurred on an SRAM of the PEP. Read PCIE_SRAM_IP register to retrieve the concerned block. The bit is kept asserted until all asserted bits in PCIE_SRAM_IP are cleared by the appropriate reset or by CW1.

           ";
    ValRandomize = true;
  } SramError[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a PFLR occurred. 

           ";
    ValRandomize = true;
  } PFLR[5:5] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a Data Path reset occurred.

           ";
    ValRandomize = true;
  } DataPathReset[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates the PEP has left any of its reset state: cold, warm, hot, PFLR, or data path reset.

           ";
    ValRandomize = true;
  } OutOfReset[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Allows the Switch Manager and the host to detect that the PEP is in one of its reset states. Note that if PEP is in WARM reset, reads by (a non-local) SM will return 0x0. Since unlike other bits in this register this bit is not reset by SM, it can be polled by host to detect the PEP has exited reset.

           ";
    ValRandomize = true;
  } NotInReset[2:2] = 1'h1;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates an access to the PEP from DBI has timed out.    

           ";
    ValRandomize = true;
  } Timeout[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates a VFLR occured. 

           ";
    ValRandomize = true;
  } VFLR[0:0] = 1'h0;
};



// PCIE_IM

reg pcie_im_r {
  shared;
  HandCoded = true;
  name = "Interrupt from PEP Mask to Switch Manager";
  desc = "
    Resets on COLD_RESET. Register not accessible while the PEP is on WARM_RESET.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Mask for PCIE_IP cause register toward the SM. Setting to '1' blocks interrupt. 

           ";
    ValRandomize = true;
  } Mask[10:3] = 8'hFF;
  field {
    AccessType = "RW";
    desc = "
        This bit has no effect since it corresponds to NotInReset bit in PCIE_IP which never generates interrupt. 

           ";
    ValRandomize = true;
  } Reserved1[2:2] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Mask for bits 9 and 10 in PCIE_IP cause register toward the SM. Setting to '1' blocks interrupt. 

           ";
    ValRandomize = true;
  } Mask9_10[1:0] = 2'h3;
};



// PCIE_IB

reg pcie_ib_r {
  shared;
  HandCoded = true;
  name = "Interrupt from PEP Mask to Boot State Machine";
  desc = "
    Resets on COLD_RESET. Register not accessible while the PEP is on WARM_RESET.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Mask for PCIE_IP cause registers toward the BSM. Setting to '1' blocks interrupt. 

           ";
    ValRandomize = true;
  } Mask[10:3] = 8'hFF;
  field {
    AccessType = "RW";
    desc = "
        This bit has no effect since it corresponds to NotInReset bit in PCIE_IP which never generates interrupt. 

           ";
    ValRandomize = true;
  } Reserved1[2:2] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Mask for bit 9 in PCIE_IP cause register toward the SM. Setting to '1' blocks interrupt. 

           ";
    ValRandomize = true;
  } Mask9_10[1:0] = 2'h3;
};



// PCIE_SRAM_IP

reg pcie_sram_ip_r {
  shared;
  HandCoded = true;
  name = "SRAM Interrupt from PEP";
  desc = "
   Indicates correctable and uncorrectable ECC error events on SRAMs. UE_ prefix is used for Uncorrectable Error, and CE_ for Correctable Error. The errors are reported per functional block. Resets on COLD_RESET. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error in the PCW block and registers. Requires a PCIe inband reset.

           ";
    ValRandomize = true;
  } UE_PCW[15:15] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_14_[14:14] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error in the FUM block, excepted to Mailbox and Interrupt memories. Requires a PCIe inband reset.

           ";
    ValRandomize = true;
  } UE_FUM[13:13] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error on Mailbox and Interrupt memories. Requires a PCIe inband reset.

           ";
    ValRandomize = true;
  } UE_MBX_INT[12:12] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error in the RHI block and registers. Requires a Data Path reset.

           ";
    ValRandomize = true;
  } UE_RHI[11:11] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error in the THI block and registers. Requires a Data Path reset.

           ";
    ValRandomize = true;
  } UE_THI[10:10] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error in the RPP or TPP block and registers. Requires a Data Path reset.

           ";
    ValRandomize = true;
  } UE_PP[9:9] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Uncorrectable error in PCA block and registers. Requires a Data Path reset.

           ";
    ValRandomize = true;
  } UE_PCA[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error in PCI block and registers.

           ";
    ValRandomize = true;
  } CE_PCW[7:7] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_6_[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error in FUM block and registers.

           ";
    ValRandomize = true;
  } CE_FUM[5:5] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error on Mailbox and Interrupt memories.

           ";
    ValRandomize = true;
  } CE_MBX_INT[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error in RHI block and registers.

           ";
    ValRandomize = true;
  } CE_RHI[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error in THI block and registers.

           ";
    ValRandomize = true;
  } CE_THI[2:2] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error in RPP or TPP block and registers.

           ";
    ValRandomize = true;
  } CE_PP[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
    Correctable error in PCA block and registers. 

           ";
    ValRandomize = true;
  } CE_PCA[0:0] = 1'h0;
};



// PCIE_SRAM_IM

reg pcie_sram_im_r {
  shared;
  HandCoded = true;
  name = "SRAM Interrupt from PEP Mask";
  desc = "
   Resets on COLD_RESET.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
   Mask for PCIE_SRAM_IP cause register. Setting to '1' blocks interrupt. 

           ";
    ValRandomize = true;
  } Mask[15:0] = 16'hFFFF;
};



// PCIE_VLAN_TABLE[0..64,0..127]

reg pcie_vlan_table_r {
  shared;
  HandCoded = true;
  name = "VLAN Table";
  desc = "
   Index j in the range 1..64 is for VF, index j=0 is for PF.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_0[31:31] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_1[30:30] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_2[29:29] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_3[28:28] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_4[27:27] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_5[26:26] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_6[25:25] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_7[24:24] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_8[23:23] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_9[22:22] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_10[21:21] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_11[20:20] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_12[19:19] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_13[18:18] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_14[17:17] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_15[16:16] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_16[15:15] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_17[14:14] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_18[13:13] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_19[12:12] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_20[11:11] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_21[10:10] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_22[9:9] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_23[8:8] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_24[7:7] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_25[6:6] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_26[5:5] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_27[4:4] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_28[3:3] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_29[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_30[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Each bit n in register i affects packets with VLAN tags equal to 32xi+n for the VF/PF indicated via j. 128 PCIE_VLAN_TABLE registers compose a table of 4096 bits that cover all possible VLAN tags. Each bit when set enables packets associated with this VLAN to pass. Each bit when cleared results in the packets associated with this VLAN being dropped.

           ";
    ValRandomize = true;
  } VID_Membership_31[0:0] = 1'h0;
};
regfile pcie_vlan_table_rf {
  pcie_vlan_table_r PCIE_VLAN_TABLE[128] += 8;
};



// PCIE_MBMEM[0..2047]

reg pcie_mbmem_r {
  shared;
  HandCoded = true;
  name = "Mailboxes Memory";
  desc = "
    Mailboxes memories. The first 1024 entries are used for VF mailboxes(64x64B), VF sees only one of these mailbox at the time. The next 1024 entries are free and intended for SM/PF communication.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Mailbox data.

           ";
    ValRandomize = true;
  } Data[31:0] = 32'h0;
};



// PCIE_MBX[0..63]

reg pcie_mbx_r {
  shared;
  HandCoded = true;
  name = "VF Mailboxes Control";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Hardware semaphore. The requester reads this field to claim ownership over the mailbox. If it is read as 1b, it means it has been granted ownership. If it is read as 0b, it means ownership has already been granted to another software entity, it shall try again later on. The owner writes a 1b to this field to release ownership. Writing zero has no effect.
* Do not use this bit. Hardware semaphore mechanism is not operational. Use a lockless mailbox mechanism instead, where the mailbox memory is split in two halves, one half for the PF and one half for the VF *

           ";
    ValRandomize = true;
  } Owner[6:6] = 1'h1;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Message to VF ready. Setting this bit causes an interrupt to the relevant VF (latched in PCIE_VFMBX). This bit always read as zero. 

           ";
    ValRandomize = true;
  } Req[5:5] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Message from VF received. Setting this bit causes an interrupt to the relevant VF (latched in PCIE_VFMBX). This bit always read as zero.

           ";
    ValRandomize = true;
  } Ack[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        VF has posted a message for PF. Setting this bit causes the interrupt to be cleared. 

           ";
    ValRandomize = true;
  } PFReqInterrupt[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        VF indicates message from PF was received.  Setting this bit causes the interrupt to be cleared. 

           ";
    ValRandomize = true;
  } PFAckInterrupt[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Mailbox interrupt enable from the VF. Read as 0 if disabled, read as 1 if enabled.
          * 0 or 3: do not change the mode
          * 1: enable mailbox interrupt from the VF
          * 2: disable mailbox interrupt from the VF  

           ";
    ValRandomize = true;
  } InterruptEnable[1:0] = 2'h0;
};



// PCIE_MBICR[0..1]

reg pcie_mbicr_r {
  shared;
  HandCoded = true;
  name = "VF Mailboxes Interrupt Causes Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Mirrors of 'PCIE_MBX[vf].PFReqInterrupt OR PCIE_MBX[vf].PFAckInterrupt', encoded PCIE_MBICR[vf/32].VF2PFInt[vf%32].

           ";
    ValRandomize = true;
  } VF2PFInt[31:0] = 32'h0;
};



// PCIE_GMBX

reg pcie_gmbx_r {
  shared;
  HandCoded = true;
  name = "Global Mailbox Control";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Hardware semaphore. The requester reads this field to claim ownership over the mailbox. If it is read as 1b, it means it has been granted ownership. If it is read as 0b, it means ownership has already been granted to another software entity, it shall try again later on. The owner writes a 1b to this field to release ownership. Writing zero has no effect.
* Do not use this bit. Hardware semaphore mechanism is not operational. Use a lockless mailbox mechanism instead, where the mailbox memory is split in two halves, one half for the PF and one half for the SM *

           ";
    ValRandomize = true;
  } Owner[12:12] = 1'h1;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Request from PF to SM is ready. Setting this bit causes a global interrupt to be latched in PCIE_IP. This bit always read as zero. 

           ";
    ValRandomize = true;
  } GlobalReq[11:11] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Message from SM to PF was read. Setting this bit causes a global interrupt to be latched in PCIE_IP. This bit always read as zero. 

           ";
    ValRandomize = true;
  } GlobalAck[10:10] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set when message from SM to PF is ready.  

           ";
    ValRandomize = true;
  } PFReqInterrupt[9:9] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set when message from PF to SM has been read by SM.  

           ";
    ValRandomize = true;
  } PFAckInterrupt[8:8] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Controls if the global mailbox host interrupts are enabled. Read as 0 if disabled, read as 1 if enabled.
          * 0 or 3: do not change the mode
          * 1: enable global mailbox host interrupts
          * 2: disable global mailbox host interrupts

           ";
    ValRandomize = true;
  } PFInterruptEnable[7:6] = 2'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Message from SM to PF is ready. Setting this bit causes an interrupt to be latched in PCIE_EICR. This bit always read as zero. 

           ";
    ValRandomize = true;
  } PFReq[5:5] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Message from PF to SM was read. Setting this bit causes an interrupt to the be latched in PCIE_EICR. This bit always read as zero. 

           ";
    ValRandomize = true;
  } PFAck[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set when message from PF to SM is ready.  

           ";
    ValRandomize = true;
  } GlobalReqInterrupt[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Set when message from SM to PF has been read by PF.  

           ";
    ValRandomize = true;
  } GlobalAckInterrupt[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Controls if the global mailbox global interrupts are enabled. Read as 0 if disabled, read as 1 if enabled.
          * 0 or 3: do not change the mode
          * 1: enable global interrupts
          * 2: disable global interrupts

           ";
    ValRandomize = true;
  } GlobalInterruptEnable[1:0] = 2'h0;
};



// PCIE_PFVFLRE

reg pcie_pfvflre_r {
  shared;
  HandCoded = true;
  name = "PF VFLR Events Indication";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_0[63:63] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_1[62:62] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_2[61:61] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_3[60:60] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_4[59:59] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_5[58:58] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_6[57:57] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_7[56:56] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_8[55:55] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_9[54:54] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_10[53:53] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_11[52:52] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_12[51:51] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_13[50:50] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_14[49:49] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_15[48:48] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_16[47:47] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_17[46:46] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_18[45:45] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_19[44:44] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_20[43:43] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_21[42:42] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_22[41:41] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_23[40:40] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_24[39:39] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_25[38:38] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_26[37:37] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_27[36:36] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_28[35:35] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_29[34:34] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_30[33:33] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_31[32:32] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_32[31:31] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_33[30:30] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_34[29:29] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_35[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_36[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_37[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_38[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_39[24:24] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_40[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_41[22:22] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_42[21:21] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_43[20:20] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_44[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_45[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_46[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_47[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_48[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_49[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_50[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_51[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_52[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_53[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_54[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_55[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_56[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_57[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_58[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_59[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_60[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_61[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_62[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indication of FLR occurence on VF[n] . These bits are accessible only to the PF and are cleared by writing 0x1 to the matched bit in the PFVFLREC registers.

           ";
    ValRandomize = true;
  } DetectEvent_63[0:0] = 1'h0;
};



// PCIE_PFVFLREC

reg pcie_pfvflrec_r {
  shared;
  HandCoded = true;
  name = "PF VFLR Events Clear";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_0[63:63] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_1[62:62] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_2[61:61] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_3[60:60] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_4[59:59] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_5[58:58] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_6[57:57] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_7[56:56] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_8[55:55] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_9[54:54] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_10[53:53] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_11[52:52] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_12[51:51] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_13[50:50] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_14[49:49] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_15[48:48] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_16[47:47] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_17[46:46] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_18[45:45] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_19[44:44] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_20[43:43] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_21[42:42] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_22[41:41] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_23[40:40] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_24[39:39] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_25[38:38] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_26[37:37] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_27[36:36] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_28[35:35] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_29[34:34] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_30[33:33] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_31[32:32] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_32[31:31] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_33[30:30] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_34[29:29] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_35[28:28] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_36[27:27] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_37[26:26] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_38[25:25] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_39[24:24] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_40[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_41[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_42[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_43[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_44[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_45[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_46[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_47[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_48[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_49[14:14] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_50[13:13] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_51[12:12] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_52[11:11] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_53[10:10] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_54[9:9] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_55[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_56[7:7] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_57[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_58[5:5] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_59[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_60[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_61[2:2] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_62[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Writing a 1 to bit 'i' clears the FLR event on VF[n] indicated in the PFVFLRE[n] registers.

           ";
    ValRandomize = true;
  } ClearEvent_63[0:0] = 1'h0;
};



// PCIE_DEBUG_CTRL0

reg pcie_debug_ctrl0_r {
  shared;
  HandCoded = true;
  name = "PF DEBUG Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
   field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[63:0] = 64'h0;
};



// PCIE_TEST_CFG0

reg pcie_test_cfg0_r {
  shared;
  HandCoded = true;
  name = "PCIE TEST Configuration Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
         PEP level loopback from Tx to Rx. Debug only.  

           ";
    ValRandomize = true;
  } PEPLoopback[31:31] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
         Debug feature that enables clearing of the per queue stats QPTC, QBTC, QPRDC, QPRC and QBRC on datapath reset events. Set to 1 to enable, 0 to disable.

           ";
    ValRandomize = true;
  } DPRStatsClearEn[30:30] = 1'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } Reserved[29:0] = 30'h0;
};



// PCIE_VISA_CTRL

reg pcie_visa_ctrl_r {
  shared;
  HandCoded = true;
  name = "PCIE Virtualization of Internal Signals Architecture Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
    field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[63:0] = 64'h0;

};



// PCIE_VISA_DATA

reg pcie_visa_data_r {
  shared;
  HandCoded = true;
  name = "PCIE Virtualization of Internal Signals Architecture Data Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
    field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[63:0] = 64'h0;

};



// PCIE_VISA_TRAP_OUT

reg pcie_visa_trap_out_r {
  shared;
  HandCoded = true;
  name = "PCIE Virtualization of Internal Signals Architecture Trap Out Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
    field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[63:0] = 64'h0;

};



// PCIE_VISA_TRAP

reg pcie_visa_trap_r {
  shared;
  HandCoded = true;
  name = "PCIE Virtualization of Internal Signals Architecture Trap Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
    field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[63:0] = 64'h0;

};



// PCIE_VISA_TRAP_MASK

reg pcie_visa_trap_mask_r {
  shared;
  HandCoded = true;
  name = "PCIE Virtualization of Internal Signals Architecture Trap Mask Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
    field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[63:0] = 64'h0;

};



// PCIE_INT_SRAM_CTRL

reg pcie_int_sram_ctrl_r {
  shared;
  HandCoded = true;
  name = "Interrupt SRAM Control Register";
  desc = "
    itr2=0, itr=1 , msix_vec_2=2 , msix_vec_1=3 , msix_vec_0=4 , vfint_map=5 , txint=6 , rxint=7 , mbmem=8.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[53:52] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[51:50] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[49:48] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[47:46] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[45:44] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[43:42] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_6[41:40] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_7[39:38] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_8[37:36] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[35:35] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[34:34] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[33:33] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[32:32] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[31:31] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[30:30] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_6[29:29] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_7[28:28] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_8[27:27] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[26:26] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[25:25] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[24:24] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_6[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_7[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_8[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_6[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_7[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_8[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_6[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_7[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_8[0:0] = 1'h0;
};



// PCIE_FUM_SRAM_CTRL

reg pcie_fum_sram_ctrl_r {
  shared;
  HandCoded = true;
  name = "FUM SRAM Control Register";
  desc = "
    qbtc_h=0, qbtc_l=1 , qptc =2 , qbrc_h=3 , qbrc_l = 4, qprc=5 , qprdc=6. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[41:40] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[39:38] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[37:36] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[35:34] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[33:32] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[31:30] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_6[29:28] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[27:27] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[26:26] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[25:25] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[24:24] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_6[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_6[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_6[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_6[0:0] = 1'h0;
};



// PCIE_PCA_SRAM_CTRL

reg pcie_pca_sram_ctrl_r {
  shared;
  HandCoded = true;
  name = "PCA SRAM Control Register";
  desc = "
    qmap=0. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite[5:4] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail[0:0] = 1'h0;
};



// PCIE_PP_SRAM_CTRL

reg pcie_pp_sram_ctrl_r {
  shared;
  HandCoded = true;
  name = "PP SRAM Control Register";
  desc = "
    srrctl=0, vlan_vf_table=1, vlan_pf_table=2, txfifo=3, tso_meta=4, tso1hdr=5, tso0hdr=6, rxfifo=7, reta=8, rssrk0=9, rssrk1=10, rssrk2=11, rssrk=12, rssrk=13.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[83:82] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[81:80] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[79:78] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[77:76] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[75:74] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[73:72] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_6[71:70] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_7[69:68] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_8[67:66] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_9[65:64] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_10[63:62] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_11[61:60] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_12[59:58] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_13[57:56] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[55:55] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[54:54] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[53:53] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[52:52] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[51:51] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[50:50] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_6[49:49] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_7[48:48] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_8[47:47] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_9[46:46] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_10[45:45] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_11[44:44] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_12[43:43] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_13[42:42] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[41:41] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[40:40] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[39:39] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[38:38] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[37:37] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[36:36] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_6[35:35] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_7[34:34] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_8[33:33] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_9[32:32] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_10[31:31] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_11[30:30] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_12[29:29] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_13[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[24:24] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[22:22] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_6[21:21] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_7[20:20] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_8[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_9[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_10[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_11[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_12[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_13[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_6[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_7[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_8[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_9[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_10[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_11[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_12[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_13[0:0] = 1'h0;
};



// PCIE_PCW_SRAM_CTRL

reg pcie_pcw_sram_ctrl_r {
  shared;
  HandCoded = true;
  name = "PCW SRAM Control Register";
  desc = "
    radm_dataq1=0, radm_dataq0=1 , radm_hdrq1=2 , radm_hdrq0=3, sotram=4, retryram1=5, retryram0=6.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[41:40] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[39:38] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[37:36] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[35:34] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[33:32] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[31:30] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_6[29:28] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[27:27] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[26:26] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[25:25] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[24:24] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_6[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_6[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_6[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_6[0:0] = 1'h0;
};



// PCIE_RHI_SRAM_CTRL1

reg pcie_rhi_sram_ctrl1_r {
  shared;
  HandCoded = true;
  name = "RHI SRAM Control1 Register";
  desc = "
    dw1=0, dw0=1, rdp=2,desc3=3, desc2=4, desc1=5, desc0=6.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[41:40] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[39:38] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[37:36] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[35:34] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[33:32] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[31:30] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_6[29:28] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[27:27] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[26:26] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[25:25] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[24:24] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_6[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_6[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_6[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_6[0:0] = 1'h0;
};



// PCIE_RHI_SRAM_CTRL2

reg pcie_rhi_sram_ctrl2_r {
  shared;
  HandCoded = true;
  name = "RHI SRAM Control2 Register";
  desc = "
    Rdt=0, rdlen=1, rdh=2, rdbal=3, rdbah=4.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[29:28] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[27:26] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[25:24] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[23:22] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[21:20] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[14:14] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[13:13] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[12:12] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[11:11] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[0:0] = 1'h0;
};



// PCIE_THI_SRAM_CTRL1

reg pcie_thi_sram_ctrl1_r {
  shared;
  HandCoded = true;
  name = "THI SRAM Control1 Register";
  desc = "
    dw1=0, dw0=1, desc3=2, desc2=3 desc1=4, desc0=5, rate=6, maxcredit=7, credit=8, rsvd=9, cb1=10, cb0=11, desc_info1=12, desc_info0=13.
           ";
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[83:82] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[81:80] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[79:78] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[77:76] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[75:74] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[73:72] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_6[71:70] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_7[69:68] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_8[67:66] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_9[65:64] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_10[63:62] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_11[61:60] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_12[59:58] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_13[57:56] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[55:55] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[54:54] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[53:53] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[52:52] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[51:51] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[50:50] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_6[49:49] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_7[48:48] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_8[47:47] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_9[46:46] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_10[45:45] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_11[44:44] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_12[43:43] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_13[42:42] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[41:41] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[40:40] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[39:39] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[38:38] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[37:37] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[36:36] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_6[35:35] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_7[34:34] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_8[33:33] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_9[32:32] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_10[31:31] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_11[30:30] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_12[29:29] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_13[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[24:24] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[22:22] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_6[21:21] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_7[20:20] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_8[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_9[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_10[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_11[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_12[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_13[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_6[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_7[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_8[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_9[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_10[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_11[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_12[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_13[0:0] = 1'h0;
};



// PCIE_THI_SRAM_CTRL2

reg pcie_thi_sram_ctrl2_r {
  shared;
  HandCoded = true;
  name = "THI SRAM Control2 Register";
  desc = "
    Txdctl=0, tdh=1, tdt=2, tdlen=3, tdbah=4, tdbal=5.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_0[35:34] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_1[33:32] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_2[31:30] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_3[29:28] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_4[27:26] = 2'h0;
  field {
    AccessType = "RW";
    desc = "
      * 11b: uncorrectable
      * 10b or 01b: correctable
      * 00b: nothing

           ";
    ValRandomize = true;
  } ErrWrite_5[25:24] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_0[23:23] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_1[22:22] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_2[21:21] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_3[20:20] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_4[19:19] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } CErr_5[18:18] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_0[17:17] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_1[16:16] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_2[15:15] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_3[14:14] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_4[13:13] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "

           ";
    ValRandomize = true;
  } UErr_5[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_0[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_1[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_2[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_3[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_4[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDonePass_5[6:6] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_0[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_1[4:4] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_2[3:3] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_3[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_4[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BistDoneFail_5[0:0] = 1'h0;
};



// PCIE_FPGA_REVID

reg pcie_fpga_revid_r {
  shared;
  HandCoded = true;
  name = "PEP FPGA Revision ID Register";
  desc = "
    Register present only at PEP validation stage, not in silicon. Hardware default to this register changes upon each release. It encodes the work week drop tag, EAS version, and FPGA version.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Day in the work week.
       * 0: Sunday
       * 1: Monday
       ...
       * 6: Saturday

           ";
    ValRandomize = true;
  } DayInWW[31:28] = 4'h0;
  field {
    AccessType = "RO";
    desc = "
       Work week expressed in 2 digits. Values in the range 0x01-0x52.

           ";
    ValRandomize = true;
  } WW[27:20] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
       Last digit of the 201x year. Values in the range 0x0-0x9.

           ";
    ValRandomize = true;
  } Year[19:16] = 4'h0;
  field {
    AccessType = "RO";
    desc = "
       For instance EAS revision 1.35 is encoded as 0x135. 

           ";
    ValRandomize = true;
  } EASVersion[15:4] = 12'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } HWVersion[3:0] = 4'h0;
};



// PCIE_TIMEOUT_CFG

reg pcie_timeout_cfg_r {
  shared;
  HandCoded = true;
  name = "PCIE Timeouts Configuration Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Defines the maximum duration in PCLK cycles units of the memory init sequence. Default setting is maximum 131us for the slowest clock case.

           ";
    ValRandomize = true;
  } MemInitTimer[23:8] = 16'h4064;
  field {
    AccessType = "RW";
    desc = "
       Defines the maximum delay in PCLK cycles units for getting ack on CSR access from host or SM/BSM. Beyond this time, the PEP returns 0xFFFFFFFF on reads, writes are aborted, and the address is logged in the PCIE_FUM_FAULT register. Default setting is 80 cycles.

           ";
    ValRandomize = true;
  } CSRAccessTimeout[7:0] = 8'h50;
};



// PCIE_DEBUG_PCA

reg pcie_debug_pca_r {
  shared;
  HandCoded = true;
  name = "PCIE PCA Debug Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Debug register used to connect essential PCA signals. Details provided in T-Spec.

           ";
    ValRandomize = true;
  } Reserved[31:0] = 32'h0;
};



// PCIE_DEBUG_RHI

reg pcie_debug_rhi_r {
  shared;
  HandCoded = true;
  name = "PCIE RHI Debug Register";
  desc = "
       Debug register used to connect essential RHI signals. Details provided in T-Spec.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } Reserved[31:0] = 32'h0;
};



// PCIE_DEBUG_THI

reg pcie_debug_thi_r {
  shared;
  HandCoded = true;
  name = "PCIE THI Debug Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Debug register used to connect essential THI signals. Details provided in T-Spec.

           ";
    ValRandomize = true;
  } Reserved[31:0] = 32'h0;
};



// PCIE_DEBUG_RPP

reg pcie_debug_rpp_r {
  shared;
  HandCoded = true;
  name = "PCIE RPP Debug Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Debug register used to connect essential RPP signals. Details provided in T-Spec.

           ";
    ValRandomize = true;
  } Reserved[31:0] = 32'h0;
};



// PCIE_DEBUG_TPP

reg pcie_debug_tpp_r {
  shared;
  HandCoded = true;
  name = "PCIE TPP Debug Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Debug register used to connect essential TPP signals. Details provided in T-Spec.

           ";
    ValRandomize = true;
  } Reserved[31:0] = 32'h0;
};



// PCIE_DEBUG_FUM

reg pcie_debug_fum_r {
  shared;
  HandCoded = true;
  name = "PCIE FUM Debug Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       Debug register used to connect essential FUM signals. Details provided in T-Spec.

           ";
    ValRandomize = true;
  } Reserved1[31:16] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
       Debug register used to connect control signals. Details provided in T-Spec.

           ";
    ValRandomize = true;
  } Reserved2[15:0] = 16'h0;
};



// PCIE_DEBUG_MEM_CTRL

reg pcie_debug_mem_ctrl_r {
  shared;
  HandCoded = true;
  name = "PCIE Debug Memory Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Memory address.

           ";
    ValRandomize = true;
  } Address[20:8] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
       Memory decoder. Select the relevant memory.

           ";
    ValRandomize = true;
  } MemDecoder[7:3] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
       Read from memory.

           ";
    ValRandomize = true;
  } Read[2:2] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
       Write from memory.

           ";
    ValRandomize = true;
  } Write[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
       Memory access done.

           ";
    ValRandomize = true;
  } Acknowledge[0:0] = 1'h0;
};



// PCIE_DEBUG_MEM_DATA[0..4]

reg pcie_debug_mem_data_r {
  shared;
  HandCoded = true;
  name = "PCIE Debug Memory Data Registers";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Memory data. Max data width is 148-bits.

           ";
    ValRandomize = true;
  } Data[31:0] = 32'h0;
};



// PCIE_LVMMC

reg pcie_lvmmc_r {
  shared;
  HandCoded = true;
  name = "PCIE Last VM Misbehavior Cause Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when HDRLEN equals 0 and MSS greater than 0. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropHDRLEN0[31:31] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when HDRLEN greater than 0 and MSS equals 0. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMSS0[30:30] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when HDRLEN greater than Packet Size. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropHDRLENGtPKTLEN[29:29] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when Packet Size smaller than 17-bytes (or 25-byte if FTAG included). The packet is silently dropped and the queue remains enabled.

           ";
    ValRandomize = true;
  } TxDropMinPkt[28:28] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when Packet Size greater than 15KB. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMaxPkt[27:27] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when HDRLEN greater than 192B. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMaxHdr[26:26] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when HDRLEN smaller than 54-bytes. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMinHdr[25:25] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when TDLEN smaller than 32. The attempt to set TDLEN below 32 is ignored.

           ";
    ValRandomize = true;
  } TxMinTDLEN[24:24] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when BUFLEN equals 0 on first descriptor. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropBUFLEN0First[23:23] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when BUFLEN equals 0 on a middle descriptor (not the first descriptor). The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropBUFLEN0Mid[22:22] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when the number of descriptors for a single packet or for a TSO is greater than the internal descriptor cache size. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMaxDesc[21:21] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when FTAG bit is set in descriptor in spite PFVTCTL[Q].FtagDescEnable bit is cleared. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropFTAGInsDis[20:20] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when MSS smaller than MinMSS. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMinMSS[19:19] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when TSO greater than (256KB - 1). The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMaxTSO[18:18] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when UR or CA is returned internally for a data read request. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropURCAData[17:17] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when UR or CA is returned internally for a descriptor read request. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropURCADesc[16:16] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when a Tx packet exceeds the TCB size of 16KB. It can happen when a packet spans over too many data buffers which are not aligned to 16-bytes address boundaries. The queue is disabled on such events.

           ";
    ValRandomize = true;
  } TxDropMaxTCB[15:15] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when modifying TDBAL or TDBAH while the queue is enabled. The write access is ignored.

           ";
    ValRandomize = true;
  } TxTDBALHQEn[14:14] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when TDT is set beyond TDLEN. TDT will point to TDLEN.

           ";
    ValRandomize = true;
  } TxTDTGtTDLEN[13:13] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bit set when TXDCTL is modified while the queue is enabled. The write access is ignored.

           ";
    ValRandomize = true;
  } TxTXDCTLQEn[12:12] = 1'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Spare cause fields.

           ";
    ValRandomize = true;
  } Reserved[11:0] = 12'h0;
};



// PCIE_LVMMI

reg pcie_lvmmi_r {
  shared;
  HandCoded = true;
  name = "PCIE Last VM Misbehavior Indexes Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO/C";
    desc = "
       Bits 7:0 - Index of the queue.
       Bits 12:8 - Malicious cause code as per LVMMC register.
       Bit 13 - First malicious valid.

           ";
    ValRandomize = true;
  } FirstMaliciousEvent[27:14] = 14'h0;
  field {
    AccessType = "RO/C";
    desc = "
       Bits 21:14 - Index of the queue.
       Bits 26:22 - Malicious cause code as per LVMMC register.
       Bit 27 - Second malicious valid.

           ";
    ValRandomize = true;
  } SecondMaliciousEvent[13:0] = 14'h0;
};



// PCIE_FUM_DFX_CNT[0..5]

reg pcie_fum_dfx_cnt_r {
  shared;
  HandCoded = true;
  name = "PCIE FUM DFX Counters";
  desc = "
    6x 32-bits counters used for debugging. They are fully documented in T-Spec.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
       CNT[0] = ASPM_L1_Entry
       CNT[1] = Receiver_Recovery_Entry
       CNT[2] = Software_L1_Entry
       CNT[3] = radm_mlf_tlp_err
       CNT[4] = lcrc_err_asserted
       CNT[5] = ecrc_err_asserted

           ";
    ValRandomize = true;
  } Debug_Counter[31:0] = 32'h0;
};



// PCIE_FUM_DFX_STA[0..5]

reg pcie_fum_dfx_sta_r {
  shared;
  HandCoded = true;
  name = "PCIE FUM DFX Status Registers";
  desc = "
    6x 32-bits registers used for debugging. They are fully documented in T-Spec.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       STA[0] = dbg_pcie_sts_ei, 16-bits, RO
       STA[1] = dbg_pcie_sts_radm, 18-bits, RO
       STA[2] = dbg_pcie_sts_mac, 32-bits, RO
       STA[3] = dbg_pcie_sts_misc0, 32-bits, RO
       STA[4] = dbg_pcie_sts_misc1, 32-bits, RO
       STA[5] = dbg_pcie_ctrl_misc0, 32-bits, RW

           ";
    ValRandomize = true;
  } Debug_Status[31:0] = 32'h0;
};



// PCIE_HOST_MISC

reg pcie_host_misc_r {
  shared;
  HandCoded = true;
  name = "PCIE Host Miscellanous Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Timeout value for MGMT accesses to PEP.

           ";
    ValRandomize = true;
  } Mgmt_TO[31:12] = 20'h800;
  field {
    AccessType = "RW";
    desc = "
       Timeout enable.

           ";
    ValRandomize = true;
  } Mgmt_TO_En[11:11] = 1'h1;
  field {
    AccessType = "RW/1C/V";
    desc = "
       Timeout status bit.

           ";
    ValRandomize = true;
  } Timeout[10:10] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[9:0] = 10'h0;
};



// PCIE_HOST_LANE_CTRL

reg pcie_host_lane_ctrl_r {
  shared;
  HandCoded = true;
  name = "PCIE Host Lane Control Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
       Select the number of the master lane in the Serdes group. This lane will act as the master, and will drive the 400MHz clock to all the rest of the lanes. Also, it will be the source of the refclk sync logic in the PCIE Serdes.
Valid values are:
PEP0: 0x0 (default for PEP0), 0x1 (x2 reversed), 0x3 (x4 reversed), 0x7 (x8 reversed).
PEP1: 0x4 (default for PEP1), 0x5 (x2 reversed), 0x7 (x4 reversed).
The correct values shall be loaded by BSM at boot time.

           ";
    ValRandomize = true;
  } MasterLane[6:4] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
       Enable Avago requirement for PIPE Rx-standby logic. When cleared, the Rx-standby is driven from Synopsys core.

           ";
    ValRandomize = true;
  } RxStandby_En[3:3] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
       Controls the i_rx_8b10b_realign input to Avago SerDes.

           ";
    ValRandomize = true;
  } Sym_Realign[2:2] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
       Controls the i_fts_align_en input to Avago SerDes.

           ";
    ValRandomize = true;
  } FTS_Align[1:1] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
       Enables auto-assertion of the i_pcs_interrupt_disable after PCIE reset to Serdes.

           ";
    ValRandomize = true;
  } IntDisableAutoAssert[0:0] = 1'h0;
};



// PCIE_SERDES_CTRL[0..7]

reg pcie_serdes_ctrl_r {
  shared;
  HandCoded = true;
  name = "SerDes Control Register";
  desc = "
   Access to register management interface, per serdes lane. The access shall be first enabled and then each access is as follow: 
   
       * set InterruptCode=XX, DataWrite=XX, Interrupt=1
       * poll until Interrupt and InProgress are 0, DataRead is the response
       
   The PCIE_SERDES_CTRL[pep][0..7] are accessible only for the serdes lanes currently attached to the PEP. If an even-numbered PEP is in x8 mode, it can access all 8 lanes and the corresponding odd-numbered PEP must not access any lane. For PEPs in x4 mode, even-numbered PEPs can access only lanes 0-3 and odd-numbered PEPs can access only lanes 4-7. For PEP # 8 (mgmt), only lane 0 exists and may be accessed. Access to inaccessible or nonexistent lanes must not be attempted, even though the PCIE_SERDES_CTRL register is defined.
   
   Normally, access to PCIE_SERDES_CTRL registers should be done by the Switch Manager or Boot State Machine. They should not be used by the host driver as the host driver should be the same for all PEPs thus not cognitive about the particular PEP the driver is attached to.

  The control values used for InterruptCode/DataRead/DataWrite are reserved to Intel. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
      Enables bypassing internal control.  Only allowed during BSM sequence.  Other usage cases are for debug purposes only.

           ";
    ValRandomize = true;
  } Enable[63:63] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
      Set to interrupt the serdes microprocessor to process the command sent. Will self clear when command done.

           ";
    ValRandomize = true;
  } Interrupt[62:62] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
      Indicates if the interrupt is in progress or not. Will self clear when command done.   

           ";
    ValRandomize = true;
  } InProgess[61:61] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } __reserved__[60:48] = 13'h0;
  field {
    AccessType = "RW";
    desc = "
      Interrupt code to send to serdes.

           ";
    ValRandomize = true;
  } InterruptCode[47:32] = 16'h0;
  field {
    AccessType = "RW";
    desc = "
      Interrupt data to send to serdes.

           ";
    ValRandomize = true;
  } DataWrite[31:16] = 16'h0;
  field {
    AccessType = "RO";
    desc = "
      Interrupt data receives from serdes.      

           ";
    ValRandomize = true;
  } DataRead[15:0] = 16'h0;
};



// Begin reg2rdl addrmap section

addrmap PCIE_PF_map {
  name = "PCIE_PF";
  desc = "PCI Express Registers - Physical Function";

  pcie_ctrl_r                PCIE_CTRL                     @0x0;
  pcie_ctrl_ext_r            PCIE_CTRL_EXT                 @0x8;
  pcie_exvet_r               PCIE_EXVET                    @0x10;
  pcie_gcr_r                 PCIE_GCR                      @0x18;
  pcie_factps_r              PCIE_FACTPS                   @0x20;
  pcie_gcr_ext_r             PCIE_GCR_EXT                  @0x28;
  pcie_eicr_r                PCIE_EICR                     @0x30;
  pcie_eimr_r                PCIE_EIMR                     @0x38;
  pcie_pca_fault_r           PCIE_PCA_FAULT                @0x40;
  pcie_rhi_fault_r           PCIE_RHI_FAULT                @0x50;
  pcie_thi_fault_r           PCIE_THI_FAULT                @0x60;
  pcie_rpp_fault_r           PCIE_RPP_FAULT                @0x70;
  pcie_tpp_fault_r           PCIE_TPP_FAULT                @0x80;
  pcie_fum_fault_r           PCIE_FUM_FAULT                @0x90;
  pcie_maxholdq_r            PCIE_MAXHOLDQ[8]              @0xc0 += 8;
  pcie_sm_area_r             PCIE_SM_AREA                  @0x100;
  pcie_dglortmap_r           PCIE_DGLORTMAP[8]             @0x140 += 8;
  pcie_dglortdec_r           PCIE_DGLORTDEC[8]             @0x180 += 8;
  pcie_tunnel_cfg_r          PCIE_TUNNEL_CFG               @0x1c0;
  pcie_swpri_map_r           PCIE_SWPRI_MAP[16]            @0x200 += 8;
  pcie_rssrk_rf              PCIE_RSSRK[65]                @0x4000 += 128;
  pcie_reta_rf               PCIE_RETA[65]                 @0x8000 += 256;
  pcie_tc_credit_r           PCIE_TC_CREDIT[64]            @0x10000 += 8;
  pcie_tc_maxcredit_r        PCIE_TC_MAXCREDIT[64]         @0x10200 += 8;
  pcie_tc_rate_r             PCIE_TC_RATE[64]              @0x10400 += 8;
  pcie_tc_rate_status_r      PCIE_TC_RATE_STATUS           @0x10600;
  pcie_pause_r               PCIE_PAUSE                    @0x10608;
  pcie_dma_ctrl_r            PCIE_DMA_CTRL                 @0x10610;
  pcie_dma_ctrl2_r           PCIE_DMA_CTRL2                @0x10618;
  pcie_dtxtcpflgl_r          PCIE_DTXTCPFLGL               @0x10620;
  pcie_dtxtcpflgh_r          PCIE_DTXTCPFLGH               @0x10628;
  pcie_tph_ctrl_r            PCIE_TPH_CTRL                 @0x10630;
  pcie_mrqc_r                PCIE_MRQC[65]                 @0x10800 += 8;
  pcie_tqmap_r               PCIE_TQMAP[2048]              @0x14000 += 8;
  pcie_rqmap_r               PCIE_RQMAP[2048]              @0x18000 += 8;
  pcie_stats_timeout_r       PCIE_STATS_TIMEOUT            @0x1c000;
  pcie_stats_ur_r            PCIE_STATS_UR                 @0x1c008;
  pcie_stats_ca_r            PCIE_STATS_CA                 @0x1c010;
  pcie_stats_um_r            PCIE_STATS_UM                 @0x1c018;
  pcie_stats_xec_r           PCIE_STATS_XEC                @0x1c020;
  pcie_stats_vlan_drop_r     PCIE_STATS_VLAN_DROP          @0x1c028;
  pcie_stats_loopback_drop_r PCIE_STATS_LOOPBACK_DROP      @0x1c030;
  pcie_stats_nodesc_drop_r   PCIE_STATS_NODESC_DROP        @0x1c038;
  pcie_rrtime_cfg_r          PCIE_RRTIME_CFG               @0x1c040;
  pcie_rrtime_limit_r        PCIE_RRTIME_LIMIT[3]          @0x1c060 += 8;
  pcie_rrtime_count_r        PCIE_RRTIME_COUNT[4]          @0x1c080 += 8;
  pcie_systime_r             PCIE_SYSTIME                  @0x1c0a0;
  pcie_systime0_r            PCIE_SYSTIME0                 @0x1c0a8;
  pcie_systime_cfg_r         PCIE_SYSTIME_CFG              @0x1c0b0;
  pcie_pfvfbme_r             PCIE_PFVFBME                  @0x1c0b8;
  pcie_phyaddr_r             PCIE_PHYADDR                  @0x1c0c0;
  pcie_rdbal_r               PCIE_RDBAL                    @0x1c0c8;
  pcie_rdbah_r               PCIE_RDBAH                    @0x1c0d0;
  pcie_rdlen_r               PCIE_RDLEN                    @0x1c0d8;
  pcie_tph_rxctrl_r          PCIE_TPH_RXCTRL               @0x1c0e0;
  pcie_rdh_r                 PCIE_RDH                      @0x1c0e8;
  pcie_rdt_r                 PCIE_RDT                      @0x1c0f0;
  pcie_rxqctl_r              PCIE_RXQCTL                   @0x1c0f8;
  pcie_rxdctl_r              PCIE_RXDCTL                   @0x1c100;
  pcie_rxint_r               PCIE_RXINT                    @0x1c108;
  pcie_srrctl_r              PCIE_SRRCTL                   @0x1c110;
  pcie_qprc_r                PCIE_QPRC                     @0x1c118;
  pcie_qprdc_r               PCIE_QPRDC                    @0x1c120;
  pcie_qbrc_l_r              PCIE_QBRC_L                   @0x1c128;
  pcie_qbrc_h_r              PCIE_QBRC_H                   @0x1c130;
  pcie_rx_sglort_r           PCIE_RX_SGLORT                @0x1c138;
  pcie_tdbal_r               PCIE_TDBAL                    @0x1c140;
  pcie_tdbah_r               PCIE_TDBAH                    @0x1c148;
  pcie_tdlen_r               PCIE_TDLEN                    @0x1c150;
  pcie_tph_txctrl_r          PCIE_TPH_TXCTRL               @0x1c158;
  pcie_tdh_r                 PCIE_TDH                      @0x1c160;
  pcie_tdt_r                 PCIE_TDT                      @0x1c168;
  pcie_txdctl_r              PCIE_TXDCTL                   @0x1c170;
  pcie_txqctl_r              PCIE_TXQCTL                   @0x1c178;
  pcie_txint_r               PCIE_TXINT                    @0x1c180;
  pcie_qptc_r                PCIE_QPTC                     @0x1c188;
  pcie_qbtc_l_r              PCIE_QBTC_L                   @0x1c190;
  pcie_qbtc_h_r              PCIE_QBTC_H                   @0x1c198;
  pcie_tqdloc_r              PCIE_TQDLOC                   @0x1c1a0;
  pcie_tx_sglort_r           PCIE_TX_SGLORT                @0x1c1a8;
  pcie_pfvtctl_r             PCIE_PFVTCTL                  @0x1c1b0;
  pcie_tx_desc_rff           PCIE_TX_DESC[256]             @0x200000 += 8192;
  pcie_pbacl_r               PCIE_PBACL[72]                @0x400000 += 8;
  pcie_int_map_r             PCIE_INT_MAP[16]              @0x400400 += 8;
  pcie_msix_vector_r         PCIE_MSIX_VECTOR[768]         @0x404000 += 16;
  pcie_int_ctrl_r            PCIE_INT_CTRL                 @0x408000;
  pcie_itr_r                 PCIE_ITR[768]                 @0x40a000 += 8;
  pcie_itr2_r                PCIE_ITR2[768]                @0x40c000 += 8;
  pcie_ip_r                  PCIE_IP                       @0x40e000;
  pcie_im_r                  PCIE_IM                       @0x40e008;
  pcie_ib_r                  PCIE_IB                       @0x40e010;
  pcie_sram_ip_r             PCIE_SRAM_IP                  @0x40e018;
  pcie_sram_im_r             PCIE_SRAM_IM                  @0x40e020;
  pcie_vlan_table_rf         PCIE_VLAN_TABLE[65]           @0x420000 += 1024;
  pcie_mbmem_r               PCIE_MBMEM[2048]              @0x440000 += 8;
  pcie_mbx_r                 PCIE_MBX[64]                  @0x444000 += 8;
  pcie_mbicr_r               PCIE_MBICR[2]                 @0x444200 += 8;
  pcie_gmbx_r                PCIE_GMBX                     @0x444210;
  pcie_pfvflre_r             PCIE_PFVFLRE                  @0x444218;
  pcie_pfvflrec_r            PCIE_PFVFLREC                 @0x444220;
  pcie_debug_ctrl0_r         PCIE_DEBUG_CTRL0              @0x444228;
  pcie_test_cfg0_r           PCIE_TEST_CFG0                @0x444230;
  pcie_visa_ctrl_r           PCIE_VISA_CTRL                @0x444238;
  pcie_visa_data_r           PCIE_VISA_DATA                @0x444240;
  pcie_visa_trap_out_r       PCIE_VISA_TRAP_OUT            @0x444248;
  pcie_visa_trap_r           PCIE_VISA_TRAP                @0x444250;
  pcie_visa_trap_mask_r      PCIE_VISA_TRAP_MASK           @0x444258;
  pcie_int_sram_ctrl_r       PCIE_INT_SRAM_CTRL            @0x444260;
  pcie_fum_sram_ctrl_r       PCIE_FUM_SRAM_CTRL            @0x444268;
  pcie_pca_sram_ctrl_r       PCIE_PCA_SRAM_CTRL            @0x444270;
  pcie_pp_sram_ctrl_r        PCIE_PP_SRAM_CTRL             @0x444280;
  pcie_pcw_sram_ctrl_r       PCIE_PCW_SRAM_CTRL            @0x444290;
  pcie_rhi_sram_ctrl1_r      PCIE_RHI_SRAM_CTRL1           @0x444298;
  pcie_rhi_sram_ctrl2_r      PCIE_RHI_SRAM_CTRL2           @0x4442a0;
  pcie_thi_sram_ctrl1_r      PCIE_THI_SRAM_CTRL1           @0x4442b0;
  pcie_thi_sram_ctrl2_r      PCIE_THI_SRAM_CTRL2           @0x4442c0;
  pcie_fpga_revid_r          PCIE_FPGA_REVID               @0x4442c8;
  pcie_timeout_cfg_r         PCIE_TIMEOUT_CFG              @0x4442d0;
  pcie_debug_pca_r           PCIE_DEBUG_PCA                @0x4442d8;
  pcie_debug_rhi_r           PCIE_DEBUG_RHI                @0x4442e0;
  pcie_debug_thi_r           PCIE_DEBUG_THI                @0x4442e8;
  pcie_debug_rpp_r           PCIE_DEBUG_RPP                @0x4442f0;
  pcie_debug_tpp_r           PCIE_DEBUG_TPP                @0x4442f8;
  pcie_debug_fum_r           PCIE_DEBUG_FUM                @0x444300;
  pcie_debug_mem_ctrl_r      PCIE_DEBUG_MEM_CTRL           @0x444308;
  pcie_debug_mem_data_r      PCIE_DEBUG_MEM_DATA[5]        @0x444340 += 8;
  pcie_lvmmc_r               PCIE_LVMMC                    @0x444380;
  pcie_lvmmi_r               PCIE_LVMMI                    @0x444388;
  pcie_fum_dfx_cnt_r         PCIE_FUM_DFX_CNT[6]           @0x4443c0 += 8;
  pcie_fum_dfx_sta_r         PCIE_FUM_DFX_STA[6]           @0x444400 += 8;
  pcie_host_misc_r           PCIE_HOST_MISC                @0x444440;
  pcie_host_lane_ctrl_r      PCIE_HOST_LANE_CTRL           @0x444448;
  pcie_serdes_ctrl_r         PCIE_SERDES_CTRL[8]           @0x444480 += 8;
}; // final size: 0x4444c0 <= 0x800000 = 8<<20

MODULE MbyMapperStageModel EXPORTS MbyMapperStageModel, MbyMapperSizes;

IMPORT mby_top_map_addr AS TopAddr;

IMPORT mby_ppe_mapper_map AS Map;
IMPORT mby_ppe_mapper_map_addr AS MapAddr;

IMPORT ServerPacket AS Pkt;
IMPORT Metadata;
IMPORT MbyParserToMapperMeta;
IMPORT MbyMapperToClassifierMeta;
IMPORT ModelStageResult;
IMPORT MbyMeta;
IMPORT MbyPaFlags, MbyPaKeys;

PROCEDURE HandlePacket(ipkt : Pkt.T;
                       h : TopAddr.H;
                       indices : Indices;
                       imd : Metadata.T;
                       out : ModelStageResult.T) =
  BEGIN
    (* purpose of this routine is to map the records,
       it should probably be autogenerated!  *)
    HandlePacketInt(h.read  .Mpt[indices.MptIdx].RxPpe.Mapper,
                    h.update.Mpt[indices.MptIdx].RxPpe.Mapper,
                    imd,
                    out)
  END HandlePacket;
  
PROCEDURE HandlePacketInt(READONLY r  : Map.T;
                          READONLY u  : MapAddr.U;
                          im          : Metadata.T;
                          out         : ModelStageResult.T) =
  VAR
    mbm : MbyMeta.T :=
        im.ofType(TYPECODE(MbyMeta.T));
    p2m : MbyParserToMapperMeta.T :=
        im.ofType(TYPECODE(MbyParserToMapperMeta.T));

    isIPv4, isIPv6 := ARRAY [0..NIsIpBits-1] OF BOOLEAN { FALSE, .. };

    
  BEGIN
    (* we dont actually use the ipkt here *)
    WITH
      portCfg = r.MapPortCfg[mbm.rxPort]
     DO
      IF p2m.paFlags[MbyPaFlags.T.InrL3V] THEN
        isIPv4[1] := p2m.paKeysValid[MbyPaKeys.T.InnerIpHdr];
        isIPv6[1] := NOT isIPv4[1];
      END;
      IF p2m.paFlags[MbyPaFlags.T.OtrL3V] THEN
        isIPv4[0] := p2m.paKeysValid[MbyPaKeys.T.OuterIpHdr];
        isIPv6[0] := NOT isIPv4[1];
      END;








      
    END;

    (* the next line s.b. moved up to HandlePacket *)
    out.push(opkt := NIL, om := NEW(MbyMapperToClassifierMeta.T))
  END HandlePacketInt;

BEGIN END MbyMapperStageModel.

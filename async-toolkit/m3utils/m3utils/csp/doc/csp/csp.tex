\documentclass[11pt]{report}

% Page layout
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{parskip}
\setlength{\parindent}{0pt}

% Typography
%\usepackage{times}
%\usepackage[T1]{fontenc}

% Math and symbols
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{longtable}
\usepackage{fancyvrb}
\usepackage{booktabs}

% Code listings for syntax
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily\small,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    breaklines=true,
    frame=none,
    xleftmargin=2em,
}

% For BNF-style syntax rules
\usepackage{syntax}
\setlength{\grammarparsep}{4pt}
\setlength{\grammarindent}{8em}

% Hyperlinks
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue]{hyperref}

% Headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{The Fulcrum CSP Language}}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Section formatting
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}

% Custom commands
\newcommand{\keyword}[1]{\texttt{\textbf{#1}}}
\newcommand{\type}[1]{\textit{#1}}
\newcommand{\term}[1]{\textit{#1}}
\newcommand{\nonterminal}[1]{\textit{#1}}

% Title page
\title{\textbf{The Fulcrum CSP Language}}
\author{Edited by\\
  Mika Nystr\"om \\
  Neuromorphic Computing Laboratory \\
Intel Corporation}
\date{Version 0.0\\
\today}

\begin{document}

\maketitle

\begin{center}
\textit{The language designer should be familiar with many alternative\\
features designed by others, and should have excellent judgment in\\
choosing the best and rejecting any that are mutually inconsistent...\\
One thing he should not do is to include untried ideas of his own.\\
His task is consolidation, not innovation.}

---C.A.R. Hoare
\end{center}

\vspace{1em}

\noindent

\vspace{1em}

\noindent
Copyright \copyright\ [2025] [Intel Corporation]. All Rights Reserved.  Distributed under the Apache License, Version 2.0.

\clearpage

\tableofcontents

\clearpage

% ========================================
% INTRODUCTION
% ========================================
\chapter{Introduction}

\section{History}
Starting in the mid 1980s, Alain Martin at Caltech started to use a
variant of Hoare's Communicating Sequential Processes to describe
asynchronous circuit designs, and while the basic syntax of the
language was well established by Martin and his students, the usage
model and many implementation details were left informal.  A detailed
implementation effort followed at Fulcrum Microsystems in the early
2000s, and the resulting language was used to describe the high-level
design of numerous Fulcrum products throughout the 2000s and 2010s,
and later at Intel, in the Neuromorphic Computing Lab of Intel Labs.
The initial implementation was structured as a circuit simulator, but
over time, a direct-to-silicon compiler was also developed at Fulcrum,
Intel, and Timeless Design Automation.  At the time of writing, CSP
has seen over two decades of successful use as a hardware description
and validation language.

CSP, like its 1970s namesake, is a programming language based on a
static graph of many small independent processes, which do not share
internal state but use the rendezvous for communication.  CSP supports
many features that are helpful in hardware design, such as
arbitrary-precision arithmetic by default, bit extraction, packing and
unpacking of structured data, and of course, extremely high levels of
multithreading.

One design goal of CSP has been to as much as possible banish
unpredictable behaviors from the language.  Unpredictable behaviors
that might be of little concern in software development can be a much
bigger concern in hardware description, because CSP is used both as
the input to a silicon compiler and to a software runtime (called a
``simulator''), and the software implementation is used to validate
the design before fabrication.  Unspecified constructs in the language
would allow the two implementations to diverge, meaning that results
from software simulation of the design could not be relied on to
validate the design since the hardware implementation might be
different.  Accordingly, CSP variables have well-defined initial
values, and expression-evaluation orders as well as function-parameter
evaluation orders are strictly specified.

Like many (but not all) of its predecessors, CSP does not include
facilities for process creation or the establishment of communication
channels between processes.  In the Fulcrum system, these tasks are
handled by an enclosing language environment called CAST (Caltech
ASynchronous Tools).  In other words, when a CSP program starts
executing, the entire process graph has already been created and
connected.  This of course closely matches the distinction between
fabrication and operation that is present in all hardware.
Nevertheless, it is not difficult to imagine a system that uses CSP to
describe processes that will be created and connected by a means other
than CAST: for example a dynamic means, such as might be desired in a
software system.  CAST is not a subject of this report, and mentions
of that language can be read as simply referring to the process
creation and connection that must occur before a CSP process begins
execution.  That being said, one of the main uses of CSP is to serve
as a vehicle for performing process decomposition (``Martin synthesis'')
and it is the CAST framework that establishes the relationship between
different CSP descriptions of the same computational process.

\subsection{Note on the name ``CSP''}
This report describes the syntax and semantics of {\em Fulcrum CSP,} a
programming language developed at Fulcrum Microsystems in the early
2000s, before that company was acquired by Intel in 2011.  The
language takes its name from Hoare's 1978 {\em Communicating
  Sequential Processes,} what the wider programming community knows as
``CSP'', but has seen significant changes from that language, in
particular following the {\em Communicating Hardware Processes\/} (CHP)
described (but not yet named) by Martin in 1986.  In any case, the
name ``CSP'' will be used to mean Fulcrum CSP throughout this report.


\section{Perspective}

The vast majority of chip design today is performed in variants of the
Verilog language.  Verilog was introduced in 1984 as a means of
circuit description and simulation, and is subject to an IEEE
standardization process.  Over the years, the simplicity of the
original Verilog idea has been transformed into a veritable
encyclopedia of design, description, and verification capabilities.
Verilog today is used for many tasks throughout a chip-design process
where each task uses only a small subset of the language.  
Verilog shares some fundamental design aspects with CSP; in
particular, Verilog's semantics allow for descriptions with a very
high level of concurrency, and another similarity is that both
languages make it difficult (but not impossible) to allocate storage
space dynamically, as this is not something that has a sensible
implementation in silicon.  At the same time, the wide variety of
computational models supported by Verilog make that language extremely
difficult to describe and extremely demanding of programming
methodology---in particular when it comes to communication between
different system modules.  In contrast, CSP provides specific,
restricted communication constructs representing the rendezvous and
Martin's probe, which leads to highly structured communicating
processes.  Unlike the situation in Verilog, where the
programmer-designer must specify the details of sequencing for every
gate, CSP allows the implementation of sequencing to be abstracted into
the chosen implementation for the rendezvous.

\section{Overview}

\section{Features}

Fulcrum CSP has a number of features that may need introduction for those
familiar with the majority of software or hardware languages, and the
remainder of the section will discuss these.

\subsection{Process decomposition}

\subsection{Guarded commands}

\subsection{The rendezvous}

\subsection{Channel probes}

\subsection{Type system}
\subsubsection{Arbitrary-precision arithmetic}
\subsubsection{Structured types}

\subsection{Variable initialization}

\subsection{Functions}



\section{Acknowledgments}
Our goal with this report is to be as clear as Greg Nelson's {\em
  Systems Programming with Modula-3\/} and the present editor
gratefully acknowledges the influence of that book, and parts of the
language definition have been shamelessly stolen from that book.  We
also gratefully acknowledge that text and inspiration has also been
borrowed from the Asynchronous Circuit Toolkit (ACT) of Rajit
Manohar's group at Yale.

\chapter{Language Definition}
% ========================================
% DEFINITIONS
% ========================================
\section{Definitions}
\label{sec:definitions}

A CSP program specifies a computation that acts on a sequence of
digital components called {\em locations.}  A CSP program describes
a {\em process\/} within a distributed system.  Within a single process,
a location can be referenced by and shared between different statements, but 
a single location is bound to only one process.

A {\em static error\/} is an error that the implementation must detect
before program execution.  Violations of the language definition are
static errors unless they are explicitly classified as runtime errors.

A {\em checked runtime error\/} is an error that the implementation must
detect and report at runtime.  The method for reporting such errors
is implementation-dependent.

An {\em unchecked runtime error\/} is an error that is not guaranteed to
be detected, and can cause the subsequent behavior of the computation to
be arbitrary.  Unchecked runtime errors cannot occur in CSP.

A {\em variable\/} is a
set of locations that represents a mathematical value according to a
convention determined by the variable's {\em type.}  If a value can be
represented by some variable of type {\tt T}, then we say that the
value is a {\em member\/} of {\tt T} and {\tt T} {\em contains\/} the
value.

A {\em port\/} is a means for a process to communicate with other
processes.  A port can be either an {\em output port,} in which case
values written to the port will appear in another process, or an {\em
  input port,} in which case values will appear at the port that were
written in another process.

An {\em identifier\/} is a symbol declared as a name for a variable,
type, port, function, etc.  The region of the program over a which a
declaration applies is called the {\em scope\/} of the declaration.
The meaning of an identifier is determined by the enclosing scope,
but declaring an identifier so that it is visible more than once in
a single scope is a static error.

\section{Types}
\label{sec:types}

\subsection{Integer types}
\label{subsec:integer-types}
There are three kinds of integer types: {\tt int}, {\em signed integers,}
and {\em unsigned integers.} {\tt int} contains zero, all positive integers
(Peano natural numbers), and the negation of the positive integers.

Signed integers are declared {\tt sint(W)} where {\tt W} is the
type's width in bits, which is a constant expression.  A type {\tt sint(W)} contains the values
$[-2^{{\tt W}-1}..2^{{\tt W}-1}-1]$.

Unsigned integers are declared {\tt int(W)} where {\tt W} is the
type's width in bits, which is a constant expression.  A type {\tt int(W)} contains the values
$[0..2^{{\tt W}}-1]$.

\subsection{Boolean}

The type {\tt bool} contains two values: {\tt false} and {\tt true}.

In cases where a boolean variable is implicitly converted to {\tt int},
{\tt false} is interpreted as 0 and {\tt true} is interpreted as -1.

\subsection{String}

The type {\tt string} contains all sequences of characters, where a
character is one of 256 constant values.  The visual representation of
the characters is system dependent but generally follows 7-bit ASCII
for the lower half (0..127) with a system-dependent upper half.

\subsection{Structure types}

A {\em structure type\/} is a sequence of named variables, called the
{\em fields\/} of the structure type. Different fields can have
different types.  The name and type of each field is statically
determined by the structure type's type.  The expression {\tt s::f}
designates the field named {\tt f} in the structure {\tt s}.

A structure type declaration has the form:
\begin{verbatim}
  structure T =
   (
    FieldList
   );
\end{verbatim}
where {\tt FieldList} is a list of field declarations, each of which has the
form:
\begin{verbatim}
   Type fieldName = initial;
\end{verbatim}
where {\tt fieldName} is an identifier, {\tt Type} is any type, and
{\tt initial} is a constant expression.  The field names must be
distinct.  Empty structure types are not allowed.

The constant {\tt initial} is a initial value used when a structure is
constructed.  The {\tt = initial} can be omitted, in which case the default
value for the type will be used for initialization.

\subsection{Array types}

An {\em array\/} is an indexed collection of component variables,
called the {\em elements\/} of the array.  The indexes are of type
{\tt int}.  The elements all have the same size and the same type,
called the {\em element type\/} of the array.

The {\em shape\/} of a multi-dimensional array is the sequence of its
lengths in each dimension.  More precisely, the shape of an array is
its length followed by the shape of any of
its elements; the shape of a non-array is the empty sequence.
The {\em layout\/} of a multi-dimensional array is the sequence of
its lengths and starting indexes in each dimension; the layout of a non-array
is the empty sequence.

All arrays are {\em fixed\/} in CSP, and the layout of every array is
determined before program startup.

An array declaration has the form:
\begin{verbatim}
  Element Id Layout;
\end{verbatim}
where {\tt Element} is the element type and {\tt Layout} represents
the layout of the array.  The layout can be specified in one of
two equivalent ways: either as a comma separated list of ranges {\tt lo..hi}
between brackets or as a list of ranges {\tt lo..hi} within separate brackets:
\begin{verbatim}
  T a[0..2,0..2];
  T b[0..2][0..2];
\end{verbatim}
here {\tt a} and {\tt b} have equivalent declarations.  Any array index
can also be specified with a single number {\tt length} in which case the
index ranges over {\tt 0..length - 1}.  Hence the following are equivalent:
\begin{verbatim}
  T c[0..2,0..5];
  T d[3][6];
\end{verbatim}

Types that are not array types are called {\em scalar types,} and instances
of such types are called {\em scalars.}

   


\subsection{Packed and fixed-width types}
The following types are of fixed width: signed integers,
unsigned integers, and booleans.

If a structure type contains only fixed-width fields, then the
structure type is a {\em packed structure type.}  A packed structure
type is itself of fixed width.

If the element type of an array is of fixed width, then the array is a
{\em packed array type.}  A packed array type is itself of fixed width.




\subsection{Channels and ports}

A channel is used for communication between two concurrent processes.
Formally, a channel is an ordered 6-tuple $(S, P_S, R, P_R, W,
\Sigma)$ where $S$ is a process called the {\em sender,} $P_S$ is the
name of the output port in the sender, $R$ is a process called the
{\em receiver,} $P_R$ is the name of the input port in the receiver, $W$
is an integer called the {\em width\/} of the channel, and $\Sigma$ is
an integer called the {\em slack\/} of the channel.  Channels are not
declared within the CSP language but described externally.  Values
transacted over a channel are of type {\tt int($W$)} (see section~\ref{subsec:integer-types}.)

Within a CSP process, a channel is visible either as an input port or
as an output port.  Hence, channels are point-to-point and have exactly
one sender and exactly one receiver.


\section{Functions}
\label{sec:functions}
A {\em function\/} is a triple consisting of:
\begin{itemize}
\item the {\em name,} which is an identifier.
  
\item the {\em body,} which is a statement.

\item the {\em signature,} which specifies the function's formal arguments and
  result type.
\end{itemize}
A function that returns as a result is also called a {\em function procedure\/}; a function that does not return a result is called a {\em proper procedure.}

A function definition has the form:
\begin{verbatim}
   function F sig = ( body );
\end{verbatim}
where {\tt body} is the body, and {\tt sig} is a signature specification,
which has the form:
\begin{verbatim}
   (formal0 ; ...; formaln-1) : R
\end{verbatim}
where each {\tt formali} is a formal parameter declaration, as described below and {\tt R} is the result type, which can be any type.  The ``{\tt : R}'' can
be omitted, making the signature that of a proper procedure.

A formal parameter declaration has the form
\begin{verbatim}
   Type Mode Name Layout = Initial
\end{verbatim}
where
\begin{itemize}
\item {\tt Type} is the type of the parameter if the parameter is scalar, or the element type of the parameter if the parameter type is an array type
  
\item {\tt Mode} is a parameter mode, which can be {\tt -}, {\tt +}, or {\tt +-}.  {\tt Mode} can be omitted, in which case it is taken to be {\tt +-}.

\item {\tt Name} is an identifier that names the parameter.

\item {\tt Layout} specifies the array layout for an array parameter; if it is
  omitted, the parameter is scalar.

\item{\tt Initial} specifies the initial value of a parameter whose mode is {\tt +}.  {\tt = Initial} can be omitted.
\end{itemize}
When a series of parameters share the same type, {\tt Mode Name Layout = Initial} can be a replaced with a comma-separated list of mode, name, layout, and initial value, in which case the type is repeated for each parameter.  That is:
\begin{verbatim}
   Type Mode0 Name0 Layout0 = Initial0, Mode1 Name1 Layout1 = Initial1, ...
\end{verbatim}
is shorthand for
\begin{verbatim}
   Type Mode0 Name0 Layout0 = Initial0; Type Mode1 Name1 Layout1 = Initial1; ...
\end{verbatim}




\section{Statements}
\label{sec:statements}

Executing a statement produces a computation that can halt, cause a checked
runtime error, or loop forever.

\subsection{Assignment}

We specify assignment rules by enumeration.

\subsubsection{General assignability rule}

A value is assignable to a variable of the same type.  If the type of a
value differs from the target variable, the value is not assignable to
the variable, with the exceptions below.

\subsubsection{Integer assignment}

The three kinds of integer types are all assignable to each other by
virtue of the fact that all integer right-hand-sides are interpreted
as being of type {\tt int}.  Assigning a value of type {\tt int} to a
variable of type {\tt int(W)} or {\tt sint(W)} is done by interpreting
the RHS as a two's-complement number and performing a bitwise
assignment into the locations representing the LHS, also interpreted
as a two's-complement number, discarding any bits that do not fit in
the target locations.


\subsubsection{Array assignment}

Arrays are assignable if they have the same shape and their element types
are assignable.

\subsubsection{Integer to string assignment}

An integer value is assignable to a string variable.  The value assigned
to the string variable is the hexadecimal ASCII string corresponding
to the integer.

\subsubsection{Expression assignment}

An expression {\tt e} is {\em assignable\/} to a type {\tt T} if {\tt e} is
assignable to a variable of type {\tt T}.

An assignment statement has the form:
\begin{verbatim}
   v = e
\end{verbatim}
where {\tt v} is a writable designator and {\tt e} is an expression
assingable to the variable designated by {\tt v}.  The statement sets
{\tt v} to the value of {\tt e}.  {\tt v} is always evaluated before
{\tt e}, and {\tt v} is updated after {\tt e} is evaluated.  In
particular, if {\tt v} and {\tt e} are overlapping subarrays, the
assignment is performed in such a way that no element is used as a
target before it is used as a source.

\subsection{Function call}

A function call has the form:
\begin{verbatim}
   F(Bindings)
\end{verbatim}
where {\tt F} is the name of a function and {\tt Bindings} is a list
of bindings.  A binding has the form {\tt actual}, where {\tt actual} is
an expression.  If the list of bindings is empty, the parentheses are still
required.

Function parameters are passed by value-return.  This means that for
each formal that has {\tt -} in its mode, the binding is turned
into an assignment
\begin{verbatim}
   Name = actual
\end{verbatim}
where {\tt Name} is the name of the formal, which is evaluated before
the body of the function.  For a formal that does not have {\tt -} in its
mode, the binding is instead turned into an assignment
\begin{verbatim}
   Name = initial
\end{verbatim}
where {\tt initial} is the initial value from the function signature
  for that parameter.
For each formal that has {\tt +} in its mode,
the binding is turned into an assignment
\begin{verbatim}
   actual = Name 
\end{verbatim}
which is evaluated after the body of the function.  Finally, for function
procedures, the return value of the function is declared using the function's
own name (e.g., {\tt F}) before the
body of the function as having type {\tt R} (the return type of the function),
and upon return of the function the returned value is {\tt F}.

To execute the call, the function's arguments are evaluated left-to-right,
the formal parameters are assigned, the body of the procedure is executed, and
{\tt +} parameters and the function result (if present) are assigned.

For example, consider:
\begin{verbatim}
  function F(int +x = 12; -y) : int = ( x = x * y; F = x + y );
  q = 2;
  z = F(q, 3);
\end{verbatim}
following the rules above, this is equivalent to:
\begin{verbatim}
  q = 2;
  int x = 12;
  int y = 3;
  int F;
  x = x * y;
  F = x + y;
  z = F;
\end{verbatim}












\section{Declarations}
\label{sec:declarations}
CSP declarations in a program occur in a specified order.  Certain
constants, functions, and structure types can be pre-declared by the
CAST environment of a CSP program.  Within a single CSP program,
the sequence of declarations is fixed:
\begin{verbatim}
  structure type declarations;
  function declarations;
  program body
\end{verbatim}
the program body is evaluated when the system starts to run.  The evaluation
order of different CSP programs within a system is unspecified.

\section{Expressions}
\label{sec:expressions}


\section{Syntax}


\textbf{Comments.} Comments are treated as whitespace and have the form...


% ========================================
% EXPRESSIONS
% ========================================
\section{Expressions}
\label{sec:expressions}

An expression denotes a value and has a type.

\subsection{Literals}

Numeric, character, and string literals.

\subsection{Operators}

\subsubsection{Arithmetic Operators}

\begin{tabular}{ll}
\texttt{+} & Addition \\
\texttt{-} & Subtraction \\
\texttt{*} & Multiplication \\
\texttt{/} & Division \\
\texttt{\%} & Modulo \\
\end{tabular}

\subsubsection{Relational Operators}

\begin{tabular}{ll}
\texttt{=} & Equal \\
\texttt{<>} & Not equal \\
\texttt{<} & Less than \\
\texttt{<=} & Less than or equal \\
\texttt{>} & Greater than \\
\texttt{>=} & Greater than or equal \\
\end{tabular}

\subsubsection{Logical Operators}

\begin{tabular}{ll}
\keyword{AND} & Logical conjunction \\
\keyword{OR} & Logical disjunction \\
\keyword{NOT} & Logical negation \\
\end{tabular}

\subsection{Type Conversions}

Describe explicit and implicit conversions.

\section{Standard Interfaces}
\label{sec:stdlib}

\section{Reserved Words}
\label{app:keywords}

\section{Operator Precedence}
\label{app:precedence}

Table of operator precedence and associativity.

\appendix

\chapter{Syntax}

\section{CSP Lexer}
\include{dist/CspLexer}

\section{CSP Parser}
\include{dist/CspParser}

\section{CAST Lexer}
\include{dist/CastTwoLexer}

\section{CAST Parser}
\include{dist/CastTwoParser}

\section{CAST Tree Parser}
\include{dist/CastTwoTreeParser}

\chapter{Example Programs}
\label{app:examples}

Complete example programs illustrating language features.

% ========================================
% INDEX (optional)
% ========================================
% \printindex


\end{document}

/**
 * INTEL TOP SECRET
 * Copyright 2004 - 2013 Intel Corporation
 * All Rights Reserved.
 */

package com.fulcrummicro.hw.verification.chip.mgmt.registers;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.avlsi.util.cmdlineargs.CommandLineArgs;
import com.avlsi.util.cmdlineargs.defimpl.CachingCommandLineArgs;
import com.avlsi.util.cmdlineargs.defimpl.CommandLineArgsDefImpl;
import com.avlsi.util.cmdlineargs.defimpl.CommandLineArgsWithConfigFiles;
import com.fulcrummicro.hw.verification.chip.mgmt.AddressTable;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CTable;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Cast;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastMgmt;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastMgmtShim;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastMgmtSynth;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMap;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMapShimRefinements;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMapSynth;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Cmd;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.H;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Perl;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Python;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.RDL;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.RDLTop;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.SdkDebugFields;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.SdkDebugRegs;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Specman;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.SramsHtml;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Tcl;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.UVM;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.VfUL;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.Verilog;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.VerilogRegMap;
import com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.VerilogStruct;
import com.fulcrummicro.hw.verification.lib.constants.ConstantsEnum;

/**
 * Generally, test bench code will request the address of a register
 * by calling one of the lookupAddress(...)
 * methods.  Three lookupAddress methods are defined:
 *
 *   lookupAddress(String regName)
 *      Use this on single-entry 32 bit registers, e.g. SYS_CFG_1
 *
 *   lookupAddress(String regName, int entry)
 *      Use this on any array registers, e.g. PORT_CFG_1[2].
 *      Note that the 'entry' value sometimes is expected to range over
 *      0..numEntries-1, while other times is expected over 1..numEntries.
 *      The legal range matches that given in the Functional Spec.
 *
 *   lookupAddress(String regName, int entry, int word)
 *      Use this to obtain the address of a particular word of a multi-word
 *      register.  Very few of these exist: only MA_TABLE, INGRESS_VID_TABLE, and
 *      INGRESS_FID_TABLE so far.
 *
 **/
public class RegisterInfo implements AddressTable {

    boolean failed = false;
    boolean verbose = false;
    private String chip = "bali";

    /** Map of base address to Base **/
    final RegisterBase rootBase = new RegisterBase(this);

    /** Map of register name to Register object **/
    final Map<String, Register> regMap;

    final TreeMap<Integer,Register> regTreeMap;
    final TreeMap<Integer,Register> regNonAliasTreeMap;

    /** Map of struct name to RegisterStruct object **/
    final Map<String, RegisterStruct> structMap;

    /** List of all typedefs that are shared among more than one field */
    final ArrayList<ConstantsEnum> sharedEnumTypedefs = new ArrayList<ConstantsEnum>();

    /* contains info about the CSRs, static so others can access it */
    public static RegisterInfo regInfo = null;

    // Hack in multi region/single entry xml registers like PCIe Host space
    Pattern regAddrExt = Pattern.compile("(.*)\\[(\\d+)\\]");

    // for autogenerated code

    /** map from crossbar port name to RegisterCrossbarPort */
    final Map<String, RegisterCrossbarPort> crossbarPortMap = new HashMap<String, RegisterCrossbarPort>();

    public RegisterInfo(String filename) {
        this(filename, false, false);
    }

    public RegisterInfo(String filename, boolean excludeOldName) {
        this(filename, false, excludeOldName);
    }

    public RegisterInfo(String filename, boolean verbose, boolean excludeOldName) {
        this.verbose = verbose;
        regMap = new HashMap<String,Register>();

        if (excludeOldName) System.out.println("Excluding oldName registers and fields.");

        failed = new RegisterXmlParser(this, excludeOldName).importXml(filename);
        checkForErrors();
        regTreeMap = buildTreeMap();
        regNonAliasTreeMap = buildNonAliasTreeMap();
        structMap = buildStructMap();
    }

    public static ArrayList<Register> getSortedRegisterList(Collection<Register> regs) {
        ArrayList<Register> result = new ArrayList<Register>();

        final TreeSet<Register> regMapSorted = new TreeSet<Register>(new Comparator<Register>() {
            @Override
            public int compare(Register o1, Register o2) {
                int a1 = o1.address+o1.getUnitBaseAddress();
                int a2 = o2.address+o2.getUnitBaseAddress();
                if(a1 == a2) return o1.getName().compareTo(o2.getName());
                return a1 - a2;
            }
        });
        Register r;
        for(Iterator<Register> i = regs.iterator(); i.hasNext(); ) {
            r = i.next(); //registerList[i];

            if(r.checkFieldsForErrors()) {
                System.out.println("Excluding register due to errors: " + r.getName());
                continue; // TODO: remove when these fail the parser as this will be unneeded.
            }

            if(r.oldName) {
                result.add(r);
            }
            regMapSorted.add(r);
        }

        for (Register register : regMapSorted) {
            result.add(register);
        }
        return result;
    }

    public ArrayList<Register> getSortedRegisterList() {
        return getSortedRegisterList(regMap.values());
    }

    protected ArrayList<ConstantsEnum> getTypedefs() {
        ArrayList<ConstantsEnum> typedefs = new ArrayList<ConstantsEnum>();
        typedefs.addAll(sharedEnumTypedefs);
        for (Register r : regMap.values()) {
            for (RegisterField f : r.fields.values()) {
                if((f.typedef != null) && !typedefs.contains(f.typedef)) {
                    typedefs.add(f.typedef);
                }
            }
        }
        return typedefs;
    }

    private static boolean areAliased(Register a, Register b) {
        return (a.alias != null && a.alias.equals(b.name)) ||
            (b.alias != null && b.alias.equals(a.name)) ||
            (a.alias != null && a.alias.equals(b.alias));
    }

    /** Attempts to find the register with the given address. Returns null if not found */
    public Register lookupRegister(int addr) {
    	if(regTreeMap.headMap(addr+1).isEmpty()) {return null;}
    	Register r = regTreeMap.get(regTreeMap.headMap(addr+1).lastKey());
    	if((r != null) && (r.contains(addr))) {
    		return r;
    	}
		return null;
    }

    public Register lookupNonAliasRegister(int addr) {
        if(regNonAliasTreeMap.headMap(addr+1).isEmpty()) {return null;}
        Register r = regNonAliasTreeMap.get(regNonAliasTreeMap.headMap(addr+1).lastKey());
        if((r != null) && (r.contains(addr))) {
            return r;
        }
        return null;
    }

    private TreeMap<Integer,Register> buildNonAliasTreeMap() {
        final TreeMap<Integer,Register> regMapSorted = new TreeMap<Integer,Register>();

        // add one entry for each register
        for(Register r : regMap.values()) {
            if (r.getAlias() == null){
                // only add the non-alias registers
                Register displaced = regMapSorted.put(r.getAddressSafe(), r);
                if(displaced != null && !displaced.oldName) {
                    regMapSorted.put(displaced.getAddressSafe(), displaced); // keep new
                }
            }
        }

        // find overlapping registers and add all their addresses
        HashSet<Register> overlapping = new HashSet<Register>();
        for(Register r : regMapSorted.values()) {
            //JDK1.6: SortedMap<Integer, Register> m = regMapSorted.subMap(r.getAddressSafe(), false, r.getMaxAddress(), true);
            SortedMap<Integer, Register> m = regMapSorted.subMap(r.getAddressSafe()+1, r.getMaxAddress()+1);
            if(!m.isEmpty()) {
                overlapping.add(r);
                overlapping.addAll(m.values());
                if(verbose) System.out.println(r.getName() + " overlaps " + Arrays.toString(m.values().toArray()));
            }
        }
        for(Register r : overlapping) {
            try {
                for(int a=r.base_entry; a<r.entries; a++) {
                    for(int b=r.base_entry_1; b<r.entries_1; b++) {
                        for(int c=r.base_entry_2; c<r.entries_2; c++) {
                            for(int w=0; w<r.width; w++) {
                                Register displaced = regMapSorted.put(r.getAddress(c, b, a, w), r);
                                if((displaced != null) && (displaced != r)) {
                                    this.failed = true;
                                    System.out.println(String.format("ERROR: %s and %s overlap at 0x%x",
                                            displaced.getName(), r.getName(), r.getAddress(c, b, a, w)));
                                }
                            }
                        }
                    }
                }
            } catch (UnknownAddressException e) {
                this.failed = true;
                System.out.println("ERROR in geteAddress of register " + r.getName());
            }
        }

        // now prune out as possible
        Register current = null;
        for(Iterator<Map.Entry<Integer, Register>> i = regMapSorted.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry<Integer, Register> entry = i.next();
            if(entry.getValue() == current) {
                i.remove();
            } else {
                current = entry.getValue();
            }
        }

        return regMapSorted;
    }

    private TreeMap<Integer,Register> buildTreeMap() {
        final TreeMap<Integer,Register> regMapSorted = new TreeMap<Integer,Register>();

        // add one entry for each register
        for(Register r : regMap.values()) {
            // only add the non-alias registers
        	Register displaced = regMapSorted.put(r.getAddressSafe(), r);
        	if(displaced != null && !displaced.oldName) {
        		regMapSorted.put(displaced.getAddressSafe(), displaced); // keep new
        	}
        }

        // find overlapping registers and add all their addresses
        HashSet<Register> overlapping = new HashSet<Register>();
        for(Register r : regMapSorted.values()) {
        	//JDK1.6: SortedMap<Integer, Register> m = regMapSorted.subMap(r.getAddressSafe(), false, r.getMaxAddress(), true);
        	SortedMap<Integer, Register> m = regMapSorted.subMap(r.getAddressSafe()+1, r.getMaxAddress()+1);
        	if(!m.isEmpty()) {
        		overlapping.add(r);
        		overlapping.addAll(m.values());
        		if(verbose) System.out.println(r.getName() + " overlaps " + Arrays.toString(m.values().toArray()));
        	}
        }
        for(Register r : overlapping) {
        	try {
	            for(int a=r.base_entry; a<r.entries; a++) {
	                for(int b=r.base_entry_1; b<r.entries_1; b++) {
	                    for(int c=r.base_entry_2; c<r.entries_2; c++) {
	                    	for(int w=0; w<r.width; w++) {
	                    		Register displaced = regMapSorted.put(r.getAddress(c, b, a, w), r);
	                    		if((displaced != null) && (displaced != r)) {
	                    			this.failed = true;
	                    			System.out.println(String.format("ERROR: %s and %s overlap at 0x%x",
	                    					displaced.getName(), r.getName(), r.getAddress(c, b, a, w)));
	                    		}
	                    	}
	                    }
	                }
	            }
        	} catch (UnknownAddressException e) {
        		this.failed = true;
        		System.out.println("ERROR in geteAddress of register " + r.getName());
        	}
        }

        // now prune out as possible
        Register current = null;
        for(Iterator<Map.Entry<Integer, Register>> i = regMapSorted.entrySet().iterator(); i.hasNext(); ) {
        	Map.Entry<Integer, Register> entry = i.next();
        	if(entry.getValue() == current) {
        		i.remove();
        	} else {
        		current = entry.getValue();
        	}
        }

        return regMapSorted;
    }

    private Map<String, RegisterStruct> buildStructMap() {
        Map<String, RegisterStruct> structs = new HashMap<String, RegisterStruct>();
        for(RegisterBase base : rootBase.getBases(null)) {
            for(RegisterStruct s : base.structs) {
                structs.put(s.name, s);
            }
        }
        return structs;
    }

    private void checkForErrors() {
        rootBase.checkForErrors(this);

        final TreeMap<Integer,ArrayList<Register>> regAddressMap = new TreeMap<Integer,ArrayList<Register>>();
        final TreeMap<Integer,Register> regMapSorted = new TreeMap<Integer,Register>();
        Register r;
        for(Iterator<Register> i = regMap.values().iterator(); i.hasNext(); ) {
            r = i.next();
            if(r.oldName) continue; // any errors will be flagged on the original register and
                                    // we want to ignore any errors about duplicates

            Register displaced = regMapSorted.put(r.address+r.getUnitBaseAddress(), r);
            if((displaced != null) && !areAliased(displaced, r)) {
                System.err.println("ERROR: " + displaced.name + " has the same address as " +
                    r.name + " (0x" + Integer.toHexString(r.address+r.getUnitBaseAddress()) + ")");
                this.failed = true;
            }
        }

        for (Integer key : regAddressMap.keySet()) {
            ArrayList<Register> addrList = regAddressMap.get(key);
            if((addrList != null) && addrList.size() > 1) {
                String error = "ERROR: multiple registers at 0x" + Integer.toHexString(key) + ": ";
                for (Register register : addrList) {
                    error += register.name + ", ";
                }
                System.err.println(error.substring(0,error.length()-2));
                this.failed = true;
            }
        }
    }

    public void printRegisterList() {
        for (Iterator<Register> i=regMap.values().iterator(); i.hasNext();) {
            System.out.println(i.next());
        }
    }

    public void printNonAtomicRegisterList() {
        System.out.println(String.format("%-15s %-30s %8s %8s",
                "Reg set", "Register", "atomic", "full"));
        for (Register r : getSortedRegisterList()) {
            if(r.atomic_width < r.width) {
                System.out.println(String.format("%-15s %-30s %8d %8d",
                        r.base.name, r.getName(), r.atomic_width, r.width));
            }
        }
    }

    public RegisterBase getRegisterBase(String name) {
        for(RegisterBase base : rootBase.getBases(null)) {
            if(base.name.equals(name)) { return base; }
        }
        return null;
    }

    public Register lookupRegister(String name) {
        return regMap.get(name);
    }

    public Map<String,Register> getRegisterMap() { return regMap; }

    /** returns a Collection that contains all current (not oldName) registers */
    public Collection<Register> getCurrentRegisters() {
        Collection<Register> regs = new ArrayList<Register>();

        for (Register register : regMap.values()) {
            if(!register.oldName) regs.add(register);
        }

        return regs;
    }

    public RegisterField getField(String regName, String fieldName) {
        RegisterStruct reg = regMap.get(regName);

        if(reg == null) reg = structMap.get(regName);

        if(reg != null)
            return reg.getField(fieldName);

        return null;
    }

    public SortedSet<RegisterCrossbarPort> getSortedCrossbarPorts() {
        TreeSet<RegisterCrossbarPort> ss = new TreeSet<RegisterCrossbarPort>(this.crossbarPortMap.values());
        return ss;
    }

    /** Returns word 'word' of entry 'entry' in the specified array register **/
    public int lookupAddress(String regName, int entry2, int entry1, int entry0, int word)
        throws IndexOutOfBoundsException, UnknownAddressException {
        String modName;
        Matcher m = regAddrExt.matcher(regName);
        int offset = 0;
        if (m.matches()) {
            modName = m.group(1);
            offset = Integer.parseInt(m.group(2));
        } else {
            modName = regName;
        }
        Register reg = regMap.get(modName);
        if (reg == null)
            throw new UnknownAddressException("Address of "+
                "Unknown register "+modName+" requested.");
        return reg.getAddress(entry2, entry1, entry0, word) + 0x100000*offset;
    }

    /** Returns word 'word' of entry 'entry' in the specified array register **/
    public int lookupAddress(String regName, int entry1, int entry0, int word)
        throws IndexOutOfBoundsException, UnknownAddressException {
        String modName;
        Matcher m = regAddrExt.matcher(regName);
        int offset = 0;
        if (m.matches()) {
            modName = m.group(1);
            offset = Integer.parseInt(m.group(2));
        } else {
            modName = regName;
        }
        Register reg = regMap.get(modName);
        if (reg == null)
            throw new UnknownAddressException("Address of "+
                "Unknown register "+modName+" requested.");
        return reg.getAddress(entry1, entry0, word) + 0x100000*offset;
    }

    /** Returns word 'word' of entry 'entry' in the specified array register **/
    public int lookupAddress(String regName, int entry, int word)
        throws IndexOutOfBoundsException, UnknownAddressException {
        String modName;
        Matcher m = regAddrExt.matcher(regName);
        int offset = 0;
        if (m.matches()) {
            modName = m.group(1);
            offset = Integer.parseInt(m.group(2));
        } else {
            modName = regName;
        }
        Register reg = regMap.get(modName);
        if (reg == null)
            throw new UnknownAddressException("Address of "+
                "Unknown register "+modName+" requested.");
        return reg.getAddress(entry,word) + 0x100000*offset;
    }

    /** Returns the address of 'entry' in the specified array register **/
    public int lookupAddress(String regName, int entry)
        throws IndexOutOfBoundsException, UnknownAddressException {
        return lookupAddress(regName,entry,0);
    }

    /** Returns the address of register 'regName' **/
    public int lookupAddress(String regName)
        throws IndexOutOfBoundsException, UnknownAddressException {
        String modName;
        Matcher m = regAddrExt.matcher(regName);
        int offset = 0;
        if (m.matches()) {
            modName = m.group(1);
            offset = Integer.parseInt(m.group(2));
        } else {
            modName = regName;
        }
        Register reg = regMap.get(modName);
        if (reg == null)
            throw new UnknownAddressException("Address of "+
                "Unknown register "+modName+" requested.");
        return reg.getAddress() +  + 0x100000*offset;
    }

    public static PrintWriter generatePrintWriter(String filename) {
        PrintWriter pw = null;
        try {
            pw = new PrintWriter(
                    new BufferedWriter(new FileWriter(filename)));
        } catch(IOException e) {
            System.out.println("Error opening " + filename + ": " + e);
            System.exit(-1);
        }
        return pw;
    }

    public static void main(final String args[]) throws Exception {
        final CommandLineArgs theArgs =
            new CachingCommandLineArgs(new CommandLineArgsWithConfigFiles(new CommandLineArgsDefImpl(args)));

        final String xml = theArgs.getArgValue("xml", "");
        final String cast = theArgs.getArgValue("cast", "");
        final String castStruct = theArgs.getArgValue("castStruct", "");
        final String castMgmt = theArgs.getArgValue("castMgmt", "");
        final String castMgmtSynth = theArgs.getArgValue("castMgmtSynth", "");
        final String castMgmtShim = theArgs.getArgValue("castMgmtShim", "");
        final String castRegMap = theArgs.getArgValue("castRegMap", "");
        final String castRegMapSynth = theArgs.getArgValue("castRegMapSynth", "");
        final String castRegMapShimRefinements = theArgs.getArgValue("castRegMapShimRefinements", "");
        final String verilog = theArgs.getArgValue("verilog", "");
        final String verilogStruct = theArgs.getArgValue("verilogStruct", "");
        final String verilogRegMap = theArgs.getArgValue("verilogRegMap", "");
        final String cDbgFields = theArgs.getArgValue("cDbgFields", "");
        final String cDbgRegs = theArgs.getArgValue("cDbgRegs", "");
        final String cTable = theArgs.getArgValue("cTable", "");
        final String h = theArgs.getArgValue("h", "");
        final String hPrefix = theArgs.getArgValue("hPrefix", "FM_");
        final String pm = theArgs.getArgValue("pm", "");
        final String pmNamespace = theArgs.getArgValue("pmNamespace", "").trim();
        final String py = theArgs.getArgValue("py", "");
        final String pyPrefix = theArgs.getArgValue("pyPrefix", "FM_");
        final String pug = theArgs.getArgValue("pug", "");
        final String pugModule = theArgs.getArgValue("pugModule", "");
        final String cmd = theArgs.getArgValue("cmd", "");
        final String sramsHtml = theArgs.getArgValue("sramsHtml", "");
        final String jamon = theArgs.getArgValue("jamon", "");
        final String uvm = theArgs.getArgValue("uvm", "");
        final String specman = theArgs.getArgValue("specman", "");
        final String vful = theArgs.getArgValue("vful", "");
        final String tcl = theArgs.getArgValue("tcl", "");
        final String tclPackage = theArgs.getArgValue("tclPackage", "");
        final String rdl = theArgs.getArgValue("rdl", "");
        final boolean specmanVirt = !theArgs.getArgValue("specmanVirt", "false").equals("false");
        final boolean verbose = !theArgs.getArgValue("verbose", "false").equals("false");
        final boolean excludeOldName = !theArgs.getArgValue("excludeOldName", "false").equals("false");
        final boolean map = !theArgs.getArgValue("map", "false").equals("false");
        final boolean registerMap = !theArgs.getArgValue("registerMap", "false").equals("false");
        final boolean suppressTypedefEnums = !theArgs.getArgValue("suppressTypedefEnums", "false").equals("false");
        final boolean force = !theArgs.getArgValue("force", "false").equals("false");
        final boolean testpoint = theArgs.getArgValue("testpoint", "false").equals("true");
        final boolean coverage = theArgs.getArgValue("coverage", "false").equals("true");
        final boolean atomicList = !theArgs.getArgValue("atomic", "false").equals("false");

        if(xml != "") {
            final RegisterInfo newRegInfo = new RegisterInfo(xml, verbose, excludeOldName);
            if(newRegInfo.failed & !force) {
                System.err.println("Error during parsing (See above). Add --force=true to generate output anyway.");
                System.exit(-2);
            }
            newRegInfo.chip = theArgs.getArgValue("chip", newRegInfo.chip);

            ArrayList<RegisterBase> bases = newRegInfo.rootBase.getBases(null);
            ArrayList<Register> regs = newRegInfo.getSortedRegisterList();

            Collection<RegisterCrossbarPort> crossbarPorts = newRegInfo.getSortedCrossbarPorts();

            if(verilog != "") {
                new Verilog().render(generatePrintWriter(verilog), bases, regs);
            }
            if(verilogStruct != "") {
                new VerilogStruct().render(generatePrintWriter(verilogStruct),
                                           bases, regs,
                                           newRegInfo.getTypedefs(), suppressTypedefEnums);
            }
            if(verilogRegMap!= "") {
                new VerilogRegMap().render(generatePrintWriter(verilogRegMap), crossbarPorts, bases, regs, newRegInfo.chip);
            }
            if(cast != "") {
                new Cast().render(generatePrintWriter(cast), bases, regs, newRegInfo.chip);
            }
            if(castStruct != "") {
                System.out.println("ERROR: --castStruct was removed. Look in the standard .cast output.");
            }
            if(castMgmt != "") {
                new CastMgmt().render(generatePrintWriter(castMgmt), bases, regs, newRegInfo.chip);
            }
            if(castMgmtSynth != "") {
                new CastMgmtSynth().render(generatePrintWriter(castMgmtSynth), bases, regs, newRegInfo.chip);
            }
            if (castMgmtShim != "") {
                new CastMgmtShim().
                    render(generatePrintWriter(castMgmtShim),
                           crossbarPorts, newRegInfo.chip);
            }
            if(castRegMap != "") {
                new CastRegMap().render(generatePrintWriter(castRegMap), crossbarPorts, bases, regs, newRegInfo.chip);
            }
            if(castRegMapSynth != "") {
                new CastRegMapSynth().render(generatePrintWriter(castRegMapSynth), crossbarPorts, bases, regs, newRegInfo.chip);
            }
            if (castRegMapShimRefinements != "") {
                new CastRegMapShimRefinements().
                    render(generatePrintWriter(castRegMapShimRefinements),
                           crossbarPorts, newRegInfo.chip);
            }
            if(cDbgFields != "") {
                new SdkDebugFields().render(generatePrintWriter(cDbgFields), regs, hPrefix);
            }
            if (!cDbgRegs.equals("")) {
                new SdkDebugRegs().render(generatePrintWriter(cDbgRegs), regs, hPrefix, 48, 9, 4);
            }
            if(cTable != "") {
                new CTable().render(generatePrintWriter(cTable), regs, hPrefix);
            }
            if(h != "") {
                new H().render(generatePrintWriter(h), bases, regs, hPrefix);
            }
            if(pm != "") {
                new Perl().render(generatePrintWriter(pm),
                                  bases,
                                  hPrefix,
                                  basename(pm),
                                  pmNamespace,
                                  testpoint);
            }
            if(py != "") {
                new Python().render(generatePrintWriter(py),
                                    bases,
                                    regs,
                                    pyPrefix);
            }
            if (uvm.length() > 0) {
                new UVM().render(generatePrintWriter(uvm), uvm, bases, coverage);
            }
            if (specman.length() > 0) {
                new Specman().render(generatePrintWriter(specman), bases, regs, newRegInfo.chip, specmanVirt);
            }
/*
            if(pug != "")
            {
                if (pugModule.equals("L2AR"))
                {
                    PugL2AR j = new com.fulcrummicro.hw.verification.chip.mgmt.registers.PugL2AR();
                    j.render(generatePrintWriter(pug),
                             bases, regs, newRegInfo, hPrefix,
                             pug.substring(0, pug.lastIndexOf('.')),
                             pugModule);
                }
                else if (pugModule.equals("L3AR"))
                {
                    PugL3AR j = new com.fulcrummicro.hw.verification.chip.mgmt.registers.PugL3AR();
                    j.render(generatePrintWriter(pug),
                             bases, regs, newRegInfo, hPrefix,
                             pug.substring(0, pug.lastIndexOf('.')),
                             pugModule);
                }
                else if (pugModule.equals("STATS"))
                {
                    PugStats pugStatsJamon = new com.fulcrummicro.hw.verification.chip.mgmt.registers.PugStats();
                    pugStatsJamon.render(generatePrintWriter(pug),
                                      bases, regs, newRegInfo, hPrefix,
                                      pug.substring(0, pug.lastIndexOf('.')),
                                      pugModule);
                }
                else if (pugModule.equals("MAPPER"))
                {
                    PugMapper pugMapperJamon = new com.fulcrummicro.hw.verification.chip.mgmt.registers.PugMapper();
                    pugMapperJamon.render(generatePrintWriter(pug),
                                      bases, regs, newRegInfo, hPrefix,
                                      pug.substring(0, pug.lastIndexOf('.')),
                                      pugModule);
                }
                else if(pugModule.equals("MOD"))
                {
                    PugMod pugModJamon = new com.fulcrummicro.hw.verification.chip.mgmt.registers.PugMod();
                    pugModJamon.render(generatePrintWriter(pug),
                                       bases, regs, newRegInfo, hPrefix,
                                       pug.substring(0, pug.lastIndexOf('.')));
                }
                else if(pugModule.equals("FFU"))
                {
                    PugFFU pugFFUJamon = new com.fulcrummicro.hw.verification.chip.mgmt.registers.PugFFU();
                    pugFFUJamon.render(generatePrintWriter(pug),
                                       bases, regs, newRegInfo, hPrefix,
                                       pug.substring(0, pug.lastIndexOf('.')));

                }
                else
                {
                    System.out.println("ERROR: unsupported PUG module");
                }
            }
*/
            if(cmd != "") {
                new Cmd().render(generatePrintWriter(cmd), newRegInfo.regMap.values());
            }
            if(sramsHtml != "") {
                new SramsHtml().render(generatePrintWriter(sramsHtml), regs);
            }
            if(jamon != "") { // for debug
                new Perl().render(generatePrintWriter(jamon),
                                  bases,
                                  hPrefix,
                                  basename(jamon),
                                  pmNamespace,
                                  testpoint);
            }
            if (vful.length() > 0) {
                new VfUL().render(generatePrintWriter(vful),
                                  new File(vful).getName(),
                                  bases,
                                  regs,
                                  hPrefix);
            }/*
            if (tcl.length() > 0) {
                new Tcl().render(generatePrintWriter(tcl),
                                 bases,
                                 regs,
                                 tclPackage,
                                 hPrefix);
            }*/
            if(rdl != "") {
                for(RegisterBase base : bases) {
                    ArrayList<RegisterBase> b = new ArrayList<RegisterBase>();
                    b.add(base);
                    String rdlFilename = String.format("%s/%s.rdl", rdl, base.getName().toLowerCase());
                    new RDL().render(generatePrintWriter(rdlFilename), b, base.getRegisters());
                }
                String rdlFilename = String.format("%s/top.rdl", rdl);
                new RDLTop().render(generatePrintWriter(rdlFilename), bases, regs);
            }
            if(map) newRegInfo.rootBase.printAddressMap();
            if(registerMap) newRegInfo.rootBase.printAddressMap(true);
            if(atomicList) newRegInfo.printNonAtomicRegisterList();
            if(newRegInfo.failed) {
                System.exit(-2);
            }
        } else {
            System.out.println("ERROR: no xml file. use --xml=");
            System.exit(-1);
        }
    }

    private static String basename(String path) {
        String name;
        int dot;

        name = new File(path).getName();
        dot = name.lastIndexOf('.');
        return dot == -1 ? name : name.substring(0, dot);
    }

}

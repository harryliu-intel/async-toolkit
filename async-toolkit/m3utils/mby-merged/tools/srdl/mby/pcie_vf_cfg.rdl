<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>
`include "lib_udp.rdl"



// PCIE_VF_CFG_ID

reg pcie_vf_cfg_id_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    Shall be read from the PF config space.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } VendorID[31:16] = 16'hFFFF       ;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } DeviceID[15:0] = 16'hFFFF;
};



// PCIE_VF_CFG_CMD

reg pcie_vf_cfg_cmd_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        I/O Access Enable. Not used in this design. Always set to zero.

           ";
    ValRandomize = true;
  } IOSpaceEn[31:31] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Memory Access Enable.  

           ";
    ValRandomize = true;
  } MemSpaceEn[30:30] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        Enable Mastering, also named Bus Master Enable (BME)).

           ";
    ValRandomize = true;
  } BusMasterEn[29:29] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Special Cycle Monitoring - Hardwire to 0.

           ";
    ValRandomize = true;
  } SpecialCycEn[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        MWI Enable - Hardwire to 0.

           ";
    ValRandomize = true;
  } MemWrInv[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Palette Snoop Enable - Hardwire to 0.

           ";
    ValRandomize = true;
  } VGAPaletteSnp[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Parity Error Response.

           ";
    ValRandomize = true;
  } ParErrResp[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Wait Cycle Enable - Hardwired to 0b.

           ";
    ValRandomize = true;
  } IdselStep[24:24] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        SERR# Enable.

           ";
    ValRandomize = true;
  } SERRnEn[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Fast Back-to-Back Enable - Hardwire to 0.

           ";
    ValRandomize = true;
  } FastB2BEn[22:22] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Interrupt Disable. When set, devices are prevented from generating legacy interrupt messages.

           ";
    ValRandomize = true;
  } INTAssertDis[21:21] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_20_13_[20:13] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Interrupt Status.

           ";
    ValRandomize = true;
  } INTStat[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
         New Capabilities: Indicates that this device implements extended capabilities, it supports PCI Power Management, Message Signaled Interrupts (MSI), Enhanced Message Signaled Interrupts (MSI-X), VPD and the PCIe extensions.

           ";
    ValRandomize = true;
  } CapList[11:11] = 1'h1;
  field {
    AccessType = "RO";
    desc = "
        66 MHz Capable - Hard wire to 0b.

           ";
    ValRandomize = true;
  } Cap66Mhz[10:10] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_9_[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Fast Back-to-Back Capable - Hard wire to 0b.

           ";
    ValRandomize = true;
  } CapFastB2B[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Data Parity Reported.

           ";
    ValRandomize = true;
  } MstrDataParErr[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        DEVSEL Timing - Hard wire to 0b.

           ";
    ValRandomize = true;
  } DevselTiming[6:5] = 2'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Signaled Target Abort.

           ";
    ValRandomize = true;
  } SigTgtAbort[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Received Target Abort.

           ";
    ValRandomize = true;
  } RcvTgtAbort[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Received Master Abort.

           ";
    ValRandomize = true;
  } RcvMstAbort[2:2] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Signaled System Error.

           ";
    ValRandomize = true;
  } SigSysErr[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Detected Parity Error.

           ";
    ValRandomize = true;
  } DetectParErr[0:0] = 1'h0;
};



// PCIE_VF_CFG_1

reg pcie_vf_cfg_1_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Set to 0 for first version. 

           ";
    ValRandomize = true;
  } RevisionID[31:24] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        The class code is a read-only value that identifies the device functionality, it is set to 0x020000 (Ethernet Adapter) by default.     

           ";
    ValRandomize = true;
  } ClassCode[23:0] = 24'h020000;
};



// PCIE_VF_CFG_2

reg pcie_vf_cfg_2_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        This field is implemented by PCIe devices as a read/write field for legacy compatibility purposes but has no impact on any PCIe device functionality. 

           ";
    ValRandomize = true;
  } CacheLineSize[31:24] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Not used. 

           ";
    ValRandomize = true;
  } LatencyTimer[23:16] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Single function. Set to 0b. 

           ";
    ValRandomize = true;
  } HeaderType[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } BIST[7:0] = 8'h0;
};



// PCIE_VF_CFG_BAR0

reg pcie_vf_cfg_bar0_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Only type 0 (MEMORY) is supported

           ";
    ValRandomize = true;
  } AccessType[31:31] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Address size on address decoding.
    
            *Mode32(0)
            *Mode64(2)

           ";
    ValRandomize = true;
  } AddressSize[30:29] = 2'h0;
  field {
    AccessType = "RO";
    desc = "
        The PEP address space does not contain volatile registers.

           ";
    ValRandomize = true;
  } Prefetchable[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Bits [20:4] of base address assigned to this device. 2MB Region. 

           ";
    ValRandomize = true;
  } Zero[27:11] = 17'h0;
  field {
    AccessType = "RO";
    desc = "
        Bits [31:21] of base address assigned to this device. 

           ";
    ValRandomize = true;
  } Address[10:0] = 11'h0;
};



// PCIE_VF_CFG_BAR1

reg pcie_vf_cfg_bar1_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Bits [63:32] of base address assigned ot this device. Only used if 64 bit addressing is active. 

           ";
    ValRandomize = true;
  } AddressHigh[31:0] = 32'h0;
};



// PCIE_VF_CFG_BAR2

reg pcie_vf_cfg_bar2_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Only type 0 (MEMORY) is supported

           ";
    ValRandomize = true;
  } AccessType[30:30] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Address size on address decoding.
    
            *Mode32(0)
            *Mode64(2)

           ";
    ValRandomize = true;
  } AddressSize[29:28] = 2'h0;
  field {
    AccessType = "RO";
    desc = "
        The PEP address space does not contain volatile registers.

           ";
    ValRandomize = true;
  } Prefetchable[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Bits [12:4] of base address assigned to this device. 8KB Region. 

           ";
    ValRandomize = true;
  } Zero[26:18] = 9'h0;
  field {
    AccessType = "RO";
    desc = "
        Bits [31:13] of base address assigned to this device. 

           ";
    ValRandomize = true;
  } Address[17:0] = 18'h0;
};



// PCIE_VF_CFG_BAR3

reg pcie_vf_cfg_bar3_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Bits [63:32] of base address assigned ot this device. Only used if 64 bit addressing is active. 

           ";
    ValRandomize = true;
  } AddressHigh[31:0] = 32'h0;
};



// PCIE_VF_CFG_BAR4

reg pcie_vf_cfg_bar4_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Only type 0 (MEMORY) is supported

           ";
    ValRandomize = true;
  } AccessType[31:31] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Address size on address decoding.
    
            *Mode32(0)
            *Mode64(2)

           ";
    ValRandomize = true;
  } AddressSize[30:29] = 2'h0;
  field {
    AccessType = "RO";
    desc = "
        The PEP address space does not contain volatile registers.

           ";
    ValRandomize = true;
  } Prefetchable[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Bits [25:4] of base address assigned to this device. 64MB Region.

           ";
    ValRandomize = true;
  } Zero[27:6] = 22'h0;
  field {
    AccessType = "RO";
    desc = "
        Bits [31:26] of base address assigned to this device. 

           ";
    ValRandomize = true;
  } Address[5:0] = 6'h0;
};



// PCIE_VF_CFG_BAR5

reg pcie_vf_cfg_bar5_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Bits [63:32] of base address assigned ot this device. Only used if 64 bit addressing is active. 

           ";
    ValRandomize = true;
  } AddressHigh[31:0] = 32'h0;
};



// PCIE_VF_CFG_CARDBUS

reg pcie_vf_cfg_cardbus_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Not used. 

           ";
    ValRandomize = true;
  } CardbusPtr[31:0] = 32'h0;
};



// PCIE_VF_CFG_SUBID

reg pcie_vf_cfg_subid_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
      This value can be loaded automatically from the EEPROM at power up or reset. A value of 0x8086 is the default for this field at power up if the EEPROM does not respond or is not programmed. All functions are initialized to the same value.

           ";
    ValRandomize = true;
  } SubVendorID[31:16] = 16'h8086;
  field {
    AccessType = "RO";
    desc = "
      This value can be loaded automatically from the EEPROM at power up with a default value of 0x0000.

           ";
    ValRandomize = true;
  } SubDeviceID[15:0] = 16'h0;
};



// PCIE_VF_CFG_EXP_ROM

reg pcie_vf_cfg_exp_rom_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Not used. 

           ";
    ValRandomize = true;
  } Enable[31:31] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_30_21_[30:21] = 10'h0;
  field {
    AccessType = "RO";
    desc = "
        Not used. 

           ";
    ValRandomize = true;
  } Address[20:0] = 21'h0;
};



// PCIE_VF_CFG_CAP_PTR

reg pcie_vf_cfg_cap_ptr_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
      The Capabilities Pointer field (Cap_Ptr) is an 8-bit field that provides an offset in the PCI configuration space for the location of the first item in the capabilities linked list. The value is 0x70, which is the address of the first entry: PCI capabilities.

           ";
    ValRandomize = true;
  } CapabilityPtr[7:0] = 8'h70;
};



// PCIE_VF_CFG_RSVD

reg pcie_vf_cfg_rsvd_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } Reserved[31:0] = 32'h0;
};



// PCIE_VF_CFG_INT

reg pcie_vf_cfg_int_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Read/write register programmed by software to indicate which of the system interrupt request lines the device interrupt pin is bound to. Refer to the PCI definition for more details. Each PCI function has its own register.      

           ";
    ValRandomize = true;
  } InterruptLine[31:24] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Not used in this design.  

           ";
    ValRandomize = true;
  } InterruptPin[23:16] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Min_Gnt not used. Hard wired to 0b.

           ";
    ValRandomize = true;
  } MinGrant[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Max_Lat not used. Hard wired to 0b.

           ";
    ValRandomize = true;
  } MaxLatency[7:0] = 8'h0;
};



// PCIE_VF_CFG_PCIE_CAP

reg pcie_vf_cfg_pcie_cap_r {
  shared;
  HandCoded = true;
  name = "PCI Express Capability";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        This field equals 0x10 indicating that the linked list item as being the PCIe Capabilities registers.

           ";
    ValRandomize = true;
  } CapID[29:22] = 8'h10;
  field {
    AccessType = "RO";
    desc = "
        Offset to the next capability item in the capability list. 

           ";
    ValRandomize = true;
  } NextCapPtr[21:14] = 8'hb0;
  field {
    AccessType = "RO";
    desc = "
        Indicates the PCIe capability structure version. The device supports PCIe version 2 (also loaded from EEPROM).

           ";
    ValRandomize = true;
  } CapabilityVersion[13:10] = 4'h2;
  field {
    AccessType = "RO";
    desc = "
        Indicates the type of PCIe functions. All functions are native PCI functions with a value of 0000b.

           ";
    ValRandomize = true;
  } DevicePortType[9:6] = 4'h0;
  field {
    AccessType = "RO";
    desc = "
        The device does not implement slot options. Therefore, this field is hard wired to 0b.

           ";
    ValRandomize = true;
  } SlotImplemented[5:5] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        The device does not implement multiple MSI per function. As a result, this field is hard wired to 0x0.

           ";
    ValRandomize = true;
  } InterrruptMessageNumber[4:0] = 5'h0;
};



// PCIE_VF_CFG_PCIE_DEV_CAP

reg pcie_vf_cfg_pcie_dev_cap_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Max Payload Size Supported. This field indicates the maximum payload that the device can support for TLPs. It is loaded from the EEPROM with a default value of 512 bytes.

           ";
    ValRandomize = true;
  } MaxPayloadSize[28:26] = 3'h2;
  field {
    AccessType = "RO";
    desc = "
        Not supported by the device.

           ";
    ValRandomize = true;
  } PhantomFunctionSupport[25:24] = 2'h0;
  field {
    AccessType = "RO";
    desc = "
        Maximum supported size of the Tag field. The device supports a 5-bit Tag field for all functions.

           ";
    ValRandomize = true;
  } ExtendedTagField[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        This field indicates the acceptable latency that the device can withstand due to the transition from L0s state to the L0 state. Value loaded from EEPROM.

        A value of 011b equals 512 ns.

           ";
    ValRandomize = true;
  } EndpointL0Latency[22:20] = 3'h3;
  field {
    AccessType = "RO";
    desc = "
        This field indicates the acceptable latency that the device can withstand due to the transition from L1 state to the L0 state.

        A value of 110b equals 32 μs-64 μs.

           ";
    ValRandomize = true;
  } EndpointL1Latency[19:17] = 3'h6;
  field {
    AccessType = "RO";
    desc = "
        Hard wired in the device to 0b.

           ";
    ValRandomize = true;
  } AttentionButtonPreset[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Hard wired in the device to 0b.

           ";
    ValRandomize = true;
  } AttentionIndicatorPreset[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Hard wired in the device to 0b.

           ";
    ValRandomize = true;
  } PowerIndicatorPreset[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Role Based Error Reporting. Hard wired in the device to 1b.

           ";
    ValRandomize = true;
  } RoleBasedErrorReporting[13:13] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_12_11_[12:11] = 2'h0;
  field {
    AccessType = "RO";
    desc = "
        Used in upstream ports only. This value is set by the Set_Slot_Power_Limit Message.

           ";
    ValRandomize = true;
  } SlotPowerLimit[10:3] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Slot Power Limit Scale. Used in upstream ports only. This value is set by the Set_Slot_Power_Limit Message.

           ";
    ValRandomize = true;
  } SlotPowerScale[2:1] = 2'h0;
  field {
    AccessType = "RO";
    desc = "
        A value of 1b indicates the Function supports the optional Function Level Reset (FLR) mechanism.

           ";
    ValRandomize = true;
  } FunctionLevelReset[0:0] = 1'h1;
};



// PCIE_VF_CFG_PCIE_DEV_CTRL

reg pcie_vf_cfg_pcie_dev_ctrl_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Enable error report.

           ";
    ValRandomize = true;
  } CorrectableErrorReportingEnable[21:21] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Enable error report.

           ";
    ValRandomize = true;
  } NonFatalErrorReportingEnable[20:20] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Enable error report.

           ";
    ValRandomize = true;
  } FatalErrorReportingEnable[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Enable error report.

           ";
    ValRandomize = true;
  } UnsupportedRequestReportingEnable[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        If this bit is set, Red Rock Canyon is permitted to set the Relaxed Ordering bit in the Attribute field of write transactions that do not need strong ordering. Refer to the CTRL_EXT register bit RO_DIS for more details.

           ";
    ValRandomize = true;
  } EnableRelaxedOrdering[17:17] = 1'h1;
  field {
    AccessType = "RO";
    desc = "
        This field sets the maximum TLP payload size for Red Rock Canyon functions. As a receiver, Red Rock Canyon must handle TLPs as large as the set value. As a transmitter, Red Rock Canyon must not generate TLPs exceeding the set value.
      
        The Max Payload Size field supported in the Device Capabilities register indicates permissible values that can be programmed.
      
        In ARI mode, Max Payload Size is determined solely by the field in function 0 while it is meaningless in the other function(s).

           ";
    ValRandomize = true;
  } MaxPayloadSize[16:14] = 3'h0;
  field {
    AccessType = "RO";
    desc = "
        Not implemented in Red Rock Canyon.

           ";
    ValRandomize = true;
  } ExtendedTagfieldEnable[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Not implemented in Red Rock Canyon.

           ";
    ValRandomize = true;
  } PhantomFunctionsEnable[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        No AUX power support in RRC.

           ";
    ValRandomize = true;
  } AuxiliaryPowerPMEnable[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        When set, the Function is permitted to set the No Snoop bit in the Requester Attributes of transactions it initiates that do not require hardware enforced cache coherency. 

           ";
    ValRandomize = true;
  } EnableNoSnoop[10:10] = 1'h1;
  field {
    AccessType = "RO";
    desc = "
        This field sets maximum read request size for Red Rock Canyon as a requester.
          
            *MAX_128(0)
            *MAX_256(1)
            *MAX_512(2)
            *MAX_1024(3)
            *MAX_2048(4)
            *MAX_4096(5)

           ";
    ValRandomize = true;
  } MaxReadRequestSize[9:7] = 3'h2;
  field {
    AccessType = "RW";
    desc = "
        A write of 1b initiates FLR to the function. The value read by software from this bit is always 0b.

           ";
    ValRandomize = true;
  } InitiateFLR[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates status of correctable error detection.

           ";
    ValRandomize = true;
  } CorrectableDetected[5:5] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates status of non-fatal error detection.

           ";
    ValRandomize = true;
  } NonFatalErrorDetected[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates status of fatal error detection.

           ";
    ValRandomize = true;
  } FatalErrorDetected[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Indicates that Red Rock Canyon received an unsupported request. This field is identical in all functions. Red Rock Canyon can’t distinguish which function causes the error.

           ";
    ValRandomize = true;
  } UnsupportedRequestDetected[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        If Aux Power is detected, this field is set to 1b. It is a strapping signal from the periphery and is identical for all functions. Resets on LAN Power Good and PE_RST_N only.

           ";
    ValRandomize = true;
  } AuxPowerDetected[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Indicates whether Red Rock Canyon has ANY transactions pending. (transactions include completions for any outstanding non-posted request for all used traffic classes).

           ";
    ValRandomize = true;
  } TransactionPending[0:0] = 1'h0;
};



// PCIE_VF_CFG_PCIE_LINK_CAP

reg pcie_vf_cfg_pcie_link_cap_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Supported Link Speeds. This field indicates the supported Link speed(s) of the associated link port.
          
        Defined encodings are:
          
            * 0001b = 2.5 GbE link speed supported.
            * 0010b = 5 GbE and 2.5 GbE link speeds supported.
            * 0011b = 8 GbE, 5 GbE and 2.5 GbE link speeds supported.

           ";
    ValRandomize = true;
  } SupportedLinkSpeeds[31:28] = 4'h3;
  field {
    AccessType = "RO";
    desc = "
        Max Link Width. Indicates the maximum link width. Depending on the SKU, Red Rock Canyon supports a x1, x2, x4 and x8-link width with a default value of eight lanes.
          
        Defined encoding:
          
            * 000000b = Reserved
            * 000001b = x1
            * 000010b = x2
            * 000100b = x4
            * 001000b = x8

           ";
    ValRandomize = true;
  } MaxLinkWidth[27:22] = 6'h8;
  field {
    AccessType = "RO";
    desc = "
        Indicates the level of the active state of power management supported in RRC. Defined encodings are:
          
            * 00b = No ASPM Support.
            * 01b = Reserved.
            * 10b = L1 supported. This is the default.
            * 11b = Reserved.
          
        All functions share the same value loaded from EEPROM.

           ";
    ValRandomize = true;
  } ActiveStateLinkPMSupport[21:20] = 2'h2;
  field {
    AccessType = "RO";
    desc = "
        L0s Exit Latency. Indicates the exit latency from L0s to L0 state. 
        
            * 000b = Less than 64 ns.
            * 001b = 64 ns - 128 ns.
            * 010b = 128ns - 256 ns.
            * 011b = 256 ns - 512 ns.
            * 100b = 512 ns -- 1 μs.
            * 101b = 1 μs - 2 μs.
            * 110b = 2 μs - 4 μs.
            * 111b = Reserved.
          
        All functions share the same value loaded from the EEPROM.

           ";
    ValRandomize = true;
  } L0sExitLatency[19:17] = 3'h3;
  field {
    AccessType = "RO";
    desc = "
        L1 Exit Latency. Indicates the exit latency from L1 to L0 state.
          
            * 000b = Less than 1 μs.
            * 001b = 1 μs -- 2 μs.
            * 010b = 2 μs -- 4 μs.
            * 011b = 4 μs -- 8 μs.
            * 100b = 8 μs -- 16 μs.
            * 101b = 16 μs -- 32 μs.
            * 110b = 32 μs -- 64 μs.
            * 111b = L1 transition not supported.
          
        All functions share the same value loaded from the EEPROM.

           ";
    ValRandomize = true;
  } L1ExitLatency[16:14] = 3'h6;
  field {
    AccessType = "RO";
    desc = "
        Hard wired to 0b.

           ";
    ValRandomize = true;
  } ClockPowerManagement[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Hard wired to 0b.

           ";
    ValRandomize = true;
  } SurpriseDownErrorReportingCapable[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Hard wired to 0b.

           ";
    ValRandomize = true;
  } DataLinkLayerLinkActiveReportingCapable[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Hard wired to 0b.

           ";
    ValRandomize = true;
  } LinkBandwidthNotificationCapability[10:10] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __Reserved_9_8_[9:8] = 2'h0   ;
  field {
    AccessType = "RO";
    desc = "
        The PCIe port number for the given PCIe link. This field is set in the link training phase.

           ";
    ValRandomize = true;
  } PortNumber[7:0] = 8'h0;
};



// PCIE_VF_CFG_PCIE_LINK_CTRL

reg pcie_vf_cfg_pcie_link_ctrl_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } RsvdZ[31:0] = 32'h0          ;
};



// PCIE_VF_CFG_PCIE_DEV_CAP2

reg pcie_vf_cfg_pcie_dev_cap2_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Completion Timeout Ranges Supported. This field indicates Red Rock Canyon’s support for the optional completion timeout programmability mechanism.

        Four time value ranges are defined:

            * Range A: 50 μs to 10 ms.
            * Range B: 10 ms to 250 ms.
            * Range C: 250 ms to 4 s.
            * Range D: 4 s to 64 s.

        Bits are set according to the following values to show the timeout value ranges that Red Rock Canyon supports.

            * 0000b = Completion timeout programming not supported. Red Rock Canyon must implement a timeout value in the range of 50 µs to 50 ms.
            * 0001b = Range A.
            * 0010b = Range B.
            * 0011b = Ranges A and B.
            * 0110b = Ranges B and C.
            * 0111b = Ranges A, B and C.
            * 1110b = Ranges B, C and D.
            * 1111b = Ranges A, B, C and D.
    
        All other values are reserved.

           ";
    ValRandomize = true;
  } CplTimeoutCfg[13:10] = 4'hf;
  field {
    AccessType = "RO";
    desc = "
        Completion Timeout Disable Supported

           ";
    ValRandomize = true;
  } CplTimeoutDisSuppt[9:9] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_8_2_[8:2] = 7'h0;
  field {
    AccessType = "RO";
    desc = "
        TPH Completer Supported – Value indicates Completer support for TPH or Extended TPH. Defined encodings are:
           * 00b TPH and Extended TPH Completer not supported.
           * 01b TPH Completer supported; Extended TPH Completer not supported.
           * 10b Reserved.
           * 11b Both TPH and Extended TPH Completer supported.
        When TPH is enabled, the device is enabled as both a requester and a completer. No control is given to support these features individually.

           ";
    ValRandomize = true;
  } TPHCplSup[1:0] = 2'h1;
};



// PCIE_VF_CFG_PCIE_DEV_CTRL2

reg pcie_vf_cfg_pcie_dev_ctrl2_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Completion Timeout Value. For devices that support completion timeout programmability, this field enables system software to modify the completion timeout value.

        Defined encodings:

            * 0000b = Default range: 50 μs to 50 ms.

        Note: It is strongly recommended that the completion timeout mechanism not expire in less than 10 ms.

        Values available if Range A (50 μs to 10 ms) programmability range is supported:

            * 0001b = 50 μs to 100 μs.
            * 0010b = 1 ms to 10 ms.

        Values available if Range B (10 ms to 250 ms) programmability range is supported:

            * 0101b = 16 ms to 55 ms.
            * 0110b = 65 ms to 210 ms.

        Values available if Range C (250 ms to 4 s) programmability range is supported:

            * 1001b = 260 ms to 900 ms.
            * 1010b = 1 s to 3.5 s.

        Values available if the Range D (4 s to 64 s) programmability range is supported:

            * 1101b = 4 s to 13 s.
            * 1110b = 17 s to 64 s.

        Values not defined are reserved.

        Software is permitted to change the value of this field at any time. For requests already pending when the completion timeout value is changed, hardware is permitted to use either the new or the old value for the outstanding requests and is permitted to base the start time for each request either on when this value was changed or on when each request was issued.

           ";
    ValRandomize = true;
  } CplTimeoutVal[4:1] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
        Completion Timeout Disable. When set to 1b, this bit disables the completion timeout mechanism.

        Software is permitted to set or clear this bit at any time. When set, the completion timeout detection mechanism is disabled. If there are outstanding requests when the bit is cleared, it is permitted but not required for hardware to apply the completion timeout mechanism to the outstanding requests. If this is done, it is permitted to base the start time for each request on either the time this bit was cleared or the time each request was issued.

           ";
    ValRandomize = true;
  } CplTimeoutDis[0:0] = 1'h0;
};



// PCIE_VF_CFG_PCIE_LINK_CTRL2

reg pcie_vf_cfg_pcie_link_ctrl2_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Target Link Speed. This field is used to set the target compliance mode speed when software is using the Enter Compliance bit to force a link into compliance mode.
                    
        Defined encodings are:
           
            * 0001b = 2.5 GbE target link speed.
            * 0010b = 5 GbE target link speed.
            * 0011b = 8 GbE target link speed.
          
        All other encodings are reserved.
          
        If a value is written to this field that does not correspond to a speed included in the Supported Link Speeds field, the result is undefined.
          
        The default value of this field is the highest link speed supported by Red Rock Canyon (as reported in the Supported Link Speeds field of the Link Capabilities register).

           ";
    ValRandomize = true;
  } TargetSpeed[27:24] = 4'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Enter Compliance. Software is permitted to force a link to enter compliance mode at the speed indicated in the Target Link Speed field by setting this bit to 1b in both components on a link and then initiating a hot reset on the link.
          
        The default value of this field following a fundamental reset is 0b.

           ";
    ValRandomize = true;
  } EnterCompliance[23:23] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Hardware Autonomous Speed Disable. When set to 1b, this bit disables hardware from changing the link speed for reasons other than attempting to correct unreliable link operation by reducing link speed.

           ";
    ValRandomize = true;
  } HwAutoSpeedDis[22:22] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Selectable De-Emphasis.          

           ";
    ValRandomize = true;
  } SelectDeEmphasis[21:21] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Transmit Margin. This field controls the value of the non de emphasized voltage level at the Transmitter pins.
          
        Encodings:
          
            * 000b = Normal operating range.
            * 001b = 800-1200 mV for full swing and 400-700 mV for half-swing.
            * 010b = (n-1) -- Values must be monotonic with a non-zero slope. The value of n must be greater than 3 and less than 7. At least two of these must be below the normal operating range of n: 200-400 mV for full-swing and 100-200 mV for half-swing.
            * 111b= (n) reserved.

           ";
    ValRandomize = true;
  } TransmitMargin[20:18] = 3'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Enter Modified Compliance. When this bit is set to 1b, the device transmits modified compliance pattern if the LTSSM enters Polling.Compliance state.

           ";
    ValRandomize = true;
  } EnterModeComp[17:17] = 1'h0;
  field {
    AccessType = "RW/1S/V";
    desc = "
        Compliance SOS. When set to 1b, the LTSSM is required to send SOS periodically in between the (modified) compliance patterns.

           ";
    ValRandomize = true;
  } CompSOS[16:16] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_15_12_[15:12] = 4'h0;
  field {
    AccessType = "RO";
    desc = "
        Current De-emphasis Level. When the Link is operating at 5.0 GT/s speed, this bit reflects the level of de-emphasis.
        Encodings:
           * 1b = 3.5 dB
           * 0b = -6 dB
        The value in this bit is undefined when the Link is not operating at 5.0 GT/s speed.
        The default value of this field is changed automatically by hardware upon link setup. 

           ";
    ValRandomize = true;
  } CAPCURRDEEMPHASIS[11:11] = 1'h1;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_10_0_[10:0] = 11'h0;
};



// PCIE_VF_CFG_MSIX_CAP

reg pcie_vf_cfg_msix_cap_r {
  shared;
  HandCoded = true;
  name = "MSI-X Capability";
  desc = "
    More than one MSI-X capability structure per function is prohibited while a function is permitted to have both an MSI and an MSI-X capability structure.
      
    In contrast to the MSI capability structure, which directly contains all of the control/status information for the function's vectors, the MSI-X capability structure instead points to an MSI-X table structure and an MSI-X Pending Bit Array (PBA) structure, each residing in memory space.
        
    Each structure is mapped by a BAR belonging to the function that begins at 0x10 in the configuration space. A BAR Indicator Register (BIR) indicates which BAR and a Qword-aligned offset indicates where the structure begins relative to the base address associated with the BAR. The BAR is 64-bit, but must map to the memory space. A function is permitted to map both structures with the same BAR or map each structure with a different BAR.
       
    The MSI-X table structure typically contains multiple entries, each consisting of several fields: Message Address, Message Upper Address, Message Data, and Vector Control. Each entry is capable of specifying a unique vector.
        
    The PBA structure contains the function's pending bits, one per table entry, organized as a packed array of bits within Qwords. The last Qword is not necessarily fully populated.
       
    To request service using a given MSI-X table entry, a function performs a Dword memory write transaction using:
       
    The contents of the Message Data field entry for data
       
    The contents of the Message Upper Address field for the upper 32 bits of the address
        
    The contents of the Message Address field entry for the lower 32 bits of the address
        
    A memory read transaction from the address targeted by the MSI-X message produces undefined results.
        
    The MSI-X table and MSI-X PBA are permitted to co-reside within a naturally aligned 4 KB address range, though they must not overlap with each other.
        
    MSI-X table entries and Pending bits are each numbered 0 through N-1, where N-1 is indicated by the Table Size field in the MSI-X Message Control register. For a given arbitrary MSI-X table entry K, its starting address can be calculated with the formula:
        
    Entry starting address = Table base + K*16
        
    For the associated Pending bit K, its address for Qword access and bit number within that Qword can be calculated with the formulas:
       
    Qword address = PBA base + (K div 64)*8
        
    Qword bit# = K mod 64
        
    Software that chooses to read Pending bit K with Dword accesses can use these formulas:
        
    Dword address = PBA base + (K div 32)*4
        
    Dword bit# = K mod 32 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Capability ID      

           ";
    ValRandomize = true;
  } CapID[31:24] = 8'h11;
  field {
    AccessType = "RO";
    desc = "
        Next capability offset    

           ";
    ValRandomize = true;
  } NextCapPtr[23:16] = 8'h00;
  field {
    AccessType = "RO";
    desc = "
       System software reads this field to determine the MSI-X Table Size N, which is encoded as N-1. The device supports up to 32 different interrupt vectors per virtual function.

           ";
    ValRandomize = true;
  } TableSize[15:5] = 11'h07;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_4_2_[4:2] = 3'h0;
  field {
    AccessType = "RO";
    desc = "
        If 1b, all of the vectors associated with the function are masked, regardless of their per-vector Mask bit states.
        
        If 0b, each vector Mask bit determines whether the vector is masked or not.
        
        Setting or clearing the MSI-X Function Mask bit has no effect on the state of the per-vector Mask bits.

           ";
    ValRandomize = true;
  } FunctionMask[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
        If 1b and the MSI Enable bit in the MSI Message Control register is 0b, the function is permitted to use MSI-X to request service and is prohibited from using its INTx# pin.
      
        System configuration software sets this bit to enable MSI-X. A device driver is prohibited from writing this bit to mask a function’s service request.
      
        If 0b, the function is prohibited from using MSI-X to request service.

           ";
    ValRandomize = true;
  } MSIX_Enable[0:0] = 1'h0;
};



// PCIE_VF_CFG_MSIX_TOFF

reg pcie_vf_cfg_msix_toff_r {
  shared;
  HandCoded = true;
  name = "MSI-X Table Offset Register";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Indicates which one of a functions BARs, beginning at 0x10 in the configuration space, is used to map the functions MSI-X table into the memory space. while BIR values: 0...5 correspond to BARs 0x10...0x 24 respectively.

           ";
    ValRandomize = true;
  } BIR[31:29] = 3'h2;
  field {
    AccessType = "RO";
    desc = "
        Used as an offset from the address contained in one of the functions BARs to point to the base of the MSI-X table. The lower three Table BIR bits are masked off (set to 0b) by software to form a 32-bit Qword-aligned offset.
          
        Note that this field is read only.

           ";
    ValRandomize = true;
  } Offset[28:0] = 29'h0;
};



// PCIE_VF_CFG_MSIX_PBA

reg pcie_vf_cfg_msix_pba_r {
  shared;
  HandCoded = true;
  name = "MSI-X Pending Bit Array -- PBA Offset";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Indicates which one of a functions BARs, beginning at 0x10 in the configuration space, is used to map the function’s MSI-X PBA into the memory space. while BIR values: 0...5 correspond to BARs 0x10...0x 24 respectively.

           ";
    ValRandomize = true;
  } BIR[31:29] = 3'h2;
  field {
    AccessType = "RO";
    desc = "
        Used as an offset from the address contained in one of the functions BARs to point to the base of the MSI-X PBA. The lower three PBA BIR bits are masked off (set to 0b) by software to form a 32-bit Qword-aligned offset.
        
        This field is read only.

           ";
    ValRandomize = true;
  } Offset[28:0] = 29'h0200;
};



// PCIE_VF_CFG_AER_HDR

reg pcie_vf_cfg_aer_hdr_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Extended Capability ID. PCIe extended capability ID indicating advanced error reporting capability.

           ";
    ValRandomize = true;
  } ExtCapId[31:16] = 16'h1;
  field {
    AccessType = "RO";
    desc = "
        Version Number. PCIe advanced error reporting extended capability version number.

           ";
    ValRandomize = true;
  } Version[15:12] = 4'h2;
  field {
    AccessType = "RO";
    desc = "
        Next Capability Pointer. 

           ";
    ValRandomize = true;
  } NextCapPtr[11:0] = 12'h148;
};



// PCIE_VF_CFG_AER_UNERR_STATUS

reg pcie_vf_cfg_aer_unerr_status_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
        The Uncorrectable Error Status register reports error status of individual uncorrectable error sources on a PCIe device. An individual error status bit that is set to 1b indicates that a particular error occurred; software can clear an error status by writing a 1b to the respective bit. Register is cleared by LAN_PWR_GOOD.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_21_18_[21:18] = 4'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Data Link Protocol Error Status.

           ";
    ValRandomize = true;
  } DLPError[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Surprise Down Error Status.

           ";
    ValRandomize = true;
  } SurpriseDownError[16:16] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_15_10_[15:10] = 6'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Poisoned TLP Status. 

           ";
    ValRandomize = true;
  } PoisonedTLP[9:9] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Flow Control Protocol Error Status.

           ";
    ValRandomize = true;
  } FlowControlError[8:8] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Completion Timeout Status. 

           ";
    ValRandomize = true;
  } CompletionTimeout[7:7] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Completer Abort Status. 

           ";
    ValRandomize = true;
  } CompleterAbort[6:6] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Unexpected Completion Status. 

           ";
    ValRandomize = true;
  } UnexpecteCompl[5:5] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Receiver Overflow Status.

           ";
    ValRandomize = true;
  } RxOverflow[4:4] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Malformed TLP Status.

           ";
    ValRandomize = true;
  } MalformedTLP[3:3] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        ECRC Error Status.

           ";
    ValRandomize = true;
  } ECRCError[2:2] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
        Unsupported Request Error Status. 

           ";
    ValRandomize = true;
  } UnsupportedRequestError[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        ACS Violation Status.

           ";
    ValRandomize = true;
  } ACSViolation[0:0] = 1'h0;
};



// PCIE_VF_CFG_AER_UNERR_MASK

reg pcie_vf_cfg_aer_unerr_mask_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
      The Uncorrectable Error Mask register controls reporting of individual uncorrectable errors by device to the host bridge via a PCIe error message. A masked error (respective bit set in mask register) is not reported to the host bridge by an individual device. Note that there is a mask bit per bit of the Uncorrectable Error Status register.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_31_28_[31:28] = 4'h0;
  field {
    AccessType = "RO";
    desc = "
        Data Link Protocol Error Mask.

           ";
    ValRandomize = true;
  } DLPError[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Surprise Down Error Mask.

           ";
    ValRandomize = true;
  } SurpriseDownError[26:26] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_25_20_[25:20] = 6'h0;
  field {
    AccessType = "RO";
    desc = "
        Poisoned TLP Mask. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } PoisonedTLP[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Flow Control Protocol Error Mask.

           ";
    ValRandomize = true;
  } FlowControlError[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Completion Timeout Mask. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } CompletionTimeout[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Completer Abort Mask. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } CompleterAbort[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Unexpected Completion Mask. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } UnexpecteCompl[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Receiver Overflow Mask.

           ";
    ValRandomize = true;
  } RxOverflow[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Malformed TLP Mask.

           ";
    ValRandomize = true;
  } MalformedTLP[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        ECRC Error Mask.

           ";
    ValRandomize = true;
  } ECRCError[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Unsupported Request Error Mask. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } UnsupportedRequestError[11:11] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_10_[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } UncorrectableInternalError[9:9] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_8_[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } AtomicOpEggressBlocked[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } TLPPrefixBlockedError[6:6] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_5_0_[5:0] = 6'h0;
};



// PCIE_VF_CFG_AER_UNERR_SEVERITY

reg pcie_vf_cfg_aer_unerr_severity_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    The Uncorrectable Error Severity register controls whether an individual uncorrectable error is reported as a fatal error. An uncorrectable error is reported as fatal when the corresponding error bit in the severity register is set. If the bit is cleared, the corresponding error is considered non-fatal.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_31_28_[31:28] = 4'h0;
  field {
    AccessType = "RO";
    desc = "
        Data Link Protocol Error Severity.

           ";
    ValRandomize = true;
  } DLPError[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Surprise Down Error Severity.

           ";
    ValRandomize = true;
  } SurpriseDownError[26:26] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_25_20_[25:20] = 6'h0;
  field {
    AccessType = "RO";
    desc = "
        Poisoned TLP Severity. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } PoisonedTLP[19:19] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Flow Control Protocol Error Severity.

           ";
    ValRandomize = true;
  } FlowControlError[18:18] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Completion Timeout Severity. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } CompletionTimeout[17:17] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Completer Abort Severity. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } CompleterAbort[16:16] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Unexpected Completion Severity. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } UnexpecteCompl[15:15] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Receiver Overflow Severity.

           ";
    ValRandomize = true;
  } RxOverflow[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Malformed TLP Severity.

           ";
    ValRandomize = true;
  } MalformedTLP[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        ECRC Error Severity.

           ";
    ValRandomize = true;
  } ECRCError[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Unsupported Request Error Severity. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } UnsupportedRequestError[11:11] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_10_[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } UncorrectableInternalError[9:9] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_8_[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } AtomicOpEggressBlocked[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "

           ";
    ValRandomize = true;
  } TLPPrefixBlockedError[6:6] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_5_0_[5:0] = 6'h0;
};



// PCIE_VF_CFG_AER_COERR_STATUS

reg pcie_vf_cfg_aer_coerr_status_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    The Correctable Error Status register reports error status of individual correctable error sources on a PCIe device. When an individual error status bit is set to 1b it indicates that a particular error occurred; software can clear an error status by writing a 1b to the respective bit. Register is cleared by LAN_PWR_GOOD.    
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Receiver Error Status.

           ";
    ValRandomize = true;
  } RxError[14:14] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_13_9_[13:9] = 5'h0;
  field {
    AccessType = "RO";
    desc = "
        Bad TLP Status.

           ";
    ValRandomize = true;
  } BadTLP[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Bad DLLP Status.

           ";
    ValRandomize = true;
  } BadDLLP[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        REPLAY_NUM Rollover Status.

           ";
    ValRandomize = true;
  } ReplayRollover[6:6] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_5_3_[5:3] = 3'h0;
  field {
    AccessType = "RO";
    desc = "
        Replay Timer Timeout Status.

           ";
    ValRandomize = true;
  } ReplayTimeout[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Advisory Non-Fatal Error Status.

           ";
    ValRandomize = true;
  } NonFatalError[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Corrected Internal Error Status.

           ";
    ValRandomize = true;
  } CorrectableInternalError[0:0] = 1'h0;
};



// PCIE_VF_CFG_AER_COERR_MASK

reg pcie_vf_cfg_aer_coerr_mask_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
      The Correctable Error Mask register controls reporting of individual correctable errors by device to the host bridge via a PCIe error message. A masked error (respective bit set in mask register) is not reported to the host bridge by an individual device. There is a mask bit per bit in the Correctable Error Status register.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Receiver Error Mask.

           ";
    ValRandomize = true;
  } RxError[14:14] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_13_9_[13:9] = 5'h0;
  field {
    AccessType = "RO";
    desc = "
        Bad TLP Mask.

           ";
    ValRandomize = true;
  } BadTLP[8:8] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Bad DLLP Mask.

           ";
    ValRandomize = true;
  } BadDLLP[7:7] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        REPLAY_NUM Rollover Mask.

           ";
    ValRandomize = true;
  } ReplayRollover[6:6] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_5_3_[5:3] = 3'h0;
  field {
    AccessType = "RO";
    desc = "
        Replay Timer Timeout Mask.

           ";
    ValRandomize = true;
  } ReplayTimeout[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Advisory Non-Fatal Error Mask. Errata: The PF setting is mirrored into the VF field.

           ";
    ValRandomize = true;
  } NonFatalError[1:1] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Corrected Internal Error Mask.

           ";
    ValRandomize = true;
  } CorrectableInternalError[0:0] = 1'h0;
};



// PCIE_VF_CFG_AER_CTRL

reg pcie_vf_cfg_aer_ctrl_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    Errata: The PF settings are mirrored into the VF fields.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Vector pointing to the first recorded error in the Uncorrectable Error Status register. This is a read-only field that identifies the bit position of the first uncorrectable error reported in the Uncorrectable Error Status register.

           ";
    ValRandomize = true;
  } ErrorIndex[8:4] = 5'h0;
  field {
    AccessType = "RO";
    desc = "
        ECRC Generation Capable. If set, this bit indicates that the function is capable of generating ECRC.
          
        This bit is loaded from EEPROM.

           ";
    ValRandomize = true;
  } ECRCGenCap[3:3] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        ECRC Generation Enable. When set, ECRC generation is enabled.

           ";
    ValRandomize = true;
  } ECRCGenEn[2:2] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        ECRC Check Capable. If set, this bit indicates that the function is capable of checking ECRC.
          
        This bit is loaded from EEPROM.

           ";
    ValRandomize = true;
  } ECRCCheckCap[1:1] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        ECRC Check Enable.When set Set, ECRC checking is enabled.

           ";
    ValRandomize = true;
  } ECRCCheckEn[0:0] = 1'h0;
};



// PCIE_VF_CFG_AER_HEADER_LOG0

reg pcie_vf_cfg_aer_header_log0_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    The header log register captures the header for the transaction that generated an error. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Header of the packet in error (TLP or DLLP).

           ";
    ValRandomize = true;
  } Header[31:0] = 32'h0;
};



// PCIE_VF_CFG_AER_HEADER_LOG1

reg pcie_vf_cfg_aer_header_log1_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    The header log register captures the header for the transaction that generated an error. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Header of the packet in error (TLP or DLLP).

           ";
    ValRandomize = true;
  } Header[31:0] = 32'h0;
};



// PCIE_VF_CFG_AER_HEADER_LOG2

reg pcie_vf_cfg_aer_header_log2_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    The header log register captures the header for the transaction that generated an error. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Header of the packet in error (TLP or DLLP).

           ";
    ValRandomize = true;
  } Header[31:0] = 32'h0;
};



// PCIE_VF_CFG_AER_HEADER_LOG3

reg pcie_vf_cfg_aer_header_log3_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    The header log register captures the header for the transaction that generated an error. 
    Errata: For CA errors, the contents of this register is not valid; which means the upper 4 bytes of the TLP/DLLP address field are not correctly logged. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Header of the packet in error (TLP or DLLP).

           ";
    ValRandomize = true;
  } Header[31:0] = 32'h0;
};



// PCIE_VF_CFG_ARI_CAP

reg pcie_vf_cfg_ari_cap_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    In order to allow more than eight functions per endpoint without requesting an internal switch, as is usually needed in virtualization scenarios, the PCI-SIG defines a new capability that allows a different interpretation of the Bus, Device, and Function fields. 
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Capability ID

           ";
    ValRandomize = true;
  } CapID[31:16] = 16'h000E;
  field {
    AccessType = "RO";
    desc = "
        Version      

           ";
    ValRandomize = true;
  } Version[15:12] = 4'h1;
  field {
    AccessType = "RO";
    desc = "
        Next capability pointer. This field shall be set to 0x000 in NVM/BSM by default for not exposing the TPH Capabilities.

           ";
    ValRandomize = true;
  } NextCapPtr[11:0] = 12'h158;
};



// PCIE_VF_CFG_ARI_CTRL

reg pcie_vf_cfg_ari_ctrl_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_15_8_[15:8] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Next function pointer, zero as there is none.

           ";
    ValRandomize = true;
  } NFP[7:0] = 8'h0;
};



// PCIE_VF_CFG_TPH_HDR

reg pcie_vf_cfg_tph_hdr_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Capability ID

           ";
    ValRandomize = true;
  } CapID[31:16] = 16'h0017;
  field {
    AccessType = "RO";
    desc = "
        Version      

           ";
    ValRandomize = true;
  } Version[15:12] = 4'h1;
  field {
    AccessType = "RO";
    desc = "
        Next capability pointer. This field contains the offset to the next PCIe extended capability structure or 0x000 if no other items exist in the linked list of capabilities. 
The field shall be set to 0x1D8 by NVM/BSM to get the ACS capability exposed to host. 

           ";
    ValRandomize = true;
  } NextCapPtr[11:0] = 12'h000;
};



// PCIE_VF_CFG_TPH_CAP

reg pcie_vf_cfg_tph_cap_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does support 

           ";
    ValRandomize = true;
  } NoStMode[31:31] = 1'h1;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support Interrupt Vector Mode of operation

           ";
    ValRandomize = true;
  } InterruptVector[30:30] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support Device Specific Mode of operation

           ";
    ValRandomize = true;
  } DeviceSpecific[29:29] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_28_24_[28:24] = 5'h0;
  field {
    AccessType = "RO";
    desc = "
        Cleared to indicate that the function is not capable of generating requests with Extended TPH TLP Prefix

           ";
    ValRandomize = true;
  } ExtendedTPH[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Value indicates if and where the ST Table is located. ST table is not available in Red Rock Canyon.

           ";
    ValRandomize = true;
  } StTableLocation[22:21] = 2'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_20_16_[20:16] = 5'h0;
  field {
    AccessType = "RO";
    desc = "
        Sets to 0, not used.

           ";
    ValRandomize = true;
  } StTableSize[15:0] = 16'h0;
};



// PCIE_VF_CFG_TPH_CTRL

reg pcie_vf_cfg_tph_ctrl_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    	Indicates the ST mode of operation selected. Defined encodings are:
    	
    	* 000b: No Table Mode
    	* 001b: Interrupt Vector Mode (not supported by RRC)
    	* 010b: Device Specific Mode (not supported by RRC)
    	* 0thers: reserved for future use
    	
    	Only a value of 000 is supported to indicates No Table mode of operation. 

           ";
    ValRandomize = true;
  } StModeSelect[8:6] = 3'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_5_1_[5:1] = 5'h0;
  field {
    AccessType = "RW";
    desc = "
    	Controls the ability to issue Request TLPs using TPH. Defined Encodings are:
    	
    	* 0b: Red Rock Canyon is not permitted to issue transactions with TPH as Requester
    	* 1b: Red Rock Canyon is permitted to issue transactions with TPH as Requester a

    	The default value of this field is 0b.

           ";
    ValRandomize = true;
  } TPH_ReqEn[0:0] = 1'h0;
};



// PCIE_VF_CFG_ACS_HDR

reg pcie_vf_cfg_acs_hdr_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
    This capability is not exposed by default, unless TPH next pointer is changed by NVM setting.
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        PCIe Extended Capability ID. PCIe extended capability ID for the SR-IOV capability.

           ";
    ValRandomize = true;
  } ID[31:16] = 16'h0D;
  field {
    AccessType = "RO";
    desc = "
        Capability Version. This field is a PCI-SIG defined version number that indicates the version of the capability structure present.
          
        Must be 0x1 for this version of the specification.

           ";
    ValRandomize = true;
  } Version[15:12] = 4'h1;
  field {
    AccessType = "RO";
    desc = "
        Next Capability Offset. This field contains the offset to the next PCIe extended capability structure or 0x000 if no other items exist in the linked list of capabilities.

           ";
    ValRandomize = true;
  } Nextpointer[11:0] = 12'h0;
};



// PCIE_VF_CFG_ACS_CAP

reg pcie_vf_cfg_acs_cap_r {
  shared;
  HandCoded = true;
  name = "";
  desc = "
           ";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does support 

           ";
    ValRandomize = true;
  } SourceValidation[30:30] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } TranslationBlocking[29:29] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } P2PRequestRedirect[28:28] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } P2PCompletionRedirect[27:27] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } UpstreamForwarding[26:26] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } P2PEgressControl[25:25] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } DirectTranslatedP2P[24:24] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_23_[23:23] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } EgressControlVectorSize[22:15] = 8'h0;
  field {
    AccessType = "RO";
    desc = "
        Must be hardwired to 0b since the ACS Source Validation functionality is not supported.

           ";
    ValRandomize = true;
  } SourceValidationEnable[14:14] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } TranslationBlockingEnable[13:13] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } P2PRequestRedirectEnable[12:12] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } P2PCompletionRedirectEnable[11:11] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } UpstreamForwardingEnable[10:10] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } P2PEgressControlEnable[9:9] = 1'h0;
  field {
    AccessType = "RO";
    desc = "
        Red Rock Canyon does not support

           ";
    ValRandomize = true;
  } DirectTranslatedP2PEnable[8:8] = 1'h0;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } __reserved_7_0_[7:0] = 8'h0;
};



// Begin reg2rdl addrmap section

addrmap PCIE_CFG_VF_map {
  name = "PCIE_CFG_VF";
  desc = "PCI Express Configuration Registers - Virtual Function";

  pcie_vf_cfg_id_r           PCIE_VF_CFG_ID                @0x0;
  pcie_vf_cfg_cmd_r          PCIE_VF_CFG_CMD               @0x8;
  pcie_vf_cfg_1_r            PCIE_VF_CFG_1                 @0x10;
  pcie_vf_cfg_2_r            PCIE_VF_CFG_2                 @0x18;
  pcie_vf_cfg_bar0_r         PCIE_VF_CFG_BAR0              @0x20;
  pcie_vf_cfg_bar1_r         PCIE_VF_CFG_BAR1              @0x28;
  pcie_vf_cfg_bar2_r         PCIE_VF_CFG_BAR2              @0x30;
  pcie_vf_cfg_bar3_r         PCIE_VF_CFG_BAR3              @0x38;
  pcie_vf_cfg_bar4_r         PCIE_VF_CFG_BAR4              @0x40;
  pcie_vf_cfg_bar5_r         PCIE_VF_CFG_BAR5              @0x48;
  pcie_vf_cfg_cardbus_r      PCIE_VF_CFG_CARDBUS           @0x50;
  pcie_vf_cfg_subid_r        PCIE_VF_CFG_SUBID             @0x58;
  pcie_vf_cfg_exp_rom_r      PCIE_VF_CFG_EXP_ROM           @0x60;
  pcie_vf_cfg_cap_ptr_r      PCIE_VF_CFG_CAP_PTR           @0x68;
  pcie_vf_cfg_rsvd_r         PCIE_VF_CFG_RSVD              @0x70;
  pcie_vf_cfg_int_r          PCIE_VF_CFG_INT               @0x78;
  pcie_vf_cfg_pcie_cap_r     PCIE_VF_CFG_PCIE_CAP          @0x80;
  pcie_vf_cfg_pcie_dev_cap_r PCIE_VF_CFG_PCIE_DEV_CAP      @0x88;
  pcie_vf_cfg_pcie_dev_ctrl_r PCIE_VF_CFG_PCIE_DEV_CTRL     @0x90;
  pcie_vf_cfg_pcie_link_cap_r PCIE_VF_CFG_PCIE_LINK_CAP     @0x98;
  pcie_vf_cfg_pcie_link_ctrl_r PCIE_VF_CFG_PCIE_LINK_CTRL    @0xa0;
  pcie_vf_cfg_pcie_dev_cap2_r PCIE_VF_CFG_PCIE_DEV_CAP2     @0xa8;
  pcie_vf_cfg_pcie_dev_ctrl2_r PCIE_VF_CFG_PCIE_DEV_CTRL2    @0xb0;
  pcie_vf_cfg_pcie_link_ctrl2_r PCIE_VF_CFG_PCIE_LINK_CTRL2   @0xb8;
  pcie_vf_cfg_msix_cap_r     PCIE_VF_CFG_MSIX_CAP          @0xc0;
  pcie_vf_cfg_msix_toff_r    PCIE_VF_CFG_MSIX_TOFF         @0xc8;
  pcie_vf_cfg_msix_pba_r     PCIE_VF_CFG_MSIX_PBA          @0xd0;
  pcie_vf_cfg_aer_hdr_r      PCIE_VF_CFG_AER_HDR           @0xd8;
  pcie_vf_cfg_aer_unerr_status_r PCIE_VF_CFG_AER_UNERR_STATUS  @0xe0;
  pcie_vf_cfg_aer_unerr_mask_r PCIE_VF_CFG_AER_UNERR_MASK    @0xe8;
  pcie_vf_cfg_aer_unerr_severity_r PCIE_VF_CFG_AER_UNERR_SEVERITY @0xf0;
  pcie_vf_cfg_aer_coerr_status_r PCIE_VF_CFG_AER_COERR_STATUS  @0xf8;
  pcie_vf_cfg_aer_coerr_mask_r PCIE_VF_CFG_AER_COERR_MASK    @0x100;
  pcie_vf_cfg_aer_ctrl_r     PCIE_VF_CFG_AER_CTRL          @0x108;
  pcie_vf_cfg_aer_header_log0_r PCIE_VF_CFG_AER_HEADER_LOG0   @0x110;
  pcie_vf_cfg_aer_header_log1_r PCIE_VF_CFG_AER_HEADER_LOG1   @0x118;
  pcie_vf_cfg_aer_header_log2_r PCIE_VF_CFG_AER_HEADER_LOG2   @0x120;
  pcie_vf_cfg_aer_header_log3_r PCIE_VF_CFG_AER_HEADER_LOG3   @0x128;
  pcie_vf_cfg_ari_cap_r      PCIE_VF_CFG_ARI_CAP           @0x130;
  pcie_vf_cfg_ari_ctrl_r     PCIE_VF_CFG_ARI_CTRL          @0x138;
  pcie_vf_cfg_tph_hdr_r      PCIE_VF_CFG_TPH_HDR           @0x140;
  pcie_vf_cfg_tph_cap_r      PCIE_VF_CFG_TPH_CAP           @0x148;
  pcie_vf_cfg_tph_ctrl_r     PCIE_VF_CFG_TPH_CTRL          @0x150;
  pcie_vf_cfg_acs_hdr_r      PCIE_VF_CFG_ACS_HDR           @0x158;
  pcie_vf_cfg_acs_cap_r      PCIE_VF_CFG_ACS_CAP           @0x160;
}; // final size: 0x168 <= 0x200 = 8<<6

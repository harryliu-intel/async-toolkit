/*
 * Copyright 2002 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

/*
 * Copyright 2001 Asynchronous Digital Design.  All rights reserved.
 * $Id$
 */

package com.avlsi.circuit;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import com.avlsi.file.common.HierName;
import com.avlsi.file.common.DeviceTypes;
import com.avlsi.file.aspice.AspiceCell;
import com.avlsi.file.aspice.Resistor;
import com.avlsi.file.aspice.Transistor;
import com.avlsi.file.aspice.Diode;
import com.avlsi.file.common.Capacitor;
import com.avlsi.util.debug.Debug;

/**********************************************************************
 * Culling circuit graph class.  This circuit graph is capable of
 * restricting the graph generation to a particular set of resistive
 * subnets.  The CullingCircuitGraph takes a list of nets to cull for
 * during parsing.  
 * <p>
 * Currently, parasitic capacitance is included only on the culled
 * resistive subnets.  The parasitic capacitance of all internal nodes
 * in the subnets' pull-up/pull-down networks are not included.  Also,
 * the resistance of these internal nodes is discarded (all nodes 
 * that are resistively connected within the pull-up/pull-down networks
 * are collapsed to a single node).
 * <p>
 * The set of nets to cull for consists of HierNames as generated by
 * HierName.getResistiveSubnetName(). 
 * <p>
 * Assumptions:
 * <ul>
 *  <li> The extractor consistently names nodes within nets of 
 *       interest as 'name:xxx' where 'xxx' can be any string.
 *  <li> Nodes within transistor pull-down/pull-up networks
 *       (usually unlabelled in the layout) are also named
 *       consistently as 'name:xxx', for any resistive internal
 *       subnet.
 * </ul>
 *
 * @author Mike Davies
 * @version $Revision$ $Date$
 **********************************************************************/
public class CullingCircuitGraph extends AbstractCircuit {

    static boolean ADDRES_DEBUG;

    /***********************************************
     * The number of resistors in the circuit
     * (only connected to culled nodes).
     ***********************************************/
    private int numResistors;

    /***********************************************
     * The number of capacitors in the circuit
     * (connected to culled nodes).
     ***********************************************/
    private int numCapacitors;

    /***********************************************
     * The number of transistors in the circuit.
     ***********************************************/
    private int numTransistors;

    /***********************************************
     * The number of diodes in the circuit
     * (connected to culled nodes).
     ***********************************************/
    private int numDiodes;

    /***********************************************
     * HierName-to-Node map for the entire circuit.
     ***********************************************/
    private HashMap nodeMap;

    

    /***********************************************
     * Specified Set of HierNames to cull.
     ***********************************************/
    private Set cullNets;

    /*****************************************************************
     * Uninitialized CullingCircuitGraph constructor.
     * @param cellType the AbstractCircuit cell type.
     * @param culledNets a list of nets (specified by canonical 
     *        HierName) to cull during parsing.
     *****************************************************************/
    public CullingCircuitGraph(final String cellType, 
                               final Set cullNets) {
        super(cellType);
        nodeMap = new HashMap();
        
        this.cullNets = new HashSet(cullNets);
    }

    /*****************************************************************
     * Adds a resistor to the circuit graph, if one of its terminals
     * belongs to the cullNets set.
     *****************************************************************/
    public void addResistor(ResistorInterface r)
    {
        HierName subnetName0 = r.getSource().getResistiveSubnetName();
        HierName subnetName1 = r.getDrain().getResistiveSubnetName();
        if (cullNets.contains(subnetName0) ||
            cullNets.contains(subnetName1)) {
            if (ADDRES_DEBUG)
                System.err.println("Adding res: "+
                                   r.getSource().getAsString('.')+" "+
                                   r.getDrain().getAsString('.'));

            AbstractNode n0 = (AbstractNode)nodeMap.get(r.getSource());
            if (n0 == null) {
                n0 = new Node(r.getSource());
                nodeMap.put(r.getSource(),n0);
            }

            AbstractNode n1 = (AbstractNode)nodeMap.get(r.getDrain());
            if (n1 == null) {
                n1 = new Node(r.getDrain());
                nodeMap.put(r.getDrain(),n1);
            }

            ResDevice rd = new ResDevice(n0,n1,(float)(1/r.getConductance()));
            n0.connectRes(rd);
            n1.connectRes(rd);

            numResistors++;
        }
    }

    /*****************************************************************
     * Adds a capacitor to the circuit graph, if one of its terminals
     * belongs to the cullNets set.
     *****************************************************************/
    public void addCapacitor(CapacitorInterface c)
    {
        boolean culls = 
            cullNets.contains(c.getSource().getResistiveSubnetName());
        boolean culld =
            cullNets.contains(c.getDrain().getResistiveSubnetName());
        
        if (culls || culld) {

            AbstractNode n0 = (AbstractNode)nodeMap.get(c.getSource());
            AbstractNode n1 = (AbstractNode)nodeMap.get(c.getDrain());

            if (n0 == null) {
                if (culls)
                    n0 = new Node(c.getSource());
                else
                    n0 = new DriverNode(c.getSource());
                nodeMap.put(c.getSource(),n0);
            }

            if (n1 == null) {
                if (culld)
                    n1 = new Node(c.getDrain());
                else
                    n1 = new DriverNode(c.getDrain());
                nodeMap.put(c.getDrain(),n1);
            }

            CapDevice cd = new CapDevice(n0,n1,(float)c.getCapacitance());
            n0.connectCap(cd);
            n1.connectCap(cd);

            numCapacitors++;
        }
    }

    /*****************************************************************
     * Adds a (MOSFET) transistor to the circuit graph.
     *****************************************************************/
    public void addTransistor(TransistorInterface t)
    {
        AbstractNode d,s,g;
        HierName subnetName = t.getGate().getResistiveSubnetName();
        boolean cullg = false;

        if (cullNets.contains(subnetName)) {
            cullg = true;
            g = (AbstractNode)nodeMap.get(t.getGate());
            if (g == null) {
                g = new Node(t.getGate());
                nodeMap.put(t.getGate(),g);
            }
        }
        else {
            g = (AbstractNode)nodeMap.get(subnetName);
            if (g == null) {
                g = new DriverNode(subnetName);
                nodeMap.put(subnetName,g);
            }
        }

        subnetName = t.getDrain().getResistiveSubnetName();

        if (cullNets.contains(subnetName)) {
            d = (AbstractNode)nodeMap.get(t.getDrain());
            if (d == null) {
                d = new Node(t.getDrain());
                nodeMap.put(t.getDrain(),d);
            }
        }
        else {
            d = (AbstractNode)nodeMap.get(subnetName);
            if (d == null) {
                d = new DriverNode(subnetName);
                nodeMap.put(subnetName,d);
            }
        }

        subnetName = t.getSource().getResistiveSubnetName();

        if (cullNets.contains(subnetName)) {
            s = (AbstractNode)nodeMap.get(t.getSource());
            if (s == null) {
                s = new Node(t.getSource());
                nodeMap.put(t.getSource(),s);
            }
        }
        else {
            s = (AbstractNode)nodeMap.get(subnetName);
            if (s == null) {
                s = new DriverNode(subnetName);
                nodeMap.put(subnetName,s);
            }
        }

        MosDevice m = new MosDevice(d,g,s,t.getType(),t.getWidth(),
                                    t.getLength());
        d.connectMos(m);
        s.connectMos(m);
        if (cullg) g.connectMos(m);

        numTransistors++;
    }

    /*****************************************************************
     * Adds a diode to the circuit graph.
     * Assumes that one of the diode's terminals is connected to 
     * either Vdd or GND.
     *****************************************************************/
    public void addDiode(DiodeInterface d) 
    {
        HierName subnetName = d.getSource().getResistiveSubnetName();
        AbstractNode n;
        if (cullNets.contains(subnetName)) {
            n = (AbstractNode)nodeMap.get(d.getSource());
            if (n == null) {
                n = new Node(d.getSource());
                nodeMap.put(d.getSource(),n);
            }
        }
        else {
            n = (AbstractNode)nodeMap.get(subnetName);
            if (n == null) {
                n = new DriverNode(subnetName);
                nodeMap.put(subnetName,n);
            }
        }
        if (n.isGND() || n.isVdd()) {
            subnetName = d.getDrain().getResistiveSubnetName();
            if (cullNets.contains(subnetName)) {
                n = (AbstractNode)nodeMap.get(d.getDrain());
                if (n == null) {
                    n = new Node(d.getDrain());
                    nodeMap.put(d.getDrain(),n);
                }
            }
            else {
                n = (AbstractNode)nodeMap.get(subnetName);
                if (n == null) {
                    n = new DriverNode(subnetName);
                    nodeMap.put(subnetName,n);
                }
            }
        }

        DiodeDevice dd = new DiodeDevice(n,d.getType(),
                                         (float)d.getWidth(),
                                         (float)d.getLength(),
                                         (float)d.getArea(),
                                         (float)d.getPerimeter());
        n.connectDiode(dd);
        numDiodes++;
    }

    /*****************************************************************
     * Returns the number of resistors in the circuit.
     *****************************************************************/
    public int getResistorCount() { return numResistors; }

    /*****************************************************************
     * Returns the number of capacitors in the circuit.
     *****************************************************************/
    public int getCapacitorCount() { return numCapacitors; }

    /*****************************************************************
     * Returns the number of transistors in the circuit.
     *****************************************************************/
    public int getTransistorCount() { return numTransistors; }

    /*****************************************************************
     * Returns the number of diodes in the circuit.
     *****************************************************************/
    public int getDiodeCount() { return numDiodes; }

    /*****************************************************************
     * Generates a TestSubnet for the specified culled net.
     * Lumps all dangling parasitic capacitors to GND, so this is 
     * not appropriate for capacitive coupling tests.
     * @return An initialized TestSubnet if subnetName was found
     *         in the circuit graph.  Otherwise, null.
     *****************************************************************/
    public TestSubnet getTestSubnet(final HierName subnetName)
    {
        TestSubnet subnet = new TestSubnet(subnetName, getType() + "." +
                                subnetName.getResistiveSubnetString());
        AbstractNode base = (AbstractNode)nodeMap.get(subnetName);
        // 
        // If a node with name equal to 'subnetName', look for
        // nodes with names equal to 'subnetBaseName:N', where
        // 'subnetBaseName' is the resisitve subnet basename and
        // N is a number between 0 and 1000.
        //
        String suffixBase = subnetName.getSuffixString();
        int idx = suffixBase.indexOf(':');
        if (idx != -1) suffixBase = suffixBase.substring(0,idx);
        for (int i=0; i <= 1000 && base == null; i++) {
            String suffix = suffixBase + ":" + String.valueOf(i);
            HierName name = HierName.makeSiblingName(subnetName,suffix);
            base = (AbstractNode) nodeMap.get(name);
        }
        if (base instanceof Node)
            base.buildTestSubnet(subnet);
        else subnet = null;
        return subnet;
    }

    /*************************************************
     * Clears all node marks throughout the net graph.
     *************************************************/
    public void clearMarks()
    {
        // Note: numMarks argument to clearAllMarks will eventually
        // require careful consideration...
        Iterator it = nodeMap.values().iterator();
        while (it.hasNext()) ((AbstractNode)it.next()).clearAllMarks(2);
    }

    /*************************************************
     * Static subcircuit repository nested subclass.
     *************************************************/
    public static class Repository extends AbstractCircuit.Repository {
        /** culling set **/
        private final Set cullSet;

        /** Constructor w/ cullSet initialization **/
        public Repository(final Set cullNetSet) {
            super();
            cullSet = cullNetSet;
        }

        /** Constructor w/out cullSet initialization **/
        public Repository() {
            super();
            cullSet = new HashSet();
        }

        /**
         * CircuitGraph generator method.
         **/
        protected AbstractCircuit newCircuitGenerator(final String cellType) {
            return new CullingCircuitGraph(cellType,cullSet);
        }
    }

    /*****************************************************************
     * Class to represent exceptions in CircuitGraph processing.
     *****************************************************************/
    public static final class Exception extends java.lang.Exception {
        public Exception(final String message) {
            super(message);
        }
    }
}


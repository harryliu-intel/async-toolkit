/*
 * Copyright 2002 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

/*
 * Copyright 2000 Asynchronous Digital Design.  All rights reserved.
 *
 * $Id$
 */

package com.avlsi.tools.jauto;

import java.io.BufferedReader;
import java.io.File;
import java.io.FilenameFilter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeSet;

import com.avlsi.cast2.directive.DirectiveConstants;
import com.avlsi.cast2.util.DirectiveUtils;
import com.avlsi.fast.CellType;
import com.avlsi.fast.CellTypeProcessor;
import com.avlsi.fast.ConnectionInfo;
import com.avlsi.geometry.BoundingBox;
import com.avlsi.geometry.Point;
import com.avlsi.file.cdl.util.rename.CadenceNameInterface;
import com.avlsi.file.cdl.util.rename.CadenceReverseNameInterface;
import com.avlsi.file.cdl.util.rename.CDLNameInterface;
import com.avlsi.file.cdl.util.rename.CDLRenameException;
import com.avlsi.file.common.HierName;
import com.avlsi.file.common.InvalidHierNameException;
import com.avlsi.tools.jauto.CellHierarchyDumpParser;
import com.avlsi.util.container.Pair;
import com.avlsi.util.text.StringUtil;

/**
 * Class for parsing floorplanning information generated by
 * //depot/sw/cad/external-tools-integration/cadence/virtuoso/main/skill/layout/instancesfile/instance.il.
 *
 * @author Aaron Denney
 * @version $Date$
 **/

public final class Floorplan {
    public static final class Exception extends RuntimeException {
        public Exception(final String message, final Throwable cause) {
            super(message, cause);
        }
        public Exception(final String message) {
            super(message);
        }
    }

    public static final String EXTENSION = ".instances";
    private final File   directory;
    private final CDLNameInterface forward, reverse;
    private final SortedSet fileCache;

    /**
     * Constructor.
     **/
    Floorplan(String directoryName) {
        this.directory = new File(directoryName);
        if (!this.directory.isDirectory()) {
            throw new Exception("Floorplanning directory " + directoryName + " is not a directory");
        }
        this.forward = new CadenceNameInterface();
        this.reverse = new CadenceReverseNameInterface();
        this.fileCache = new TreeSet();
        directory.listFiles(new FilenameFilter() {
            public boolean accept(final File dir, final String name) {
                final int index = name.lastIndexOf(EXTENSION);
                if (index > -1) {
                    final String cell = name.substring(0, index);
                    fileCache.add(cell);
                }
                return false;
            }
        });

    }

    void process(final CellType ct) {
        process(ct, new HashSet());
    }

    private String exceptionMessage(final Throwable e) {
        final StringBuffer sb = new StringBuffer();
        final String message = e.getMessage();
        if (message == null || message.equals("")) {
            sb.append(e.toString());
        } else {
            sb.append(message);
        }
        if (e.getCause() != null) {
            sb.append(": ");
            sb.append(exceptionMessage(e.getCause()));
        }
        return sb.toString();
    }

    /* This code is similar to CellType.walkOnce, but that method doesn't
     * easily allow one to skip a portion of the instantiation tree. */
    private void process(final CellType ct, final Set seen) {
        if (!seen.add(ct) || ct.isInternalEnv()) return;
        
        // skip over top level $env cell
        if (ct != ct.design.getTopLevelCell())
            try {
                readHierarchy(ct);
            } catch (Exception e) {
                System.err.println(exceptionMessage(e));
            }

        for (Iterator i = ct.getAllSubcellConnections().iterator();
             i.hasNext(); ) {
            final CellType c = ((ConnectionInfo) i.next()).child;
            process(c, seen);
        }
    }

    /**
     * Return the name of the instance file for the given cell type.
     **/
    public static String getInstanceFilename(final String typeName)
        throws CDLRenameException {
        final CDLNameInterface forward = new CadenceNameInterface();
        return forward.renameCell(typeName) + EXTENSION;
    }

    /**
     * Returns a <code>File</code> representing the instance file of the given
     * cell type.  It first tries to find the file in the cache of the
     * directory listing.  If it's not found there, it falls back to try
     * reading the instance file of the minimum lexigraphic subtype which has
     * the same module name as <code>typeName</code>, and a warning is emitted.
     *
     * @param typeName which cell's instance file to read.
     * @return File representing the instance file, or <code>null</code> if no
     * such instance file exists.
     * @throws CDLRenameException if <code>typeName</code> cannot be converted
     * to a Cadence name.
     **/
    private File getInstanceFile(final String typeName)
        throws CDLRenameException {
        final String name = forward.renameCell(typeName);
        if (fileCache.contains(name)) {
            return new File(directory, name + EXTENSION);
        } else {
            final int index = name.lastIndexOf('.');
            if (index < 0) return null;
            
            final String base = name.substring(0, index + 1);
            final SortedSet subset =
                fileCache.subSet(base + Character.MIN_VALUE,
                                 base + Character.MAX_VALUE);
            if (subset.isEmpty()) {
                return null;
            } else {
                final File f =
                    new File(directory, (String) subset.first() + EXTENSION);
                System.out.println("Warning: Falling back to reading " + f + " for cell " + typeName);
                return f;
            }
        }
    }

    /**
     * Read instance file for the given <code>CellType</code> and fill in the
     * xOffset, yOffset, and orientation fields of the appropriate
     * <code>ConnectionInfo</code>s.
     *
     * @param ct for which <code>CellType</code> to fill in data
     * @throws Floorplan.Exception if anything goes wrong
     **/
    private void readHierarchy(final CellType ct) {
        final Set<ConnectionInfo> subcells = new HashSet<ConnectionInfo>();
        for (ConnectionInfo ci : ct.getAllSubcellConnections()) {
            if (!ci.child.isInternalEnv()) subcells.add(ci);
        }
        final Set extras = new HashSet();
        final Set<String> extraPins = new HashSet<String>();
        final Collection mismatch = new ArrayList();

        readHierarchy(ct.typeName, new SubcellProcessor() {
            public void process(BoundingBox bBox) {
                final Point ll = bBox.getLowerLeft();
                final Point ur = bBox.getUpperRight();
                ct.xSize = (float) (ur.getX() - ll.getX());
                ct.ySize = (float) (ur.getY() - ll.getY());
                if(ct.getLevel() == 0) { //do this only for leaf cells
                    for (CellType.PortInfoIterator i = ct.getPorts(); i.hasNext();) {
                        CellType.PortInfo pi = i.next();
                        //The pin bbox are referenced from the center
                        //Hence you cannot use ll and ur from above.
                        BoundingBox NewbBox = new BoundingBox(-(ct.xSize/2),
                                                              -(ct.ySize/2),
                                                              (ct.xSize/2),
                                                              (ct.ySize/2));
                        pi.bBox = NewbBox;
                    }
                }
            }

            public void process(String pinName,
                                BoundingBox bBox) {
                if(ct.getLevel() > 0) { //do this only for cells that are not leaf cells
                    CellType.PortInfo pi = ct.getPortInfoForPinNamed(pinName);
                    if (pi == null) {
                        extraPins.add(pinName);
                    } else {
                        pi.bBox = bBox;
                    }
                }
            }

            public void process(String typeName,
                                String instanceName,
                                int orientation,
                                BoundingBox bBox) {
                final HierName hName;
                try {
                    hName = HierName.makeHierName(instanceName, '.');
                } catch (InvalidHierNameException e) {
                    throw new Exception("Error constructing HierName from " + instanceName, e);
                }

                final ConnectionInfo ci = ct.getSubcellNamed(hName);
                if (ci == null) {
                    extras.add(new Pair(typeName, instanceName));
                    return;
                }
                subcells.remove(ci);

                if (!typeName.equals(ci.child.typeName))
                    mismatch.add(new Pair(typeName, ci));
                
                /* Set the orientation of this instance */
                ci.orientation = orientation;

                /* Use the center of the bounding box as the location of
                 * this instance */
                final Point ll = bBox.getLowerLeft();
                final Point ur = bBox.getUpperRight();
                ci.xOffset = (float) (ll.getX() + ur.getX()) / 2;
                ci.yOffset = (float) (ll.getY() + ur.getY()) / 2;
            }
        });
        if (!extras.isEmpty() || !subcells.isEmpty() || !mismatch.isEmpty() ||
            !extraPins.isEmpty()) {
            System.err.println("In geometry information for cell " + ct.typeName + ": ");
            if (!extras.isEmpty()) {
                System.err.println("  Extra:");
                for (Iterator i = extras.iterator(); i.hasNext(); ) {
                    final Pair p = (Pair) i.next();
                    System.err.println("    " + p.getSecond() + "(" + p.getFirst() + ")");
                }
            }
            if (!subcells.isEmpty()) {
                System.err.println("  Missing:");
                for (Iterator i = subcells.iterator(); i.hasNext(); ) {
                    final ConnectionInfo ci = (ConnectionInfo) i.next();
                    System.err.println("    " + ci.nameInParent + "(" + ci.child.typeName + ")");
                }
            }
            if (!mismatch.isEmpty()) {
                System.err.println("  Mismatch [instance(dfII type/CAST type)]:");
                for (Iterator i = mismatch.iterator(); i.hasNext(); ) {
                    final Pair p = (Pair) i.next();
                    final ConnectionInfo ci = (ConnectionInfo) p.getSecond();
                    System.err.println("    " + ci.nameInParent + "(" + p.getFirst()  + 
                                       "/" + ci.child.typeName + ")");
                }
            }
            if (!extraPins.isEmpty()) {
                System.err.println("  Invalid pins: ");
                for (String pin : extraPins) {
                    System.err.println("    " + pin);
                }
            }
            System.err.println();
        }
    }

    /**
     * Read the instances file associated with a given cell, and call the given
     * <code>SubcellProcessor</code> with cell and instance names already
     * translated back to CAST.
     *
     * @param cellType which cell's instance file to parse
     * @param proc callback object to process parsed data
     *
     * @throws Floorplan.Exception if anything goes wrong.
     **/
    void readHierarchy(final String cellType, final SubcellProcessor proc) {
        final File instances;
        try {
            instances = getInstanceFile(cellType);
        } catch (CDLRenameException e) {
            throw new Exception("Cannot translate cell name " + cellType, e);
        }

        if (instances == null) {
            throw new Exception("No geometry information found for cell " + cellType);
        }

        final FileReader in;
        try {
            in = new FileReader(instances);
        } catch (FileNotFoundException e) {
            throw new Exception("Cannot read geometry information from " + instances, e);
        }

        try {
            readHierarchy(in, reverse, proc);
        } catch (Exception e) {
            throw new Exception("Cannot parse " + instances + " for type " + cellType, e);
        }

        try {
            in.close();
        } catch (IOException e) {
            throw new Exception("Cannot close instance file " + instances, e);
        }
    }

    public static void readHierarchy(final Reader in,
                                     final SubcellProcessor proc) {
        readHierarchy(in, new CadenceReverseNameInterface(), proc);
    }

    public static void readHierarchy(final Reader in,
                                     final CDLNameInterface reverse,
                                     final SubcellProcessor proc) {
        final CellHierarchyDumpLexer lexer = new CellHierarchyDumpLexer(in);
        final CellHierarchyDumpParser parser =
            new CellHierarchyDumpParser(lexer);
        try {
            parser.goal(new SubcellProcessor() {
                public void process(BoundingBox bBox) {
                    proc.process(bBox);
                }

                public void process(String pinName,
                                    BoundingBox bBox) {
                    try {
                        pinName = reverse.renameNode(pinName);
                    } catch (CDLRenameException e) {
                        throw new Exception("Error translating names while reading geometry information", e);
                    }
                    proc.process(pinName, bBox);
                }

                public void process(String typeName,
                                    String instanceName,
                                    int orientation,
                                    BoundingBox bBox) {
                    try {
                        typeName = reverse.renameCell(typeName);
                        // skip the renaming process, if the instance contains
                        // the pipe character, because the renamer does not
                        // handle it, and since it only occurs when we are
                        // interfacing to a synchronous flow through wrappers,
                        // which is rare, there is little benefit in adding the
                        // transformation to the renamers.  See bug 6290 for
                        // more information on this special case.
                        if (instanceName.indexOf('|') == -1)
                            instanceName =
                                reverse.renameSubCellInstance(instanceName);
                    } catch (CDLRenameException e) {
                        throw new Exception("Error translating names while reading geometry information", e);
                    }
                    proc.process(typeName, instanceName, orientation, bBox);
                }
            });
        } catch (java.lang.Exception e) {
            throw new Exception("Error parsing geometry information", e);
        }
    }
}

package casa_TREX;
use strict;
use TRex_lib;
use ToolConfig;
use File::Basename;
use Getopt::Long;
use Cwd;
use Carp;
use vars qw(%casa_args @Casa_Switches);


sub TREX_INIT
{
  TRex_lib::log("Initializing casa TRex module...\n");
  @Casa_Switches = ('-casa_args--', '-casa','casa_code','casa_func',);
  my @tempSwitches = @Casa_Switches;
  foreach (@tempSwitches)
  {
          s/^\-+//;
          s/:$//;
  }
  push(@{$Project_Config::TRex_CmdLine{'Hidden flags'}},@tempSwitches);
  push(@{$Project_Config::Rerun{'Common'}{'Drop switches'}},@tempSwitches);

  # Add casa switches to TREX's command line supported switches.
  push(@{Project_Config::TRex_CmdLine_Get_Switches()},@Casa_Switches);
  Project_Config::Intercept_Stage('BUILD-TEST', \&casa_init);
  Project_Config::Extend_Stage('END',\&casa_end);

  # these will be needed for emulation assuming we'll support casa for emulation
  # Project_Config::Intercept_Stage('END', \&casa_init);
  # $init_done = 0;
}


# ==
# Called at the beginning of the test (test build stage)
# ===

sub casa_init
{
    TRex_lib::log("casa_Trex inside casa_init\n");
    #return unless ($main::found_opt{'casa_args'} || $main::found_opt{'casa'});
    # for emulation
    #return if $init_done == 1; 
    #$init_done = 1;

    if ($main::found_opt{'casa_args'})
    {
        TRex_lib::log("Parse Casa Args...\n");
        parse_casa_args();
    } 
    if ($main::found_opt{'casa_code'})
    {
	TRex_lib::log("Inside casa_TREX.pm, found casa_code switch...\n");
	# code coverage: line, tgl, cond, branch, fsm
	# functional coverage: assert
	push(@{$main::Test_Info{'Model_Tool_Args'}},'-ace_args  -cc_on -ccmerge -ccm "cond+branch+fsm+assert+line+tgl" -ace_args-');
    }
    if ($main::found_opt{'casa_func'})
    {
	TRex_lib::log("Inside casa_TREX.pm, found casa_func switch...\n");
	push(@{$main::Test_Info{'Model_Tool_Args'}},'-ace_args  -cc_on -ccmerge -ccm "assert" -ace_args-');
    }
    return;
}

# ==
# Called at the and of the test
# ===

sub casa_end
{
    TRex_lib::log("casa_Trex inside casa_end\n");

    # Some checks to determine if we want to send the coverage data to the coverage tree
    return unless ($main::found_opt{'casa_args'} || $main::found_opt{'casa'});
    return unless (main::Is_Test_Passed() || $casa_args{'allow_fail'});

    my $cwd = cwd();
    my @vdb_dirs = glob("$cwd/*.vdb");
    if (scalar(@vdb_dirs) == 0)
    {
        TRex_lib::log("No .vdb dir found in run area.\n");
        return;
    }
    my $vdb_dir = basename($vdb_dirs[0]);
    copy_design_vdb($vdb_dirs[0]);
    my $date = `/usr/intel/bin/gdate`; chomp $date;

    # support for the basic tree for now project/stepping/cluster/dut/date
    my $tree = defined $casa_args{'tree'} ? $casa_args{'tree'} : "basic";

    # Find project/stepping/cluster values
    # Do not allow unknown values for any of these attributes
    my $project = get_attribute_value("project");
    if ($project eq "unknown")
    {
        main::warning("failed to extract project name.\n");
        return;
    }
    my $stepping = get_attribute_value("stepping");
    if ($stepping eq "unknown")
    {
        main::warning("failed to extract stepping name.\n");
        return;
    }
    my $cluster = get_attribute_value("cluster");  
    if ($cluster eq "unknown")
    {
        main::warning("failed to extract cluster name.\n");
        return;
    }
    
    # To use the .rpt file we need the CDS enhancement to runtools to add project/stepping/cluster information
    # use -e for now.
    # would like to add a check to generateTestInfo that the tree exists in CasaConfig - we don't want to send junk data to the sandbox  
    my $cmd = "casa generateTestInfo --results-tree '$tree' --level 'project:=$project' --level 'stepping:=$stepping' --level 'cluster:=$cluster' --level 'date:=$date'";
    
    # Find vcs version
    my @simv_files = glob("$cwd/*.simv");
    if ($main::Test_Info{'Model_Tool'} =~ /\/?acerun$/ && scalar(@simv_files) > 0) {   
        # it's safe(-ish) to assume that this is a vdb that was generated by VCS.
        # The only exception is if some other post-processing script generated the vdb
        my $vcs_path = ToolConfig::get_tool_path('vcsmx');
        my $vcs_version = basename($vcs_path);
        $cmd .= " --vcs-version '$vcs_version'";
    }

    TRex_lib::log("Running Command: $cmd\n");
    unless (defined(eval {TRex_lib::exec_and_check_error($cmd);})) {
        main::warning($@);
        return;
    } 
    # Check that the file exists
    if (!-e "testInfo.casa.xml")
    {
        main::warning("failed to generate testInfo.casa.xml.\n");
        return;
    }

    # Create the tarball for Casa to be sent to the sandbox
    # use md5 instead of sha1_hex since sha1_hex is considered to be "broken or risky cryptographic algorithm" by checkmarx
    my $tarball = $vdb_dir;
    $tarball =~ s/\.vdb$//;
    $tarball =~ s/\.simv$//;
    $tarball .= ".tar.gz";
    $cmd = "/usr/intel/bin/gtar -hcvzf $tarball testInfo.casa.xml $vdb_dir";
    TRex_lib::log("Running Command: $cmd\n");
    unless (defined(eval {TRex_lib::exec_and_check_error($cmd);})) {
        main::warning($@);
        return;
    } 
    # Check that the file exists
    if (!-e "$tarball")
    {
        main::warning("failed to generate casa tarball $tarball.\n");
        return;
    }

    # Don't send the tarball to the sandbox if testonly is specified on the command line
    return if defined $casa_args{'testonly'};

    # send the tarball to the sandbox area
    $cmd = "casa transfer --unique-name $tarball";
    TRex_lib::log("Running Command: $cmd\n");
    unless (defined(eval {TRex_lib::exec_and_check_error($cmd);})) {
        main::warning($@);
        return;
    } 
}


# ==
# Return the attribute value from the model
# ===

sub get_attribute_value
{
    my $attr = shift;
    my $res;
    if (ToolConfig::facet_exists($attr))
    {
        
        eval { $res = ToolConfig::facet_exists($attr) ? ToolConfig::get_facet($attr) : "unknown" };
        return $res if $res ne "unknown";
    }
    # This works for projects that make sure to put the values in .git/config
    $res = `/usr/intel/bin/git --git-dir=$ENV{MODEL_ROOT}/.git  --work-tree=$ENV{MODEL_ROOT} config --get intel.$attr`; chomp $res;    
    return ($res eq "" ? "unknown" : $res);
}


# ==
# Parsing the casa arguments. For initial deployment testonly and allow_fail are the only arguments supported.
# ===

sub parse_casa_args
{
    if ($main::found_opt{'casa_args'})
    {
        my @BAK_ARGV = @main::ARGV;
        @ARGV = split (/\s+/, ${$main::opt{'casa_args'}}[-1]);
        GetOptions (\%casa_args, "tree|s", "testonly", "allow_fail");
        # use Carp::croak instead of die since die is considered to be obsolete by checkmarx.
        # see: https://www.securecoding.cert.org/confluence/display/perl/EXP30-PL.+Do+not+use+deprecated+or+obsolete+functions+or+modules
        Carp::croak ("extra arguments in casa_args command line\n") if (scalar(@ARGV) > 0);
        @main::ARGV = @BAK_ARGV;
    }
}


# ==
# A function to find the .rpt file for Casa 
# Not used in this version of casa_TREX - will need it later on when we start using the .rpt file to generate the Casa xml file
# ===

sub find_rpt_file
{
    my $dir = cwd();
    my @rpt_files = glob("$dir/*.rpt");
    # use Carp::croak instead of die since die is considered to be obsolete by checkmarx.
    # see: https://www.securecoding.cert.org/confluence/display/perl/EXP30-PL.+Do+not+use+deprecated+or+obsolete+functions+or+modules
    Carp::croak ("Failed to find RPT file") unless scalar(@rpt_files) >= 0;
    foreach my $file (@rpt_files)
    {
        my $num = `/usr/bin/grep 'T E S T    R E P O R T   F I L E' $file|wc -l`;
        return $file if ($num >= 1);

    }
    return "";
}

sub copy_design_vdb
{  
    my $dir = shift;

    my $area = "$ENV{'MODEL_ROOT'}/target/$ENV{'DUT'}/aceroot/results/vcs_lib/*/models/*/*.simv.vdb";
    my @designVdbs = glob($area);
    if (scalar(@designVdbs)!=1) {
	    main::warning("casa_Trex expecting to find one designVdb in $area. found: " . join(", ", @designVdbs) . "\n");
        return;
    }
    my $designVdb = $designVdbs[0];
        
    if (!-e "$designVdb")  { main::warning("casa_Trex designVdb $designVdb doesn't exist\n");  return;  }
    
    my $cwd = cwd();
    TRex_lib::log("casa_TREX: cwd = $cwd designvdb = $designVdb\n");
    if (-e "$designVdb") {
        my $cmd1 = "/bin/cp -a $designVdb/snps/coverage/db/* $dir/snps/coverage/db/";
        TRex_lib::log("Running Command: $cmd1\n");
        unless (defined(eval {TRex_lib::exec_and_check_error($cmd1);})) {
            main::warning($@);
            #return;
        }
        #
        if (-e "$designVdb/partitionlib") {
            # dereference files and directories in source
	        my $cmd2 = "/bin/cp -aL $designVdb/partitionlib $dir/";
    	    TRex_lib::log("Running Command: $cmd2\n");
        	unless (defined(eval {TRex_lib::exec_and_check_error($cmd2);})) {
            	main::warning($@);
	            #return;
    	    }
        }
        
    #my $gzcmd = "/usr/intel/bin/gunzip -r $dir";
    #print ("Running Command: $gzcmd\n");
    #unless (defined(eval {TRex_lib::exec_and_check_error($gzcmd);})) { print ($@); }

    } 
}

1;


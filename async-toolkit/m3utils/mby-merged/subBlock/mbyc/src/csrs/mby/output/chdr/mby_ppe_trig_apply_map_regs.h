/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_trig_apply_map_regs.h                              
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_TRIG_APPLY_MAP_REGS_H_
#define _MBY_PPE_TRIG_APPLY_MAP_REGS_H_

#define TRIG_APPLY_MSGPORT     0x0
#define TRIG_APPLY_TRIGGER_CONDITION_CFG_MSGREGADDR 0x0
#define TRIG_APPLY_TRIGGER_CONDITION_PARAM_MSGREGADDR 0x300
#define TRIG_APPLY_TRIGGER_CONDITION_CGRP_MSGREGADDR 0x600
#define TRIG_APPLY_TRIGGER_CONDITION_GLORT_MSGREGADDR 0x900
#define TRIG_APPLY_TRIGGER_CONDITION_RX_MSGREGADDR 0x0C00
#define TRIG_APPLY_TRIGGER_CONDITION_AMASK_1_MSGREGADDR 0x0F00
#define TRIG_APPLY_TRIGGER_CONDITION_AMASK_2_MSGREGADDR 0x1200
#define TRIG_APPLY_TRIGGER_ACTION_CFG_1_MSGREGADDR 0x1500
#define TRIG_APPLY_TRIGGER_ACTION_CFG_2_MSGREGADDR 0x1800
#define TRIG_APPLY_TRIGGER_ACTION_GLORT_MSGREGADDR 0x1B00
#define TRIG_APPLY_TRIGGER_ACTION_MIRROR_MSGREGADDR 0x1E00
#define TRIG_APPLY_TRIGGER_STATS_MSGREGADDR 0x2100
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_CTRL_MSGREGADDR 0x2400
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_CTX0_MSGREGADDR 0x2408
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_CTX1_MSGREGADDR 0x2410
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_CTX2_MSGREGADDR 0x2418
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_CTX3_MSGREGADDR 0x2420
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_CTX4_MSGREGADDR 0x2428
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADM0_MSGREGADDR 0x2430
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADM1_MSGREGADDR 0x2438
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADM2_MSGREGADDR 0x2440
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADM3_MSGREGADDR 0x2448
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADM4_MSGREGADDR 0x2450
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADR0_MSGREGADDR 0x2458
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADR1_MSGREGADDR 0x2460
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADR2_MSGREGADDR 0x2468
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADR3_MSGREGADDR 0x2470
#define TRIG_APPLY_TRIGGER_DIRECT_MAP_ADR4_MSGREGADDR 0x2478

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_FLAG
// TRIGGER_CONDITION_CFG desc:  Each 2-bit condition field specifies one of three defined match
// cases: [list] [*] 0: Associated frame property must not equal the
// corresponding trigger parameter in order to match. [*] 1: Associated
// frame property must equal the corresponding trigger parameter in
// order to match. [*] 2: Match unconditionally. [/list] A
// configuration value of 0x3 is reserved and will cause undefined
// behavior if selected.
typedef union {
    struct {
        uint64_t  _RSVD0_              :   4;    //  Reserved
        uint64_t  LEARN                :   2;    //  Matches whether a
                                                 // LEARN_NOTIFY action was
                                                 // generated by the Classifier
                                                 // (typically in
                                                 // EM_B_HASH_MISS).[br] 0 :
                                                 // match if LEARN_NOTIFY action
                                                 // is 0[br] 1 : match if
                                                 // LEARN_NOTIFY action is 1[br]
                                                 // 2 : ignore this field[br] 3 :
                                                 // undefined
        uint64_t  _RSVD1_              :   4;    //  Reserved
        uint64_t  MATCH_VLAN           :   2;    //  Match depending on whether
                                                 // the TrigID from the VID_TABLE
                                                 // lookup matches VID_ID from
                                                 // TRIGGER_CONDITION_PARAM.[br]
                                                 // 0 : match if not equal[br] 1
                                                 // : match if equal[br] 2 :
                                                 // ignore this field[br] 3 :
                                                 // undefined
        uint64_t  MATCH_CGRP           :   2;    //  Match depending on whether
                                                 // the TrigID from the
                                                 // Classifier's SET_TRIG action
                                                 // matches CGRP_ID, when both are
                                                 // ANDed with CGRP_Mask (See
                                                 // TRIGGER_CONDITION_CGRP
                                                 // register).[br] 0 : match if
                                                 // not equal[br] 1 : match if
                                                 // equal[br] 2 : ignore this
                                                 // field[br] 3 : undefined
        uint64_t  MATCH_TC             :   2;    //  Match if the frame's TC
                                                 // matches TC from
                                                 // TRIGGER_CONDITION_PARAM.[br]
                                                 // 0 : match if not equal[br] 1
                                                 // : match if equal[br] 2 :
                                                 // ignore this field[br] 3 :
                                                 // undefined
        uint64_t  _RSVD2_              :   2;    //  Reserved
        uint64_t  MATCH_DEST_GLORT     :   2;    //  Match if the destination
                                                 // glort associated with the
                                                 // frame matches DestGlort when
                                                 // both are ANDed with GlortMask
                                                 // (See TRIGGER_CONDITION_GLORT
                                                 // register).[br] 0 : match if
                                                 // not equal[br] 1 : match if
                                                 // equal[br] 2 : ignore this
                                                 // field[br] 3 : undefined
        uint64_t  MATCH_EGRESS_DOMAIN  :   2;    //  Match if the egress domain
                                                 // associated with the frame
                                                 // matches EgressDomain
                                                 // parameter in
                                                 // TRIGGER_CONDITION_PARAM
                                                 // register.[br] 0 : match if
                                                 // not equal[br] 1 : match if
                                                 // equal[br] 2 : ignore this
                                                 // field[br] 3 : undefined
        uint64_t  _RSVD3_              :   4;    //  Reserved
        uint64_t  MATCH_BY_PRECEDENCE  :   1;    //  If 0, begins a new
                                                 // precedence-evaluated trigger
                                                 // set, evaluated in parallel
                                                 // with all other
                                                 // precedence-evaluated sets.
        uint64_t  MATCH_RANDOM_NUMBER  :   1;    //  Specifies one of two random
                                                 // number generators to compare
                                                 // against.
        uint64_t  MATCH_RANDOM_IF_LESS :   1;    //  When set to 1, matches if
                                                 // 'random is less than or equal
                                                 // to 2^MatchRandomThreshold';
                                                 // otherwise, matches if 'random
                                                 // is greater than or equal to
                                                 // 2^MatchRandomThreshold'.
        uint64_t  MATCH_RANDOM_THRESHOLD :   5;    //  Exponent used to calculate
                                                 // the threshold for
                                                 // rate-constrained matching.
                                                 // Threshold equals
                                                 // 2^MatchRandomThreshold.
        uint64_t  MATCH_TX             :   2;    //  Compare destination mask for
                                                 // this frame to the destination
                                                 // mask defined in
                                                 // TRIGGER_CONDITION_TX:
                                                 // [br][br] 00b: Match if (DMASK
                                                 // AND DestPortMask) is 0 (Used
                                                 // to check if a frame is not
                                                 // going to any port in a given
                                                 // set) [br][br] 01b: Match if
                                                 // (DMASK AND DestPortMask) is
                                                 // not 0 (Used to check if a
                                                 // frame is going to any port in
                                                 // a given set) [br][br] 10b:
                                                 // Match if (DMASK ==
                                                 // DestPortMask) (Used to check
                                                 // if a frame is going to a set
                                                 // of ports that is identical to
                                                 // a given set) [br][br] 11b:
                                                 // Match if (DMASK !=
                                                 // DestPortMask) (Used to check
                                                 // if a frame is going to a set
                                                 // of ports that is not identical
                                                 // to a given set) [br][br]
                                                 // Selecting 00b and using a
                                                 // DestPortMask of 0 is always a
                                                 // match regardless whether the
                                                 // frame is forwarded on any port
                                                 // or dropped.
        uint64_t  _RSVD4_              :  28;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_BITFIELD_COUNT 0x10
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_RESET 0x31028a820

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD0__LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD0__MSB 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD0__RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD0__MASK 0x0000000f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_LEARN_LSB 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_LEARN_MSB 0x0005
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_LEARN_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_LEARN_MASK 0x00000030
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_LEARN_RESET_VALUE 0x00000002

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD1__LSB 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD1__MSB 0x0009
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD1__RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD1__MASK 0x000003c0
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD1__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_VLAN_LSB 0x000a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_VLAN_MSB 0x000b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_VLAN_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_VLAN_MASK 0x00000c00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_VLAN_RESET_VALUE 0x00000002

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_CGRP_LSB 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_CGRP_MSB 0x000d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_CGRP_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_CGRP_MASK 0x00003000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_CGRP_RESET_VALUE 0x00000002

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TC_LSB 0x000e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TC_MSB 0x000f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TC_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TC_MASK 0x0000c000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TC_RESET_VALUE 0x00000002

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD2__LSB 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD2__MSB 0x0011
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD2__RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD2__MASK 0x00030000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD2__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_DEST_GLORT_LSB 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_DEST_GLORT_MSB 0x0013
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_DEST_GLORT_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_DEST_GLORT_MASK 0x000c0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_DEST_GLORT_RESET_VALUE 0x00000002

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_EGRESS_DOMAIN_LSB 0x0014
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_EGRESS_DOMAIN_MSB 0x0015
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_EGRESS_DOMAIN_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_EGRESS_DOMAIN_MASK 0x00300000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_EGRESS_DOMAIN_RESET_VALUE 0x00000002

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD3__LSB 0x0016
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD3__MSB 0x0019
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD3__RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD3__MASK 0x03c00000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD3__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_BY_PRECEDENCE_LSB 0x001a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_BY_PRECEDENCE_MSB 0x001a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_BY_PRECEDENCE_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_BY_PRECEDENCE_MASK 0x04000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_BY_PRECEDENCE_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_NUMBER_LSB 0x001b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_NUMBER_MSB 0x001b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_NUMBER_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_NUMBER_MASK 0x08000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_NUMBER_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_IF_LESS_LSB 0x001c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_IF_LESS_MSB 0x001c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_IF_LESS_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_IF_LESS_MASK 0x10000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_IF_LESS_RESET_VALUE 0x00000001

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_THRESHOLD_LSB 0x001d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_THRESHOLD_MSB 0x0021
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_THRESHOLD_RANGE 0x0005
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_THRESHOLD_MASK 0x3e0000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_RANDOM_THRESHOLD_RESET_VALUE 0x00000018

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TX_LSB 0x0022
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TX_MSB 0x0023
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TX_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TX_MASK 0xc00000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_MATCH_TX_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD4__LSB 0x0024
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD4__MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD4__RANGE 0x001c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD4__MASK 0xfffffff000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG__RSVD4__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FLAG
// TRIGGER_CONDITION_PARAM desc:  Match values for trigger conditions as configured in
// TRIGGER_CONDITION_CFG.
typedef union {
    struct {
        uint64_t  _RSVD0_              :  12;    //  Reserved
        uint64_t  VID_ID               :   6;    //  VLAN ID, compared against
                                                 // TrigID from the VID_TABLE
                                                 // lookup.
        uint64_t  TC                   :   3;    //  Trigger parameter to compare
                                                 // against the frame's associated
                                                 // TC.
        uint64_t  FRAME_CLASS_MASK     :   3;    //  If bit 0 is set, the trigger
                                                 // will match against unicast
                                                 // frames. If bit 1 is set, the
                                                 // trigger will match against
                                                 // broadcast frames. If bit 2 is
                                                 // set, the trigger will match
                                                 // against multicast frames.
        uint64_t  ROUTED_MASK          :   2;    //  If bit 0 is set, trigger
                                                 // will match on switched frames.
                                                 // If bit 1 is set, trigger will
                                                 // match on routed frames.
        uint64_t  _RSVD1_              :   4;    //  Reserved
        uint64_t  EGRESS_DOMAIN_VALUE  :  14;    //  Value to match against the
                                                 // egress domain value
                                                 // {egress_l3_domain (6b),
                                                 // egress_l2_domain (8b)}
                                                 // associated with the packet
                                                 // after applying mask.
                                                 // EgressDomainValue ==
                                                 // EgressDomainMask &
                                                 // {egress_l3_domain,
                                                 // egress_l2_domain}
        uint64_t  _RSVD2_              :   1;    //  Reserved
        uint64_t  EGRESS_DOMAIN_MASK   :  14;    //  Mask (AND) the egress domain
                                                 // value associated with the
                                                 // packet before comparison.
        uint64_t  _RSVD3_              :   5;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_BITFIELD_COUNT 0x0a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_RESET 0x03e00000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD0__LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD0__MSB 0x000b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD0__RANGE 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD0__MASK 0x00000fff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_VID_ID_LSB 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_VID_ID_MSB 0x0011
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_VID_ID_RANGE 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_VID_ID_MASK 0x0003f000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_VID_ID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_TC_LSB 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_TC_MSB 0x0014
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_TC_RANGE 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_TC_MASK 0x001c0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_TC_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FRAME_CLASS_MASK_LSB 0x0015
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FRAME_CLASS_MASK_MSB 0x0017
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FRAME_CLASS_MASK_RANGE 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FRAME_CLASS_MASK_MASK 0x00e00000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_FRAME_CLASS_MASK_RESET_VALUE 0x00000007

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_ROUTED_MASK_LSB 0x0018
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_ROUTED_MASK_MSB 0x0019
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_ROUTED_MASK_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_ROUTED_MASK_MASK 0x03000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_ROUTED_MASK_RESET_VALUE 0x00000003

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD1__LSB 0x001a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD1__MSB 0x001d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD1__RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD1__MASK 0x3c000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD1__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_VALUE_LSB 0x001e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_VALUE_MSB 0x002b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_VALUE_RANGE 0x000e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_VALUE_MASK 0xfffc0000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_VALUE_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD2__LSB 0x002c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD2__MSB 0x002c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD2__RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD2__MASK 0x100000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD2__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_MASK_LSB 0x002d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_MASK_MSB 0x003a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_MASK_RANGE 0x000e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_MASK_MASK 0x7ffe00000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_EGRESS_DOMAIN_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD3__LSB 0x003b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD3__MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD3__RANGE 0x0005
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD3__MASK 0xf800000000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM__RSVD3__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_FLAG
// TRIGGER_CONDITION_CGRP desc:  Match value for the Classifier related fields enabled by
// TRIGGER_CONDITION_CFG
typedef union {
    struct {
        uint64_t  CGRP_ID              :   8;    //  ID to compare against the
                                                 // TrigID specified by an
                                                 // Classifier SET_TRIG action.
                                                 // Note that 0 is a reserved
                                                 // value (it is the default value
                                                 // assigned by the Classifier to
                                                 // the CGRP_ID) and should not be
                                                 // used for normal use.
        uint64_t  CGRP_MASK            :   8;    //  Mask to be ANDed with both
                                                 // CGRP_ID and the TrigID
                                                 // specified by a Classifier
                                                 // SET_TRIG action prior to
                                                 // comparison.
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_ID_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_ID_MSB 0x0007
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_ID_RANGE 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_ID_MASK 0x000000ff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_ID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_MASK_LSB 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_MASK_MSB 0x000f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_MASK_RANGE 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_MASK_MASK 0x0000ff00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_CGRP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_FLAG
// TRIGGER_CONDITION_GLORT desc:  Match values for the GLORT related fields enabled by
// TRIGGER_CONDITION_CFG
typedef union {
    struct {
        uint64_t  DEST_GLORT           :  16;    //  Glort value to compare
                                                 // against the frame's
                                                 // destination glort.
        uint64_t  GLORT_MASK           :  16;    //  Mask to be ANDed with both
                                                 // the DestGlort trigger
                                                 // parameter and the frame's
                                                 // destination glort prior to
                                                 // comparison.
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_DEST_GLORT_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_DEST_GLORT_MSB 0x000f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_DEST_GLORT_RANGE 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_DEST_GLORT_MASK 0x0000ffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_DEST_GLORT_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_GLORT_MASK_LSB 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_GLORT_MASK_MSB 0x001f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_GLORT_MASK_RANGE 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_GLORT_MASK_MASK 0xffff0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_GLORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_FLAG
// TRIGGER_CONDITION_RX desc:  The source port mask is unconditionally ANDed with this mask. The
// result must be nonzero in order for this condition to match.
typedef union {
    struct {
        uint64_t  SRC_PORT_MASK        :  18;    //  Source port mask. The bit
                                                 // corresponding to the frame's
                                                 // source port must be set in
                                                 // order for the trigger to
                                                 // match. Setting to '1 will
                                                 // cause the trigger to match
                                                 // regardless of where the frame
                                                 // is coming from. Setting to '0
                                                 // will cause the trigger to
                                                 // never match regardless of
                                                 // where the frame is coming
                                                 // from.
        uint64_t  RSVD_0               :  46;    // Nebulon auto filled RSVD [63:18]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SRC_PORT_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SRC_PORT_MASK_MSB 0x0011
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SRC_PORT_MASK_RANGE 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SRC_PORT_MASK_MASK 0x0003ffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_SRC_PORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_FLAG
// TRIGGER_CONDITION_AMASK_1 desc:  Indicates which action mask bits to match on when the action mask
// match is enabled in TRIGGER_CONDITION_CFG.
typedef union {
    struct {
        uint64_t  HANDLER_ACTION_MASK  :  32;    //  Defines which actions
                                                 // enables this triggers (first
                                                 // 32b). Exact bits defined in
                                                 // the destination mask
                                                 // generation chapter of the HAS.
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_HANDLER_ACTION_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_HANDLER_ACTION_MASK_MSB 0x001f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_HANDLER_ACTION_MASK_RANGE 0x0020
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_HANDLER_ACTION_MASK_MASK 0xffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_HANDLER_ACTION_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_FLAG
// TRIGGER_CONDITION_AMASK_2 desc:  Indicates which action mask bits to match on when the action mask
// match is enabled in TRIGGER_CONDITION_CFG.
typedef union {
    struct {
        uint64_t  HANDLER_ACTION_MASK  :  13;    //  Defines which actions
                                                 // enables this triggers (next
                                                 // 13b, action bits 32 to 44).
                                                 // Exact bits defined in the
                                                 // destination mask generation
                                                 // chapter of the HAS.
        uint64_t  RSVD_0               :  51;    // Nebulon auto filled RSVD [63:13]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_HANDLER_ACTION_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_HANDLER_ACTION_MASK_MSB 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_HANDLER_ACTION_MASK_RANGE 0x000d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_HANDLER_ACTION_MASK_MASK 0x00001fff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_HANDLER_ACTION_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FLAG
// TRIGGER_ACTION_CFG_1 desc:  Configuration associated with trigger actions.
typedef union {
    struct {
        uint64_t  FORWARDING_ACTION    :   2;    //  Forwarding action:[br] 0:
                                                 // Leave as-is[br] 1:
                                                 // Forward[br] 2: Redirect[br]
                                                 // 3: Drop
        uint64_t  TRAP_ACTION          :   2;    //  Trap action:[br] 0: Leave
                                                 // as-is[br] 1: Trap[br] 2:
                                                 // Log[br] 3: Do not Trap or Log
        uint64_t  _RSVD0_              :   4;    //  Reserved
        uint64_t  TC_ACTION            :   1;    //  TC modification action:[br]
                                                 // 0: Leave as-is[br] 1:
                                                 // Reassign
        uint64_t  VLAN_ACTION          :   1;    //  Egress VLAN modification
                                                 // action:[br] 0: Leave
                                                 // as-is[br] 1: Reassign
        uint64_t  LEARNING_ACTION      :   2;    //  Learning action:[br] 0:
                                                 // Leave as-is, no change in
                                                 // learning[br] 1: Do not learn
                                                 // the source L2 address in to MA
                                                 // table[br] 2: Always learn[br]
                                                 // 3: Reserved
        uint64_t  RATE_LIMIT_ACTION    :   1;    //  Rate limiter action:[br] 0:
                                                 // Leave as-is[br] 1: Apply rate
                                                 // limit
        uint64_t  _RSVD1_              :   4;    //  Reserved
        uint64_t  EGRESS_L2_DOMAIN_ACTION :   1;    //  Egress L2 domain action:[br]
                                                 // 0: Always update[br] 1: Skip
        uint64_t  EGRESS_L3_DOMAIN_ACTION :   1;    //  Egress L3 domain action:[br]
                                                 // 0: Always update[br] 1: Skip
        uint64_t  POLICER_ACTION       :   1;    //  Policer action:[br] 0:
                                                 // None[br] 1: Don't police
        uint64_t  NO_MODIFY_ACTION     :   1;    //  Indicate no modifications
                                                 // allowed on this packet.
                                                 // Subject to restrictions (see
                                                 // the modify chapter).
        uint64_t  MIRRORING_ACTION0    :   2;    //  Mirroring action for mirror
                                                 // 0:[br] 0: Leave as-is[br] 1:
                                                 // Mirror[br] 2: Do not mirror
        uint64_t  MIRRORING_ACTION1    :   2;    //  Mirroring action for mirror
                                                 // 1:[br] 0: Leave as-is[br] 1:
                                                 // Mirror[br] 2: Do not mirror
        uint64_t  MIRRORING_ACTION2    :   2;    //  Mirroring action for mirror
                                                 // 2:[br] 0: Leave as-is[br] 1:
                                                 // Mirror[br] 2: Do not mirror
        uint64_t  MIRRORING_ACTION3    :   2;    //  Mirroring action for mirror
                                                 // 3:[br] 0: Leave as-is[br] 1:
                                                 // Mirror[br] 2: Do not mirror
        uint64_t  _RSVD2_              :  35;    //  Reserved

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_BITFIELD_COUNT 0x11
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FORWARDING_ACTION_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FORWARDING_ACTION_MSB 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FORWARDING_ACTION_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FORWARDING_ACTION_MASK 0x00000003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_FORWARDING_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TRAP_ACTION_LSB 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TRAP_ACTION_MSB 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TRAP_ACTION_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TRAP_ACTION_MASK 0x0000000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TRAP_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD0__LSB 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD0__MSB 0x0007
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD0__RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD0__MASK 0x000000f0
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TC_ACTION_LSB 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TC_ACTION_MSB 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TC_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TC_ACTION_MASK 0x00000100
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_TC_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_VLAN_ACTION_LSB 0x0009
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_VLAN_ACTION_MSB 0x0009
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_VLAN_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_VLAN_ACTION_MASK 0x00000200
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_VLAN_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_LEARNING_ACTION_LSB 0x000a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_LEARNING_ACTION_MSB 0x000b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_LEARNING_ACTION_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_LEARNING_ACTION_MASK 0x00000c00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_LEARNING_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_RATE_LIMIT_ACTION_LSB 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_RATE_LIMIT_ACTION_MSB 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_RATE_LIMIT_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_RATE_LIMIT_ACTION_MASK 0x00001000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_RATE_LIMIT_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD1__LSB 0x000d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD1__MSB 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD1__RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD1__MASK 0x0001e000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD1__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L2_DOMAIN_ACTION_LSB 0x0011
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L2_DOMAIN_ACTION_MSB 0x0011
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L2_DOMAIN_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L2_DOMAIN_ACTION_MASK 0x00020000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L2_DOMAIN_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L3_DOMAIN_ACTION_LSB 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L3_DOMAIN_ACTION_MSB 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L3_DOMAIN_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L3_DOMAIN_ACTION_MASK 0x00040000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_EGRESS_L3_DOMAIN_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_POLICER_ACTION_LSB 0x0013
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_POLICER_ACTION_MSB 0x0013
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_POLICER_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_POLICER_ACTION_MASK 0x00080000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_POLICER_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_NO_MODIFY_ACTION_LSB 0x0014
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_NO_MODIFY_ACTION_MSB 0x0014
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_NO_MODIFY_ACTION_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_NO_MODIFY_ACTION_MASK 0x00100000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_NO_MODIFY_ACTION_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION0_LSB 0x0015
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION0_MSB 0x0016
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION0_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION0_MASK 0x00600000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION0_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION1_LSB 0x0017
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION1_MSB 0x0018
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION1_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION1_MASK 0x01800000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION1_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION2_LSB 0x0019
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION2_MSB 0x001a
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION2_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION2_MASK 0x06000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION2_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION3_LSB 0x001b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION3_MSB 0x001c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION3_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION3_MASK 0x18000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_MIRRORING_ACTION3_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD2__LSB 0x001d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD2__MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD2__RANGE 0x0023
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD2__MASK 0xffffffffe0000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1__RSVD2__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_FLAG
// TRIGGER_ACTION_CFG_2 desc:  Configuration associated with trigger actions.
typedef union {
    struct {
        uint64_t  NEW_TC               :   3;    //  New TC (applicable when
                                                 // TCAction is 1.)
        uint64_t  NEW_EVID             :  12;    //  New egress VLAN ID
                                                 // (applicable when VlanAction is
                                                 // 1.)
        uint64_t  RATE_LIMIT_NUM       :   4;    //  Rate limiter number
                                                 // (applicable when
                                                 // RateLimitAction is 1.)
        uint64_t  TRAP_CODE            :   3;    //  Trap log CPU code for trap
                                                 // or log action
        uint64_t  RSVD_0               :  42;    // Nebulon auto filled RSVD [63:22]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_BITFIELD_COUNT 0x04
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_TC_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_TC_MSB 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_TC_RANGE 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_TC_MASK 0x00000007
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_TC_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_EVID_LSB 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_EVID_MSB 0x000e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_EVID_RANGE 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_EVID_MASK 0x00007ff8
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_NEW_EVID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_RATE_LIMIT_NUM_LSB 0x000f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_RATE_LIMIT_NUM_MSB 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_RATE_LIMIT_NUM_RANGE 0x0004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_RATE_LIMIT_NUM_MASK 0x00078000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_RATE_LIMIT_NUM_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_TRAP_CODE_LSB 0x0013
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_TRAP_CODE_MSB 0x0015
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_TRAP_CODE_RANGE 0x0003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_TRAP_CODE_MASK 0x00380000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_TRAP_CODE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_FLAG
// TRIGGER_ACTION_GLORT desc:  Action parameters used when the trigger action sets the forwarding
// mode to forward or redirect.
typedef union {
    struct {
        uint64_t  NEW_DEST_GLORT       :  16;    //  New destination glort when
                                                 // ForwardingAction is 1 or 2.
        uint64_t  NEW_DEST_GLORT_MASK  :  16;    //  Only bits that are set to 1
                                                 // will be overwritten by
                                                 // NewDestGlort.
        uint64_t  RSVD_0               :  32;    // Nebulon auto filled RSVD [63:32]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MSB 0x000f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_RANGE 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MASK 0x0000ffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MASK_LSB 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MASK_MSB 0x001f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MASK_RANGE 0x0010
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MASK_MASK 0xffff0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_NEW_DEST_GLORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_FLAG
// TRIGGER_ACTION_MIRROR desc:  Mirror related action parameters when the trigger action specifies a
// mirror.
typedef union {
    struct {
        uint64_t  MIRROR_PROFILE_INDEX0 :   6;    //  Mirror profile index value
                                                 // to set for the profile
                                                 // selected.
        uint64_t  MIRROR_PROFILE_INDEX1 :   6;    //  Mirror profile index value
                                                 // to set for the profile
                                                 // selected.
        uint64_t  MIRROR_PROFILE_INDEX2 :   6;    //  Mirror profile index value
                                                 // to set for the profile
                                                 // selected.
        uint64_t  MIRROR_PROFILE_INDEX3 :   6;    //  Mirror profile index value
                                                 // to set for the profile
                                                 // selected.
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_BITFIELD_COUNT 0x04
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX0_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX0_MSB 0x0005
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX0_RANGE 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX0_MASK 0x0000003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX0_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX1_LSB 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX1_MSB 0x000b
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX1_RANGE 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX1_MASK 0x00000fc0
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX1_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX2_LSB 0x000c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX2_MSB 0x0011
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX2_RANGE 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX2_MASK 0x0003f000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX2_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX3_LSB 0x0012
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX3_MSB 0x0017
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX3_RANGE 0x0006
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX3_MASK 0x00fc0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_MIRROR_PROFILE_INDEX3_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_FLAG
// TRIGGER_STATS desc:  Statistics register tracking the number of times a trigger fired.
typedef union {
    struct {
        uint64_t  COUNT                :  64;    //  Number of times that this
                                                 // trigger was applied to a
                                                 // frame. Does not include
                                                 // triggers that fire but are
                                                 // overrriden by
                                                 // higher-precedence triggers.
                                                 // Applies even if the frame is
                                                 // tail dropped due to an error.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_COUNT_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_COUNT_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_COUNT_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_COUNT_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_COUNT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_FLAG
// TRIGGER_DIRECT_MAP_CTRL desc:  Control Register for proxy access to TRIGGER_CONDITION_TX.
typedef union {
    struct {
        uint64_t  REG_INDX             :  32;    //  Register Entry Index.
                                                 // Indicates the trigger index.
                                                 // Valid values are 0 - 95.
        uint64_t  REG_SUB_ID           :   8;    //  Register File Sub Index. Not
                                                 // used. Set to zero.
        uint64_t  REG_ID               :   8;    //  Register File ID.[br] 0 -
                                                 // TRIGGER_CONDITION_TX [br] 1 -
                                                 // TRIGGER_ACTION_DMASK [br] 2 -
                                                 // TRIGGER_ACTION_DROP [br]
                                                 // 3-255 Reserved
        uint64_t  _RSVD0_              :  13;    //  Reserved
        uint64_t  OP_TYPE              :   1;    //  Operation Type:[br] 0:
                                                 // Read[br] 1: Write
        uint64_t  STATUS               :   1;    //  Completion Status. Set by
                                                 // hardware upon completion of
                                                 // operation.[br] 0: Successful
                                                 // completion[br] 1: Address
                                                 // Out-of-Range error
        uint64_t  GO_COMPL             :   1;    //  Go command and completion
                                                 // status. [list] [*] Set to 1
                                                 // by software to initiate
                                                 // operation [*] Set to 0 by
                                                 // hardware when the operation is
                                                 // complete [/list]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_BITFIELD_COUNT 0x07
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_INDX_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_INDX_MSB 0x001f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_INDX_RANGE 0x0020
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_INDX_MASK 0xffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_INDX_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_SUB_ID_LSB 0x0020
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_SUB_ID_MSB 0x0027
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_SUB_ID_RANGE 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_SUB_ID_MASK 0xff00000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_SUB_ID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_ID_LSB 0x0028
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_ID_MSB 0x002f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_ID_RANGE 0x0008
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_ID_MASK 0xff0000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_REG_ID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL__RSVD0__LSB 0x0030
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL__RSVD0__MSB 0x003c
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL__RSVD0__RANGE 0x000d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL__RSVD0__MASK 0x1fff000000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_OP_TYPE_LSB 0x003d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_OP_TYPE_MSB 0x003d
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_OP_TYPE_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_OP_TYPE_MASK 0x2000000000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_OP_TYPE_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_STATUS_LSB 0x003e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_STATUS_MSB 0x003e
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_STATUS_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_STATUS_MASK 0x4000000000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_STATUS_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_GO_COMPL_LSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_GO_COMPL_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_GO_COMPL_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_GO_COMPL_MASK 0x8000000000000000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_GO_COMPL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_FLAG
// TRIGGER_DIRECT_MAP_CTX0 desc:  Data register 0 for proxy access to the TRIGGER_CONDITION_TX.
// [br][br] Destination port mask match when MatchTx is enabled in
// TRIGGER_CONDITION_CFG. The complete mask is 258 bits. [br][br] Proxy
// accesses to TRIGGER_CONDITION_TX are 320b atomic operations.
typedef union {
    struct {
        uint64_t  DEST_PORT_MASK       :  64;    //  Contains bits 0..63 of the
                                                 // 258-bit destination port mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_OFFSET 0x08
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_DEST_PORT_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_DEST_PORT_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_DEST_PORT_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_DEST_PORT_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_DEST_PORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_FLAG
// TRIGGER_DIRECT_MAP_CTX1 desc:  Data register 1 for proxy access to the TRIGGER_CONDITION_TX.
// [br][br] Destination port mask match when MatchTx is enabled in
// TRIGGER_CONDITION_CFG. The complete mask is 258 bits. [br][br] Proxy
// accesses to TRIGGER_CONDITION_TX are 320b atomic operations.
typedef union {
    struct {
        uint64_t  DEST_PORT_MASK       :  64;    //  Contains bits 64..127 of the
                                                 // 258-bit destination port mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_OFFSET 0x10
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_DEST_PORT_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_DEST_PORT_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_DEST_PORT_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_DEST_PORT_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_DEST_PORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_FLAG
// TRIGGER_DIRECT_MAP_CTX2 desc:  Data register 2 for proxy access to the TRIGGER_CONDITION_TX.
// [br][br] Destination port mask match when MatchTx is enabled in
// TRIGGER_CONDITION_CFG. The complete mask is 258 bits. [br][br] Proxy
// accesses to TRIGGER_CONDITION_TX are 320b atomic operations.
typedef union {
    struct {
        uint64_t  DEST_PORT_MASK       :  64;    //  Contains bits 128..191 of
                                                 // the 258-bit destination port
                                                 // mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_OFFSET 0x18
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_DEST_PORT_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_DEST_PORT_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_DEST_PORT_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_DEST_PORT_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_DEST_PORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_FLAG
// TRIGGER_DIRECT_MAP_CTX3 desc:  Data register 3 for proxy access to the TRIGGER_CONDITION_TX.
// [br][br] Destination port mask match when MatchTx is enabled in
// TRIGGER_CONDITION_CFG. The complete mask is 258 bits. [br][br] Proxy
// accesses to TRIGGER_CONDITION_TX are 320b atomic operations.
typedef union {
    struct {
        uint64_t  DEST_PORT_MASK       :  64;    //  Contains bits 192..255 of
                                                 // the 258-bit destination port
                                                 // mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_OFFSET 0x20
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_DEST_PORT_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_DEST_PORT_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_DEST_PORT_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_DEST_PORT_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_DEST_PORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_FLAG
// TRIGGER_DIRECT_MAP_CTX4 desc:  Data register 4 for proxy access to the TRIGGER_CONDITION_TX.
// [br][br] Destination port mask match when MatchTx is enabled in
// TRIGGER_CONDITION_CFG. The complete mask is 258 bits. [br][br] Proxy
// accesses to TRIGGER_CONDITION_TX are 320b atomic operations.
typedef union {
    struct {
        uint64_t  DEST_PORT_MASK       :   2;    //  Contains bits 256..257 of
                                                 // the 258-bit destination port
                                                 // mask.
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_OFFSET 0x28
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_DEST_PORT_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_DEST_PORT_MASK_MSB 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_DEST_PORT_MASK_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_DEST_PORT_MASK_MASK 0x00000003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_DEST_PORT_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_FLAG
// TRIGGER_DIRECT_MAP_ADM0 desc:  Data register 0 for proxy access to the TRIGGER_ACTION_DMASK.
// [br][br] Action parameters used when the trigger action sets the
// forwarding mode to redirect. [br][br] Proxy accesses to
// TRIGGER_ACTION_DMASK are 320b atomic operations.
typedef union {
    struct {
        uint64_t  NEW_DEST_MASK        :  64;    //  Contains bits 0..63 of the
                                                 // new 258-bit port destination
                                                 // mask when when
                                                 // ForwardingAction is 2.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_OFFSET 0x30
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_NEW_DEST_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_NEW_DEST_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_NEW_DEST_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_NEW_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_NEW_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_FLAG
// TRIGGER_DIRECT_MAP_ADM1 desc:  Data register 1 for proxy access to the TRIGGER_ACTION_DMASK.
// [br][br] Action parameters used when the trigger action sets the
// forwarding mode to redirect. [br][br] Proxy accesses to
// TRIGGER_ACTION_DMASK are 320b atomic operations.
typedef union {
    struct {
        uint64_t  NEW_DEST_MASK        :  64;    //  Contains bits 64..127 of the
                                                 // new 258-bit port destination
                                                 // mask when when
                                                 // ForwardingAction is 2.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_OFFSET 0x38
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_NEW_DEST_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_NEW_DEST_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_NEW_DEST_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_NEW_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_NEW_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_FLAG
// TRIGGER_DIRECT_MAP_ADM2 desc:  Data register 2 for proxy access to the TRIGGER_ACTION_DMASK.
// [br][br] Action parameters used when the trigger action sets the
// forwarding mode to redirect. [br][br] Proxy accesses to
// TRIGGER_ACTION_DMASK are 320b atomic operations.
typedef union {
    struct {
        uint64_t  NEW_DEST_MASK        :  64;    //  Contains bits 128..191 of
                                                 // the new 258-bit port
                                                 // destination mask when when
                                                 // ForwardingAction is 2.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_OFFSET 0x40
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_NEW_DEST_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_NEW_DEST_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_NEW_DEST_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_NEW_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_NEW_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_FLAG
// TRIGGER_DIRECT_MAP_ADM3 desc:  Data register 3 for proxy access to the TRIGGER_ACTION_DMASK.
// [br][br] Action parameters used when the trigger action sets the
// forwarding mode to redirect. [br][br] Proxy accesses to
// TRIGGER_ACTION_DMASK are 320b atomic operations.
typedef union {
    struct {
        uint64_t  NEW_DEST_MASK        :  64;    //  Contains bits 192..255 of
                                                 // the new 258-bit port
                                                 // destination mask when when
                                                 // ForwardingAction is 2.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_OFFSET 0x48
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_NEW_DEST_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_NEW_DEST_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_NEW_DEST_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_NEW_DEST_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_NEW_DEST_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FLAG
// TRIGGER_DIRECT_MAP_ADM4 desc:  Data register 4 for proxy access to the TRIGGER_ACTION_DMASK.
// [br][br] Action parameters used when the trigger action sets the
// forwarding mode to redirect. [br][br] Proxy accesses to
// TRIGGER_ACTION_DMASK are 320b atomic operations.
typedef union {
    struct {
        uint64_t  NEW_DEST_MASK        :   2;    //  Contains bits 256..257 of
                                                 // the new 258-bit port
                                                 // destination mask when when
                                                 // ForwardingAction is 2.
        uint64_t  FILTER_DEST_MASK     :   1;    //  Destination mask will be
                                                 // LAG-filtered when set to 1
                                                 // when ForwardingAction is 2.
        uint64_t  RSVD_0               :  61;    // Nebulon auto filled RSVD [63:3]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_OFFSET 0x50
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_RESET 0x00000004

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_NEW_DEST_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_NEW_DEST_MASK_MSB 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_NEW_DEST_MASK_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_NEW_DEST_MASK_MASK 0x00000003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_NEW_DEST_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FILTER_DEST_MASK_LSB 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FILTER_DEST_MASK_MSB 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FILTER_DEST_MASK_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FILTER_DEST_MASK_MASK 0x00000004
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_FILTER_DEST_MASK_RESET_VALUE 0x00000001


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_FLAG
// TRIGGER_DIRECT_MAP_ADR0 desc:  Data register 0 for proxy access to the TRIGGER_ACTION_DROP.
// [br][br] The drop mask is applied to the frame's destination mask
// when ForwardingAction in TRIGGER_ACTION_CFG_1 is set to 3 (drop).
// [br][br] Proxy accesses to TRIGGER_ACTION_DROP are 320b atomic
// operations.
typedef union {
    struct {
        uint64_t  DROP_MASK            :  64;    //  Contains bits 0..63 of the
                                                 // 258-bit drop mask. Bits set
                                                 // to 1 will be cleared in the
                                                 // frame's destination mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_OFFSET 0x58
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_DROP_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_DROP_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_DROP_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_DROP_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_DROP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_FLAG
// TRIGGER_DIRECT_MAP_ADR1 desc:  Data register 1 for proxy access to the TRIGGER_ACTION_DROP.
// [br][br] The drop mask is applied to the frame's destination mask
// when ForwardingAction in TRIGGER_ACTION_CFG_1 is set to 3 (drop).
// [br][br] Proxy accesses to TRIGGER_ACTION_DROP are 320b atomic
// operations.
typedef union {
    struct {
        uint64_t  DROP_MASK            :  64;    //  Contains bits 64..127 of the
                                                 // 258-bit drop mask. Bits set
                                                 // to 1 will be cleared in the
                                                 // frame's destination mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_OFFSET 0x60
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_DROP_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_DROP_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_DROP_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_DROP_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_DROP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_FLAG
// TRIGGER_DIRECT_MAP_ADR2 desc:  Data register 2 for proxy access to the TRIGGER_ACTION_DROP.
// [br][br] The drop mask is applied to the frame's destination mask
// when ForwardingAction in TRIGGER_ACTION_CFG_1 is set to 3 (drop).
// [br][br] Proxy accesses to TRIGGER_ACTION_DROP are 320b atomic
// operations.
typedef union {
    struct {
        uint64_t  DROP_MASK            :  64;    //  Contains bits 128..191 of
                                                 // the 258-bit drop mask. Bits
                                                 // set to 1 will be cleared in
                                                 // the frame's destination mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_OFFSET 0x68
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_DROP_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_DROP_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_DROP_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_DROP_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_DROP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_FLAG
// TRIGGER_DIRECT_MAP_ADR3 desc:  Data register 3 for proxy access to the TRIGGER_ACTION_DROP.
// [br][br] The drop mask is applied to the frame's destination mask
// when ForwardingAction in TRIGGER_ACTION_CFG_1 is set to 3 (drop).
// [br][br] Proxy accesses to TRIGGER_ACTION_DROP are 320b atomic
// operations.
typedef union {
    struct {
        uint64_t  DROP_MASK            :  64;    //  Contains bits 192..255 of
                                                 // the 258-bit drop mask. Bits
                                                 // set to 1 will be cleared in
                                                 // the frame's destination mask.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_OFFSET 0x70
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_DROP_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_DROP_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_DROP_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_DROP_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_DROP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_FLAG
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_FLAG
// TRIGGER_DIRECT_MAP_ADR4 desc:  Data register 4 for proxy access to the TRIGGER_ACTION_DROP.
// [br][br] The drop mask is applied to the frame's destination mask
// when ForwardingAction in TRIGGER_ACTION_CFG_1 is set to 3 (drop).
// [br][br] Proxy accesses to TRIGGER_ACTION_DROP are 320b atomic
// operations.
typedef union {
    struct {
        uint64_t  DROP_MASK            :   2;    //  Contains bits 256..257 of
                                                 // the 258-bit drop mask. Bits
                                                 // set to 1 will be cleared in
                                                 // the frame's destination mask.
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_t;
#endif
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_OFFSET 0x78
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_SIZE 64
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_DROP_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_DROP_MASK_MSB 0x0001
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_DROP_MASK_RANGE 0x0002
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_DROP_MASK_MASK 0x00000003
#define MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_DROP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CFG_t TRIGGER_CONDITION_CFG[96]; // offset 4'h0, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_PARAM_t TRIGGER_CONDITION_PARAM[96]; // offset 12'h300, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_CGRP_t TRIGGER_CONDITION_CGRP[96]; // offset 12'h600, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_GLORT_t TRIGGER_CONDITION_GLORT[96]; // offset 12'h900, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_RX_t TRIGGER_CONDITION_RX[96]; // offset 16'h0C00, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_1_t TRIGGER_CONDITION_AMASK_1[96]; // offset 16'h0F00, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_CONDITION_AMASK_2_t TRIGGER_CONDITION_AMASK_2[96]; // offset 16'h1200, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_1_t TRIGGER_ACTION_CFG_1[96]; // offset 16'h1500, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_CFG_2_t TRIGGER_ACTION_CFG_2[96]; // offset 16'h1800, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_GLORT_t TRIGGER_ACTION_GLORT[96]; // offset 16'h1B00, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_ACTION_MIRROR_t TRIGGER_ACTION_MIRROR[96]; // offset 16'h1E00, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_STATS_t TRIGGER_STATS[96]; // offset 16'h2100, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTRL_t TRIGGER_DIRECT_MAP_CTRL; // offset 16'h2400, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX0_t TRIGGER_DIRECT_MAP_CTX0; // offset 16'h2408, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX1_t TRIGGER_DIRECT_MAP_CTX1; // offset 16'h2410, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX2_t TRIGGER_DIRECT_MAP_CTX2; // offset 16'h2418, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX3_t TRIGGER_DIRECT_MAP_CTX3; // offset 16'h2420, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_CTX4_t TRIGGER_DIRECT_MAP_CTX4; // offset 16'h2428, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM0_t TRIGGER_DIRECT_MAP_ADM0; // offset 16'h2430, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM1_t TRIGGER_DIRECT_MAP_ADM1; // offset 16'h2438, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM2_t TRIGGER_DIRECT_MAP_ADM2; // offset 16'h2440, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM3_t TRIGGER_DIRECT_MAP_ADM3; // offset 16'h2448, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADM4_t TRIGGER_DIRECT_MAP_ADM4; // offset 16'h2450, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR0_t TRIGGER_DIRECT_MAP_ADR0; // offset 16'h2458, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR1_t TRIGGER_DIRECT_MAP_ADR1; // offset 16'h2460, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR2_t TRIGGER_DIRECT_MAP_ADR2; // offset 16'h2468, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR3_t TRIGGER_DIRECT_MAP_ADR3; // offset 16'h2470, width 64
    MBY_PPE_TRIG_APPLY_MAP_MSG_TRIGGER_DIRECT_MAP_ADR4_t TRIGGER_DIRECT_MAP_ADR4; // offset 16'h2478, width 64
} mby_ppe_trig_apply_map_t;                      // size:  16'h2480


#endif // _MBY_PPE_TRIG_APPLY_MAP_REGS_H_


<% use security; %>
<% my %Security_Props = security::GetSecurityInfo(); %>

// WCM_TCAM[0..19,0..1023]

reg wcm_tcam_r {
  shared;
  HandCoded = true;
  name = "Configures an entry in a slice's key TCAM";
  desc = "
    Configures an entry in the TCAM.
    [br][br]
    A match occurs when the data searched is equal to the content, as defined
    in the table below.
    [br][br]
    A key is loaded by writing the key into 'Key' (KEY / KEY_TOP) and loading its 1s
    compliment in KeyInvert (KEY_INVERT / KEY_TOP_INVERT). Writing both 'Key' and 'KeyInvert' with 1
    on same bit in both fields will invalidate the entry while writing
    0 on same bit in both field is equivalent of ignoring this bit in
    the seach.
    [br][br]
    The table below shows the encoded data value stored (Content)
    based on the Key and KeyInvert values.

    [code]
          +-----------------------------------------------------+
          | KeyInvert    | Key          |        Content        |
          =======================================================
          |      0       |      0       |   X (always match)    |
          +-----------------------------------------------------+
          |      0       |      1       |           1           |
          +-----------------------------------------------------+
          |      1       |      0       |           0           |
          +-----------------------------------------------------+
          |      1       |      1       | Always mismatch state |
          +-----------------------------------------------------+
    [/code]

    The highest index has precedence in case there is more than one match in
    the same slice.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 128;
  accesswidth = 64;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } _RSVD1_[127:104] = 24'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY_TOP_INVERT[103:96] = 8'hff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY_INVERT[95:64] = 32'hffffffff;
  field {
    AccessType = "RSV";
    desc = "

           ";
    ValRandomize = true;
  } _RSVD0_[63:40] = 24'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY_TOP[39:32] = 8'hff;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } KEY[31:0] = 32'hffffffff;
};
regfile wcm_tcam_rf {
  wcm_tcam_r WCM_TCAM[1024] += 16;
};



// WCM_ACTION[0..19,0..1023]

reg wcm_action_r {
  shared;
  HandCoded = true;
  name = "Configures an entry in action RAM";
  desc = "
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION1[63:32] = 32'h0;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } ACTION0[31:0] = 32'h0;
};
regfile wcm_action_rf {
  wcm_action_r WCM_ACTION[1024] += 8;
};



// WCM_TCAM_CFG[0..15,0..63]

reg wcm_tcam_cfg_r {
  shared;
  HandCoded = true;
  name = "Configures TCAM slice";
  desc = "
    Configure each slice behavior for each packet profile.
    This register is indexed first by slice, then by packet profile.
    It provides configuration for the cascading and mux selection.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
        Specifies the validity of 64-rule chunks.  ChunkMask[0] enables rules 0..63,
        ChunkMask[1] enables rules 64..127, etc.  Used to create smaller per-profile tables.

           ";
    ValRandomize = true;
  } CHUNK_MASK[51:36] = 16'hffff;
  field {
    AccessType = "RW";
    desc = "
        Starts a compare cascade

           ";
    ValRandomize = true;
  } START_COMPARE[35:35] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Starts an exclusion set

           ";
    ValRandomize = true;
  } START_SET[34:34] = 1'h1;
  field {
    AccessType = "RW";
    desc = "
        Selects KEY8[SelectTop] as the top 8 bits of the lookup key. Only KEY8s can be selected
        for this field.

           ";
    ValRandomize = true;
  } SELECT_TOP[33:28] = 6'h0;
  field {
    AccessType = "RW";
    desc = "
         Selects byte 0 of the lookup key.
         [list]
         [*] If Select0 is in the range of 0-31, then the value is KEY16[Select0][7:0].
         [*] If Select0 is in the range of 32-95, then the value is KEY8[Select0 - 32].
         [*] If Select0 is in the range of 96-111, then the value is KEY32[Select0 - 96][7:0].
         [/list]

           ";
    ValRandomize = true;
  } SELECT0[27:21] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Selects byte 1 of the lookup key.
        [list]
        [*] If Select1 is in the range of 0-31, then the value is KEY16[Select1][15:8].
        [*] If Select1 is in the range of 32-95, then the value is KEY8[Select1 - 32].
        [*] If Select1 is in the range of 96-111, then the value is KEY32[Select1 - 96][15:8].
        [/list]

           ";
    ValRandomize = true;
  } SELECT1[20:14] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Selects byte 2 of the lookup key.
        [list]
        [*] If Select2 is in the range of 0-31, then the value is KEY16[Select2][7:0].
        [*] If Select2 is in the range of 32-95, then the value is KEY8[Select2 - 32].
        [*] If Select2 is in the range of 96-111, then the value is KEY32[Select2 - 96][23:16].
        [/list]

           ";
    ValRandomize = true;
  } SELECT2[13:7] = 7'h0;
  field {
    AccessType = "RW";
    desc = "
        Selects byte 3 of the lookup key.
        [list]
        [*] If Select3 is in the range of 0-31, then the value is KEY16[Select3][15:8].
        [*] If Select3 is in the range of 32-95, then the value is KEY8[Select3 - 32].
        [*] If Select3 is in the range of 96-111, then the value is KEY32[Select3 - 96][31:24].
        [/list]

           ";
    ValRandomize = true;
  } SELECT3[6:0] = 7'h0;
};
regfile wcm_tcam_cfg_rf {
  wcm_tcam_cfg_r WCM_TCAM_CFG[64] += 8;
};



// WCM_ACTION_CFG_EN[0..63]

reg wcm_action_cfg_en_r {
  shared;
  HandCoded = true;
  name = "Configures action RAM Enable bits source.";
  desc = "
  This register is indexed by packet profile.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "
    Bit N enables the Nth action RAM bank.

           ";
    ValRandomize = true;
  } ENABLE[23:0] = 1'h0;
};

// WCM_ACTION_CFG_IDX1[0..63]

reg wcm_action_cfg_r {
  shared;
  HandCoded = true;
  name = "Configures action RAM Enable bits source.";
  desc = "
  This register is indexed by packet profile.
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;

  field {
    AccessType = "RW";
    desc = "
    Select which TCAM slice controls Nth action RAM bank.  The field contains 12 5-b quantities denoting the TCAM slice for the Nth bank in the bits [ 5*N :+ 5] (little-endian order).

           ";
    ValRandomize = true;
  } INDEX[59:0] ;
};

regfile wcm_action_cfg_rf {
  desc = "Two registers for configuring entries in action RAM.  Reg 0 configures N=0..11, Reg 1 configures N=12..23.";
  wcm_action_cfg_r IDX[2];
};

reg wcm_ip_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  name = "WCM IP register";
  desc = "WCM Interrupt Pending Register";
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for correctable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_C_ERR[15:12] = 4'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for uncorrectable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_U_ERR[11:8] = 4'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for errors set in FGHASH_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGHASH_ERR[7:5] = 3'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bits, for errors set in FGRP_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGRP_ERR[4:2] = 3'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bit, for error set in WCM_SWEEPER/WCM_SWEEP_ERR register.
           ";
    ValRandomize = true;
  } TCAM_SWEEP_ERR[1:1] = 1'h0;
  field {
    AccessType = "RW/1C/V";
    desc = "
            Interrupt pending bit, for error set in FCMN_SHELL_CTL register.
           ";
    ValRandomize = true;
  } FCMN_SHELL_CTRL_ERR[0:0] = 1'h0;
};

reg wcm_im_r {
  Security_PolicyGroup     = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str  = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  shared;
  name = "WCM IM register";
  desc = "Selects WCM Interrupt Mask Bits";
  regwidth = 64;
  accesswidth = 64;

  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for correctable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_C_ERR[15:12] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for uncorrectable errors set in HASH_ENTRY_RAM[0..1][0..1] registers
           ";
    ValRandomize = true;
  } HASH_ENTRY_RAM_U_ERR[11:8] = 4'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for errors set in FGHASH_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGHASH_ERR[7:5] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bits, for errors set in FGRP_SHELL_CTL[0..2] registers
           ";
    ValRandomize = true;
  } FGRP_ERR[4:2] = 3'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bit, for error set in WCM_SWEEPER/WCM_SWEEP_ERR register.
           ";
    ValRandomize = true;
  } TCAM_SWEEP_ERR[1:1] = 1'h0;
  field {
    AccessType = "RW";
    desc = "
            Interrupt mask bit, for error set in FCMN_SHELL_CTL register.
           ";
    ValRandomize = true;
  } FCMN_SHELL_CTRL_ERR[0:0] = 1'h0;
};
// CGRP_B_LPP_CONFIG [0]

reg cgrp_b_lpp_config {
  shared;
  HandCoded = true;
  name = "Sets CGRP_B in LPP Mode"; 
  desc = "
  This bit sets the CGRP_B in LPP mode 
           ";
  Security_PolicyGroup = <%=$Security_Props{'MBY_PG1'}%>;
  Security_ReadAccess_Str = <%=$Security_Props{'MBY_PG1_RAC_AGENTS'}%>;
  Security_WriteAccess_Str = <%=$Security_Props{'MBY_PG1_WAC_AGENTS'}%>;
  regwidth = 64;
  accesswidth = 64;
  field {
    AccessType = "RW";
    desc = "

           ";
    ValRandomize = true;
  } CGRP_B_LPP_MODE[0:0] = 1'h0;
};

addrmap mby_ppe_cgrp_b_nested_map {
  name = "mby_nested_b";
  desc = "Classifier group B registers";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  em_hash_lookup_r            EM_HASH_LOOKUP[8192]; // 8k

  wcm_tcam_rf                 WCM_TCAM[20]          ;
  wcm_action_rf               WCM_ACTION[24]        ;
  wcm_tcam_cfg_rf             WCM_TCAM_CFG[20]      ;
  wcm_action_cfg_en_r         WCM_ACTION_CFG_EN[64] ;
  wcm_action_cfg_rf           WCM_ACTION_CFG[64]    ;
  wcm_ip_r                    WCM_IP                ;
  wcm_im_r                    WCM_IM                ;
};


addrmap mby_ppe_cgrp_b_map {
  name = "mby_em";
  desc = "Classifier group B registers";
  Space = "MSG";
  Opcode = "MEM-SB";
  No_IOSF_Primary = true;
  addressing = fullalign;

  mby_ppe_cgrp_em_map         EM;
  mby_ppe_cgrp_b_nested_map   B;
}; // final size: 0x22600 <= 0x40000 = 8<<15

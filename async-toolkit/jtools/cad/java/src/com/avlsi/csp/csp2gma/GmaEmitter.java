/*
 * Copyright 2004 Fulcrum Microsystems.  All rights reserved.
 * $Id$
 * $DateTime$
 * $Author$
 */

package com.avlsi.csp.csp2gma;

import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.avlsi.csp.ast.*;
import com.avlsi.csp.grammar.ParseRange;
import com.avlsi.csp.grammar.ParsePosition;
import com.avlsi.csp.util.CSPCellInfo;
import com.avlsi.csp.util.RefinementResolver;
import com.avlsi.csp.util.VariableAnalysisException;
import com.avlsi.csp.util.VariableAnalyzer;
import com.avlsi.fast.ports.PortDefinition;
import com.avlsi.fast.ports.PortTypeInterface;
import com.avlsi.util.container.Pair;

/**
 * Visitor pattern to emit GMAs from csp.
 *
 * @author Jesse Rosenstock
 * @version $Revision$ $Date$
 **/
public class GmaEmitter implements VisitorInterface {
    private final CSPCellInfo cellInfo;

    // State needed for traversal
    final PrintWriter out;

    private final PrintWriter debugWriter;

    private final PrintWriter warningWriter;

    private final PrintWriter errorWriter;

    /**
     * Autogenerated variable number.
     **/
    private int varNum = 0;

    /**
     * Autogenerated token number.
     **/
    private int tokenNum = 0;

    /**
     * Tokens that have been generated.
     **/
    private final ArrayList/*<String>*/ tokens;

    /**
     * The token that will have value <code>1</code> when the statement
     * being processed should begin executing.
     **/
    private String precondition = null;

    private VariableAnalyzer.Results analysisResults;

    private RefinementResolver resolver =
        new RefinementResolver(RefinementResolver.NAME);

    public GmaEmitter(final CSPCellInfo cellInfo,
                      final PrintWriter out,
                      final PrintWriter warningWriter,
                      final PrintWriter errorWriter,
                      final PrintWriter debugWriter) {
        this.cellInfo = cellInfo;
        this.out = out;
        this.warningWriter = warningWriter;
        this.errorWriter = errorWriter;
        this.debugWriter = debugWriter;
        this.tokens = new ArrayList/*<String>*/();
        this.analysisResults = null;
    }

    /**
     * Returns a pair of (data nodes, enable nodes) that we control
     * and so need to be initialized.
     **/
    private Pair/*<List<String>,List<String>>*/ emitPortList() {
        // TODO: when we strip out things from the implied port list,
        // we will need to handle _RESET manually here.
        // do reset
        // out.print("_RESET");

        final List/*<String>*/ dataNodes = new ArrayList/*<String>*/();
        final List/*<String>*/ enableNodes = new ArrayList/*<String>*/();

        // and the real ports
        boolean first = true;
        for (Iterator i = cellInfo.getPortDefinitions(); i.hasNext(); ) {
            final PortDefinition portDefinition = (PortDefinition) i.next();
            final PortTypeInterface portType = portDefinition.getType();
            final String name = portDefinition.getName();

            if (!first)
                out.print(", ");
            first = false;

            if (portType instanceof com.avlsi.fast.ports.ArrayType) {
                throw new AssertionError("Array ports not yet supported.");
            } else if (portType instanceof com.avlsi.fast.ports.ChannelType) {
                final String data = name + ".d";
                final String enable = name + ".e";
                if (portDefinition.getDirection() == PortDefinition.OUT)
                    dataNodes.add(data);
                else {
                    assert portDefinition.getDirection() == PortDefinition.IN;
                    enableNodes.add(enable);
                }
                out.print(data + ", " + enable);
            } else if (portType instanceof com.avlsi.fast.ports.NodeType) {
                // XXX: what to do about initial value?
                out.print(name);
            } else if (portType instanceof
                           com.avlsi.fast.ports.StructureType) {
                throw new AssertionError(
                        "Structure ports not yet supported.");
            }
        }

        return new Pair/*<List<String>,List<String>*/(dataNodes, enableNodes);
    }

    private void processUnary(final AbstractUnaryExpression expr,
            final String op) throws VisitorException {
        out.print('(' + op);
        expr.getExpression().accept(this);
        out.print(')');
    }

    private void processBinary(final AbstractBinaryExpression expr,
            final String op)
        throws VisitorException {
        out.print('(');
        expr.getLeft().accept(this);
        out.print(' ' + op + ' ');
        expr.getRight().accept(this);
        out.print(')');
    }

    private void processCompare(final AbstractBinaryExpression expr,
            final String op)
        throws VisitorException {
        // convert truth values of 0 and 1 to 0 and -1
        out.print("(-");
        processBinary(expr, op);
        out.print(')');
    }

    /** 
     * Inspect the sets of uninitialized variables returned by variable
     * analysis.  
     * XXX: duplicates code with JavaEmitter.processResults().
     **/
    private Set/*<String>*/ processResults(VariableAnalyzer.Results r) {
        if (r.getUnusedSet().size() != 0) {
            for (final Iterator i = r.getUnusedSet().iterator();
                    i.hasNext(); ) {
                errorWriter.println ("CSP undeclared variable " 
                        + ((String) i.next())
                        + " is set, but not used.");
            }   
            errorWriter.flush();
            warningWriter.flush();
            // throw new Error ("CSP undeclared variable is set, but not used.");
        }
        if (r.getUninitializedSet().size() != 0) {
            for (final Iterator i = r.getUninitializedSet().iterator();
                    i.hasNext(); ) {
                errorWriter.println ("CSP undeclared variable "
                        + ((String) i.next())
                        + " is uninitialized.");
            }   
            errorWriter.flush();
            warningWriter.flush();
            throw new Error ("Uninitialized variables in " +
                             cellInfo.getType() + '.');
        }   

        final Set/*<String>*/ undeclaredVars = new HashSet/*<String>*/();
        Map m = r.getUndeclaredTypes();
        for (final Iterator i = m.keySet().iterator(); i.hasNext(); ) {
            String name = (String) i.next();
            Type type = (Type) m.get(name);

            if (type == null
             || type instanceof IntegerType
             || type instanceof BooleanType)
                undeclaredVars.add(name);
            else {  
                errorWriter.flush();
                warningWriter.flush();
                throw new Error ("Undeclared variable has unsupported type.");
            }
        }

        return undeclaredVars;
    }

    private void emitChannelGroup(
            final /*@ non_null @*/ List/*<String>*/ nodes,
            final /*@ non_null @*/ String groupName) {
        if (!nodes.isEmpty()) {
            out.print("group " + groupName + '(');
            boolean first = true;
            for (Iterator i = nodes.iterator(); i.hasNext(); ) {
                final String node = (String) i.next();
                if (!first)
                    out.print(", ");
                first = false;
                out.print(node);
            }
            out.println(");");
        }
    }


    public void visitCSPProgram(CSPProgram e) throws VisitorException {
        // determine correspondence between function calls and function
        // declarations, and structure types and structure declarations
        resolver.resolve(e);
        e = resolver.getCSPProgram();

        // quote the type name in case of ()'s from meta params
        out.print("define \"" + cellInfo.getType() + "\"(");
        final Pair/*<List<String>,List<String>>*/ p = emitPortList();
        out.println(") {");

        // set all enables to 0 and data rails to -1
        final List/*<String>*/ dataNodes = (List) p.getFirst();
        final List/*<String>*/ enableNodes = (List) p.getSecond();
        emitChannelGroup(dataNodes, "$channel_data");
        emitChannelGroup(enableNodes, "$channel_enables");

        // XXX: function declarations

        // emit a group of the undeclared variables
        final boolean haveUndeclaredVars;
        try {
            analysisResults =
                new VariableAnalyzer(cellInfo).getResults(e, resolver);
            final Set/*<String>*/ undeclaredVars =
                processResults(analysisResults);

            // Groups of size 0 are not allowed.
            haveUndeclaredVars = !undeclaredVars.isEmpty();
            if (haveUndeclaredVars) {
                out.print("group $undeclared_vars(");
                boolean first = true;
                for (Iterator i = undeclaredVars.iterator(); i.hasNext(); ) {
                    final String undeclaredVar = (String) i.next();
                    if (!first)
                        out.print(',');
                    first = false;
                    out.print(undeclaredVar);
                }
                out.println(");");
            }
        } catch (VariableAnalysisException x) {
            throw new VisitorException(x.getMessage());
        }

        // start gma block
        out.println("gma {");

        // handle reset
        out.println("_RESET == 0 ->");
        // set variables to zero
        out.println("    instant $tokens = 0,");
        if (haveUndeclaredVars)
            out.println("    instant $undeclared_vars = 0,");
        if (!dataNodes.isEmpty())
            out.println("    instant $channel_data = -1,");
        if (!enableNodes.isEmpty())
            out.println("    instant $channel_enables = 0,");
        out.println("    $tok_start = 1");

        // Because of the way things are set up elsewhere, we might end up
        // wiring a token to the starting token.  Wiring anything to
        // $tok_start is not good.  Add in another token to prevent this.
        out.println("_RESET == 1 && $tok_start ->");
        // disable self
        out.println("    instant $tok_start = 0,");
        // pass on token
        precondition = genToken();
        out.println("    " + precondition + " = 1");

        // handle initializer statement to deal with top-level constants
        // TODO: Share top-level constants, as this wastes memory
        if (e.getInitializerStatement() != null)
            e.getInitializerStatement().accept(this);

        // csp body
        e.getStatement().accept(this);

        // end gma block
        out.println('}');

        // declare token group
        out.print("group $tokens(");
        for (int i = 0; i < tokens.size(); ++i) {
            final String token = (String) tokens.get(i);
            if (i != 0)
                out.print(',');
            out.print(token);
        }
        out.println(");");

        // end cell definition
        out.println('}');

        // again, quote the type name
        out.println('"' + cellInfo.getType() + "\" x;");
    }

    /**
     * Return a new autogenerated variable number.
     **/
    private int genVarNum() {
        return varNum++;
    }

    private String genToken() {
        final String token = "$tok_" + tokenNum++;
        tokens.add(token);
        return token;
    }

    public void visitAddExpression(AddExpression e)
        throws VisitorException {
        processBinary(e, "+");
    }

    public void visitAndExpression(AndExpression e)
        throws VisitorException {
        processBinary(e, "&");
    }

    public void visitArrayAccessExpression(ArrayAccessExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitBitRangeExpression(BitRangeExpression e)
        throws VisitorException {
        out.print("EXT(");
        e.getBitsExpression().accept(this);
        out.print(',');
        e.getMinExpression().accept(this);
        out.print(',');
        e.getMaxExpression().accept(this);
        out.print(')');
    }

    public void visitConditionalAndExpression(ConditionalAndExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitConditionalOrExpression(ConditionalOrExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitFunctionCallExpression(FunctionCallExpression e)
        throws VisitorException {
        final ExpressionInterface func = e.getFunctionExpression();
        if (func instanceof IdentifierExpression &&
            ((IdentifierExpression) func).getIdentifier().equals("print")) {
            final Iterator actuals = e.getActuals();
            if (actuals.hasNext()) {
                final ExpressionInterface arg =
                    (ExpressionInterface) actuals.next();
                if (!actuals.hasNext()) {
                    new AssignmentStatement(new IdentifierExpression("stdout"),
                                            arg).accept(this);
                    return;
                }
            }
        }
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitDivideExpression(DivideExpression e)
        throws VisitorException {
        processBinary(e, "/");
    }

    public void visitExponentialExpression(ExponentialExpression e)
        throws VisitorException {
        processBinary(e, "**");
    }

    public void visitEqualityExpression(EqualityExpression e)
        throws VisitorException {
        processCompare(e, "==");
    }

    public void visitGreaterEqualExpression(GreaterEqualExpression e)
        throws VisitorException {
        processCompare(e, ">=");
    }

    public void visitGreaterThanExpression(GreaterThanExpression e)
        throws VisitorException {
        processCompare(e, ">");
    }

    public void visitInequalityExpression(InequalityExpression e)
        throws VisitorException {
        processCompare(e, "!=");
    }

    public void visitLessEqualExpression(LessEqualExpression e)
        throws VisitorException {
        processCompare(e, "<=");
    }

    public void visitLessThanExpression(LessThanExpression e)
        throws VisitorException {
        processCompare(e, "<");
    }

    public void visitIntegerExpression(IntegerExpression e)
        throws VisitorException {
        if (e.getRadix() == 10)
            out.print(e.getValue());
        else if (e.getRadix() == 16)
            out.print("0x" + e.getValue());
        else {
            // write other bases in hex for no particular reason
            out.print("0x" + new BigInteger(e.getValue(), e.getRadix())
                                 .toString(16));
        }
    }

    public void visitLeftShiftExpression(LeftShiftExpression e)
        throws VisitorException {
        processBinary(e, "<<");
    }

    public void visitRightShiftExpression(RightShiftExpression e)
        throws VisitorException {
        processBinary(e, ">>");
    }

    public void visitIdentifierExpression(IdentifierExpression e) {
        out.print(e.getIdentifier());
    }

    public void visitLoopExpression(LoopExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitMultiplyExpression(MultiplyExpression e)
        throws VisitorException {
        processBinary(e, "*");
    }

    public void visitNegateExpression(NegateExpression e)
        throws VisitorException {
        processUnary(e, "-");
    }

    public void visitNotExpression(NotExpression e)
        throws VisitorException {
        processUnary(e, "~");
    }

    public void visitOrExpression(OrExpression e)
        throws VisitorException {
        processBinary(e, "|");
    }

    public void visitXorExpression(XorExpression e)
        throws VisitorException {
        processBinary(e, "^");
    }

    public void visitPeekExpression(PeekExpression e)
        throws VisitorException {
        //  inside guard: #L? == L.d
        // outside guard: #L? == ( [ L.d >= 0 ] ; L.d )
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitProbeExpression(ProbeExpression e)
        throws VisitorException {
        // #L == (L.d >= 0)
        // #R == R.e

        final ExpressionInterface chanExpr = e.getChannelExpression();
        // The type checking pass should have ensured that this is indeed
        // a channel type.
        final ChannelType type = 
            (ChannelType) analysisResults.getType(chanExpr);
        if (chanExpr instanceof IdentifierExpression) {
            final IdentifierExpression identExpr =
                (IdentifierExpression) chanExpr;
            final String channel = identExpr.getIdentifier();
            if (type.getDirection() == PortDirection.IN) {
                // Add - to compensate for difference in gma and csp
                // comparison semantics.
                out.println("(-(" + channel + ".d >= 0))");
            } else {
                assert type.getDirection() == PortDirection.OUT;
                out.println('-' + channel + ".e");
            }
        } else {
            assert chanExpr instanceof ArrayAccessExpression;
            throw new AssertionError("Arrays not yet supported.");
        }
    }

    public void visitReceiveExpression(ReceiveExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitRemainderExpression(RemainderExpression e)
        throws VisitorException {
        processBinary(e, "%");
    }

    public void visitSubtractExpression(SubtractExpression e)
        throws VisitorException {
        processBinary(e, "-");
    }

    public void visitStructureAccessExpression(StructureAccessExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitMemberAccessExpression(MemberAccessExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitAssignmentStatement(AssignmentStatement s)
        throws VisitorException {
        // our precondition
        out.println("_RESET == 1 && " + precondition + " ->");
        // disable self
        out.println("    instant " + precondition + " = 0,");
        // pass on token
        precondition = genToken();
        out.println("    " + precondition + " = 1,");
        // do the assignment
        // XXX: support array and structure access
        out.print("    instant ");
        if (s.getLeftHandSide() instanceof BitRangeExpression) {
            final BitRangeExpression bitRangeExpression =
                (BitRangeExpression) s.getLeftHandSide();
            out.print("INS(");
            bitRangeExpression.getBitsExpression().accept(this);
            out.print(',');
            s.getRightHandSide().accept(this);
            out.print(',');
            bitRangeExpression.getMinExpression().accept(this);
            out.print(',');
            bitRangeExpression.getMaxExpression().accept(this);
            out.println(')');
        } else {
            s.getLeftHandSide().accept(this);
            out.print(" = ");
            s.getRightHandSide().accept(this);
            out.println();
        }
    }

    private void emitWire(final String node1, final String node2) {
        // End and restart the gma block because wires need to be outside
        out.println('}');
        out.println("wire(" + node1 + ", " + node2 + ");");
        out.println("gma {");
    }

    public void processDeterministicSelectionOrRepetition(
            final AbstractGuardedStatement s,
            final boolean isRepetition)
        throws VisitorException {
        // XXX: does not detect multiple true guards
        // TODO: This implementation has needless token transitions,
        // optimize them away.
        final String loopPrecondition = precondition;
        final String loopPostcondition = genToken();
        // The statement to go to after an alternative has been executed.
        // This will be the beginning of the loop for a repetition, or
        // the statement after the loop for a selection.
        final String afterStatement =
            isRepetition ? loopPrecondition : loopPostcondition;
        for (Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
            final GuardedCommand gc = (GuardedCommand) i.next();
            // handle guard
            out.print("_RESET == 1 && " + loopPrecondition + " && ");
            gc.getGuard().accept(this);
            out.println(" ->");
            // disable self
            out.println("    instant " + loopPrecondition + " = 0,");
            // pass on token
            precondition = genToken();
            out.println("    " + precondition + " = 1");

            // handle body
            gc.getCommand().accept(this);

            // go back to beginning of loop or after loop
            emitWire(afterStatement, precondition);
        }

        if (isRepetition || s.getElseStatement() != null) {
            // handle loop exit
            // if all guards are false ...
            out.print("_RESET == 1 && " + loopPrecondition);
            for (Iterator i = s.getGuardedCommands(); i.hasNext(); ) {
                final GuardedCommand gc = (GuardedCommand) i.next();
                // handle guard
                out.print(" && ~");
                gc.getGuard().accept(this);
            }
            out.println(" ->");
            // disable self
            out.println("    instant " + loopPrecondition + " = 0,");

            if (s.getElseStatement() != null) {
                // pass on token
                precondition = genToken();
                out.println("    " + precondition + " = 1");

                // else statement, loop can not exit

                // handle else
                s.getElseStatement().accept(this);

                // and go back to beginning of loop or after the loop
                emitWire(afterStatement, precondition);
            } else {
                // no else statement, loop can exit

                // pass on token
                out.println("    " + loopPostcondition + " = 1");
            }
        }

        precondition = loopPostcondition;
    }

    public void visitDeterministicRepetitionStatement(
            DeterministicRepetitionStatement s)
        throws VisitorException {
        processDeterministicSelectionOrRepetition(s, true);
    }

    public void visitDeterministicSelectionStatement(
            DeterministicSelectionStatement s)
        throws VisitorException {
        processDeterministicSelectionOrRepetition(s, false);
    }

    public void visitExpressionStatement(ExpressionStatement s)
        throws VisitorException {
        final ExpressionInterface expr = s.getExpression();
        if (expr instanceof FunctionCallExpression) {
            expr.accept(this);
            return;
        }
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLoopStatement(LoopStatement s) throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitNonDeterministicRepetitionStatement(
            NonDeterministicRepetitionStatement s)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitNonDeterministicSelectionStatement(
            NonDeterministicSelectionStatement s)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLinkageLoopTerm(final LinkageLoopTerm term)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLinkageExpressionTerm(final LinkageExpressionTerm term)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLinkageArrayAccessExpression(
            final LinkageArrayAccessExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLinkageIdentifierExpression(
            final LinkageIdentifierExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLinkageStructureAccessExpression(
            final LinkageStructureAccessExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitParallelStatement(ParallelStatement s)
        throws VisitorException {
        // TODO: factor out parallel assignments to all be done at once
        final String parallelPrecondition = precondition;
        final ArrayList/*<String>*/ preconditions =
            new ArrayList/*<String>*/();
        final ArrayList/*<String>*/ postconditions =
            new ArrayList/*<String>*/();

        for (Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();

            // This token will be activated by the fork, which we emit
            // below.
            precondition = genToken();
            preconditions.add(precondition);

            // emit the parallel code
            stmt.accept(this);

            // keep track of all post-conditions so we can do the join
            postconditions.add(precondition);
        }

        // Emit the join after the parallel statements.  A bit awkward,
        // but better than storing all the statements to get them
        // in the "right" order.

        // fork
        out.println("_RESET == 1 && " + parallelPrecondition + " ->");
        // enable children
        for (int i = 0; i < preconditions.size(); ++i) {
            final String precondition = (String) preconditions.get(i);
            out.println("    " + precondition + " = 1,");
        }
        // disable self
        out.println("    instant " + parallelPrecondition + " = 0");
        
        // join
        out.print("_RESET == 1");
        for (int i = 0; i < postconditions.size(); ++i) {
            final String postcondition = (String) postconditions.get(i);
            out.print(" && " + postcondition);
        }
        out.println(" ->");
        // disable all children
        for (int i = 0; i < postconditions.size(); ++i) {
            final String postcondition = (String) postconditions.get(i);
            out.println("    instant " + postcondition + " = 0,");
        }
        // enable next statement
        precondition = genToken();
        out.println("    " + precondition + " = 1");
    }

    public void visitReceiveStatement(ReceiveStatement s)
        throws VisitorException {
        // L?x == ( L.e = 1 ; [ L.d >= 0 ] ; x = L.d
        //        ; L.e = 0 ; [ L.d <  0 ] )
        //     == $pre0             -> L.e = 1, $pre0 = 0, $pre1 = 1
        //        $pre1 && L.d >= 0 -> x = L.d, $pre1 = 0, $pre2 = 1
        //        $pre2             -> L.e = 0, $pre2 = 0, $pre3 = 1
        //        $pre3 && L.d  < 0 ->          $pre3 = 0, $pre4 = 1
        // Good test cases include:
        // 1. L[getTime() % N]?x
        // 2. L[x]?x
        // These will ensure channel is evaluated only once

        // Using 2-phase handshaking, this becomes:
        // L?x == ( [ L.e != L.v ] ; x = L.d ; L.e = !L.e )
        //     == $pre0 && L.e != L.v -> x = L.d,    $pre0 = 0, $pre1 = 1
        //     == $pre1               -> L.e = !L.e, $pre1 = 0, $pre2 = 1
        // R!x == ( [ R.e == R.v ] ; R.d = x ; R.v = !R.v )
        //     == $pre0 && R.e == R.v -> R.d = x,    $pre0 = 0, $pre1 = 1
        //     == $pre1               -> R.v = !R.v, $pre1 = 0, $pre2 = 1
        // #L  == ( L.e != L.v )
        // #R  == ( R.e == R.v )
        
        final ExpressionInterface chanExpr = s.getChannelExpression();
        final String data;
        final String enable;
        if (chanExpr instanceof IdentifierExpression) {
            final IdentifierExpression identExpr =
                (IdentifierExpression) chanExpr;
            final String channel = identExpr.getIdentifier();
            data = channel + ".d";
            enable = channel + ".e";
        } else {
            assert chanExpr instanceof ArrayAccessExpression;
            throw new AssertionError("Arrays not yet supported.");
        }

        // now process the expanded version
        // TODO: this probably won't work too well for the array version
        // TODO: currently, this is a bit inefficient because there are:
        //     * extra -'s from the comparisons
        //     * extra wire() statements
        //     * extra skip statements
        final IdentifierExpression dataExpr = new IdentifierExpression(data);
        final IdentifierExpression enableExpr =
            new IdentifierExpression(enable);
        final IntegerExpression zero = new IntegerExpression("0", 10);
        // L.e = 1
        new AssignmentStatement(enableExpr,
                                new IntegerExpression("1", 10)).accept(this);
        // [ L.d >= 0 -> x = L.d ]
        final DeterministicSelectionStatement waitValid =
            new DeterministicSelectionStatement();
        waitValid.addGuardedCommand(new GuardedCommand(
                    new GreaterEqualExpression(dataExpr, zero),
                    s.getRightHandSide() != null
                        ? (StatementInterface) new AssignmentStatement(
                            s.getRightHandSide(), dataExpr)
                        : (StatementInterface) new SkipStatement()));
        waitValid.accept(this);
        // L.e = 0
        new AssignmentStatement(enableExpr, zero).accept(this);
        // [ L.d < 0 ]
        final DeterministicSelectionStatement waitNeutral =
            new DeterministicSelectionStatement();
        waitNeutral.addGuardedCommand(new GuardedCommand(
                    new LessThanExpression(dataExpr, zero),
                    new SkipStatement()));
        waitNeutral.accept(this);
    }

    public void visitSendStatement(SendStatement s)
        throws VisitorException {
        // R!x == ( [  R.e ] ; R.d = POSMOD(x, numValues)
        //        ; [ !R.e ] ; R.d = -1 )
        //     == $pre0 && R.e -> R.d = POSMOD(x, numValues),
        //                                   $pre0 = 0, $pre1 = 1
        //        $pre1 && !R.e -> R.d = -1, $pre1 = 0, $pre2 = 1
        // Good test cases include:
        // 1. R[getTime() % N]!x
        // This will ensure channel is evaluated only once
        
        final ExpressionInterface chanExpr = s.getChannelExpression();
        final String data;
        final String enable;
        if (chanExpr instanceof IdentifierExpression) {
            final IdentifierExpression identExpr =
                (IdentifierExpression) chanExpr;
            final String channel = identExpr.getIdentifier();
            data = channel + ".d";
            enable = channel + ".e";
        } else {
            assert chanExpr instanceof ArrayAccessExpression;
            throw new AssertionError("Arrays not yet supported.");
        }

        // The type checking pass should have ensured that this is indeed
        // a channel type and that the direction is appropriate
        final ChannelType type =
            (ChannelType) analysisResults.getType(chanExpr);
        assert type.getDirection() == PortDirection.OUT;
        final BigInteger numValues = type.getNumValues();
        assert numValues.signum() == 1;

        // [ R.e -> R.d = POSMOD(x, numValues) ]
        out.println("_RESET == 1 && " + precondition +
                    " && " + enable + " ->");
        // disable self
        out.println("    instant " + precondition + " = 0,");
        // assign data
        out.print("    instant " + data + " = ");
        out.print("POSMOD(");
        s.getRightHandSide().accept(this);
        // Channel widths will generally be more understandable in hex
        out.println(", 0x" + numValues.toString(16) + "),");
        // enable next
        precondition = genToken();
        out.println("    " + precondition + " = 1");

        // [ !R.e -> R.d = -1 ]
        out.println("_RESET == 1 && " + precondition +
                    " && !" + enable + " ->");
        // disable self
        out.println("    instant " + precondition + " = 0,");
        // assign data
        out.println("    instant " + data + " = -1,");
        // enable next
        precondition = genToken();
        out.println("    " + precondition + " = 1");
    }

    public void visitSequentialStatement(SequentialStatement s)
        throws VisitorException {
        for (final Iterator i = s.getStatements(); i.hasNext(); ) {
            final StatementInterface stmt = (StatementInterface) i.next();
            stmt.accept(this);
        }   
    }

    public void visitErrorStatement(ErrorStatement s)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitSkipStatement(SkipStatement s)
        throws VisitorException {
        // TODO: optimize this token transition away.
        //   if we do, we need to make sure *[skip] works
        out.println("_RESET == 1 && " + precondition + " ->");
        // disable self
        out.println("    instant " + precondition + " = 0,");
        // enable next
        precondition = genToken();
        out.println("    " + precondition + " = 1");
    }

    public void visitVarStatement(VarStatement s)
        throws VisitorException {
        for (Iterator i = s.getDeclarationList().getDeclarations();
             i.hasNext(); ) {
            final Declaration declaration = (Declaration) i.next();

            for (Iterator j =
                     declaration.getDeclaratorList().getDeclarators();
                 j.hasNext(); ) {
                final Declarator declarator = (Declarator) j.next();

                // XXX: support only integer declarations
                assert declarator.getTypeFragment() instanceof IntegerType;

                // add the variable to the set of declared variables
                // XXX: we currently do not support variables with the
                // same name in parallel scopes.
                // declaredVariables.add(declarator.getIdentifier()
                                                // .getIdentifier());

                // emit an assignment of the variable to its initial value
                new AssignmentStatement(declarator.getIdentifier(),
                                        declarator.getInitializer() != null
                                            ? declarator.getInitializer()
                                            : new IntegerExpression("0", 10))
                    .accept(this);
            }
        }

        // only support new style declarations
        assert s.getStatement() == null;
    }


    public void visitArrayType(ArrayType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitChannelType(ChannelType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitChannelStructureType(ChannelStructureType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitIntegerType(IntegerType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitBooleanType(BooleanType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitNodeType(NodeType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitStringType(StringType t) throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitStructureType(StructureType t)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitIdentifierList(IdentifierList il)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitLoopGuard(LoopGuard s) throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitStringExpression(StringExpression e)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }

    public void visitIncDecStatement(IncDecStatement s)
        throws VisitorException {
        throw new AssertionError("CSP construct not yet supported");
    }
}

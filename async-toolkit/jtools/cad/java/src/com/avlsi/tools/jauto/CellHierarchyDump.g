// This reads in a dump of the form generated by the skill function
// DumpCellHierarchy.  allRecords() is the main function.  It produces
// a Vector of SubCellRecords, one per subcell, which contain the
// type, name (relative to the parent), and bounding box (relative to
// the parent) of the subcell.

header {
    ///////////////////////////////////////////////////////////////////////
    //
    // Copyright 2001 Fulcrum Microsystems.  All rights reserved.
    //
    // Warning:  This file was AUTOMATICALLY GENERATED!!!
    // 
    // DO NOT check in.
    // DO NOT modify.
    //
    // You want to modify CellHierarchyDump.g instead
    //
    ///////////////////////////////////////////////////////////////////////

    package com.avlsi.tools.jauto;
}

{
    import java.util.Vector;

    import com.avlsi.geometry.Point;
    import com.avlsi.geometry.BoundingBox;

    import com.avlsi.fast.ConnectionInfo;
    import com.avlsi.tools.jauto.SubcellProcessor;
    import com.avlsi.util.debug.Debug;
}

class CellHierarchyDumpParser extends Parser;

{
    private Point makePoint(Token tx, Token ty) throws SemanticException {
        Point p = null;
        try {
            double x = Double.parseDouble(tx.getText());
            double y = Double.parseDouble(ty.getText());
            p = new Point(x, y);
        } catch (NumberFormatException e) {
            throw new SemanticException("Invalid number in coordinate (" + tx.getText() + ", " + ty.getText()+ ") found at line " + tx.getLine() + " column " + tx.getColumn() + "!");
        }
        return p;
    }
    private int orientValue(String o) {
        if (o.equals("R0")) return ConnectionInfo.R0;
        else if (o.equals("R90")) return ConnectionInfo.R90;
        else if (o.equals("R180")) return ConnectionInfo.R180;
        else if (o.equals("R270")) return ConnectionInfo.R270;
        else if (o.equals("MX")) return ConnectionInfo.MX;
        else if (o.equals("MXR90")) return ConnectionInfo.MXR90;
        else if (o.equals("MY")) return ConnectionInfo.MY;
        else if (o.equals("MYR90")) return ConnectionInfo.MYR90;
        Debug.assertTrue(false, "Invalid orientation " + o + "!");
        return 0; // Not reached.
    }
}

// MAIN FUNCTION
// Returns a Vector of SubCellRecords.
goal [ SubcellProcessor p ] {
        BoundingBox b;
    }
    :   b = bBox {
            p.process(b);
        } 
        (pinRecords[p]) ? 
        (subCellRecords[p]) ? 
        EOF
    ;

pinRecords [ SubcellProcessor p ]
    :   PINS_TOKEN
        BEGIN_TOKEN
        (
            pinRecord[p]
        )*
        END_TOKEN
    ;

pinRecord [ SubcellProcessor p ] {
        BoundingBox b;
    }
    :   BEGIN_TOKEN name:STRING b = bBox END_TOKEN
        {
            p.process(name.getText(),
                      b);
        }
    ;

subCellRecords [ SubcellProcessor p ]
    :   SUBCELLS_TOKEN
        BEGIN_TOKEN
        (
            subCellRecord[p]
        )*
        END_TOKEN
    ;


subCellRecord [ SubcellProcessor p ] {
        BoundingBox b;
    }
    :   BEGIN_TOKEN type:STRING name:STRING orient:ORIENT b = bBox END_TOKEN
        {
            p.process(type.getText(),
                      name.getText(),
                      orientValue(orient.getText()),
                      b);
        }
    ;

bBox returns [BoundingBox b]
{ b = null;
  Point lowerLeft;
  Point upperRight; }
    :   BEGIN_TOKEN lowerLeft = coord upperRight = coord END_TOKEN
        {
            b = new BoundingBox(lowerLeft, upperRight);
        }
    ;

coord returns [Point p]
{ p = null; }
    :   BEGIN_TOKEN x:NUMBER y:NUMBER END_TOKEN 
        {
            p = makePoint(x, y);
        }
    ;

string returns [String s]
{ s = null; }
    :   str:STRING
        {
            s = str.getText();
        }
    ;

class CellHierarchyDumpLexer extends Lexer;
options {
    k = 3;
}

BEGIN_TOKEN
    :   ( "beginlist" )
    ;

END_TOKEN
    :   ( "endlist" )
    ;

PINS_TOKEN
    :   ( "pins" )
    ;

SUBCELLS_TOKEN
    :   ( "subcells" )
    ;

// Represents what's between quote marks
STRING
    :   '\"'! ( 'a'..'z'|'A'..'Z'|'-'|'0'..'9'|'['|']'|'.'|'('|')'|'_'|','|'|' )+ '\"'!
    ;

NUMBER
    :   ('+' | '-')?
        (
            ( ('0'..'9')+ ('.' ('0'..'9')+ )? )
        |
            ( '.' ('0'..'9')+ )
        )
        ( ('e' | 'E') ('+' | '-')? ('0'..'9')+ )?
    ;

WS  :   (   ' '
        |   '\t'
        |   '\r' '\n' { newline(); }
        |   '\n'      { newline(); }
        )
        {$setType(Token.SKIP);} //ignore this token
    ;



ORIENT
    : "R0" | "R90" | "R180" | "R270" | "MX" | "MXR90" | "MY" | "MYR90"
    ;

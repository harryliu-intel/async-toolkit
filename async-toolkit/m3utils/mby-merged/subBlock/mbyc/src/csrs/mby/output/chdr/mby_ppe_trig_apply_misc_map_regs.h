/* Copyright (c) 2025 Intel Corporation.  All rights reserved.  See the file COPYRIGHT for more information. */
/* SPDX-License-Identifier: Apache-2.0 */

//                                                                             
// File:            mby_ppe_trig_apply_misc_map_regs.h                         
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_TRIG_APPLY_MISC_MAP_REGS_H_
#define _MBY_PPE_TRIG_APPLY_MISC_MAP_REGS_H_

#define TRIG_APPLY_MISC_MSGPORT     0x0
#define TRIG_APPLY_MISC_TRIGGER_RATE_LIM_CFG_2_MSGREGADDR 0x0
#define TRIG_APPLY_MISC_TRIGGER_ACTION_METADATA_MASK_MSGREGADDR 0x80
#define TRIG_APPLY_MISC_TRIGGER_IP_MSGREGADDR 0x0C0
#define TRIG_APPLY_MISC_TRIGGER_IM_MSGREGADDR 0x0D0
#define TRIG_APPLY_MISC_TRIGGER_RATE_LIM_EMPTY_MSGREGADDR 0x0E0
#define TRIG_APPLY_MISC_MA_TCN_FIFO_0_MSGREGADDR 0x100
#define TRIG_APPLY_MISC_MA_TCN_FIFO_1_MSGREGADDR 0x1100
#define TRIG_APPLY_MISC_MA_TCN_DEQUEUE_MSGREGADDR 0x2100
#define TRIG_APPLY_MISC_MA_TCN_DATA_0_MSGREGADDR 0x2108
#define TRIG_APPLY_MISC_MA_TCN_DATA_1_MSGREGADDR 0x2110
#define TRIG_APPLY_MISC_MA_TCN_PTR_HEAD_MSGREGADDR 0x2118
#define TRIG_APPLY_MISC_MA_TCN_PTR_TAIL_MSGREGADDR 0x2120
#define TRIG_APPLY_MISC_MA_TCN_IP_MSGREGADDR 0x2128
#define TRIG_APPLY_MISC_MA_TCN_IM_MSGREGADDR 0x2130
#define TRIG_APPLY_MISC_MA_TCN_WM_MSGREGADDR 0x2140
#define TRIG_APPLY_MISC_MA_TCN_USAGE_MSGREGADDR 0x21D0

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_FLAG
// TRIGGER_RATE_LIM_CFG_2 desc:  Configuration fields related to the trigger rate limiting action.
typedef union {
    struct {
        uint64_t  DROP_MASK            :  24;    //  Drop mask to apply to the
                                                 // frame when the rate limiter
                                                 // exceeds its configured rate.
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_DROP_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_DROP_MASK_MSB 0x0017
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_DROP_MASK_RANGE 0x0018
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_DROP_MASK_MASK 0x00ffffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_DROP_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_FLAG
// TRIGGER_ACTION_METADATA_MASK desc:  Metadata mask applied to the packet metadata on output from triggers.
typedef union {
    struct {
        uint64_t  METADATA_MASK        :  64;    //  Bitwise mask applied to the
                                                 // metadata output in the case
                                                 // that the NoModify action is
                                                 // set.

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_METADATA_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_METADATA_MASK_MSB 0x003f
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_METADATA_MASK_RANGE 0x0040
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_METADATA_MASK_MASK 0xffffffffffffffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_METADATA_MASK_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_FLAG
// TRIGGER_IP desc:  Pending bits indicating a corresponding trigger has fired.
typedef union {
    struct {
        uint64_t  PENDING              :  48;    //  Interrupt pending bits, set
                                                 // whenever the corresponding
                                                 // trigger fires.
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_OFFSET 0xc0
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_PENDING_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_PENDING_MSB 0x002f
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_PENDING_RANGE 0x0030
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_PENDING_MASK 0xffffffffffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_PENDING_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_FLAG
// TRIGGER_IM desc:  Mask bits associated with the trigger inrrupts.
typedef union {
    struct {
        uint64_t  MASK                 :  48;    //  Interrupt mask bits.
        uint64_t  RSVD_0               :  16;    // Nebulon auto filled RSVD [63:48]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_OFFSET 0xd0
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_RESET 0xffffffffffff

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_MASK_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_MASK_MSB 0x002f
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_MASK_RANGE 0x0030
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_MASK_MASK 0xffffffffffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_MASK_RESET_VALUE 0xffffffffffff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_FLAG
// TRIGGER_RATE_LIM_EMPTY desc:  Tracks the token-bucket status of the trigger rate limiter.
typedef union {
    struct {
        uint64_t  EMPTY                :  16;    //  Bit set for each rate
                                                 // limiter with an empty token
                                                 // bucket
                                                 // (TRIGGER_RATE_LIM_USAGE=0)
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_OFFSET 0xe0
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_RESET 0x0000ffff

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_EMPTY_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_EMPTY_MSB 0x000f
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_EMPTY_RANGE 0x0010
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_EMPTY_MASK 0x0000ffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_EMPTY_RESET_VALUE 0x0000ffff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_FLAG
// MA_TCN_FIFO_0 desc:  The MAC Address Table is a use case of the Exact Match unit in
// CGRP_B (EM_B). If the following conditions are met: [list] [*] The
// packet does not match any EM_B entry [*] EM_B is programmed with a
// default miss action of LEARN_NOTIFY [*] The domain mapper indicates
// learning is enabled for the packet's associated L2 Domain [*]
// Learning is configured as enabled on the ingress port in
// FWD_PORT_CFG_1 [/list] then an entry will be made in the TCN FIFO so
// that software can optoinally add an MA table entry in EM_B.
typedef union {
    struct {
        uint64_t  MAC_ADDRESS          :  48;    //  Source MAC address that was
                                                 // not found in the MA Table
        uint64_t  PORT                 :   5;    //  Ingress port
        uint64_t  RSVD_0               :  11;    // Nebulon auto filled RSVD [63:53]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_MAC_ADDRESS_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_MAC_ADDRESS_MSB 0x002f
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_MAC_ADDRESS_RANGE 0x0030
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_MAC_ADDRESS_MASK 0xffffffffffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_MAC_ADDRESS_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_PORT_LSB 0x0030
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_PORT_MSB 0x0034
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_PORT_RANGE 0x0005
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_PORT_MASK 0x1f000000000000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_PORT_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_FLAG
// MA_TCN_FIFO_1 desc:  See MA_TCN_FIFO_0
typedef union {
    struct {
        uint64_t  VID                  :  12;    //  Ingress VLAN ID
        uint64_t  L2_DOMAIN            :   8;    //  L2 Domain
        uint64_t  RSVD_0               :  44;    // Nebulon auto filled RSVD [63:20]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_VID_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_VID_MSB 0x000b
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_VID_RANGE 0x000c
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_VID_MASK 0x00000fff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_VID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_L2_DOMAIN_LSB 0x000c
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_L2_DOMAIN_MSB 0x0013
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_L2_DOMAIN_RANGE 0x0008
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_L2_DOMAIN_MASK 0x000ff000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_L2_DOMAIN_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_FLAG
// MA_TCN_DEQUEUE desc:  Software writes a 1 to the READY bit to initiate the dequeue
// operation. If there is a TCN FIFO entry, it will be copied to
// MA_TCN_DATA_{0,1} and MA_TCN_DATA_0.VALID set to 1. When the
// operation completes, the hardware clears the READY bit, indicating
// that MA_TCN_DATA_{0,1} may be read.
typedef union {
    struct {
        uint64_t  READY                :   1;    //  When software writes a 1, a
                                                 // TCN FIFO dequeue operation is
                                                 // initiated. Hardware will
                                                 // clear to 0 when the dequeue
                                                 // operation is complete.
                                                 // Behavior is undefined if
                                                 // software writes a 0.
        uint64_t  RSVD_0               :  63;    // Nebulon auto filled RSVD [63:1]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_OFFSET 0x00
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_READY_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_READY_MSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_READY_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_READY_MASK 0x00000001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_READY_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_FLAG
// MA_TCN_DATA_0 desc:  When a TCN FIFO dequeue command operation is completed
// (MA_TCN_DEQUEUE.READY=0), this register will hold a copy of the TCN
// FIFO entry, if there was one to dequeue. The contents of this
// register and MA_TCN_DATA_1 are not valid while MA_TCN_DEQUEUE.READY=1.
typedef union {
    struct {
        uint64_t  MAC_ADDRESS          :  48;    //  Source MAC address that was
                                                 // not found in the MA Table
        uint64_t  PORT                 :   5;    //  Ingress port
        uint64_t  VALID                :   1;    //  Indicates that there was a
                                                 // TCN FIFO entry and it was
                                                 // copied to this register and
                                                 // to MA_TCN_DATA_1.
        uint64_t  RSVD_0               :  10;    // Nebulon auto filled RSVD [63:54]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_OFFSET 0x08
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_BITFIELD_COUNT 0x03
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_MAC_ADDRESS_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_MAC_ADDRESS_MSB 0x002f
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_MAC_ADDRESS_RANGE 0x0030
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_MAC_ADDRESS_MASK 0xffffffffffff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_MAC_ADDRESS_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_PORT_LSB 0x0030
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_PORT_MSB 0x0034
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_PORT_RANGE 0x0005
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_PORT_MASK 0x1f000000000000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_PORT_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_VALID_LSB 0x0035
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_VALID_MSB 0x0035
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_VALID_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_VALID_MASK 0x20000000000000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_VALID_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_FLAG
// MA_TCN_DATA_1 desc:  See MA_TCN_DATA_0.
typedef union {
    struct {
        uint64_t  VID                  :  12;    //  Ingress VLAN ID
        uint64_t  L2_DOMAIN            :   8;    //  L2 Domain
        uint64_t  RSVD_0               :  44;    // Nebulon auto filled RSVD [63:20]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_OFFSET 0x10
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_VID_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_VID_MSB 0x000b
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_VID_RANGE 0x000c
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_VID_MASK 0x00000fff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_VID_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_L2_DOMAIN_LSB 0x000c
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_L2_DOMAIN_MSB 0x0013
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_L2_DOMAIN_RANGE 0x0008
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_L2_DOMAIN_MASK 0x000ff000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_L2_DOMAIN_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_FLAG
// MA_TCN_PTR_HEAD desc:  Points to the next entry in the TCN FIFO to be read by software.
// Software advances the pointer by setting MA_TCN_DEQUEUE.READY to 1.
// [br][br] This register is RW for debugging purposes.
typedef union {
    struct {
        uint64_t  HEAD                 :   9;    //  Offset into the TCN FIFO
                                                 // where the next entry will be
                                                 // read from.
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_OFFSET 0x18
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_HEAD_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_HEAD_MSB 0x0008
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_HEAD_RANGE 0x0009
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_HEAD_MASK 0x000001ff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_HEAD_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_FLAG
// MA_TCN_PTR_TAIL desc:  Points to the next entry in the TCN FIFO where hardware will write a
// new entry. Hardware will advance the pointer after writing the new
// entry. [br][br] This register is RW for debugging purposes.
typedef union {
    struct {
        uint64_t  TAIL                 :   9;    //  Offset into the TCN FIFO
                                                 // where the next entry will be
                                                 // written.
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_OFFSET 0x20
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_TAIL_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_TAIL_MSB 0x0008
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_TAIL_RANGE 0x0009
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_TAIL_MASK 0x000001ff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_TAIL_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_FLAG
// MA_TCN_IP desc:  Writing '1' into any bit clears the corresponding bit, writing 0 has
// no effect.
typedef union {
    struct {
        uint64_t  TCN_OVERFLOW         :   1;    //  Set whenever a new
                                                 // notification could not be
                                                 // enqueued to the MA_TCN_FIFO
                                                 // (FIFO full).
        uint64_t  PENDING_EVENTS       :   1;    //  Set whenever MA_TCN_PTR_TAIL
                                                 // is advanced and (512 +
                                                 // Tail(new) - Head) % 512 is
                                                 // greater than 0 (FIFO not
                                                 // empty)
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_OFFSET 0x28
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_TCN_OVERFLOW_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_TCN_OVERFLOW_MSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_TCN_OVERFLOW_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_TCN_OVERFLOW_MASK 0x00000001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_TCN_OVERFLOW_RESET_VALUE 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_PENDING_EVENTS_LSB 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_PENDING_EVENTS_MSB 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_PENDING_EVENTS_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_PENDING_EVENTS_MASK 0x00000002
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_PENDING_EVENTS_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_FLAG
// MA_TCN_IM desc:  The interrupt mask register controls if the corresponding interrupt
// source in MA_TCN_IP is presented to the interrupt hierarchy (bit is
// set to 0) or masked out (bit is set to 1).
typedef union {
    struct {
        uint64_t  TCN_OVERFLOW         :   1;    // 
        uint64_t  PENDING_EVENTS       :   1;    // 
        uint64_t  RSVD_0               :  62;    // Nebulon auto filled RSVD [63:2]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_OFFSET 0x30
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_BITFIELD_COUNT 0x02
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_RESET 0x00000003

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_TCN_OVERFLOW_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_TCN_OVERFLOW_MSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_TCN_OVERFLOW_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_TCN_OVERFLOW_MASK 0x00000001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_TCN_OVERFLOW_RESET_VALUE 0x00000001

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_PENDING_EVENTS_LSB 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_PENDING_EVENTS_MSB 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_PENDING_EVENTS_RANGE 0x0001
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_PENDING_EVENTS_MASK 0x00000002
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_PENDING_EVENTS_RESET_VALUE 0x00000001


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_FLAG
// MA_TCN_WM desc:  Indicates the maximum number of TCN FIFO entries that may be
// consumed by each port.
typedef union {
    struct {
        uint64_t  WM                   :   9;    // 
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_OFFSET 0x40
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_RESET 0x0000001e

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_WM_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_WM_MSB 0x0008
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_WM_RANGE 0x0009
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_WM_MASK 0x000001ff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_WM_RESET_VALUE 0x0000001e


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_FLAG
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_FLAG
// MA_TCN_USAGE desc:  Indicates the actual number of TCN FIFO entries in use by each port.
typedef union {
    struct {
        uint64_t  USAGE                :   9;    // 
        uint64_t  RSVD_0               :  55;    // Nebulon auto filled RSVD [63:9]

    }                                field;
    uint64_t                         val;
} MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_t;
#endif
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_OFFSET 0xd0
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_SCOPE 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_SIZE 64
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_BITFIELD_COUNT 0x01
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_RESET 0x00000000

#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_USAGE_LSB 0x0000
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_USAGE_MSB 0x0008
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_USAGE_RANGE 0x0009
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_USAGE_MASK 0x000001ff
#define MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_USAGE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_CFG_2_t TRIGGER_RATE_LIM_CFG_2[16]; // offset 4'h0, width 64
    // starting the regfile section
    struct {
        MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_ACTION_METADATA_MASK_t TRIGGER_ACTION_METADATA_MASK[4]; // offset 4'h0, width 64
    } TRIGGER_ACTION_METADATA_MASK[2];           // offset 8'h80, size: 32
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IP_t TRIGGER_IP[2];    // offset 12'h0C0, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_IM_t TRIGGER_IM[2];    // offset 12'h0D0, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_TRIGGER_RATE_LIM_EMPTY_t TRIGGER_RATE_LIM_EMPTY; // offset 12'h0E0, width 64
    uint8_t                    rsvd0[24];
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_0_t MA_TCN_FIFO_0[512]; // offset 12'h100, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_FIFO_1_t MA_TCN_FIFO_1[512]; // offset 16'h1100, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DEQUEUE_t MA_TCN_DEQUEUE;   // offset 16'h2100, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_0_t MA_TCN_DATA_0;    // offset 16'h2108, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_DATA_1_t MA_TCN_DATA_1;    // offset 16'h2110, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_HEAD_t MA_TCN_PTR_HEAD;  // offset 16'h2118, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_PTR_TAIL_t MA_TCN_PTR_TAIL;  // offset 16'h2120, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IP_t MA_TCN_IP;        // offset 16'h2128, width 64
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_IM_t MA_TCN_IM;        // offset 16'h2130, width 64
    uint8_t                    rsvd1[8];
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_WM_t MA_TCN_WM[17];    // offset 16'h2140, width 64
    uint8_t                    rsvd2[8];
    MBY_PPE_TRIG_APPLY_MISC_MAP_MSG_MA_TCN_USAGE_t MA_TCN_USAGE[17]; // offset 16'h21D0, width 64
} mby_ppe_trig_apply_misc_map_t;                 // size:  16'h2258


#endif // _MBY_PPE_TRIG_APPLY_MISC_MAP_REGS_H_


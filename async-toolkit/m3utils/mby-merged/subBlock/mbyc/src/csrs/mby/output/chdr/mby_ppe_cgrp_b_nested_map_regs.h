//                                                                             
// File:            mby_ppe_cgrp_b_nested_map_regs.h                           
// Creator:         solson                                                     
// Time:            Wednesday Dec 12, 2018 [10:52:09 am]                       
//                                                                             
// Path:            /tmp/solson/nebulon_run/4706538284_2018-12-12.10:40:08     
// Arguments:       -I                                                         
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/tools/srdl
//                  -sv_no_sai_checks -sverilog -xml -chdr -crif -ovm -input   
//                  mby_top_map.rdl -timeout 60000 -out_dir                    
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby
//                  -rtlgencomp -log_file                                      
//                  /nfs/site/disks/slx_1593/solson/mby/work_root/mby-mby-x0_WW5018a/MockTurnin/target/GenRTL/regflow/mby/nebulon_sv_output.log
//                                                                             
// MRE:             5.2018.2                                                   
// Machine:         scci79110                                                  
// OS:              Linux 3.0.101-108.13.1.14249.0.PTF-default                 
// Nebulon version: d18ww24.4                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2018 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


#ifndef _MBY_PPE_CGRP_B_NESTED_MAP_REGS_H_
#define _MBY_PPE_CGRP_B_NESTED_MAP_REGS_H_

#define B_MSGPORT     0x0
#define B_EM_HASH_LOOKUP_MSGREGADDR 0x0
#define B_WCM_TCAM_MSGREGADDR 0x80000
#define B_WCM_ACTION_MSGREGADDR 0x100000
#define B_WCM_TCAM_CFG_MSGREGADDR 0x130000
#define B_WCM_ACTION_CFG_EN_MSGREGADDR 0x132800
#define B_IDX_MSGREGADDR 0x132C00
#define B_WCM_IP_MSGREGADDR 0x133000
#define B_WCM_IM_MSGREGADDR 0x133008

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_FLAG
// EM_HASH_LOOKUP desc:  In single lookup mode, there is one table with [list] [*] 32K
// buckets in CGRP_A [*] 8K buckets in CGRP_B [/list] In split mode,
// the total number of buckets gets divided between the two halves of
// the split:[br] In CGRP_A: [list] [*] LOOKUP0 =
// EM_HASH_LOOKUP[0..16383] [*] LOOKUP1 = EM_HASH_LOOKUP[16384..32767]
// [/list] In CGRP_B: [list] [*] LOOKUP0 = EM_HASH_LOOKUP[0..4095]
// [*] LOOKUP1 = EM_HASH_LOOKUP[4096..8191] [/list]
typedef union {
    struct {
        uint128_t  MASK                 :  32;    //  selects which bucket_hash
                                                 // values have entries.
        uint128_t  SELECT_0             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_1             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_2             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_3             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  SELECT_4             :   4;    //  selects 'more' hash
                                                 // bits:[br] bucket_hash[i] =
                                                 // more_hash[select[i]]
        uint128_t  RSVD1_               :  12;    // 
        uint128_t  PTR                  :  20;    //  ptr*4 is the byte-location
                                                 // of the bucket's first entry in
                                                 // Hash Entry RAM.
        uint128_t  RSVD_0               :  44;    // Nebulon auto filled RSVD [127:84]

    }                                field;
    uint128_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SIZE 128
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_BITFIELD_COUNT 0x08
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_RESET 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_MSB 0x001f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_RANGE 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_MASK 0xffffffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_MASK_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_LSB 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_MSB 0x0023
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_MASK 0xf00000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_LSB 0x0024
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_MSB 0x0027
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_MASK 0xf000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_1_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_LSB 0x0028
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_MSB 0x002b
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_MASK 0xf0000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_2_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_LSB 0x002c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_MSB 0x002f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_MASK 0xf00000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_3_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_LSB 0x0030
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_MSB 0x0033
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_MASK 0xf000000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_SELECT_4_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__LSB 0x0034
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__MSB 0x003f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__RANGE 0x000c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__MASK 0xfff0000000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_RSVD1__RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_LSB 0x0040
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_MSB 0x0053
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_RANGE 0x0014
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_MASK 0x000fffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_PTR_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_FLAG
// WCM_TCAM desc:  Configures an entry in the TCAM. [br][br] A match occurs when the
// data searched is equal to the content, as defined in the table below.
// [br][br] A key is loaded by writing the key into 'Key' (KEY /
// KEY_TOP) and loading its 1s compliment in KeyInvert (KEY_INVERT /
// KEY_TOP_INVERT). Writing both 'Key' and 'KeyInvert' with 1 on same
// bit in both fields will invalidate the entry while writing 0 on same
// bit in both field is equivalent of ignoring this bit in the seach.
// [br][br] The table below shows the encoded data value stored
// (Content) based on the Key and KeyInvert values. [code]
// +-----------------------------------------------------+ | KeyInvert |
// Key | Content |
// ======================================================= | 0 | 0 | X
// (always match) |
// +-----------------------------------------------------+ | 0 | 1 | 1 |
// +-----------------------------------------------------+ | 1 | 0 | 0
// | +-----------------------------------------------------+ | 1 | 1 |
// Always mismatch state |
// +-----------------------------------------------------+ [/code] The
// highest index has precedence in case there is more than one match in
// the same slice.
typedef union {
    struct {
        uint128_t  KEY                  :  32;    // 
        uint128_t  KEY_TOP              :   8;    // 
        uint128_t  _RSVD0_              :  24;    // 
        uint128_t  KEY_INVERT           :  32;    // 
        uint128_t  KEY_TOP_INVERT       :   8;    // 
        uint128_t  _RSVD1_              :  24;    // 

    }                                field;
    uint128_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_SIZE 128
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_BITFIELD_COUNT 0x06
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_RESET 0xffffffffff

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_MSB 0x001f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_RANGE 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_MASK 0xffffffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_RESET_VALUE 0xffffffff

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_LSB 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_MSB 0x0027
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_RANGE 0x0008
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_MASK 0xff00000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_RESET_VALUE 0x000000ff

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD0__LSB 0x0028
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD0__MSB 0x003f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD0__RANGE 0x0018
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD0__MASK 0xffffff0000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD0__RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_INVERT_LSB 0x0040
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_INVERT_MSB 0x005f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_INVERT_RANGE 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_INVERT_MASK 0xffffffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_INVERT_RESET_VALUE 0xffffffff

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_INVERT_LSB 0x0060
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_INVERT_MSB 0x0067
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_INVERT_RANGE 0x0008
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_INVERT_MASK 0xff00000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_KEY_TOP_INVERT_RESET_VALUE 0x000000ff

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD1__LSB 0x0068
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD1__MSB 0x007f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD1__RANGE 0x0018
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD1__MASK 0xffffff0000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM__RSVD1__RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_FLAG
// WCM_ACTION desc: 
typedef union {
    struct {
        uint64_t  ACTION0              :  32;    // 
        uint64_t  ACTION1              :  32;    // 

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_SIZE 64
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_BITFIELD_COUNT 0x02
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_RESET 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION0_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION0_MSB 0x001f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION0_RANGE 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION0_MASK 0xffffffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION1_LSB 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION1_MSB 0x003f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION1_RANGE 0x0020
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION1_MASK 0xffffffff00000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_ACTION1_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_FLAG
// WCM_TCAM_CFG desc:  Configure each slice behavior for each packet profile. This
// register is indexed first by slice, then by packet profile. It
// provides configuration for the cascading and mux selection.
typedef union {
    struct {
        uint64_t  SELECT3              :   7;    //  Selects byte 3 of the lookup
                                                 // key. [list] [*] If Select3
                                                 // is in the range of 0-31, then
                                                 // the value is
                                                 // KEY16[Select3][15:8]. [*] If
                                                 // Select3 is in the range of
                                                 // 32-95, then the value is
                                                 // KEY8[Select3 - 32]. [*] If
                                                 // Select3 is in the range of
                                                 // 96-111, then the value is
                                                 // KEY32[Select3 - 96][31:24].
                                                 // [/list]
        uint64_t  SELECT2              :   7;    //  Selects byte 2 of the lookup
                                                 // key. [list] [*] If Select2
                                                 // is in the range of 0-31, then
                                                 // the value is
                                                 // KEY16[Select2][7:0]. [*] If
                                                 // Select2 is in the range of
                                                 // 32-95, then the value is
                                                 // KEY8[Select2 - 32]. [*] If
                                                 // Select2 is in the range of
                                                 // 96-111, then the value is
                                                 // KEY32[Select2 - 96][23:16].
                                                 // [/list]
        uint64_t  SELECT1              :   7;    //  Selects byte 1 of the lookup
                                                 // key. [list] [*] If Select1
                                                 // is in the range of 0-31, then
                                                 // the value is
                                                 // KEY16[Select1][15:8]. [*] If
                                                 // Select1 is in the range of
                                                 // 32-95, then the value is
                                                 // KEY8[Select1 - 32]. [*] If
                                                 // Select1 is in the range of
                                                 // 96-111, then the value is
                                                 // KEY32[Select1 - 96][15:8].
                                                 // [/list]
        uint64_t  SELECT0              :   7;    //  Selects byte 0 of the lookup
                                                 // key. [list] [*] If Select0
                                                 // is in the range of 0-31, then
                                                 // the value is
                                                 // KEY16[Select0][7:0]. [*] If
                                                 // Select0 is in the range of
                                                 // 32-95, then the value is
                                                 // KEY8[Select0 - 32]. [*] If
                                                 // Select0 is in the range of
                                                 // 96-111, then the value is
                                                 // KEY32[Select0 - 96][7:0].
                                                 // [/list]
        uint64_t  SELECT_TOP           :   6;    //  Selects KEY8[SelectTop] as
                                                 // the top 8 bits of the lookup
                                                 // key. Only KEY8s can be
                                                 // selected for this field.
        uint64_t  START_SET            :   1;    //  Starts an exclusion set
        uint64_t  START_COMPARE        :   1;    //  Starts a compare cascade
        uint64_t  CHUNK_MASK           :  16;    //  Specifies the validity of
                                                 // 64-rule chunks. ChunkMask[0]
                                                 // enables rules 0..63,
                                                 // ChunkMask[1] enables rules
                                                 // 64..127, etc. Used to create
                                                 // smaller per-profile tables.
        uint64_t  RSVD_0               :  12;    // Nebulon auto filled RSVD [63:52]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SIZE 64
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_BITFIELD_COUNT 0x08
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_RESET 0xffffc00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT3_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT3_MSB 0x0006
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT3_RANGE 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT3_MASK 0x0000007f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT3_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT2_LSB 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT2_MSB 0x000d
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT2_RANGE 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT2_MASK 0x00003f80
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT2_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT1_LSB 0x000e
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT1_MSB 0x0014
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT1_RANGE 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT1_MASK 0x001fc000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT1_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT0_LSB 0x0015
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT0_MSB 0x001b
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT0_RANGE 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT0_MASK 0x0fe00000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT0_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT_TOP_LSB 0x001c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT_TOP_MSB 0x0021
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT_TOP_RANGE 0x0006
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT_TOP_MASK 0x3f0000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_SELECT_TOP_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_SET_LSB 0x0022
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_SET_MSB 0x0022
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_SET_RANGE 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_SET_MASK 0x400000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_SET_RESET_VALUE 0x00000001

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_COMPARE_LSB 0x0023
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_COMPARE_MSB 0x0023
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_COMPARE_RANGE 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_COMPARE_MASK 0x800000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_START_COMPARE_RESET_VALUE 0x00000001

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_CHUNK_MASK_LSB 0x0024
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_CHUNK_MASK_MSB 0x0033
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_CHUNK_MASK_RANGE 0x0010
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_CHUNK_MASK_MASK 0xffff000000000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_CHUNK_MASK_RESET_VALUE 0x0000ffff


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_FLAG
// WCM_ACTION_CFG_EN desc:  This register is indexed by packet profile.
typedef union {
    struct {
        uint64_t  ENABLE               :  24;    //  Bit N enables the Nth action
                                                 // RAM bank.
        uint64_t  RSVD_0               :  40;    // Nebulon auto filled RSVD [63:24]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_SIZE 64
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_RESET 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_ENABLE_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_ENABLE_MSB 0x0017
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_ENABLE_RANGE 0x0018
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_ENABLE_MASK 0x00ffffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_ENABLE_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_FLAG
// IDX desc:  This register is indexed by packet profile.
typedef union {
    struct {
        uint64_t  INDEX                :  60;    //  Select which TCAM slice
                                                 // controls Nth action RAM bank.
                                                 // The field contains 12 5-b
                                                 // quantities denoting the TCAM
                                                 // slice for the Nth bank in the
                                                 // bits [ 5*N :+ 5]
                                                 // (little-endian order).
        uint64_t  RSVD_0               :   4;    // Nebulon auto filled RSVD [63:60]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_SIZE 64
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_BITFIELD_COUNT 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_RESET 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_INDEX_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_INDEX_MSB 0x003b
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_INDEX_RANGE 0x003c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_INDEX_MASK 0xfffffffffffffff
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_INDEX_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FLAG
// WCM_IP desc:  WCM Interrupt Pending Register
typedef union {
    struct {
        uint64_t  FCMN_SHELL_CTRL_ERR  :   1;    //  Interrupt pending bit, for
                                                 // error set in FCMN_SHELL_CTL
                                                 // register.
        uint64_t  TCAM_SWEEP_ERR       :   1;    //  Interrupt pending bit, for
                                                 // error set in
                                                 // WCM_SWEEPER/WCM_SWEEP_ERR
                                                 // register.
        uint64_t  FGRP_ERR             :   3;    //  Interrupt pending bits, for
                                                 // errors set in
                                                 // FGRP_SHELL_CTL[0..2] registers
        uint64_t  FGHASH_ERR           :   3;    //  Interrupt pending bits, for
                                                 // errors set in
                                                 // FGHASH_SHELL_CTL[0..2]
                                                 // registers
        uint64_t  HASH_ENTRY_RAM_U_ERR :   4;    //  Interrupt pending bits, for
                                                 // uncorrectable errors set in
                                                 // HASH_ENTRY_RAM[0..1][0..1]
                                                 // registers
        uint64_t  HASH_ENTRY_RAM_C_ERR :   4;    //  Interrupt pending bits, for
                                                 // correctable errors set in
                                                 // HASH_ENTRY_RAM[0..1][0..1]
                                                 // registers
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_OFFSET 0x00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_SIZE 64
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_BITFIELD_COUNT 0x06
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_RESET 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FCMN_SHELL_CTRL_ERR_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FCMN_SHELL_CTRL_ERR_MSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FCMN_SHELL_CTRL_ERR_RANGE 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FCMN_SHELL_CTRL_ERR_MASK 0x00000001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FCMN_SHELL_CTRL_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_TCAM_SWEEP_ERR_LSB 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_TCAM_SWEEP_ERR_MSB 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_TCAM_SWEEP_ERR_RANGE 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_TCAM_SWEEP_ERR_MASK 0x00000002
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_TCAM_SWEEP_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGRP_ERR_LSB 0x0002
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGRP_ERR_MSB 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGRP_ERR_RANGE 0x0003
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGRP_ERR_MASK 0x0000001c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGRP_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGHASH_ERR_LSB 0x0005
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGHASH_ERR_MSB 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGHASH_ERR_RANGE 0x0003
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGHASH_ERR_MASK 0x000000e0
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_FGHASH_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_U_ERR_LSB 0x0008
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_U_ERR_MSB 0x000b
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_U_ERR_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_U_ERR_MASK 0x00000f00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_U_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_C_ERR_LSB 0x000c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_C_ERR_MSB 0x000f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_C_ERR_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_C_ERR_MASK 0x0000f000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_HASH_ENTRY_RAM_C_ERR_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

#ifndef MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FLAG
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FLAG
// WCM_IM desc:  Selects WCM Interrupt Mask Bits
typedef union {
    struct {
        uint64_t  FCMN_SHELL_CTRL_ERR  :   1;    //  Interrupt mask bit, for
                                                 // error set in FCMN_SHELL_CTL
                                                 // register.
        uint64_t  TCAM_SWEEP_ERR       :   1;    //  Interrupt mask bit, for
                                                 // error set in
                                                 // WCM_SWEEPER/WCM_SWEEP_ERR
                                                 // register.
        uint64_t  FGRP_ERR             :   3;    //  Interrupt mask bits, for
                                                 // errors set in
                                                 // FGRP_SHELL_CTL[0..2] registers
        uint64_t  FGHASH_ERR           :   3;    //  Interrupt mask bits, for
                                                 // errors set in
                                                 // FGHASH_SHELL_CTL[0..2]
                                                 // registers
        uint64_t  HASH_ENTRY_RAM_U_ERR :   4;    //  Interrupt mask bits, for
                                                 // uncorrectable errors set in
                                                 // HASH_ENTRY_RAM[0..1][0..1]
                                                 // registers
        uint64_t  HASH_ENTRY_RAM_C_ERR :   4;    //  Interrupt mask bits, for
                                                 // correctable errors set in
                                                 // HASH_ENTRY_RAM[0..1][0..1]
                                                 // registers
        uint64_t  RSVD_0               :  48;    // Nebulon auto filled RSVD [63:16]

    }                                field;
    uint64_t                         val;
} MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_t;
#endif
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_OFFSET 0x08
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_SCOPE 0x01
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_SIZE 64
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_BITFIELD_COUNT 0x06
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_RESET 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FCMN_SHELL_CTRL_ERR_LSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FCMN_SHELL_CTRL_ERR_MSB 0x0000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FCMN_SHELL_CTRL_ERR_RANGE 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FCMN_SHELL_CTRL_ERR_MASK 0x00000001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FCMN_SHELL_CTRL_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_TCAM_SWEEP_ERR_LSB 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_TCAM_SWEEP_ERR_MSB 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_TCAM_SWEEP_ERR_RANGE 0x0001
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_TCAM_SWEEP_ERR_MASK 0x00000002
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_TCAM_SWEEP_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGRP_ERR_LSB 0x0002
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGRP_ERR_MSB 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGRP_ERR_RANGE 0x0003
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGRP_ERR_MASK 0x0000001c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGRP_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGHASH_ERR_LSB 0x0005
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGHASH_ERR_MSB 0x0007
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGHASH_ERR_RANGE 0x0003
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGHASH_ERR_MASK 0x000000e0
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_FGHASH_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_U_ERR_LSB 0x0008
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_U_ERR_MSB 0x000b
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_U_ERR_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_U_ERR_MASK 0x00000f00
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_U_ERR_RESET_VALUE 0x00000000

#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_C_ERR_LSB 0x000c
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_C_ERR_MSB 0x000f
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_C_ERR_RANGE 0x0004
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_C_ERR_MASK 0x0000f000
#define MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_HASH_ENTRY_RAM_C_ERR_RESET_VALUE 0x00000000


// --------------------------------------------------------------------------------------------------------------------------------

// starting the array instantiation section
typedef struct {
    MBY_PPE_CGRP_B_NESTED_MAP_MSG_EM_HASH_LOOKUP_t EM_HASH_LOOKUP[8192]; // offset 4'h0, width 128
    uint8_t                    rsvd0[393216];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_t WCM_TCAM[1024];   // offset 4'h0, width 128
    } WCM_TCAM[20];                              // offset 20'h80000, size: 16384
    uint8_t                    rsvd1[196608];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_t WCM_ACTION[1024]; // offset 4'h0, width 64
    } WCM_ACTION[24];                            // offset 24'h100000, size: 8192
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_TCAM_CFG_t WCM_TCAM_CFG[64]; // offset 4'h0, width 64
    } WCM_TCAM_CFG[20];                          // offset 24'h130000, size: 512
    MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_ACTION_CFG_EN_t WCM_ACTION_CFG_EN[64]; // offset 24'h132800, width 64
    uint8_t                    rsvd2[512];
    // starting the regfile section
    struct {
        MBY_PPE_CGRP_B_NESTED_MAP_MSG_IDX_t IDX[2];           // offset 4'h0, width 64
    } WCM_ACTION_CFG[64];                        // offset 24'h132C00, size: 16
    MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IP_t WCM_IP;           // offset 24'h133000, width 64
    MBY_PPE_CGRP_B_NESTED_MAP_MSG_WCM_IM_t WCM_IM;           // offset 24'h133008, width 64
} mby_ppe_cgrp_b_nested_map_t;                   // size:  24'h133010


#endif // _MBY_PPE_CGRP_B_NESTED_MAP_REGS_H_


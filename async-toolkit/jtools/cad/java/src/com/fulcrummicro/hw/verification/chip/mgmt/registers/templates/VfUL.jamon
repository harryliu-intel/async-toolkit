<%doc>
INTEL TOP SECRET
Copyright 2013 - 2014 Intel Corporation
All Rights Reserved.
</%doc>
<%extends /com/fulcrummicro/util/jamon/timestamp>
<%import>
java.util.Collection;
java.util.Iterator;
com.fulcrummicro.util.misc.Utility;
com.fulcrummicro.hw.verification.chip.mgmt.registers.Register;
com.fulcrummicro.hw.verification.chip.mgmt.registers.RegisterBase;
com.fulcrummicro.hw.verification.chip.mgmt.registers.RegisterField;
com.fulcrummicro.hw.verification.lib.constants.ConstantsEnum;
com.fulcrummicro.hw.verification.lib.constants.ConstantsEnumValue;
</%import>
<%doc>


</%doc>
<%def __decl>
<%args>
String keyword = null;
String name;
String suffix = null;
int w = __DECL_DEFAULT_WIDTH;
</%args>
<%java>
StringBuilder decl = new StringBuilder();
if (keyword != null) {
    decl.append(keyword);
    decl.append(" ");
}
decl.append(prefix.toUpperCase());
decl.append(name);
if (suffix != null) {
    decl.append(suffix);
}
</%java>
<% String.format(String.format("%%-%ds", w), decl.toString()) %>\
</%def>
<%doc>


</%doc>
<%def __enum>
<%args>
ConstantsEnum e;
</%args>
<%java>
Iterator<ConstantsEnumValue> it = e.values.iterator();
int n = e.values.size();
</%java>
typedef enum logic [<% e.getSize() - 1 %>:0]
{
<%for int i = 1; i <= n; i++ %>\
<%java>
ConstantsEnumValue c = it.next();
</%java>
<& __decl; keyword = "    "; name = c.getVerilogName().toUpperCase(); w = __DECL_ENUM_WIDTH &> = \
<% String.format("%5s", c.getVerilogEncoding()) %><%if i < n %>,</%if>
</%for>\

} <% prefix.toLowerCase() %><% Utility.setFirstLetterCase(e.getName(), false) %>;
</%def>
<%doc>


</%doc>
<%def __init>
<%args>
Register r;
</%args>
<%java>
Collection<RegisterField> fields = r.getSortedFields(false, true, false, false);
String func = Utility.underscoreToCamelCase(prefix.toLowerCase().concat("init_").concat(r.getName()), false);
</%java>
function void <% func %> (inout [<% r.getNumberFieldBits() - 1 %>:0] io_data, input string i_datfile);
    logic [32*<% prefix.concat(r.getRegisterBase().getName()).concat("_MAX_WIDTH").toUpperCase() %>-1:0] value;
    integer code;
    integer fd;
    integer line;
    string  buffer;
    string  error;
    string  key;
begin
    fd = $fopen(i_datfile, "r");
    if (fd == 0)
    begin
        void'($ferror(fd, error));
        $display("%m: %s: I/O error: %s", i_datfile, error);
        $finish(1);
    end
    for (line = 0; ; line++)
    begin
        code = $fgets(buffer, fd);
        if (code == 0)
        begin
            if ($feof(fd) != 0)
            begin
                break;
            end
            else
            begin
                void'($ferror(fd, error));
                $display("%m: %s:%d: I/O error: %s", i_datfile, line, error);
                $finish(1);
            end
        end
        if (buffer.getc(0) == "#")
        begin
            // Do not process comments.
            continue;
        end
        code = $sscanf(buffer, "%s %x", key, value);
        if (code == 0)
        begin
            void'($ferror(fd, error));
            $display("%m: %s:%d: parse error: %s", i_datfile, line, error);
            $finish(1);
        end
<%java>
Iterator<RegisterField> it = fields.iterator();
</%java>
<%for int i = 0; it.hasNext(); i++ %>\
<%java>
RegisterField f = it.next();
</%java>
<%if i == 0 %>\
        if\
<%else>\
        else if\
</%if> (key == "<% r.getName() %>.<% f.desc %>")
        begin
            io_data[<% f.pos + f.len - 1 %>:<% f.pos %>] = value[<% f.len - 1 %>:0];
        end
</%for>\
    end
    $fclose(fd);
end
endfunction : <% func %>
</%def>
<%doc>


</%doc>
<%def __regflds>
<%args>
Register r;
</%args>
<%java>
Collection<RegisterField> fields = r.getSortedFields(false, true, false, false);
</%java>
<%if fields == null %>
<%java>throw new Error(r.getName() + " contains overlapping fields");</%java>
</%if>\
<%for RegisterField f : fields %>\
<%if f.len == 1 %>\
<& __decl; keyword = "localparam"; name = r.getName(); suffix = "_b_" + f.desc &> = \
<% f.pos %>;
<%else>\
<& __decl; keyword = "localparam"; name = r.getName(); suffix = "_l_" + f.desc &> = \
<% f.pos %>;
<& __decl; keyword = "localparam"; name = r.getName(); suffix = "_h_" + f.desc &> = \
<% f.pos + (f.entries * f.len) - 1 %>;
<%if f.entries > 1 %>\
<& __decl; keyword = "localparam"; name = r.getName(); suffix = "_s_" + f.desc &> = \
<% f.len %>;
</%if>\
</%if>\
</%for>\
</%def>
<%doc>


/******************************************************************************/
/** __strfaddr
 *
 * \desc            Converts the supplied register address or offset to its
 *                  hexadecimal string representation. Emits the result.
 *
 * \param[in]       addr is the register address or offset.
 *
 ******************************************************************************/
</%doc>
<%def __strfaddr>
<%args>
int addr;
</%args>
<& __xdisplay; i = addr; w = addrBits &>\
</%def>
<%doc>


</%doc>
<%def __struct>
<%args>
Register r;
</%args>
<%java>
Collection<RegisterField> fields = r.getSortedFields(false, true, true, true);
</%java>
<%if fields == null %>\
<%java>throw new Error(r.getName() + " contains overlapping fields");</%java>
</%if>\
typedef struct packed
{
<%for RegisterField f : fields %>\
    logic <%if f.entries > 1 %>[<% f.entries - 1 %>:<% f.baseEntry %>]</%if>\
[<% f.len - 1 %>:0] <% f.desc %>;
</%for>\

} <% prefix.toLowerCase() %><% Utility.underscoreToCamelCase(r.getName(), false) %>;
</%def>
<%doc>


/******************************************************************************/
/** __xdisplay
 *
 * \desc            Converts the supplied integer value to its hexadecimal
 *                  string representation. Emits the result.
 *
 * \param[in]       i is the integer value to convert.
 *
 * \param[in]       w is the minimum number of bits to display.
 *
 ******************************************************************************/
</%doc>
<%def __xdisplay>
<%args>
Number i;
int w;
</%args>
<%java>
int nibbles = (int) Math.ceil(w / 4.0);
</%java>
<% String.format(String.format("%%d'h%%0%dX", nibbles), w, i) %>\
</%def>
<%doc>

/******************************************************************************
 * Main Template
/******************************************************************************

</%doc>
<%args>
String output;
Collection<RegisterBase> bases;
Collection<Register> regs;
String prefix;
int addrBits = 24;
</%args>
<%class>
static int ndims(Register r) {
    return r.getNumDimensions() == 1 && r.getNumEntries() == 1 ?
           0 :
           r.getNumDimensions();
}
static int __DECL_DEFAULT_WIDTH = 70;
static int __DECL_ENUM_WIDTH = 60;
static int __DECL_BASE_WIDTH = 40;
</%class>
<%java>
String guard = "__".concat(prefix).concat(output).replaceAll("\\.", "_").toUpperCase();
String pakkage = prefix.concat("registers_pkg").toLowerCase();
</%java>
/**
 * INTEL TOP SECRET
 * Copyright <& copyright_year; creationYear = 2013 &> Intel Corporation
 * All Rights Reserved.
 *
 * THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.
 * Last Updated <& timestamp; &>
 */

`ifndef <% guard %>
`define <% guard %>

package <% pakkage %>;

/******************************************************************************
 * Utility Parameters & Macros
 ******************************************************************************/

<& __decl; keyword = "localparam"; name = "ADDR_BITS"; w = __DECL_BASE_WIDTH &> = \
<% addrBits %>;

`define <% prefix.toUpperCase() %>GET_BIT(rvalue, csr, field)                 \\

    rvalue[csr``_b_``field]
`define <% prefix.toUpperCase() %>GET_FIELD(rvalue, csr, field)               \\

    rvalue[csr``_h_``field:csr``_l_``field]
`define <% prefix.toUpperCase() %>SET_BIT(lvalue, csr, field, rvalue)         \\

    lvalue[csr``_b_``field] = rvalue
`define <% prefix.toUpperCase() %>SET_FIELD(lvalue, csr, field, rvalue)       \\

    lvalue[csr``_h_``field:csr``_l_``field] = rvalue

/******************************************************************************
 * Register Base Parameters, Macros & Types
 ******************************************************************************/

<%for RegisterBase b : bases %>\
<%java>RegisterBase parent = b.getParent();</%java>
<& __decl; keyword = "localparam"; name = b.getFullName(); w = __DECL_BASE_WIDTH &> = \
<& __strfaddr; addr = b.getIncrementalAddress() &>\
<%if parent.getParent() != null %>+ <% prefix.concat(parent.getFullName()).toUpperCase() %></%if>;
<%doc>Compute the maximum entry width for this register base.</%doc>
<%java>
int w = Integer.MIN_VALUE;
for (Register r : b.getRegisters()) {
    w = Math.max(w, r.getEntryWidth());
}
</%java>
<& __decl; keyword = "localparam"; name = b.getName().toUpperCase(); suffix = "_MAX_WIDTH"; w = __DECL_BASE_WIDTH &> = \
<& __xdisplay; i = w; w = 32 &>;

<%for ConstantsEnum e : b.getEnums() %>\
<& __enum; e = e &>
</%for>\
</%for>\

/******************************************************************************
 * Register Parameters & Macros
 ******************************************************************************/

<%for Register r : regs %>\
<%java>
int nDims = ndims(r);
boolean w = r.getEntryWidth() > 1;
</%java>
<%doc>Emit the register default parameter.</%doc>
<& __decl; keyword = "localparam"; name = r.getName(); suffix = "_DEFAULT" &> = \
<& __xdisplay; i = r.getDefault(0); w = r.getNumberFieldBits() &>;
<%doc>Emit the register entry width parameter.</%doc>
<& __decl; keyword = "localparam"; name = r.getName(); suffix = "_WIDTH" &> = \
<% r.getEntryWidth() %>;
<%doc>Emit the register address macro.</%doc>
<%if nDims == 0 %>\
<& __decl; keyword = "`define"; name = r.getName(); suffix = w ? "(word)" : "()" &> (\
<%elseif nDims == 1 %>\
<& __decl; keyword = "`define"; name = r.getName(); suffix = w ? "(index, word)" : "(index)" &> (\
(<& __strfaddr; addr = r.getEntrySpace() &>) * ((index) - <% r.getBaseEntry() %>) + \
<%elseif nDims == 2 %>\
<& __decl; keyword = "`define"; name = r.getName(); suffix = w ? "(index1, index0, word)" : "(index1, index0)" &> (\
(<& __strfaddr; addr = r.getEntrySpace1() &>) * ((index1) - <% r.getBaseEntry1() %>) + \
(<& __strfaddr; addr = r.getEntrySpace() &>) * ((index0) - <% r.getBaseEntry() %>) + \
<%elseif nDims == 3 %>\
<& __decl; keyword = "`define"; name = r.getName(); suffix = w ? "(index2, index1, index0, word)" : "(index2, index1, index0)" &> (\
(<& __strfaddr; addr = r.getEntrySpace2() &>) * ((index2) - <% r.getBaseEntry2() %>) + \
(<& __strfaddr; addr = r.getEntrySpace1() &>) * ((index1) - <% r.getBaseEntry1() %>) + \
(<& __strfaddr; addr = r.getEntrySpace() &>) * ((index0) - <% r.getBaseEntry() %>) + \
<%else>\
<%java>throw new Error(nDims + "-dimensional registers not supported");</%java>\
</%if>\
<%if w %>(word) + </%if>\
(<& __strfaddr; addr = r.getAddressOffset() &>) + \
(<% prefix.toUpperCase() + r.getBaseName() %>))

</%for>\

/******************************************************************************
 * Register Field Parameters
 ******************************************************************************/

<%for Register r : regs %>\
<& __regflds; r = r &>
</%for>\

/******************************************************************************
 * Register Types & Functions
 ******************************************************************************/

<%for Register r : regs %>\
<& __struct; r = r &>
<& __init; r = r &>
</%for>\
endpackage : <% pakkage %>

`endif  /* <% guard %> */

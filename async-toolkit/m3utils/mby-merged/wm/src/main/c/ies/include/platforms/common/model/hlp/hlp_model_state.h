/* vim:et:sw=4:ts=4:sw=4:tw=80:
 * (No tabs, indent level is 4 spaces)  */
/*****************************************************************************
 * File:            hlp_model_state.h
 * Creation Date:   August  7, 2012
 * Description:     HLP white model packet state data structure.
 *
 *                  DO NOT MODIFY THIS FILE - IT IS AUTOMATICALLY GENERATED
 *                  FROM hlp/hlp_state.tt.
 *
 * INTEL CONFIDENTIAL
 * Copyright 2012 - 2017 Intel Corporation. All Rights Reserved.
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material may
 * be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other intellectual
 * property right is granted to or conferred upon you by disclosure or
 * delivery of the Materials, either expressly, by implication, inducement,
 * estoppel or otherwise. Any license under such intellectual property rights
 * must be express and approved by Intel in writing.
 *****************************************************************************/

#ifndef __HLP_MODEL_STATE_H
#define __HLP_MODEL_STATE_H

typedef struct _hlp_modelState
{
    /* The ingress packet data. */
    fm_byte *               RX_DATA;

    /* The sideband data. */
    fm_modelSidebandData *  SB_DATA;

    /* The ingress packet data length in units of bytes. */
    fm_uint32               RX_LENGTH;

    /* The ingress port. */
    fm_int                  RX_PORT;

    /* Packet Meta Data. */
    fm_byte                 PKT_META[32];

    /* Packet Egress Meta Data. */
    fm_byte                 TX_PKT_META[32];

    /* Set on last segment of each ingress packet. */
    fm_bool                 RX_EOP;

    /* Set on first segment of each ingress packet. */
    fm_bool                 RX_SOP;

    /* The 4-bit set of RX EPL flags. Bits [7:3] are reserved and always
     * set to zero. For bits [2:0] see also ''hlp_modelRxFlags''. */
    fm_byte                 RX_FLAGS;

    /* Pkt Seg Meta Err. Valid on EOP. */
    fm_bool                 SEG_META_ERR;

    /* Pre-IPP Packet Meta Data. */
    fm_byte                 PARSER_PKT_META[32];

    /* Adjusted segment length. */
    fm_uint16               PA_ADJ_SEG_LEN;

    /* 16-bit Parser keys extracted from packet. */
    fm_uint16               PA_KEYS[84];

    /* Boolean valid bits to match Parser keys assigned by extract actions
     * for packet. */
    fm_bool                 PA_KEYS_VALID[84];

    /* Parser flag values assigned per bit by extract actions. */
    fm_bool                 PA_FLAGS[48];

    /* Byte offsets of interest within packet resulting from Parser extract
     * actions. */
    fm_byte                 PA_PTRS[8];

    /* Boolean valid bits to match pointers of interest within packet from
     * Parser extract actions. */
    fm_bool                 PA_PTRS_VALID[8];

    /* Checksum OK result for outer (bit 0) and inner (bit 1) IPv4 headers.
     * */
    fm_byte                 PA_CSUM_OK;

    /* Parser analyzer stage where exception was reached. */
    fm_byte                 PA_EX_STAGE;

    /* Parser stopped: EOS exception and segment was not EOP. */
    fm_bool                 PA_EX_DEPTH_EXCEED;

    /* Parser stopped: EOS exception and segment was EOP. */
    fm_bool                 PA_EX_TRUNC_HEADER;

    /* Parser stopped: Parsing Done exception. */
    fm_bool                 PA_EX_PARSING_DONE;

    /* Checksum validation/computation, force SAF mode in Tail. */
    fm_bool                 PA_FORCE_SAF;

    /* Checksum validation error, drop pkt in Tail. */
    fm_bool                 PA_DROP;

    /* Checksum validation error. */
    fm_bool                 PA_CSUM_ERR;

    /* L3 length error. */
    fm_bool                 PA_L3LEN_ERR;

    /* L4 CSUM related information. */
    fm_uint64               TAIL_CSUM_LEN;

    /* parser_info to be used for modify */
    hlp_modelParserInfo     PARSER_INFO;

    /* Keys to be used for FFU TCAM lookup */
    hlp_modelFfuKeys        FFU_KEYS;

    /* Actions generated by FFU lookup */
    hlp_modelFfuActions     FFU_ACTIONS;

    /* The 6-bit FFU scenario. */
    fm_byte                 FFU_SCENARIO;

    /* The 4-bit FFU vrid. */
    fm_byte                 FFU_VRID;

    /* ip_option to be used for counting trap_ip_iptions */
    fm_bool                 IP_OPTION[2];

    /* The 5-bit FFU priority profile. */
    fm_byte                 PRIORITY_PROFILE;

    /* Mapper decision for using default priority */
    fm_bool                 NO_PRI_ENC;

    /* FFU Group Keys feeding to next group. Per FFU Group data to be used
     * by DV.	*/
    hlp_modelFfuKeys        FFU_GRP_KEYS[HLP_FFU_TCAM_ENTRIES_2-1];

    /* FFU Group Actions going to next group Per FFU Group data to be used
     * DV.  */
    hlp_modelFfuActions     FFU_GRP_ACTIONS[HLP_FFU_TCAM_ENTRIES_2-1];

    /* Fghash Actions going to next group Per Fghash data to be used DV. 
     * */
    hlp_modelFghashActions  FGHASH_ACTIONS[HLP_FFU_HASH_CFG_ENTRIES_1];

    /* The 6-bit FFU scenario to be used by next FFU group. Per FFU Group
     * data to be used by DV.	*/
    fm_byte                 FFU_GRP_SCENARIO[HLP_FFU_TCAM_ENTRIES_2-1];

    /* ECN/SWPRI/TTL01/DSCP and merged VPRI */
    hlp_modelFfuMuxedAction FFU_MUXED_ACTION;

    /* Hash value to be used by ARP_TABLE */
    fm_uint32               ECMP_HASH;

    /* Hash value used by HQM, stored in meta data */
    fm_uint16               HQM_HASH;

    /* Flag to inidcate if hqm_hash to be stored in meta data */
    fm_bool                 HQM_HASH_V;

    /* Combined hash/ffu/ptr metadata for Modify */
    fm_uint64               MOD_META;

    /* Hash value to be used by ARP_TABLE */
    fm_uint64               L34_HASH;

    /* Egress L2 domain */
    fm_uint16               L2_EDOMAIN;

    /* Egress L3 domain */
    fm_byte                 L3_EDOMAIN;

    /* 0 for Shared Vlan Learning (SVL), 1 for Independent Vlan Learning
     * (IVL) */
    fm_bool                 LEARN_MODE;

    /* Index into the MODIFY descriptor tables. */
    fm_uint32               MOD_IDX;

    /* The 16-bit innermost Ethernet type. */
    fm_uint16               L2_ETYPE;

    /* The 4-bit Switch priority. */
    fm_byte                 QOS_SWPRI;

    /* The 16-bit source GLORT. */
    fm_uint16               SGLORT;

    /* The 16-bit ingress destination GLORT. This channel is used
     * throughout the ingress portion of the HLP white model pipeline. See
     * ''EDGLORT'' for the egress destination GLORT. */
    fm_uint16               IDGLORT;

    /* The Layer 2 destination address. */
    fm_macaddr              L2_DMAC;

    /* The Layer 2 source address. */
    fm_macaddr              L2_SMAC;

    /* DMAC embedded in DIP of IPV6 packet. */
    fm_macaddr              DMAC_FROM_IPV6;

    /* Boolean indicating whether the packet is IPv4. */
    fm_bool                 IS_IPV4;

    /* Boolean indicating whether the packet is IPv6. */
    fm_bool                 IS_IPV6;

    /* Flag to indicate presence of IP options */
    fm_bool                 TRAP_IP_OPTIONS;

    /* The 16-bit IPv4 datagram length for outer/inner header depending on
     * ENCAP or DECAP. */
    fm_uint16               L3_LENGTH;

    /* The 16-bit IPv4 datagram length for outer header (including the IPv4
     * header and payload) or 16-bit IPv6 payload length (including any
     * extension headers) in units of octets. */
    fm_uint16               OUTER_L3_LENGTH;

    /* The 16-bit IPv4 datagram length for Inner header (including the IPv4
     * header and payload) or 16-bit IPv6 payload length (including any
     * extension headers) in units of octets. */
    fm_uint16               INNER_L3_LENGTH;

    /* Boolean indicating whether this packet should be dropped becuase TTL
     * is either 0 or 1. */
    fm_bool                 DROP_TTL;

    /* Boolean indicating whether this ICMP packet should be trapped. */
    fm_bool                 TRAP_ICMP;

    /* Boolean indicating whether this IGMP packet should be trapped. */
    fm_bool                 TRAP_IGMP;

    /* Controls update of TTL field of egress packet */
    fm_byte                 TTL_CTRL;

    /* Boolean indicating whether a header parse error has occurred. */
    fm_bool                 PARSER_ERROR;

    /* The 6-bit set of FFU flags. Bits [5:0] contain {CAPTURE-TIME,
     * RX_MIRROR, NO_ROUTE, LOG, TRAP, DROP}. */
    hlp_modelFfuFlags       FFU_FLAGS;

    fm_uint32               FFU_ROUTE;

    /* Boolean indicating no learning. */
    fm_bool                 NO_LEARN;

    /* The 12-bit ingress VLAN ID. This channel is initialized by the FFU
     * and updated by other stages */
    fm_uint16               L2_IVID1;

    fm_byte                 TX_TAG;

    /* The 4-bit QOS VLAN priority. */
    fm_byte                 QOS_L2_VPRI1;

    fm_byte                 FFU_TRIG;

    /* The 6-bit QOS Differentiated Services Code Point. */
    fm_byte                 QOS_L3_DSCP;

    /* The 16-bit Flood GLORT. */
    fm_uint16               FLOOD_GLORT;

    /* Policer action set by FFU to be used policers */
    fm_uint32               POLICER_ACTION[4];

    /* Boolean indicating whether a parity error has been detected in any
     * of the memories while processing this packet. */
    fm_bool                 PARITY_ERROR;

    /* ECN vlaue to use in egress packet */
    fm_byte                 ECN;

    /* AQM_MARK_EN to use in egress packet */
    fm_byte                 AQM_MARK_EN;

    /* VLAN counter index, 12 bits */
    fm_uint16               VLAN_COUNTER;

    /* The Layer 2, 3 & 4 and Layer 3 & 4 hash keys and the associated
     * configuration information. */
    hlp_modelHashKeys       HASH_KEYS;

    /* The 16-entry next hop hash array. Each entry is 4 bits wide. */
    fm_byte                 ARP_HASH[16];

    /* The raw hash value. */
    fm_uint16               RAW_HASH;

    /* The rotation A hash value. */
    fm_uint32               HASH_ROT_A;

    /* The rotation B hash value. */
    fm_uint32               HASH_ROT_B;

    /* Ptable Index used for the rotation A hash value. */
    fm_uint16               HASH_ROT_A_PTABLE_INDEX;

    /* Ptable Index used for the rotation B hash value. */
    fm_uint16               HASH_ROT_B_PTABLE_INDEX;

    /* The 12-bit outer egress VLAN ID. */
    fm_uint16               L2_EVID1;

    fm_bool                 MARK_ROUTED;

    fm_uint16               ARP_TABLE_INDEX;

    fm_byte                 MTU_INDEX;

    fm_bool                 FLOOD_SET;

    /* Ingress L2 domain */
    fm_uint16               L2_IDOMAIN;

    /* Ingress L3 domain */
    fm_byte                 L3_IDOMAIN;

    /* Boolean indicating whether ingress VLAN reflection is enabled. */
    fm_bool                 L2_IVLAN1_REFLECT;

    fm_uint16               L2_IVLAN1_CNT_INDEX;

    /* Boolean indicating whether the ingress port is part of the ingress
     * VLAN. */
    fm_bool                 L2_IVLAN1_MEMBERSHIP;

    /* The 24-bit egress VLAN port membership vector. */
    fm_uint32               L2_EVLAN1_MEMBERSHIP;

    fm_byte                 L2_EVLAN1_TRIG;

    /* Boolean indicating whether this packet violates the MTU. */
    fm_bool                 MTU_VIOLATION;

    /* The 13-bit hash bin index of the destination MAC address lookup
     * result. */
    fm_uint16               DA_INDEX;

    /* The 3-bit hash set of the destination MAC address lookup result. */
    fm_byte                 DA_SET;

    /* Boolean indicating whether the destination MAC address lookup
     * resulted in a hit or miss. */
    fm_bool                 DA_HIT;

    /* The destination MAC address lookup result. */
    hlpMaTable              DA_RESULT;

    /* The 13-bit hash bin index of the source MAC address lookup result.
     * */
    fm_uint16               SA_INDEX;

    /* The 3-bit hash set of the source MAC address lookup result. */
    fm_byte                 SA_SET;

    /* Set by L2Lookup, indicates free index to learn smac into  */
    fm_uint16               FREE_INDEX;

    /* Set by L2Lookup, indicates free set to learn smac into	*/
    fm_byte                 FREE_SET;

    /* Boolean indicating whether the source MAC address lookup resulted in
     * a hit or miss. */
    fm_bool                 SA_HIT;

    /* The source MAC address lookup result. */
    hlpMaTable              SA_RESULT;

    /* The 2-bit spanning tree state for the ingress port. */
    hlp_modelSTPState       L2_IFID1_STATE;

    /* The 24-bit egress forwarding vector. */
    fm_uint32               L2_EFID1_STATE;

    /* Boolean indicating whether glort is forwarded due to FFU rule. */
    fm_bool                 GLORT_FORWARDED;

    /* Boolean indicating whether glort is flood forwarded rule. */
    fm_bool                 FLOOD_FORWARDED;

    fm_byte                 PORT_FIELD_SIZE;

    /* The 16-bit canonical source GLORT. */
    fm_uint16               CSGLORT;

    /* Boolean indicating whether there was an exsting provisional entry
     * related to the port move event. */
    fm_bool                 MOVED_PROV_ENTRY_EXISTED;

    /* Boolean indicating RX_PORT is a secured port. */
    fm_bool                 SECURED_PORT;

    /* Set by L2Lookup indicates existing provisional entry info. */
    fm_uint16               PROV_INDEX;

    /* Set by L2Lookup indicates existing provisional entry info. */
    fm_byte                 PROV_SET;

    /* MAC security violation info. It will set action for tail to update
     * rx_stats. */
    fm_byte                 SV_DROP;

    /* Set by DMAC L2Lookup when hit entry if of entry_type provisional */
    fm_byte                 DROP_PROVISIONAL;

    /* Whether or not DA_LOOKUP is performed. */
    fm_bool                 DA_LOOKUP_PERFORMED;

    /* Boolean indicating whether the GLORT lookup resulted in a miss or
     * hit. */
    fm_bool                 GLORT_CAM_MISS;

    /* The 46-bit action mask. */
    fm_uint64               AMASK;

    /* Boolean indicating that the packet is strict GLORT routed. */
    fm_bool                 STRICT_GLORT_ROUTING;

    /* Boolean indicating that strict mode is set to targeted deterministic
     * */
    fm_bool                 TARGETED_DETERMINISTIC;

    /* The 24-bit GLORT based destination mask. */
    fm_uint32               GLORT_DMASK;

    fm_uint16               IP_MCAST_IDX;

    /* The 6-bit logging action mask. */
    fm_byte                 LOG_AMASK;

    /* The 24-bit destination mask. */
    fm_uint32               DMASK;

    fm_bool                 RX_MIRROR;

    fm_bool                 QCN_MIRROR0_PROFILE_V;

    fm_bool                 QCN_MIRROR1_PROFILE_V;

    fm_bool                 MIRROR1_PROFILE_V;

    fm_int                  MIRROR1_PROFILE_IDX;

    fm_uint32               PRE_RESOLVE_ACTION;

    fm_uint32               PRE_RESOLVE_DMASK;

    fm_uint16               PRE_RESOLVE_DGLORT;

    /* The resolved action. */
    fm_uint32               ACTION;

    /* The 4-bit CPU code which forms the lower 4 bits of the CPU bound
     * destination glort. */
    fm_byte                 CPU_CODE;

    /* The 24-bit normal forwarding mask. */
    fm_uint32               FNMASK;

    /* Boolean indicating that a non-secure MAC was found when source
     * lookup was performed */
    fm_bool                 MAC_MOVED;

    /* Boolean indicating learning enabled status within action codes. */
    fm_bool                 LEARNING_ENABLED;

    /* Boolean that defines current epoch for multicast garbage collection
     * */
    fm_bool                 MCAST_EPOCH;

    /* Class state (Unicast, Broadcast or Multicast) detected in GEN_MASK
     * and available for apply. */
    fm_byte                 FCLASS;

    fm_bool                 LOGGING_HIT;

    /* The mirror0 port. */
    fm_int                  MIRROR0_PORT;

    /* The mirror1 port. */
    fm_int                  MIRROR1_PORT;

    /* Boolean indicates if frame should be sent to CPU */
    fm_bool                 CPU_TRAP;

    /* Boolean indicates if frame should be dropped by policer */
    fm_bool                 POLICER_DROP;

    /* The 4-bit operator_id comes from ONPI metadata. A form of
     * virtualization allowing multiple operators to share the same base
     * station. */
    fm_byte                 OPERATOR_ID;

    /* Boolean indicates if 4bit trap action code will be stored in
     * metadata */
    fm_bool                 STORE_TRAP_ACTION;

    fm_int                  LOG_MIRROR_PROFILE_IDX;

    /* From IPP to MODIFY, indicates ucast, mcast, bcast. */
    fm_byte                 XCAST;

    fm_uint64               TRIG_HIT_MASK_RESOLVED_HI;

    fm_uint64               TRIG_HIT_MASK_RESOLVED_LO;

    fm_byte                 MIRROR0_PROFILE_V;

    fm_int                  MIRROR0_PROFILE_IDX;

    hlp_modelTriggerResults TRIGGERS;

    /* Skip most of modifications in MODIFY. */
    fm_bool                 NO_MODIFY;

    /* S key learning indication for the aging checker (the valid bit). */
    fm_bool                 L2_S_KEY_LEARN;

    /* S key learning index in MA_TABLE is overwritten, for the aging
     * checker. */
    fm_bool                 L2_S_MA_TABLE_OVERWRITE;

    /* S key learning index in MA_TABLE, for the aging checker. */
    fm_int                  L2_S_MA_TABLE_INDEX;

    /* The 3-bit traffic class. */
    fm_byte                 TC;

    /* The 2-bit SMP membership. */
    fm_byte                 SMP_MEMBERSHIP;

    /* The 8-bit vector of TCs to pause */
    fm_byte                 PAUSE_TC_XOFF;

    /* SAF'ed frame has error.. */
    fm_bool                 SAF_ERROR;

    /* ECC error on pm.. */
    fm_bool                 PM_ERR;

    fm_bool                 FSCHED_INIT;

    /* An internal variable used by Fsched to remember which L2 port it's
     * currently servicing */
    fm_uint32               FSCHED_L2_PORTNUM;

    /* An internal variable used by Fsched to compute the index into the
     * MCAST_LEN_TABLE. */
    fm_uint32               FSCHED_LEN_TABLE_OFFSET;

    /* The egress port. */
    fm_int                  TX_PORT;

    /* The 16-bit egress destination GLORT. This channel is used throughout
     * the egress portion of the HLP white model pipeline. See
     * ''ISL_IDGLORT'' for the ingress ISL destination GLORT. */
    fm_uint16               EDGLORT;

    /* Index into the MOD_MCAST_VLAN_TABLE */
    fm_uint16               MOD_IP_MCAST_IDX;

    /* An internal variable used by Fsched to remember that if it has sent
     * the mirror0 copy or not.  */
    fm_bool                 MIRROR0_SENT;

    /* An internal variable used by Fsched to remember that if it has sent
     * the mirror1 copy or not.  */
    fm_bool                 MIRROR1_SENT;

    /* Channel to MODIFY indicating if the frame is a normal frame or which
     * mirror it belongs to */
    hlp_modelMirTyp         MIRTYP;

    /* The 1-bit timeout indicator from ModCtrl.pf */
    fm_byte                 IS_TIMEOUT;

    /* The 4-bit quantized queue level per EWMA, computed from min/max
     * thresholds in sweeper */
    fm_byte                 QEWMA[2];

    /* Queue level over DCTCP threshold, per DCTCP enabled traffic class */
    fm_byte                 DCTCP_MARK;

    /* LFSR value from Checker */
    fm_uint32               LFSR;

    /* The egress packet data length in units of bytes. */
    fm_uint32               TX_LENGTH;

    /* The egress packet data stats length in units of bytes. */
    fm_uint32               TX_STATS_LENGTH;

    /* Byte counts for split CRC when truncation happens. */
    fm_uint32               TX_STATS_LAST_LEN;

    /* The egress packet transmission error reason code. */
    fm_byte                 TX_REASONCODE;

    /* The 4-bit egress frame disposition */
    fm_byte                 TX_DISP;

    /* 1-bit egress drop indicator */
    fm_byte                 TX_DROP;

    /* 1-bit egress drop/truncation indicator */
    fm_byte                 SEG_DROP;

    /* For DV-use only: data from modify stage to modify unit level
     * testbench. */
    fm_byte                 MODIFY_DV_DATA[64];

    /* # of MPLS labels to pop in Modify. */
    fm_byte                 MPLS_POP;

    fm_bool                 ENCAP;

    fm_bool                 DECAP;

    /* Skipping DGLORT lookup for pkt_meta updates. */
    fm_bool                 SKIP_DGLORT_DEC;

    /* IEEE 1588 egress timestamp capture request, valid at SOP. */
    fm_bool                 TS_1588_CAPTURE;

    /* Packet TimeOut Timestamp, valid at SOP. */
    fm_byte                 PTOT;

    /* Number of ports in L2 multicast on this egress tile. */
    fm_byte                 L2_COUNT;

    /* Used to coordinate resets of DRR counters between ESCHED and
     * MONITOR. */
    fm_bool                 DRR_PHASE;

    /* L3 multicast complete. */
    fm_bool                 TX_FREE;

    /* Out Of Memory (addr is NULL). */
    fm_bool                 OOM;

    /* ECC error on pm.. */
    fm_bool                 PM_ERR_NONSOP;

    /* Address in Packet Memory used for reporting in Modify. */
    fm_int                  ADDR;

    /* Holds the physical port number on egress */
    fm_int                  TX_PHYS_PORT;

    /* Flag used to indicate whether the WM function is called from unit
     * level or chained model. */
    fm_bool                 CALLED_FRM_UNIT;

    /* Flag used to disable WM debug dump. */
    fm_bool                 DISABLE_DBG_DUMP;

} hlp_modelState;


#endif  /* __HLP_MODEL_STATE_H */


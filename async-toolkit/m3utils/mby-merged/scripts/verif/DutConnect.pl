#!/usr/intel/bin/perl -w
# This script is to generate DUT signal lists and connections from a top level module

# Note: using die instead of die because die doesn't seem to do anything

use strict;
use Cwd;
use File::Basename;
#$| = 1;

my $aceroot_path = "";
my $file_generated = 0;
my $in_port_list = 0;
my @signal_names;           # names of all of the signals used by project top level
my @wire_definitions;       # wire definitions for all of the signals in @signal_names
my @port_list;              # port list for empty module wrapper
my $module_name = 'dummy_module';
my $instance_name = 'dummy_instance';
my $interface_name = 'dummy_interface';
my $fctop_dut_if = "fctop_dut_if.";
my @files_to_be_compiled = ();

if(@ARGV != 2) {
    die("insufficient arguments\n" .
          helpmsg());
} else {
    $aceroot_path = $ARGV[1];
}
if (not -e $ARGV[0]) {
     die("ERROR: No config file specified\n" .
         "Configuration file should be specified on the command line.\n" .
          helpmsg());
}

my $cmd;
for $cmd (<>) {
    chomp $cmd;
    if($cmd =~ /^\s*#/ or $cmd =~ /^\s*$/) {
        # ignore comment lines or empty lines
    } elsif($cmd =~ /^\s*-*module_name\s+(\w+)\s*$/) {
        $module_name = $1;
    } elsif($cmd =~ /^\s*-*instance_name\s+(\w+)\s*$/) {
        $instance_name = $1;
    } elsif($cmd =~ /^\s*-*interface_name\s+(\w+)\s*$/) {
        $interface_name = $1;
    } elsif($cmd =~ /^\s*-*read_module_file\s+(\S+)\s*$/) {
        eval "read_module_file(\"$1\")";
        die if $@;
    } elsif($cmd =~ /^\s*-*update_file\s+(\S+)\s*$/) {
        eval "update_file(\"$1\")";
        die if $@;
        $file_generated = 1;
    } elsif($cmd =~ /^\s*-*generate_connect_file\s+(\S+)\s*$/) {
        eval "generate_connect_file(\"$1\")";
        die if $@;
        $file_generated = 1;
    } elsif($cmd =~ /^\s*-*generate_interface_file\s+(\S+)\s*$/) {
        eval "generate_interface_file(\"$1\")";
        push(@files_to_be_compiled, $1);
        die if $@;
        $file_generated = 1;
    } elsif($cmd =~ /^\s*-*generate_empty_module_file\s+(\S+)\s*$/) {
        eval "generate_empty_module_file(\"$1\")";
        die if $@;
        $file_generated = 1;
    } elsif($cmd =~ /^\s*-*fctop_dut_if\s+(\S+)\s*$/) {
        die if $@;
        $fctop_dut_if = $1;
        if ($fctop_dut_if =~ /NONE/){
          $fctop_dut_if = "";
        } else { 
          $fctop_dut_if =~ s/(\.|)$/./;
        }
    } elsif ($cmd =~ /^\s*-*generate_hdl_file\s+(\S+)\s*$/) {
        eval "generate_hdl_file(\"$1\")";
    } else {
        die("\nERROR: Unknown command in the config file: $cmd\n\n" . helpmsg());
    }
}

if(not $file_generated) {
    die("\n\nERROR: No output files generated by run\n\n" . helpmsg());
}

sub helpmsg {
    return "Script accepts two arguments: configuration file and path to aceroot
    Commands in the configuration file are executed in order they are read in.
The following commands may be used in the configuration file:
   module_name <name>
   instance_name <name>
   interface_name <name>
   read_module_file <filename>
   update_file <filename>
   generate_connect_file <filename>
   generate_interface_file <filename>
   generate_empty_module_file <filename>
\n";
}

sub read_module_file {
    my $module = shift;
    my $module_filename = "";
    my $module_filepath_fc = $ENV{MODEL_ROOT}."/target/fc/".$module;
    my $module_filepath_dut = $ENV{MODEL_ROOT}."/target/$ENV{SOC_DUT}/".$module;
    if (!-e $module_filepath_fc && !-e $module_filepath_dut) {
      $module_filename = $module_filepath_dut;
    } elsif (!-e $module_filepath_dut) {
      $module_filename = $module_filepath_fc;
    } else {
      $module_filename = $module_filepath_dut;
    }
    
    print "Loading signals from the module file: $module_filename\n";
    open(PROJECT_MODULE, "<$module_filename") or die("ERROR: missing file $module_filename\n");
    while (<PROJECT_MODULE>) {
        if($in_port_list or /endmodule/) {
            push @port_list, $_;
            $in_port_list = 0 if(/\);/);
        } elsif(/module/) {
            push @port_list, $_;
            $in_port_list = 1;
        }
        if (/^\s+input|^\s+output|^\s+inout/) {
            chomp;
            s/^logic\s*//g;
            s/^\s+//g;
            # change to wire
            s/^input/wire/g;
            s/^output/wire/g;
            s/^inout/wire/g;
            s/\s*\,?\s*$//g;
            push @wire_definitions, $_;
            # remove wire type
            s/^wire\s*//g;
            if(/^\S+|^\S+(\[\d+:\d+\])\S+$/) {
                push @signal_names, $_;
            } else {
                die("ERROR: can not understand port name '$_'\n");
            }
        }
    }
    close(PROJECT_MODULE);
}

sub die {
    my $msg = shift;
    print "$msg\n";
    exit;
}

sub gen_signal_list {
    my $wire;
    my $signal_list = "";
    foreach $wire (@wire_definitions) {
        $signal_list .= "    $wire;\n";
    }
    return $signal_list;
}

sub gen_signal_connections {
    my $sig;
    my @signal_connections;
    foreach $sig (@signal_names) {
        $sig =~ s/\[\d+:\d+\]\s+//g;
        my $aligned_sig = $sig;
        while(length $aligned_sig < 32) { $aligned_sig .= " "; }
        push @signal_connections, "    .$aligned_sig ($fctop_dut_if$sig)";
    }
    return join(",\n", @signal_connections) . "\n";
}

sub update_file {
    my $filename = shift;
    $filename = $aceroot_path."/".$filename;
    print "Updating $filename\n";
    open(UPDATE_FILE, "<$filename") or quit $!;
    my @file_input = <UPDATE_FILE>;
    close(UPDATE_FILE);
    open(UPDATE_FILE, ">$filename") or quit $!;

    # Generate connections to DUT

    my $line;
    while($line = shift @file_input) {
        print UPDATE_FILE $line;
        if($line =~ /BEGIN_DUT_SIGNAL_LIST/) {
            # Print connections to DUT
            print UPDATE_FILE gen_signal_list();

            while(not $line =~ /END_DUT_SIGNAL_LIST/) {
                $line = shift @file_input;
            }
            print UPDATE_FILE $line;
        }
        if($line =~ /BEGIN_DUT_CONNECTIONS/) {
            # Print connections to DUT
            print UPDATE_FILE gen_signal_connections();

            while(not $line =~ /END_DUT_CONNECTIONS/) {
                $line = shift @file_input;
            }
            print UPDATE_FILE $line;
        }
    }
    close(UPDATE_FILE);
 
    print "Finished updating $filename\n";
}

sub gen_header {
    my $year = ((split/ /, localtime($^T))[-1]);
    return 
'// -----------------------------------------------------------------------------
// Copyright(C) '.$year.' Intel Corporation, Confidential Information
// -----------------------------------------------------------------------------
//
';
}

sub generate_connect_file {
    my $filename = shift;
    $filename = $aceroot_path."/".$filename;
    print "Updating $filename\n";
    my $dirname = dirname($filename);
    system("mkdir -p $dirname") if (!(-d $dirname));
    open(GEN_FILE, ">$filename") or quit $!;
    print GEN_FILE gen_header();
    print GEN_FILE "// Description:  Connecting DUT to DUT Interface\n";
    print GEN_FILE "//\n\n";
    print GEN_FILE "$module_name $instance_name (\n";
    print GEN_FILE gen_signal_connections();
    print GEN_FILE ");\n";
    close(GEN_FILE);
}

sub generate_interface_file {
    my $filename = shift;
    $filename = $aceroot_path."/".$filename;
    print "Updating $filename\n";
    my $dirname = dirname($filename);
    system("mkdir -p $dirname") if (!(-d $dirname));
    open(GEN_FILE, ">$filename") or quit $!;
    print GEN_FILE gen_header();
    print GEN_FILE "// Description:  Interface object for DUT signals\n";
    print GEN_FILE "//\n\n";
    print GEN_FILE "interface $interface_name;\n";
    print GEN_FILE gen_signal_list();
    print GEN_FILE "endinterface\n";
    close(GEN_FILE);
}

sub generate_empty_module_file {
    my $filename = shift;
    $filename = $aceroot_path."/".$filename;
    print "Updating $filename\n";
    my $dirname = dirname($filename);
    system("mkdir -p $dirname") if (!(-d $dirname));
    open(GEN_FILE, ">$filename") or quit $!;
    print GEN_FILE gen_header();
    print GEN_FILE "// Description:  Empty module wrapper for DUT signals\n";
    print GEN_FILE "//\n\n";
    print GEN_FILE join("", @port_list);
    print GEN_FILE "\n";
    print GEN_FILE "    config pch_cfg;\n";
    print GEN_FILE "        design `TB_TOP_LIB.top;\n";
    print GEN_FILE "    endconfig\n";
    print GEN_FILE "    config pch_realmia_cfg;\n";
    print GEN_FILE "        design `TB_TOP_LIB.top;\n";
    print GEN_FILE "    endconfig\n";
    close(GEN_FILE);
}

sub generate_hdl_file {
    my $filename = shift;
    $filename = $aceroot_path."/".$filename;
    print "Updating $filename\n";
    my $dirname = dirname($filename);
    system("mkdir -p $dirname") if (!(-d $dirname));
    open(GEN_FILE, ">$filename") or quit $!;
    print GEN_FILE "\$hdl_spec = {\n\n";
    print GEN_FILE "    # List of VERILOG source files that belong in this library\n";
    print GEN_FILE "    -vlog_files => [\n";
    foreach my $vfiles (@files_to_be_compiled) {
        print GEN_FILE "        \"$vfiles\",\n";
    }
    print GEN_FILE "    ],\n\n";
    print GEN_FILE "};\n";
    close(GEN_FILE);
}

#!/usr/intel/bin/perl -l
# AAG
# $Id$
# $DateTime$

use strict;
use Getopt::Long;
use CGI qw(:all);

my $cgi=new CGI;
my $iscgi=0;
my $since="0.5";
my $os = "lx24-x86";
my $mode = "x11";
my $loop = 0;
my $smooth=1;
my $transparent=0;

sub usage {
    print STDERR <<EU;
Usage: graph [options] license(s)
    graph grid server usage
    --loop        continuous update
    --mode        x11, png, postscript
    --nosmooth    do not smooth graph
    --os=os       os is one of a (amd), g (glinux), b (both)
    --since=days  start time of graph, days ago
    --transparent for png, transparent background, requires ImageMagick
EU
    exit 1;
}

GetOptions (
    "loop" => \$loop,
    "mode=s" => \$mode,
    "nosmooth" => \$smooth,
    "os=s" => \$os,
    "since=s" => \$since,
    "transparent" => \$transparent,
) or usage;

$|=1;

if (defined ($cgi->request_method)) {
    $loop=0;
    $mode="html";
    $mode = $cgi->param("mode") if defined ($cgi->param("mode"));
    $since = $cgi->param("days") if defined ($cgi->param("days"));
    $os = $cgi->param("os") if defined ($cgi->param("os"));
    $transparent = 1;
    $iscgi=1;
    if ($mode eq "png") {
        print "Content-type: image/png\n";
    }
    else {
        print "Content-type: text/html\n";
        $mode = "html";
    }
}
my $days=180;
if ($since =~ /^y/) {
    $days = 1;
}
elsif ($since =~ /^d/) {
    my @f=split(/=/,$since);
    if (defined ($f[1]) and $f[1] =~ /^\d+/) {
        $days = $f[1];
    }
}
elsif ($since =~ /^\d+/) {
    $days = $since;
}

sub ncmp {
    $a - $b;
}

sub median {
    my ($aa,$ba,$ca) = sort ncmp @_;
    $ba;
}

my $file="/mnt/fulcrum/local/common/logs/qstat/logfile6";
if ($ARGV[0] and -f $ARGV[0] ) {
    $file=$ARGV[0];
}
my $osindex;
my $osindexp0;
my %osindextable = (
    "lx24-x86" => [1,7],
    "g" => [1,7],
    "solaris64" => [3,8],
    "solaris" => [3,8],
    "s" => [3,8],
    "lx24-amd64" => [9,11],
    "opteron" => [9,11],
    "o" => [9,11],
    "a" => [9,11],
    "b" => ["1 9","7 11"],
    "all" => ["1 9","7 11"],
);
my %osname = (
    "a" => "lx24-amd64",
    "o" => "lx24-amd64",
    "l" => "lx24-amd64",
    "g" => "lx24-x86",
    "x" => "lx24-x86",
    "s" => "solaris64",
    "b" => "all",
);

my %os = (
    "lx24-x86" => 1,
    "solaris64" => 1,
    "lx24-amd64" => 1,
    "all" => 1,
);

$os = $osname{$os} if length($os) == 1;
if (!defined ($osindextable{$os})) {
    $os = "lx24-amd64";
}

my @osindex = split(/ /, $osindextable{$os}[0]);
my @osindexp0 = split(/ /, $osindextable{$os}[1]);
my $lpcnt=0;
my $datfile="/tmp/tmpdat$$.dat";
my $xlabel="Date/Time";
$xlabel = "Time" if $days < 2;
my $xfmt = "%m/%y";
$xfmt = "%d.%k" if $days < 60;
$xfmt = "%k" if $days < 2;
$xfmt = "%k:%M" if $days <= 0.51;
my $gnuplot;
$gnuplot="/home/htmldirs/aubrey/internal/cgi-bin/gnuplot";
$gnuplot="gnuplot";
if ($mode eq "x11") {
    open (GNU, "| $gnuplot -title '$os Queue' -persist -noraise");
}
elsif ($mode eq "png") {
    if ($transparent) {
        open (GNU, "| $gnuplot -title Queue | /usr/bin/mogrify -transparent white png:-");
    }
    else {
        open (GNU, "| $gnuplot -title Queue");
    }
}
my %selected;
if ($mode eq "html") {
    undef %selected;
    $selected{$days}=" selected";
    print <<EF;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML><HEAD><TITLE>Queue Graph</TITLE>
<link rel="StyleSheet" href="/fm-basic.css" type="text/css">
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
</HEAD>
<BODY>
<center>
<form method=post action="qstatgraph.pl">
<select name="days">
<option$selected{0.1}>0.1
<option$selected{0.2}>0.2
<option$selected{0.5}>0.5
<option$selected{1}>1
<option$selected{7}>7
</select>
&nbsp;Days<br>
<select name="os">
EF
undef %selected;
$selected{$os}=" selected";
foreach my $osk (sort keys %os) {
    print "<option$selected{$osk}>$osk";
}
print <<EF;
</select> Arch
<br>
<input type=submit name="Draw" value="Draw">
<br>
</form>
<br>
<img src="qstatgraph.pl?os=$os\&days=$since\&mode=png">
</center>
</BODY>
</HTML>
EF
}
else {
    select GNU;
    $|=1;
    my $time=time;
    select STDOUT;
    while (1) {
        $time = time;
        my $date=localtime($time);
        chomp $date;
        $date =~ s/ 20\d\d$//;
        my $sec = $date;
        $sec =~ s/.*://;
        $sec = 65-$sec;
        if ($sec > 60) {
            $sec -= 60;
        }
        if ($days < 180) {
           my $lines = int(($days)*24*60+2);
           open (P, "tail -$lines $file |");
        }
        else {
            open (P, "<$file");
        }
        my $n=0;
        $"=':';
        my $end = undef;
        my $start = undef;
        my @list=();
        while (<P>) {
            chomp;
            my @f=split(/:/);
            if ($n == 0) {
                $start = $f[0];
            }
            $end = $f[0];
            $n++;
            push (@list,"@f");
        }
        close P;
        my $now=time;
        my $delta = $end - $start;
        $"=' ';
        my @a = split(/:/,$list[0]);
        if ( $a[6] > 120 ) { $a[6] = 121;}
        if (! defined ($a[7])) {
            $a[7]=66;
            $a[8]=66;
        }
        my @b = split(/:/,$list[1]);
        if ( $b[6] > 120 ) { $b[6] = 121;}
        if ( $b[6] > 120 ) { $b[6] = 121;}
        if (! defined ($b[7])) {
            $b[7]=66;
            $b[8]=66;
        }
        push (@list, $list[$#list]);
        open (P, ">$datfile");
        my @c;
        my @d=(0,0,0);
        my $first;
        my $firstfmt;
        my $last;
        my $lastfmt;
        my $max=0;
        my $points=$#list;
        my $interval=int($points/1000);
        $interval=1 if $interval == 0;
        my $cnt=0;
        foreach $n (1..$#list-1) {
            $cnt++;
            @c=split(/:/,$list[$n+1]);
    #        $c[0] -= $now/3600;
            if (! defined ($c[7])) {
                $c[7]=66;
                $c[8]=66;
            }
            if ( $c[6] > 120 ) { $c[6] = 121;}
            my @f=@c;
            if ($smooth) {
                foreach my $n (0..$#osindex) {
                    foreach my $x ($osindex[$n], $osindex[$n]+1, 6, $osindexp0[$n]) {
                        $f[$x] = median($b[$x],$a[$x],$c[$x]);
                    }
                }
            }
            if ($days <= 0 or $f[0] >= -(24*$days + 1) ) {
                if ($os =~ /^s/) {
                    $f[7] = $f[8];
                }
                if ( !defined ($first)) { $first=$f[0]; }
                my @lt=localtime($f[0]);
                my $fmt = sprintf "%d/%d/%02d/%02d/%02d/%02d", $lt[4]+1,$lt[3],$lt[5]%100,$lt[2],$lt[1],$lt[0];
                if ( !defined ($firstfmt)) { $firstfmt=$fmt;}
                $last=$f[0];
                $lastfmt = $fmt;
                foreach my $n (0..$#osindex) {
                    $d[0] += $f[$osindex[$n]]*1/$interval;
                    $d[1] += $f[$osindex[$n]+1]*1/$interval;
                    $d[2] += $f[$osindexp0[$n]]*1/$interval;
                }
                $max = $d[2] if $d[2] > $max;
                $max = $d[1] if $d[1] > $max;
                $max = $d[0] if $d[0] > $max;
                if ($cnt == $interval) {
                    print P "$fmt @d";
                    @d=(0,0,0);
                    $cnt=0;
                }
            }
            @a = @b;
            @b = @c;
        }
        close P;
        my $avail = 8;
        $max = 10*(int($max/10))+10;
        if ($lpcnt == 0) {
        print GNU <<EF;
set term $mode
set grid
set title "$os utilization $date"
set xlabel "$xlabel"
set xdata time
set timefmt "%m/%d/%Y/%H/%M/%S"
set format x '$xfmt'
set xrange ["$firstfmt":"$lastfmt"]
set yrange [0:$max]
set ylabel "Jobs"
plot '$datfile' using 1:3 smooth unique title 'Total' w lines 1, '$datfile' using 1:2 smooth unique title 'Running' w lines 6, '$datfile' using 1:4 smooth unique title "Available" w lines 3
EF
        }
        else {
            print GNU "set xrange [\"$firstfmt\":\"$lastfmt\"]";
            print GNU "set title \"$os utilization $date\"";
            print GNU "replot";
        }
        if ( ! $loop ) {
            print GNU "quit";
            close GNU;
            last;
        }
        else {
            sleep $sec;
        }
        $lpcnt++;
    }
    unlink "$datfile";
}

<%extends /com/fulcrummicro/util/jamon/timestamp>
<%import>
java.util.Collection;
com.fulcrummicro.util.misc.Utility;
com.fulcrummicro.hw.verification.chip.mgmt.registers.*;
</%import>\
<%args>
Collection<RegisterCrossbarPort> crossbarPorts;
Collection<RegisterBase> bases;
Collection<Register> regs;
String chip;
</%args>\
// INTEL TOP SECRET
// Copyright <& copyright_year; &> Intel Corporation. All Rights Reserved.
//
// THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY.
// Last Updated <& timestamp &>
//
// Functions defined:
//
<%for RegisterCrossbarPort xbPort : crossbarPorts %>\
<%if xbPort.hasBusStops() %>\
//   <% xbPort.getBusStopCspAttributeName() %>
</%if>\
</%for>\

package register_map_pkg;
  import register_constants_pkg::*;
  import mgmt_constants_pkg::*;
  
  typedef struct packed {
    logic[24-1:0] addr;        // chip addr
    logic[8-1:0]  bus_stop_nr; // target bus stop
    logic[4-1:0]  num_words;   // number of atomic words in this register
                               // otherwise one for non-atomic reg
    logic[4-1:0]  word_nr;     // word offset for current mgmt cycle for atomic reg
                               // otherwise zero for non-atomic reg
  } decoded_register_t;


<%for RegisterCrossbarPort xbPort : crossbarPorts %>\
<%if xbPort.hasBusStops() %>\
<%doc>package <% Utility.camelCaseToUnderscore(xbPort.getBusStopCspRawName()).toLowerCase() %>_pkg;
  import register_map_pkg::*;
  import register_constants_pkg::*;
  import mgmt_constants_pkg::*;
</%doc>\

  function automatic void <% Utility.camelCaseToUnderscore(xbPort.getBusStopCspRawName()).toLowerCase() %>_reg_map (
    input logic [24-1:0]  chip_addr,
    output decoded_register_t dec_reg
  );
    logic[3:0] word;
    word = chip_addr[3:0];

    dec_reg.num_words = 4'd1; // default for registers w/ atomic width 1
    dec_reg.word_nr   = '0; // default for registers w/ atomic width 1
    dec_reg.bus_stop_nr = '0; // need default for invalid range
    dec_reg.addr = chip_addr;
    //assumes all registers aligned to power of 2
    //assumes max atomic width < 4
      
    case(1'b1)
<%doc></%doc><%for RegisterBusStop busStop : xbPort.getBusStops() %>\
<%doc>--</%doc><%for RegisterBase base : busStop.getRegisterBases() %>\
      (chip_addr & <% String.format("24'h%06x", ~(base.getSize() - 1) & 0xffffff) %>) == <% String.format("24'h%06x", base.getAbsoluteAddress()) %>: begin
        // <% base.getFullName() %>
<%doc>----</%doc><%if busStop.getStride() > 0 %>\
        logic[24-1:0] bus_stop_offset;
        bus_stop_offset = (chip_addr - <% base.getFullName() %>) / <% String.format("24'h%x",busStop.getStride()) %>;
        dec_reg.bus_stop_nr = <% busStop.getName() %> + bus_stop_offset[7:0];
<%doc>----</%doc><%else>\
        dec_reg.bus_stop_nr = <% busStop.getName() %>;
<%doc>----</%doc></%if>\
        dec_reg.num_words   = 4'd<% base.getAtomicWidth() %>;
        <& print_atomic_word_nr; atomicWidth=base.getAtomicWidth() &>
      
<%java boolean found=false; %>\
<%doc>----</%doc><%for Register reg : base.getRegisters() %>\
<%if (reg.getAlias() == null) && (reg.getAtomicWidth()!=base.getAtomicWidth())%>\
<%if !found %>\
        case(1'b1)
</%if><%java found=true; %>\
<%doc>Compute the address mask per register</%doc>\
          (( chip_addr & <% String.format("24'h%h", reg.getAddressMatchMask() & 0xffffff) %> ) == <% String.format("24'h%h",reg.getUnitBaseAddress() + reg.getAddressOffset()) %>): begin
<%java
int atomicWidth = reg.getAtomicWidth();
//MGMT_IN address decoding requirements:
//mgmt_in needs a word number in the atomic cache, ideally we take
//address % atomicWidth to get word number, however we want to use bit select
//for optimization
//if bit select is used, then % operator is the same as bit select when
//atomicWidth is a power of 2
//when atomic width is not a power of 2, then the bit select does not work if
//the register length is greater than the atomic width because the upper words
//will not be written
if (!Util.isPowerOf2(atomicWidth)) {
	if (reg.getEntryWidth() > atomicWidth) {
		System.out.printf("ERROR %s reg width = %d > atomic width = %d, upper words inaccessible\n",
			reg.getName(), reg.getEntryWidth(), atomicWidth);
	}
}
if(reg.getAtomicWidth()<base.getAtomicWidth()) {
    System.out.printf("WARNING %s base atomic width = %d > atomic width = %d\n",
                      reg.getName(), base.getAtomicWidth(), atomicWidth);
}
%>\
            dec_reg.num_words   = <% reg.getName() %>_ATOMIC_WIDTH; // <% atomicWidth %>
            <& print_atomic_word_nr; atomicWidth=atomicWidth &>
            <& print_atomic_word_addr; atomicWidth=atomicWidth &>
          end
<%doc>----</%doc></%if></%for><%doc>register</%doc>\
<%if found %>\
          default: begin
            <& print_atomic_word_addr; atomicWidth=base.getAtomicWidth() &>
          end
        endcase
<%elseif base.getAtomicWidth() > 1 %>\
        <& print_atomic_word_addr; atomicWidth=base.getAtomicWidth() &>
</%if>\
      end
<%doc>--</%doc></%for><%doc>register base in bus stop</%doc>\
<%doc></%doc></%for><%doc>bus stop</%doc>\
    endcase
  endfunction
<%doc>endpackage</%doc>


</%if><%doc>has bus stops</%doc>
</%for><%doc>crossbar ports</%doc>
endpackage
<%doc>End Mgmt Linear Bus Decode Function</%doc>
\
\
<%def print_atomic_word_nr>\
<%args>int atomicWidth;</%args>\
<%java
if (atomicWidth > 4) {
	System.out.printf("ERROR register map synth version does not support atomic width=%d > 4\n",atomicWidth);
}
int atomicMask = (1 << Util.log2(atomicWidth)) - 1;
%>\
dec_reg.word_nr     = word & <% String.format("4'h%h",atomicMask) %>;\
</%def>\
\
<%def print_atomic_word_addr>\
<%args>int atomicWidth;</%args>\
<%if atomicWidth > 1 %>\
dec_reg.addr[<% Util.log2(atomicWidth)-1 %>:0]   = '0;\
<%else>\
dec_reg.word_nr     = '0;\
</%if>\
</%def>\


MODULE Main;
IMPORT BDD;
IMPORT Debug;
FROM BDD IMPORT Implies, Not, And, Or, MakeTrue, MakeFalse;
IMPORT LongrealSetDef;
IMPORT RefSeq;
IMPORT CardSeq, CardList, CardBDDTbl;
IMPORT Fmt; 
FROM Fmt IMPORT F;
IMPORT Rd, TextReader, Stdio, Scan, Text;
IMPORT LongRealSeq;
IMPORT Lex, FloatMode;
IMPORT Thread;
IMPORT Wx;
IMPORT BDDSet, BDDSetHash, BDDSetHashRefTbl;
IMPORT BDDIntPairTbl, BDDDepends, IntPair;
IMPORT IntPairBDDTbl;
IMPORT Wr, FileWr;

<*FATAL Thread.Alerted*>

CONST I = Fmt.Int;
      L = Fmt.LongReal;

CONST TE = Text.Equal;

VAR
  N, deltaGapMax, minPortRep     : CARDINAL;
  underrunMax, minRepBits, clock : LONGREAL;

VAR ch    : REF ARRAY OF ARRAY OF BDD.T; 
    (* ch[sp,sl] <=> speed[sp] in slot sl *)
    minct : REF ARRAY OF CARDINAL;
    deps  : REF ARRAY OF ARRAY OF CardList.T;

    ports : REF ARRAY OF LONGREAL;

VAR equations : RefSeq.T;
TYPE Eq = OBJECT label : TEXT; eq : BDD.T END;

VAR eqc := 0;

PROCEDURE Assert(label : TEXT; what : BDD.T) =
  BEGIN
    equations.addhi(NEW(Eq, 
                        label := F("[%s,sz=%s]",I(eqc),I(BDD.Size(what))) & 
                                     label, 
                        eq := what));
    INC(eqc)
  END Assert;

PROCEDURE ClearEquations() =
  BEGIN
    equations := NEW(RefSeq.T).init()
  END ClearEquations;

TYPE 
  Equations = OBJECT
    tbl : CardBDDTbl.T;
    up  : Equations;
  METHODS
    get(idx : CARDINAL) : BDD.T         := EGet;
    init(e : Equations := NIL) : Equations := EInit;
    modify(idx : CARDINAL; to : BDD.T)  := EModify;
  END;

PROCEDURE EGet(e : Equations; idx : CARDINAL) : BDD.T =
  VAR r : BDD.T;
  BEGIN
    IF e.tbl.get(idx, r) THEN
      RETURN r
    ELSIF e.up = NIL THEN 
      RETURN NARROW(equations.get(idx),Eq).eq
    ELSE
      RETURN e.up.get(idx)
    END
  END EGet;

PROCEDURE EInit(e, from : Equations) : Equations =
  BEGIN
    e.tbl := NEW(CardBDDTbl.Default).init(); 
    e.up := from;
    RETURN e
  END EInit;

PROCEDURE EModify(e : Equations; idx : CARDINAL; to : BDD.T) =
  BEGIN
    EVAL e.tbl.put(idx,to)
  END EModify;
  
(**********************************************************************)

PROCEDURE Msg(i : CARDINAL) : TEXT =
  BEGIN RETURN NARROW(equations.get(i),Eq).label END Msg;

PROCEDURE AssertShannon(b, v : BDD.T) =
  VAR
    mf := MakeFalse(b, v);
    mt := MakeTrue (b, v);
    sh := Or(And(v, mt), And(Not(v), mf));
  BEGIN
    <* ASSERT sh = b *>
  END AssertShannon;

PROCEDURE SatisfyAssertions(READONLY ni : ARRAY OF CARDINAL) : BOOLEAN =

  PROCEDURE Recurse(p         : CARDINAL; 
                    e         : Equations) : BOOLEAN =

    VAR f : Equations;
        reason : TEXT;

    PROCEDURE MakeTrue(sp, sl : CARDINAL) : BOOLEAN =
      VAR 
        p := deps[sp,sl];
      BEGIN
        (*
        Debug.Out(F("MakeTrue(%s,%s)", I(sp), I(sl)));
        *)
        WHILE p # NIL DO
          WITH idx = p.head,
               old = f.get(idx),
               new = BDD.MakeTrue(old, ch[sp,sl]) DO
            IF new = BDD.False() THEN 
              (*
              Debug.Out(F("MakeTrue %s,%s FAIL (%s)",I(sp),I(sl),Msg(idx)));
              *)
              reason := NARROW(equations.get(idx),Eq).label;
              RETURN FALSE 
            END;
            IF old # new THEN f.modify(idx, new) END
          END;
          p := p.tail
        END;
        RETURN TRUE
      END MakeTrue;

    PROCEDURE MakeFalse(sp, sl : CARDINAL) : BOOLEAN =
      VAR 
        p := deps[sp,sl];
      BEGIN
        (*
        Debug.Out(F("MakeFalse(%s,%s), ndeps=%s", I(sp), I(sl), I(CardList.Length(p))));
        *)
        WHILE p # NIL DO
          WITH idx = p.head,
               old = f.get(idx),
               new = BDD.MakeFalse(old, ch[sp,sl]),
               msg = NARROW(equations.get(idx),Eq).label DO
            (*Debug.Out(msg);*)
            (*AssertShannon(old, ch[sp,sl]);*)
            IF new = BDD.False() THEN 
              (*
              Debug.Out(F("MakeFalse %s,%s FAIL (%s)",I(sp),I(sl),Msg(idx)));
              Debug.Out("old " & BDD.Format(old));
              Debug.Out("new " & BDD.Format(new));
              *)
              reason := msg ;
              RETURN FALSE 
            END;
            IF old # new THEN f.modify(idx, new) END
          END;
          p := p.tail
        END;
        RETURN TRUE
      END MakeFalse;

    PROCEDURE SetSlot(p  : CARDINAL;
                      sp : [-1..LAST(CARDINAL)]) : BOOLEAN =
      
    PROCEDURE Print(txt : TEXT) =
      BEGIN
        IF printAttempt THEN
          VAR
            wx := Wx.New();
          BEGIN
            Wx.PutInt(wx, attempts);
            Wx.PutText(wx, " : ");
            FOR i := 0 TO p DO
              Wx.PutInt(wx, slots[i]);
              Wx.PutChar(wx, ' ')
            END;
            Wx.PutText(wx, "[slot ");
            Wx.PutInt(wx, p);
            Wx.PutText(wx, "] ");
            Wx.PutText(wx, txt);
            Debug.Out(Wx.ToText(wx))
          END;
          INC(attempts)
        END
      END Print;
        
      VAR
        printAttempt := TRUE;
      BEGIN
        (*
        Debug.Out(F("SetSlot %s -> %s",I(p),I(sp)));
        *)
        slots[p] := sp;

        FOR i := 0 TO NUMBER(ports^)-1 DO
          IF i = sp THEN 
            IF NOT MakeTrue(i,p) THEN 
              Print(reason);
              RETURN FALSE
            END
          ELSE
            IF NOT MakeFalse(i,p) THEN 
              Print(reason);
              RETURN FALSE 
            END
          END
        END;
        (*
        Debug.Out(F("SetSlot %s -> %s SUCCESS",I(p),I(sp)));
        *)
        Print("OK");
        RETURN TRUE
      END SetSlot;

    BEGIN
      IF p = nslots THEN
        Debug.Out("Success!"); 
        RETURN TRUE
      END;

      (* each slot can have NUMBER(ports^)+1 values (idle=-1, plus any port) *)
      FOR incr := 2 TO NUMBER(ports^)+2 DO
        VAR 
          prev, try : [-1..LAST(CARDINAL)];
          cnt := 0;
        BEGIN
          IF p = 0 THEN 
            prev := NUMBER(ports^)-1
          ELSE
            prev := slots[p-1]
          END;

          try := (prev+incr) MOD(NUMBER(ports^)+1) - 1;

          (* we should try "try" *)
          (* but first.. make sure we dont already have too many! *)
          
          FOR i := 0 TO p-1 DO
            IF slots[i] = try THEN INC(cnt) END
          END;

          IF try = -1 AND cnt < n1cnt OR try # -1 AND cnt < ni[try] THEN
            f := NEW(Equations).init(e);
        
            IF SetSlot(p, try) THEN
              IF Recurse(p+1, f) THEN arr[p] := try; RETURN TRUE END
            END
          ELSE
            Debug.Out(F("[skipping %s, already allocated all of it]", I(try)));
          END
        END
      END;
      RETURN FALSE
    END Recurse;

  VAR
    arr, slots := NEW(REF ARRAY OF [-1 ..LAST(CARDINAL)], nslots);
    n1cnt := nslots;

  BEGIN
    FOR i := FIRST(ni) TO LAST(ni) DO
      n1cnt := n1cnt-ni[i]
    END;
    Debug.Out("-1 slots total: " & I(n1cnt));

    FOR i := FIRST(arr^) TO LAST(arr^) DO
      arr[i] := LAST(CARDINAL);
    END;

    WITH done = Recurse(0, NEW(Equations).init()) DO
      IF done THEN
        FOR i := FIRST(arr^) TO LAST(arr^) DO
          Debug.Out(F("slot %s port %s", I(i), I(arr[i])))
        END
      END;
      RETURN done
    END
  END SatisfyAssertions;

(**********************************************************************)

PROCEDURE GapOfLengthAt(sp  : CARDINAL;
                        at  : CARDINAL;
                        len : CARDINAL) : BDD.T =
  VAR 
    x := ch[sp, at];
  BEGIN
    FOR i := 1 TO len-1 DO
      x := And(x, Not(ch[sp, (at+i) MOD nslots]))
    END;
    x := And(x, ch[sp, (at+len) MOD nslots]);
    RETURN x
  END GapOfLengthAt;

VAR gapTbl := NEW(IntPairBDDTbl.Default).init(); (* memoize GapOfLength *)

PROCEDURE GapOfLength(sp : CARDINAL; len : CARDINAL) : BDD.T =
  VAR
    k := IntPair.T { sp, len };
    x : BDD.T;

  BEGIN
    IF gapTbl.get(k, x) THEN 
      RETURN x
    ELSE
      x := BDD.False();
      FOR i := 0 TO nslots-1 DO
        x := Or(x, GapOfLengthAt(sp, i, len))
      END;
      EVAL gapTbl.put(k, x);
      RETURN x
    END
  END GapOfLength;

PROCEDURE NotGapOfLengthAt(sp  : CARDINAL;
                           at  : CARDINAL;
                           len : CARDINAL) : BDD.T =
  VAR 
    x := Not(ch[sp, at]);
  BEGIN
    FOR i := 1 TO len-1 DO
      x := Or(x, ch[sp, (at+i) MOD nslots])
    END;
    x := Or(x, Not(ch[sp, (at+len) MOD nslots]));
    RETURN x
  END NotGapOfLengthAt;

PROCEDURE NotGapOfLength(sp : CARDINAL; len : CARDINAL) : BDD.T =
  VAR
    k := IntPair.T { sp, -1-len };
    x : BDD.T;

  BEGIN
    IF gapTbl.get(k, x) THEN 
      RETURN x
    ELSE
      x := BDD.True();
      FOR i := 0 TO nslots-1 DO
        x := And(x, NotGapOfLengthAt(sp, i, len))
      END;
      EVAL gapTbl.put(k, x);
      RETURN x
    END
  END NotGapOfLength;

PROCEDURE RepTime(bitRate : LONGREAL) : LONGREAL =
  (* given a port running at bitRate b.p.s., what is the minimum
     required repetition time (on average)? 
     
     assumption: it is equal to 84 byte times 
  *)
  BEGIN RETURN minRepBits / bitRate END RepTime;

PROCEDURE AssertNoUnderrun(sp : CARDINAL) =
  BEGIN
    FOR sl := 0 TO nslots - 1 DO
      (* on the assumption that we are allocated to slot "sl", what else can
         we say? *)
      WITH deadlineCyc = RepTime(ports[sp]) * underrunMax * clock DO
        (*
        Debug.Out(F("AssertNoUnderrun(%s) deadline=%s in slot %s", I(sp), L(deadlineCyc), I(sl)));
        *)
        VAR x := BDD.False(); 
        BEGIN
          FOR i := 1 TO FLOOR(deadlineCyc) DO
            (*
            Debug.Out(F("sp=%s might have slots (%s and %s)", 
                        I(sp), I(sl), I((sl+i) MOD nslots)));
             *)
            x := Or(x, ch[sp, (sl+i) MOD nslots])
          END;
          Assert(F("no underrun %s", I(sp)), Implies(ch[sp,sl], x))
        END
      END;

      (* rep rate *)
      FOR i := 1 TO minPortRep-1 DO
        WITH x = Implies(ch[sp,sl], Not(ch[sp,(sl+i) MOD nslots])) DO
          Assert(F("min rep rate (port %s) = %s", I(sp), I(i)), x)
        END
      END
    END
  END AssertNoUnderrun;

PROCEDURE AssertPortAppears(sp : CARDINAL) =
  VAR
    x := BDD.False();
  BEGIN
    FOR sl := 0 TO nslots-1 DO
      x := Or(x, ch[sp,sl])
    END;
    Assert(F("port appears in schedule %s", I(sp)), x)
  END AssertPortAppears;

PROCEDURE AssertNoneInIdleSlot() =
  (* 0 is the idle slot, dont assign me to it *)
  BEGIN
    FOR sp := FIRST(ports^) TO LAST(ports^) DO
      WITH x = Not(ch[sp,0]) DO
        Assert(F("port %s not in idle slot", I(sp)), x)
      END
    END
  END AssertNoneInIdleSlot;

PROCEDURE DoSpeedAssertions(idx : CARDINAL) =
  VAR
    indices := NEW(CardSeq.T).init();
  BEGIN
    FOR j := FIRST(ports^) TO LAST(ports^) DO
      IF ports[j] = ports[idx] THEN
        indices.addhi(j)
      END
    END;

    FOR i := 0 TO indices.size()-1 DO
      FOR j := i TO indices.size()-1 DO
        WITH ii = indices.get(i),
             jj = indices.get(j) DO
          AssertMaxGapDelta(ii, jj, deltaGapMax,
                            givenMin := minGap[ii],
                            givenMax := maxGap[ii])
        END
      END
    END
  END DoSpeedAssertions;

PROCEDURE AssertMaxGapDelta(s0, s1   : CARDINAL;
                            maxDelta : CARDINAL;
                            givenMin, givenMax : LONGREAL) =
  BEGIN
    Debug.Out(F("AssertMaxGapDelta(s0=%s s1=%s maxDelta=%s givenMin=%s givenMax=%s)",
              I(s0), I(s1), I(maxDelta), L(givenMin), L(givenMax)));
    FOR i := CEILING(givenMin) TO FLOOR(givenMax) DO
      FOR j := i+maxDelta+1 TO FLOOR(givenMax) DO
        Assert(F("gap(%s)=%s and gap(%s)=%s ruled out", 
                 I(s0), I(i), I(s1), I(j)),
               Or(NotGapOfLength(s0, i), NotGapOfLength(s1, j)));
        Assert(F("gap(%s)=%s and gap(%s)=%s ruled out", 
                 I(s1), I(i), I(s0), I(j)),
               Or(NotGapOfLength(s1, i), NotGapOfLength(s0, j)))
      END
    END
  END AssertMaxGapDelta;

VAR minGap, maxGap : REF ARRAY OF LONGREAL;

PROCEDURE SlotFree(sl : CARDINAL) : BDD.T =
  VAR
    x := BDD.True();
  BEGIN
    FOR i := 0 TO NUMBER(ports^)-1 DO
      x := And(x, Not(ch[i,sl]))
    END;
    RETURN x
  END SlotFree;

PROCEDURE AssertNotTooManyFree(maxFree : CARDINAL) =
  VAR 
    x := BDD.True();
  BEGIN
    FOR sl := 0 TO maxFree-1 DO
      x := And(x, SlotFree(sl))
    END;
    FOR i := maxFree TO nslots-1 DO
      WITH y = Implies(x, Not(SlotFree(i))) DO
        (*
        Debug.Out(F("maxFree=%s i=%s : %s", I(maxFree), I(i), BDD.Format(y)));
        *)

        Assert(F("at most the first %s slots are free : %s", I(maxFree), I(i)),
               y)
      END
    END
  END AssertNotTooManyFree;

PROCEDURE Attempt(READONLY ni : ARRAY OF CARDINAL) : BOOLEAN =
  (* speed i has ni[i] entries in schedule *)

  VAR
    donePorts := NEW(LongrealSetDef.T).init();
    maxFree := nslots;
  BEGIN

    minGap := NEW(REF ARRAY OF LONGREAL, NUMBER(ni));
    maxGap := NEW(REF ARRAY OF LONGREAL, NUMBER(ni));

    ClearEquations();

    AssertNoneInIdleSlot();

    FOR i := FIRST(ni) TO LAST(ni) DO

      AssertPortAppears(i);

      AssertNoUnderrun(i);

      Debug.Out(F("i=%s ni[i]=%s minct[i]=%s", I(i), I(ni[i]), I(minct[i])));
      <* ASSERT ni[i] >= minct[i] *>
      WITH aveDelta = FLOAT(nslots, LONGREAL) / FLOAT(ni[i],LONGREAL) DO
        minGap[i] := MAX(FLOAT(minPortRep,LONGREAL), 
                         aveDelta - FLOAT(deltaGapMax,LONGREAL));
        maxGap[i] := aveDelta + FLOAT(deltaGapMax,LONGREAL);

        AssertNoSmallerGap         (i, minGap[i]);

        AssertAlwaysExistsSuccessor(i, minGap[i], maxGap[i])
      END;
      maxFree := maxFree - ni[i]
    END;

    Debug.Out("Max free slots allowed: " & I(maxFree));

    AssertNotTooManyFree(maxFree);

    (* scan ports and make cross-port assertions *)
    FOR i := FIRST(ports^) TO LAST(ports^) DO
      WITH thisSpeed = ports[i] DO
        IF NOT donePorts.member(thisSpeed) THEN
          Debug.Out("Doing speed assertions for speed " & L(thisSpeed));
          DoSpeedAssertions(i);
          EVAL donePorts.insert(thisSpeed)
        END
      END
    END;

    (*
    AssertAssignmentsAreExclusive();
    *)

    Debug.Out(F("There are %s unreduced equations", I(equations.size())));

    (* dump equations to disk for reference *)
    VAR 
      wr := FileWr.Open("equations.dat");
    BEGIN
      FOR i := 0 TO equations.size()-1 DO
        WITH eq = NARROW(equations.get(i),Eq) DO
          Wr.PutText(wr, F("%s %s %s\n", I(i), I(BDD.Size(eq.eq)), eq.label))
        END
      END;
      Wr.Close(wr)
    END;

    ReduceEquations();

    RecordDependencies();

    RETURN SatisfyAssertions(ni)
  END Attempt;

PROCEDURE PrintDependSet(s : BDDSet.T) =
  VAR iter := s.iterate();
      b : BDD.T;
      p : IntPair.T;
      lookup : BOOLEAN;
  BEGIN
    WHILE iter.next(b) DO
      lookup := bddTbl.get(b, p);
      <*ASSERT lookup*>
      Debug.Out(F("(%s,%s)", I(p.k1), I(p.k2)))
    END
  END PrintDependSet;

VAR print := -1; pMu := NEW(MUTEX);

PROCEDURE ReduceEquations() =
  VAR
    arr2 := NEW(REF ARRAY OF BDDSet.T, equations.size());
    tbl := NEW(BDDSetHashRefTbl.Default).init();
  BEGIN
    FOR a := FIRST(arr2^) TO LAST(arr2^) DO
      arr2[a] := NEW(BDDSetHash.T).init()
    END;

    Debug.Out("Calculating dependencies...");
    FOR i := 0 TO equations.size()-1 DO
      LOCK pMu DO print := i END;
      VAR 
        eq : Eq := equations.get(i);
      BEGIN
        arr2[i] := BDDDepends.Depends(eq.eq);
      END
    END;

    print := -1;

    (* now hash everything *)
    FOR i := 0 TO equations.size() -1 DO
      VAR new := NEW(BDDSetHash.T).init();
          iter := arr2[i].iterate();
          b : BDD.T;
      BEGIN
        WHILE iter.next(b) DO
          EVAL new.insert(b)
        END;
        arr2[i] := new
      END
    END;

    FOR i := 0 TO equations.size()-1 DO
      VAR 
        old, new : REFANY := NIL;
      BEGIN
        EVAL tbl.get(arr2[i], old);
        new := CardList.Cons(i, old);
        EVAL tbl.put(arr2[i], new)
      END
    END;

    Debug.Out(I(tbl.size()) & " reduced equations");

    VAR newEquations := NEW(RefSeq.T).init(); 
        iter := tbl.iterate();
        s : BDDSetHash.T;
        r : REFANY;
    BEGIN
      WHILE iter.next(s, r) DO
        VAR p := NARROW(r, CardList.T); 
            q := BDD.True();
            t := "";
        BEGIN
          WHILE p # NIL DO
            WITH eq = NARROW(equations.get(p.head),Eq) DO
              q := BDD.And(eq.eq, q);
              t := t & eq.label;
              IF p.tail # NIL THEN t := t & " AND " END;
              p := p.tail
            END
          END;
          newEquations.addhi(NEW(Eq, label := t, eq := q))
          (* at this point we have all the info needed for 
             RecordDependencies..*)
        END
      END;
      equations := newEquations
    END
  END ReduceEquations;

PROCEDURE RecordDependencies() =
  VAR
    b : BDD.T;
    x : BOOLEAN;
    k : IntPair.T;

  BEGIN
    deps := NEW(REF ARRAY OF ARRAY OF CardList.T, NUMBER(ch^), NUMBER(ch[0]));
    FOR i := FIRST(deps^) TO LAST(deps^) DO
      FOR j := FIRST(deps[0]) TO LAST(deps[0]) DO
        deps[i,j] := NIL
      END
    END;
    FOR i := 0 TO equations.size() -1 DO
      WITH d    = BDDDepends.Depends(NARROW(equations.get(i),Eq).eq),
           iter = d.iterate() DO
        WHILE iter.next(b) DO
          x := bddTbl.get(b, k);
          <*ASSERT x*>
          deps[k.k1,k.k2] := CardList.Cons(i, deps[k.k1,k.k2])
        END
      END
    END
  END RecordDependencies;

PROCEDURE AssertNoSmallerGap(sp  : CARDINAL;
                             gap : LONGREAL) =
  BEGIN
    Debug.Out(F("AssertNoSmallerGap(sp=%s gap=%s)", I(sp), L(gap)));
    FOR sl := 0 TO nslots-1 DO
      FOR j := sl+1 TO sl + CEILING(gap)-1 DO
        WITH str = F("sp=%s ruling out slots (%s and %s)", 
                     I(sp), I(sl), I(j MOD nslots)) DO
          Assert(str, Implies(ch[sp,sl], Not(ch[sp,j MOD nslots])));
          (*
          Debug.Out(str)
          *)
        END
      END
    END
  END AssertNoSmallerGap;

PROCEDURE AssertAlwaysExistsSuccessor(sp : CARDINAL;
                                      minGap, maxGap : LONGREAL) =
  VAR
    x : BDD.T;
  BEGIN
    Debug.Out(F("AssertAlwaysExistsSuccessor(sp=%s minGap=%s maxGap=%s)", I(sp), L(minGap), L(maxGap)));
    FOR sl := 0 TO nslots-1 DO
      x := BDD.False();
      FOR j := sl+CEILING(minGap) TO sl+FLOOR(maxGap) DO
        x := Or(x, ch[sp, j MOD nslots]);
        (*
        Debug.Out(F("sp=%s might have slots (%s and %s)", 
                    I(sp), I(sl), I(j MOD nslots)));
                    *)
      END;
      Assert(F("sp=%s has slot %s -> has slot in [%s,%s])",
               I(sp), I(sl), I(sl+CEILING(minGap)), I(sl+FLOOR(maxGap))), 
             Implies(ch[sp,sl], x))
    END
  END AssertAlwaysExistsSuccessor;

VAR slack : INTEGER;

VAR ct : REF ARRAY OF CARDINAL;

VAR bddTbl : BDDIntPairTbl.T;

PROCEDURE Solve() : TEXT (* NIL on success *)=

  VAR
    tt := 1.0d0 / clock * FLOAT(nslots,LONGREAL); 
    (* total time to run through schedule *)
    
    s_ccnt : CARDINAL := 0;

  BEGIN
    (* calculate how many entries each speed needs *)
    minct  := NEW(REF ARRAY OF CARDINAL, NUMBER(ports^));
    ct     := NEW(REF ARRAY OF CARDINAL, NUMBER(ports^));
    FOR i := FIRST(minct^) TO LAST(minct^) DO
      WITH rt   = RepTime(ports[i]),
           cnt  = tt / rt,
           ccnt = CEILING(cnt) DO
        Debug.Out(F("Speed idx %s spd %s rt %s cnt %s ccnt %s",
                    I(i), L(ports[i]), L(rt), L(cnt), I(ccnt)));
        minct[i] := ccnt;
        s_ccnt := s_ccnt + ccnt
      END
    END;

    slack := nslots - s_ccnt - 1;
    
    IF slack < 0 THEN RETURN "not enough slots" END;

    ch := NEW(REF ARRAY OF ARRAY OF BDD.T, NUMBER(ports^), nslots);
    bddTbl := NEW(BDDIntPairTbl.Default).init();
    FOR i := FIRST(ch^) TO LAST(ch^) DO
      FOR j := FIRST(ch[0]) TO LAST(ch[0]) DO
        ch[i,j] := BDD.New(F("ch[%s,%s]",I(i),I(j)));
        EVAL bddTbl.put(ch[i,j], IntPair.T { i,j })
      END
    END;

    VAR 
      extra := NEW(REF ARRAY OF CARDINAL, NUMBER(ports^));
      success : BOOLEAN;
    BEGIN
      FOR appslack := 0 TO slack DO
        (* apportion "appslack" among ports *)
        Zero(extra^);
        Debug.Out("Apportioning slot slack of " & I(appslack));
        extra[0] := appslack;
        
        REPEAT
          Debug.Out("slack is apportioned " & FmtSlack(extra^));
          AddSlack(ct^, minct^, extra^);
          success := Attempt(ct^);
          IF success THEN RETURN NIL END
        UNTIL success OR NOT StepSlack(extra^);
      END;
      RETURN "No schedule found"
    END
  END Solve;

PROCEDURE FmtSlack(READONLY arr : ARRAY OF CARDINAL) : TEXT =
  VAR
    s := "";
  BEGIN
    FOR i := FIRST(arr) TO LAST(arr) DO
      s := s & " " & I(arr[i])
    END;
    RETURN s
  END FmtSlack;

PROCEDURE StepSlack(VAR arr : ARRAY OF CARDINAL) : BOOLEAN =
  BEGIN
    FOR i := FIRST(arr) TO LAST(arr)-1 DO
      IF arr[i] # 0 THEN
        INC(arr[i+1]); DEC(arr[i]); RETURN TRUE
      END
    END;
    RETURN FALSE
  END StepSlack;

PROCEDURE AddSlack(VAR c          : ARRAY OF CARDINAL;
                   READONLY a, b  : ARRAY OF CARDINAL) =
  BEGIN
    FOR i := FIRST(c) TO LAST(c) DO c[i] := a[i] + b[i] END
  END AddSlack;

PROCEDURE Zero(VAR a : ARRAY OF CARDINAL) =
  BEGIN
    FOR i := FIRST(a) TO LAST(a) DO a[i] := 0 END
  END Zero;


VAR nslots : CARDINAL;

PROCEDURE ParseInput() =
  VAR rd := Stdio.stdin;
      reader : TextReader.T;
      portseq := NEW(LongRealSeq.T).init();
      
  CONST 
    White = "\t ";

  PROCEDURE Get() : TEXT RAISES { TextReader.NoMore } = 
    BEGIN RETURN reader.nextE(White, skipNulls := TRUE) END Get;

  VAR
    cmd : TEXT;
    lNo := 0;
  BEGIN
    TRY
      LOOP
        WITH line   = Rd.GetLine(rd) DO
          INC(lNo);
          reader := NEW(TextReader.T).init(line);
          IF reader.next(White, cmd, skipNulls := TRUE) AND 
             Text.GetChar(cmd, 0) # '#' THEN
            IF TE(cmd, "CLOCK")       THEN 
              clock := Scan.LongReal(Get()) 
            END;
            IF TE(cmd, "UNDERRUNMAX") THEN 
              underrunMax := Scan.LongReal(Get()) 
            END;
            IF TE(cmd, "MINREPBITS") THEN 
              minRepBits := Scan.LongReal(Get()) 
            END;
            IF TE(cmd, "MINPORTREP") THEN
              minPortRep := Scan.Int(Get())
            END;
            IF TE(cmd, "DELTAGAPMAX") THEN
              deltaGapMax := Scan.Int(Get())
            END;
            IF TE(cmd, "N") THEN
              N := Scan.Int(Get())
            END;
            IF TE (cmd, "PORT") THEN
              portseq.addhi(Scan.LongReal(Get()))
            END
          END
        END    
      END
    EXCEPT
      Rd.EndOfFile => (* skip *)
    |
      Rd.Failure, Lex.Error, FloatMode.Trap, TextReader.NoMore => 
      Debug.Error("Parse error in input, line " & I(lNo))
    END;
    ports := NEW(REF ARRAY OF LONGREAL, portseq.size());
    FOR i := 0 TO portseq.size()-1 DO
      ports[i] := portseq.get(i)
    END
  END ParseInput;

VAR
  attempts : CARDINAL;
BEGIN

 (* EVAL Thread.Fork(NEW(Thread.Closure, apply := PApply));*)

  ParseInput();

  Debug.Out(I(NUMBER(ports^)) & " ports");
  FOR i := FIRST(ports^) TO LAST(ports^) DO
    Debug.Out(F("port %s speed %s", I(i), L(ports[i])));
  END;

  attempts := 0;
  FOR i := 1 TO N DO
    Debug.Out(F("\n======================================================================\nTrying %s slots", I(i)));
    nslots := i;
    WITH s = Solve() DO
      IF s # NIL THEN
        Debug.Out("Failed: " & s)
      ELSE
        Debug.Out("Success!"); EXIT 
      END
    END
  END
END Main.


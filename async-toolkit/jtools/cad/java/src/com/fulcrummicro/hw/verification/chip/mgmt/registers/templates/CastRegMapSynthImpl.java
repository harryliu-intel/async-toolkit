// Autogenerated Jamon implementation
// /nfs/site/disks/wdisk.53/kedunckl/p4wd/reg-main-1/shared/java/src/./com/fulcrummicro/hw/verification/chip/mgmt/registers/templates/CastRegMapSynth.jamon

package com.fulcrummicro.hw.verification.chip.mgmt.registers.templates;

// 3, 1
import java.util.Collection;
// 4, 1
import com.fulcrummicro.util.misc.Utility;
// 5, 1
import com.fulcrummicro.hw.verification.chip.mgmt.registers.*;

public class CastRegMapSynthImpl
  extends com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastCommonImpl
  implements com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMapSynth.Intf

{
  private final Collection<RegisterCrossbarPort> crossbarPorts;
  private final Collection<RegisterBase> bases;
  private final Collection<Register> regs;
  private final String chip;
  protected static com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMapSynth.ImplData __jamon_setOptionalArguments(com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMapSynth.ImplData p_implData)
  {
    com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastCommonImpl.__jamon_setOptionalArguments(p_implData);
    return p_implData;
  }
  public CastRegMapSynthImpl(org.jamon.TemplateManager p_templateManager, com.fulcrummicro.hw.verification.chip.mgmt.registers.templates.CastRegMapSynth.ImplData p_implData)
  {
    super(p_templateManager, __jamon_setOptionalArguments(p_implData));
    crossbarPorts = p_implData.getCrossbarPorts();
    bases = p_implData.getBases();
    regs = p_implData.getRegs();
    chip = p_implData.getChip();
  }
  
  @Override protected void child_render_2(final java.io.Writer jamonWriter)
    throws java.io.IOException
  {
    // 12, 9
    jamonWriter.write("module chip.");
    // 13, 13
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(chip), jamonWriter);
    // 13, 23
    jamonWriter.write(".base.register_map_synth;\n\nimport chip.");
    // 15, 13
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(chip), jamonWriter);
    // 15, 23
    jamonWriter.write(".base.functions.*;\nimport chip.");
    // 16, 13
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(chip), jamonWriter);
    // 16, 23
    jamonWriter.write(".base.registers.*;\n\n/**\n * Functions defined:\n *\n");
    // 21, 1
    for (RegisterCrossbarPort xbPort : crossbarPorts )
    {
      // 22, 1
      if (xbPort.hasBusStops() )
      {
        // 22, 29
        jamonWriter.write(" * ");
        // 23, 4
        org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(xbPort.getBusStopCspAttributeName()), jamonWriter);
        // 23, 45
        jamonWriter.write("\n");
      }
    }
    // 25, 8
    jamonWriter.write(" *\n * CbpDecoderFunctions\n *\n */\n\ndefine BusFunctions()() attributes {\n  csp {\n    structure DecodedRegister = (\n//FIXME addr using chip_addr for now\n//if changed to block_offset_addr there will be aliasing problems\n//if 2 or more register sets map onto the same bus stop\n      int(32) addr;       // index into structure (in units of register width)\n      int(8) bus_stop_nr; // target bus stop\n      int(8) num_words;   // number of atomic words in this register\n                          // otherwise one for non-atomic reg\n      int(4) word_nr;     // word offset for current mgmt cycle for atomic reg\n                          // otherwise zero for non-atomic reg\n    );\n  }\n}\n\n");
    // 47, 1
    for (RegisterCrossbarPort xbPort : crossbarPorts )
    {
      // 48, 1
      if (xbPort.hasBusStops() )
      {
        // 48, 29
        jamonWriter.write("//Mgmt linear bus register decode functions\ndefine ");
        // 50, 8
        org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(xbPort.getBusStopCspAttributeName()), jamonWriter);
        // 50, 49
        jamonWriter.write("()() attributes\n  <+ chip.");
        // 51, 11
        org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(chip), jamonWriter);
        // 51, 21
        jamonWriter.write(".base.functions.RegisterFunctions\n  <+ chip.");
        // 52, 11
        org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(chip), jamonWriter);
        // 52, 21
        jamonWriter.write(".base.registers.AddressSpace\n  <+ BusFunctions\n{\n  csp {\n//FIXME dec_reg::addr using chip_addr for now\n//if changed to block_offset_addr there will be aliasing problems\n//if 2 or more register sets map onto the same bus stop\n\n    //decode chip address into bus stop address for MGMT_IN\n    function ");
        // 61, 14
        org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(Utility.camelCaseToUnderscore(xbPort.getBusStopCspRawName()).toLowerCase()), jamonWriter);
        // 61, 94
        jamonWriter.write("_reg_map(\n      int(32) -chip_addr; //chip level address\n      DecodedRegister +dec_reg) = (\n      //int(32) block_addr;\n      //int(16) i, i0, i1, i2;\n\n      dec_reg::num_words = 1; // default for registers w/ atomic width 1\n      dec_reg::word_nr   = 0; // default for registers w/ atomic width 1\n      dec_reg::addr = chip_addr; //FIXME may want to change to block_addr later\n      //assumes all registers aligned to power of 2\n      //assumes max atomic width < 4\n      int(2)  word = chip_addr{1:0};\n");
        // 73, 1
        boolean firstBusStop = true; 
        // 73, 39
        jamonWriter.write("      #[");
        // 75, 14
        for (RegisterBusStop busStop : xbPort.getBusStops() )
        {
          // 76, 16
          for (RegisterBase base : busStop.getRegisterBases() )
          {
            // 77, 1
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(firstBusStop ? "" : "      []"), jamonWriter);
            // 77, 37
            firstBusStop=false; 
            // 77, 66
            jamonWriter.write("(chip_addr & ");
            // 78, 14
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(String.format("0x%08x", ~(base.getSize() - 1))), jamonWriter);
            // 78, 66
            jamonWriter.write(") == ");
            // 78, 71
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(String.format("0x%08x", base.getAbsoluteAddress())), jamonWriter);
            // 78, 127
            jamonWriter.write(" ->\n        //regRange(chip_addr, ");
            // 79, 31
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(base.getFullName()), jamonWriter);
            // 79, 55
            jamonWriter.write(", ");
            // 79, 57
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(base.getName()), jamonWriter);
            // 79, 77
            jamonWriter.write("_SIZE, block_addr) ->\n");
            // 80, 18
            if (busStop.getStride() > 0 )
            {
              // 80, 49
              jamonWriter.write("        int bus_stop_offset = (chip_addr - ");
              // 81, 44
              org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(base.getFullName()), jamonWriter);
              // 81, 68
              jamonWriter.write(") / ");
              // 81, 72
              org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(String.format("0x%x",busStop.getStride())), jamonWriter);
              // 81, 119
              jamonWriter.write(";\n        dec_reg::bus_stop_nr = ");
              // 82, 32
              org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(busStop.getName()), jamonWriter);
              // 82, 55
              jamonWriter.write(" + bus_stop_offset;\n        block_addr = block_addr - ");
              // 83, 35
              org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(String.format("0x%x",busStop.getStride())), jamonWriter);
              // 83, 82
              jamonWriter.write(" * bus_stop_offset;\n");
            }
            // 84, 18
            else
            {
              // 84, 25
              jamonWriter.write("        dec_reg::bus_stop_nr = ");
              // 85, 32
              org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(busStop.getName()), jamonWriter);
              // 85, 55
              jamonWriter.write(";\n");
            }
            // 92, 8
            jamonWriter.write("        dec_reg::num_words   = ");
            // 93, 32
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(base.getAtomicWidth()), jamonWriter);
            // 93, 59
            jamonWriter.write(";\n        ");
            // 94, 9
            {
              // 94, 9
              __jamon_innerUnit__print_atomic_word_nr(jamonWriter, base.getAtomicWidth() );
            }
            // 94, 70
            jamonWriter.write(";\n");
            // 95, 1
            boolean firstReg = true; 
            // 96, 18
            for (Register reg : base.getRegisters() )
            {
              // 97, 1
              if ((reg.getAlias() == null) && (reg.getAtomicWidth()!=base.getAtomicWidth()))
              {
                // 98, 1
                org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(firstReg ? "        #[" : "        []"), jamonWriter);
                // 98, 45
                firstReg=false; 
                // 100, 1
                {
                  // 100, 1
                  __jamon_innerUnit__registerAddressGuard(jamonWriter, reg);
                }
                // 101, 1
                int atomicWidth = reg.getAtomicWidth();
//MGMT_IN address decoding requirements:
//mgmt_in needs a word number in the atomic cache, ideally we take
//address % atomicWidth to get word number, however we want to use bit select
//for optimization
//if bit select is used, then % operator is the same as bit select when
//atomicWidth is a power of 2
//when atomic width is not a power of 2, then the bit select does not work if
//the register length is greater than the atomic width because the upper words
//will not be written
if (!Util.isPowerOf2(atomicWidth)) {
	if (reg.getEntryWidth() > atomicWidth) {
		System.out.printf("ERROR %s reg width = %d > atomic width = %d, upper words inaccessible\n",
			reg.getName(), reg.getEntryWidth(), atomicWidth);
	}
}
if(reg.getAtomicWidth()<base.getAtomicWidth()) {
    System.out.printf("WARNING %s base atomic width = %d > atomic width = %d\n",
                      reg.getName(), base.getAtomicWidth(), atomicWidth);
}

                // 122, 3
                jamonWriter.write("//atomic width  ");
                // 123, 17
                org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(atomicWidth), jamonWriter);
                // 123, 34
                jamonWriter.write("\n          dec_reg::num_words   = ");
                // 124, 34
                org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(reg.getName()), jamonWriter);
                // 124, 53
                jamonWriter.write("_ATOMIC_WIDTH;\n          ");
                // 125, 11
                {
                  // 125, 11
                  __jamon_innerUnit__print_atomic_word_nr(jamonWriter, atomicWidth );
                }
                // 125, 62
                jamonWriter.write("\n\n");
              }
            }
            // 128, 1
            org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(firstReg ? "        /* no registers with atomic width greater than base width */\n" : "        ]"), jamonWriter);
            // 128, 104
            jamonWriter.write("\n");
          }
        }
        // 130, 42
        jamonWriter.write("      ]\n    );\n  }\n}\n\n");
      }
    }
    // 150, 8
    jamonWriter.write("\n");
  }
  
  
  // 141, 1
  private void __jamon_innerUnit__print_atomic_word_nr(final java.io.Writer jamonWriter, final int atomicWidth)
    throws java.io.IOException
  {
    // 143, 1
    if (atomicWidth > 4) {
	System.out.printf("ERROR register map synth version does not support atomic width=%d > 4\n",atomicWidth);
}
int atomicMask = (1 << Util.log2(atomicWidth)) - 1;

    // 148, 3
    jamonWriter.write("dec_reg::word_nr     = word & ");
    // 149, 31
    org.jamon.escaping.Escaping.HTML.write(org.jamon.emit.StandardEmitter.valueOf(String.format("0x%h",atomicMask)), jamonWriter);
  }
  
  
}
